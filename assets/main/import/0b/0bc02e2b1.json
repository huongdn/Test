[1,["40d71xE1dIkLzJxP+wBDfR","afGeD/wZdPZrp4WUs/j8e8@ae8cb","20g1ukYUVPvKWKBRznAKo+@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","80GPjRoWtLUIxSnuxHVLoU@1dd6b","a9HWa5/S9KhoRWyEk61Vwd@f9941","bcrwvzz+5MWbdFlWrnFBi3@f9941","7fLTVR3xtLaZyz0px7kGVG@77d60","0cZ5w+l29CaLq3joj2jOKy@2b10d","2ewRRY+FVJeLFN8+1c9pf6","ccs9isokhOa6d07vfA4SiQ@f9941","47NaOsdqdBhoWvDHRTb0Jb@f9941","d9raNLtQZI9IRQrefgwc1z@f9941","e0Rr0RF9ZIYKdaUwp1xY2y@6e4de","69ylYO5DhBgbB8Fj+LRTro@f9941","489z+B1NFOh7ThUNtAzlC/","4buBEXdBtIeow2DC31WSFI@c8ece","12Y9dMgWdJKJGmTiZyQR9H@2e76e","d07XQlNhVDZpxSCmdyyaFN@ca819","d2r09H4wJHVZdy08NnK+rR@f9941","0b9ydyQQVHDKxH8/+vf3gY@f9941","a8GaI9vIdOSozw78tYEZp0@3e5fe","23DtfcTepGEKiY19rJZWu0@f9941","aaj03mnPpMVr/7MyLJqggh@f52ba","8f+iIjuyFIBJEVTNc7Tppr@f9941","c7oBdUr3xBsKHRYU8fyS29@f9941","1bNcHuB59CQYGaLwIhNRr9@f6f3a","d1NGQ2rJZCcbhjH0/erZWw","1brw/JvvpFnIvdrxpFCgMZ","12Y9dMgWdJKJGmTiZyQR9H@17020","7fP/3CgeVIX4VLJIQXP1j5","4fCQqbozJBZ6GdA50cZG5O@a0980","47rk923HNHQ4UAznWceAEl@56725","1dRliFBxROmqkR6plgxK9L@609ce","7fbR/1kSpKQrFLapYe7oCC@f9941","44RjoGNRVJgaw4zCCgqfZ6@6c48a","b7z6xJL7hHFYgQsNhaoInU","6a9URC2HRN15mlUT89cmsl@98927","e8zh+xEtxGqIqnWm/MbdVa","04W8QaSRdIR4h6B+xJ+ZqA@a7cf4","aftjMyzy1Ieptzk1+/1qk8@73b7f","b84lEKuW9LprjxfT26C0By@f9941","17/SJaJyhL+oRZRiTDRVOg","8clH2Uv/9HGp7LwUcnj9Eb@f9941","d6y9FwjAFGipgcJK200Pkl@f9941","20kQRIf1tEGqW70+/Er9/r@f9941","f8CXtpAlhIkK4xF/nly61l@f9941","64mvp6pYJKOLdWGlqM1WDt","74pagElr1OobymmpC61brW","80B7u3PwxGF6QKpcKsE2Il@f9941","7fLTVR3xtLaZyz0px7kGVG@fa5d9","a1t/h2hpJMaIRCyAVfht5y","afGeD/wZdPZrp4WUs/j8e8@e713a","afGeD/wZdPZrp4WUs/j8e8@65479","afGeD/wZdPZrp4WUs/j8e8@438fe","96U3ByT1dJGIAzUdq2+miZ","7bqZOrIMlAt5vzsuUK+VaR@3a253","99FiRbnJRBQ5uUDiSUZal/@f5fff","7fLTVR3xtLaZyz0px7kGVG@12b06","c8u0/QMRpKQp3yhGnXiL4B@f9941","a7Q3J5XtxB/bX3BSf5LEY2@f9941","7fLTVR3xtLaZyz0px7kGVG@4bb13","7fLTVR3xtLaZyz0px7kGVG@438fe","246bPsmBBAObZvvj7HXQEw","15y7JnTyRAKaV8IyhmhhoI@f9941","62yT94yUNKsap2osRQLcdy","c9loJE8v9BwYpWPmwUlspB@f9941","c03TwwvaxNJ5vrfGYHnGE7@f9941","9cPnP6saBAsICcg5IdHIZo","4aDWXSC/NH6YecKJZUTNVX@f9941","38Byz2UcVGlIkPuOEmlT3d","9fdpkWlF9D8Z2Fgx7DNExq@f9941","44RjoGNRVJgaw4zCCgqfZ6@f9941","a82V7ce3lGVKaWgKgV9cGi@f9941","8152UZ+xND0Y/fL7hMzpFv@f9941","53WrYhS7NB4KnN3VuvbgL8@f9941","81xpOUvslJxosK0aj///aG@f9941","9d981VZwtHL7r3lJb6meJF","b1xx3EU/tDoJzYDMIKKF+w","e8rshwdKxE2K9xh71hGBqi","c4DVSS6u1HGoGqxwbj6ztP@7f7a4","f6SsA8pT5DZ6IIMaplEtGv@73b7f","9ciDzyZcdKaKajFHGYxNOi@f9941","1bNcHuB59CQYGaLwIhNRr9@b8ef3","1bNcHuB59CQYGaLwIhNRr9@6e9f2","1bNcHuB59CQYGaLwIhNRr9@438fe","61aq+1inVPILaDjHDSkpHu@6c48a","4aDWXSC/NH6YecKJZUTNVX@6c48a","c52N1jo6RLiqURt+vmOolb@6c48a","d5RrOsNt9Bp6zPk3CPxp+g@6c48a","86KQSCB/5ABpWPqZEVGlns@6c48a","fc9Viql0BBkoVCVQ3yHRHG@6c48a","9bKkVmh1VK+pC+V390N5Oe@6c48a","45yKHZXdZJD5fNSNQOuk8n","72J47Fp3FP4rP3IM7FuLh0","80GPjRoWtLUIxSnuxHVLoU@5c986","80GPjRoWtLUIxSnuxHVLoU@ac1d6","80GPjRoWtLUIxSnuxHVLoU@438fe","afGeD/wZdPZrp4WUs/j8e8@73b7f","e8Uu0XxMxEQ5/yLmMOZf1l","d3x4IMKphEKYvHuEU7yaxB","69diohqZJPAILhJwyRQw2e","7ae6DcTARPVarZdrHytYcy@f9941","2fLmfWA/NKsroAhf/6NOYp@f9941","9dPm8YoL1M9aujCOc76XDO@f9941","d7uBccB0JMpKmJTi13/eqg@f9941","32RpYxJKlCNbSJ0LVxwzeh@f9941","58X5W8fqdHcpZnALtm5aoM@f9941","a3L+u4eBdO1Lt9DNXEEfx4@f9941","c9ZhCFblpJ1bVqoMNBQizM@f9941","35o1MU4ftLiafnOmi7D+sQ","5cmGaOV1pGEpRqEVyEXMef","461MOA2WVGIYJdPd7gs721@f9941","f8ewnJ7DROq6tjlTZYG4rM@f9941","93E3KbYKxEworr+tgC+dnl@f9941","61Kt0GUoFJ5IRwe8GLex3D@f9941","faptbw5W1OipZ+tR1QhN75@f9941","3bdmu3LRxMOKz9SD3YAoAe@f9941","0aqn3ByaBJ0oDnepCdIUVb@f9941","54tU/cFetH8I+gv6CsaQmx@f9941","c5uJwZyBNILbmkv4gQUgoV@f9941","93pHBiiRZFt4lOGHUdowxr@f9941","855mZGdqdJcoWdttKo7YDT@f9941","96KQiRVAtMNo/JFo3fCNQj@f9941","4bxaN+UyJBPbMvfjMqwoNI@f9941","c6w8Ty0ftGUqs7SxkTSw/E@f9941","00iBdUA9BNt5PBby8nrTA3@f9941","b1tKJ2+0hKSZ/DJ2MBE1mO@f9941","65c3DPkA5A/rSL6zECKGwz@f9941","acP3r33hlF2IUS76vroLkS@f9941","27kahNwglEg6toorieGX+5@f9941","bdOiEnnMNKLr3a/MTaQ8Zj@f9941","cfA8Ld4jdCMLKTPyKFBrW2@f9941","a3bV3x7UhNJqmdMpNvsOWT@f9941","13jGVI9fFGarBc7SjcgJpO@f9941","f4pPLJX3lHi40b+3SbzhCi@f9941","557gjrYzJGtKGGPp0qq+Ma@f9941","28wbjdyDdMS7txskNZ5wZe@f9941","67SNyWoWxLYb0E7vV/xGm7@f9941","c2a94U4sxDDrQqnHjmzdDb@f9941","83c8bW2yFDFI9zgnhhSar/","1bNcHuB59CQYGaLwIhNRr9@3a45e","e4GBS5/25LroavEjKIQNhZ@f9941","e3eMYgj3tAZpIr5YsxSLKg@f9941","80GPjRoWtLUIxSnuxHVLoU@df584","55qUnI2stDE6KWycV85Ref@f9941","7afSngisZOWa1x+3BCRX8b@f9941","afGeD/wZdPZrp4WUs/j8e8@fe2ee","b2YJ/LeoVAj7u/1PauuUTZ@f9941","a092wBrNhNZas/t1IZla0j","46qELMVcdBY7wNIxnEL/mZ@f9941","aegctx67NKUJ0lTjkvHm84@f9941","3cha0s8/FGXbEUFxdzlscy","a7Z5C5w1ZMj5nptlTkARHi","b0ixpMjndDoaSJQwKF1w6D","75zXWnX2ZMCL3xyeCotNiu","55pVp1Z1hO+bOd6fheEW24@f9941","1bNcHuB59CQYGaLwIhNRr9@f0b43","1bNcHuB59CQYGaLwIhNRr9@ba49c","23mmFfSUREa62JBMx5ZMpn@3b02d","28wbjdyDdMS7txskNZ5wZe@6c48a","23mmFfSUREa62JBMx5ZMpn@18210","23mmFfSUREa62JBMx5ZMpn@43181","48XQvP7PxCmJNmXjXfBq84@f9941","4b6eNqicRGSZQIVfox1DPy@89b79","58xh3Ml11LO6N5+l2Db8tW@6c48a","8djP4wpIJLrIgJ0jKt4e/P","a8/neMo49FaaN5WYLnt9LZ","b7rukwnuNFn7MPEKksNLh1","e65j+SW4ROgYSaYhfxWdvg","95OaXZsItBtLQ7eMsYvnix","27cruePMBBLrTCi3+rdIgz","4b6eNqicRGSZQIVfox1DPy@834fd","4b6eNqicRGSZQIVfox1DPy@66609","7fLTVR3xtLaZyz0px7kGVG@f4d2a","7fLTVR3xtLaZyz0px7kGVG@7c993","a4ZFfS0VRAjqO09ZNzy7h5","58xh3Ml11LO6N5+l2Db8tW@f9941","80GPjRoWtLUIxSnuxHVLoU@0e838","80GPjRoWtLUIxSnuxHVLoU@f0924","94yiVgqY9HJ7KhcpdyYnBE@6c48a","9fdpkWlF9D8Z2Fgx7DNExq@6c48a","f7yvGO71ZMRZuSyGZJKdnL@6c48a","173rzDCmtLirAL3Fi4hVge","e6v62Zsu5HXpnhzK4LNBqp@18210","e6v62Zsu5HXpnhzK4LNBqp@74e9f","afGeD/wZdPZrp4WUs/j8e8@1e178","afGeD/wZdPZrp4WUs/j8e8@43bd2","fdyj2CldxPW4QZfy/xDpTa@f4a1b","fdyj2CldxPW4QZfy/xDpTa@80d75","bdOiEnnMNKLr3a/MTaQ8Zj@6c48a","e6v62Zsu5HXpnhzK4LNBqp@3b02d","40p6jX6wdI4I2+8uHNVNyB","faptbw5W1OipZ+tR1QhN75@6c48a","fdyj2CldxPW4QZfy/xDpTa@575b7"],["node","_parent","_spriteFrame","targetInfo","root","value","_normalSprite","asset","_font","_hoverSprite","_pressedSprite","_target","_mesh","_disabledSprite","_effectAsset","mainTexture","to","from","data","clip","_skeleton","source","graph","_textureSource","_particleSystem","_mainTexture","target","_checkMark","_anyState","_exitState","_entryState","_defaultClip","normalMap","unlockBG3dWorld","_targetTexture","_cameraComponent","popupTutorial","popupRedirectCRML","popupUnlockAnimal","popupParent","popupChangeAnimal","soundBtn","backGroundNode","scene","animalModel","toggleSelection","renderTexture","material","_clip","uiSoundSF","uiSoundMuteSF","prefabBerries","prefabSteak","prefabTwigs","prefabSeaweed","btnNormalSF","btnSelectSF","normalSF","selectedSF","_file","kangarooNode"],[["cc.Node",["_name","_layer","_id","_active","_objFlags","_components","_parent","_lpos","_lrot","_euler","_prefab","_children","_lscale","__editorExtras__"],-2,9,1,5,5,5,4,12,5,11],["cc.Node",["_name","_layer","_active","_objFlags","__editorExtras__","_id","_parent","_lpos","_lrot","_euler","_children","_prefab","_components","_lscale"],-3,1,5,5,5,2,4,12,5],["cc.Node",["_name","_layer","_active","_id","_children","_components","_parent","_lpos","_prefab","_lscale"],-1,2,9,1,5,4,5],["cc.Button",["_transition","node","clickEvents","_target","_normalSprite","_pressedColor","_normalColor","_hoverSprite","_pressedSprite","_disabledSprite","__prefab","_hoverColor"],2,1,9,1,6,5,5,6,6,6,4,5],["cc.Label",["_string","_actualFontSize","_fontSize","_lineHeight","_isSystemFontUsed","_overflow","_enableWrapText","_isBold","node","_font","_color","__prefab"],-5,1,6,5,4],["cc.Sprite",["_sizeMode","_type","_enabled","node","_spriteFrame","_color","__prefab"],0,1,6,5,4],["cc.Node",["_name","_id","_layer","_lpos","_parent","_prefab","_components","_children","_lrot","_euler"],0,5,1,4,2,9,5,5],"cc.SpriteFrame",["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedChildren","mountedComponents"],1,9,9,9],["cc.RealKeyframeValue",["interpolationMode","rightTangent","leftTangent","value","rightTangentWeight","leftTangentWeight"],-3],["cc.UITransform",["node","__prefab","_contentSize"],3,1,4,5],["cc.SkeletalAnimation",["_useBakedAnimation","node","_clips","__prefab","_defaultClip"],2,1,3,4,6],["cc.LabelOutline",["_width","node","_color","__prefab"],2,1,5,4],["cc.CurveRange",["mode","constantMin","constantMax","multiplier","constant","spline"],-2,4],["cc.MeshRenderer",["_name","_enabled","node","_materials","lightmapSettings","_mesh","__prefab"],1,1,3,4,6,4],["cc.Camera",["_visibility","_clearFlags","_fov","_projection","_priority","_orthoHeight","_far","_name","node","_color","_targetTexture"],-5,1,5,6],["cc.ShapeModule",["_enable","emitFrom","radius","radiusThickness","length","_angle","_shapeType","alignToDirection","arcSpeed"],-5,4],["cc.Widget",["_alignFlags","_bottom","_originalWidth","_left","_right","_top","_isAbsBottom","_originalHeight","node","__prefab"],-5,1,4],["cc.PrefabInfo",["fileId","nestedPrefabInstanceRoots","root","asset","targetOverrides"],2,2,1,1,9],["c8d65aN9XJPtacH/s2uxMQ5",["animalType","node","animalTitle","animalUnlockImg","animalUnlockCanvas","lockStatus","animalEncyCanvas","animalModelEncy","habitatSF","imageSF","foodSF","mapSF","toggleSelection","animalModel","unlockBG3dWorld"],2,1,1,1,1,1,1,1,1,1,1,1,1,1,1],["cc.Material",["_states","_defines","_name","_techIdx","_props"],-1,12],["cc.ParticleSystem",["duration","loop","_capacity","simulationSpeed","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer","bursts"],-1,1,4,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,9],["cc.Gradient",["colorKeys","alphaKeys"],3,9,9],["cc.ColorKey",["time","color"],2,5],["cc.VelocityOvertimeModule",["space","_enable","x","y","z","speedModifier"],1,4,4,4,4],["cc.ForceOvertimeModule",["space","_enable","x","y","z"],1,4,4,4],["cc.LimitVelocityOvertimeModule",["dampen","_enable","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.TextureAnimationModule",["_numTilesX","_numTilesY","animation","randomRow","rowIndex","_enable","cycleCount","frameOverTime","startFrame"],-4,4,4],["cc.TrailModule",["_minParticleDistance","colorFromParticle","_space","_enable","lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],-1,4,4,4,4,1],["cc.ParticleSystemRenderer",["_renderMode","_mainTexture","_mesh"],2,6,6],["cc.PrefabInfo",["fileId","targetOverrides","root","instance","asset"],1,1,4,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["cc.UIMeshRenderer",["node"],3,1],["cc.TargetOverrideInfo",["propertyPath","source","target","targetInfo","sourceInfo"],2,1,1,4,4],["cc.animation.AnimationController",["node","graph","__prefab"],3,1,6,4],["cc.ClickEvent",["_componentId","handler","target"],1,1],["cc.Toggle",["_isChecked","_interactable","node","_normalColor","_target","clickEvents","checkEvents"],1,1,5,1,9,9],["cc.SkinnedMeshRenderer",["node","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton","__prefab"],3,1,3,4,1,6,6,4],["eb8b7+ixMxD2KAScxnIdYKz",["_enabled","node","kagaroo","lion","flamingo","giraffe","default"],2,1,1,1,1,1,1],["cc.Prefab",["_name"],2],["cc.animation.AnimationTransition",["_exitCondition","exitConditionEnabled","from","to","conditions"],1,1,1,9],["cc.animation.BinaryCondition",["operator","lhs","rhs"],2,4,4],["cc.animation.BindableNumber",["variable"],2],["cc.animation.UnaryCondition",["operator","operand"],2,4],["cc.animation.PlainVariable",["_type","_value"],1],["36bf7HXO8BIo6hgAnIa2Qi5",["foodType","node","__prefab"],2,1,4],["cc.Animation",["_enabled","playOnLoad","node","__prefab","_clips","_defaultClip"],1,1,4,3,6],["cc.GradientRange",["_mode","gradient"],2,4],["cc.AlphaKey",["alpha","time"],1],["cc.Burst",["_time","_repeatCount","repeatInterval","count"],0,4],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.RotationOvertimeModule",["_enable","x","y","z"],2,4,4,4],"cc.RenderTexture",["cc.SceneAsset",["_name"],2],["cc.Node",["_name","_children","_components","_prefab","_lrot","_euler"],2,2,2,4,5,5],["cc.CompPrefabInfo",["fileId"],2],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["cc.PrefabInfo",["fileId","targetOverrides","root","asset"],1,1,1],["cc.PrefabInstance",["fileId","prefabRootNode","mountedComponents","propertyOverrides"],2,1,9,9],["cc.MountedChildrenInfo",["targetInfo","nodes"],3,4,2],["cc.TargetInfo",["localID"],2],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,6],["ed6bd7rLAVBMaM/SGvjXE4O",["node","popupChangeAnimal","popupParent","popupUnlockAnimal","popupRedirectCRML","popupTutorial"],3,1,1,1,1,1,1],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,9],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_skyColorLDR"],2,5,5],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",["_fogColor"],3,5],["cc.OctreeInfo",[],3],["75348tPWIlDzr3PoY+ONjZ9",["node","ActiveAnimal","mainUI"],3,1,1,1],["d374f3afZlFhqlWZXIRgbUa",["node"],3,1],["cc.ToggleContainer",["node"],3,1],["39f2fM7jelFaZyUGOwsWI38",["node"],3,1],["cc.ModelLightmapSettings",[],3],["cc.PlaneCollider",["node"],3,1],["cc.AudioSource",["_loop","node","_clip"],2,1,6],["c77dbLCyX5LurO0ldLEomso",["node","soundBtn","uiSoundSF","uiSoundMuteSF"],3,1,1,6,6],["cc.RichText",["node"],3,1],["6eb27HnczxB9K2KuFxqvoc0",["node"],3,1],["d08376zPztHyYCFCQIDFW0A",["node","backGroundNode","UIPhoto","UITitle","UIHome","renderTexture","material"],3,1,1,1,1,1,6,6],["cc.DirectionalLight",["_shadowBias","_shadowNear","_shadowFar","node","_staticSettings"],0,1,4],["cc.StaticLightSettings",[],3],["b8d4b3RAspMgahjL55H+VVV",["node"],3,1],["48028piprRLMaVhc/TgnTtM",["node","spawnBerriesBtn","spawnSteakBtn","spawnTwigsBtn","spawnSeaweedBtn","closeBtn","reactionMessage"],3,1,1,1,1,1,1,1],["d5570+aNMNBpKsWeic7F5lj",["node","completeExplorePopup","tutorialPopup","animalLabel","btnMap","btnHabitat","btnPicture","btnFood","mapImage","habitatImage","Image","foodImage"],3,1,1,1,4,1,1,1,1,1,1,1,1],["e82abKmN3RKEZxtRGra74Dr",["node","titleUI","foodBtn","encyclopediaBtn","changeAnimalBtn","photoBtn"],3,1,1,1,1,1,1],["2b974OfW8lHy6X91zIaDTZD",["node","kangarooTg","flamingoTg","lionTg","giraffeTg","closeBtn"],3,1,1,1,1,1,1],["38f24x0crREJarqw3t2YPCS",["node","bg3dWord","kangarooUnlock","FlamingoUnlock","lionUnlock","giraffeUnlock"],3,1,1,1,1,1,1],["e1635qo31ZDXY0lR5t4Pnha",["node","fakeARCamBtn","kangarooBtn","flamingoBtn","lionBtn","giraffeBtn"],3,1,1,1,1,1,1],["facc9jj535Fnre+IlyJZiWZ",["node","foodUI","characterSelectUI","unlockUI","homeUI","encyclopediaUI","changeAnimalUI","animalLabel","homePanelSP","foodPanelSP","bgUnlock3dWorld"],3,1,1,1,1,1,1,1,1,1,1,1],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.Material",["_props","_defines"],1],["cc.animation.AnimationGraph",["_layers","_variables"],3,9,11],["cc.animation.Layer",["_stateMachine"],3,4],["cc.animation.StateMachine",["_states","_transitions","_entryState","_exitState","_anyState"],3,2,9,1,1,1],["cc.animation.Transition",["from","to"],3,1,1],["cc.animation.BindableBoolean",["variable"],2],["cc.animation.Motion",["name","motion"],2,4],["cc.animation.ClipMotion",["clip"],3,6],["cc.animation.State",["name"],2],["cc.TTFFont",["_name","_native"],1],["cc.ParticleSystem",["duration","loop","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],1,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4],["cc.RealCurve",["_times","_values"],2,9],["cc.ParticleSystem2D",["_name","emissionRate","life","lifeVar","angle","angleVar","startSizeVar","endSize","startSpin","endSpin","endSpinVar","speed","speedVar","tangentialAccel","autoRemoveOnFinish","_custom","_totalParticles","node","__prefab","posVar","gravity","_startColor","_startColorVar","_endColor","_endColorVar","_file","_spriteFrame"],-14,1,4,5,5,5,5,5,5,6,6],["cc.AudioClip",["_name","_native","_duration"],0],["cc.Asset",["_name","_native"],1],["48620PnKRFFB6jQjEJujCIK",["mainCamera","sphere","node","__prefab","kangarooNode"],1,1,4,1]],[[61,0,2],[18,0,2,3,2],[62,0,1,2,3],[31,0,1,2,2],[1,0,6,11,7,8,9,2],[10,0,2,1],[1,0,6,10,11,7,8,9,2],[13,1],[66,0,1,2,2],[65,0,1,2,3],[56,0,2],[35,0,1,2,3],[5,0,3,4,2],[9,0,3,3],[6,0,4,7,5,3,8,9,2],[69,0,1,2,2],[13,4,2],[48,0,1,3],[5,1,0,3,4,3],[30,0,2,3,4,2],[1,3,4,6,11,3],[0,0,1,6,5,7,3],[1,0,6,7,8,9,2],[114,0,1,2],[1,0,1,6,11,7,8,9,3],[71,0,1,1],[23,0,1,2],[13,0,5,2],[0,0,3,1,6,5,7,4],[83,1],[10,0,1],[32,1],[10,1],[1,0,6,10,7,8,9,2],[0,0,1,6,5,7,12,3],[8,0,2,2],[2,0,1,6,4,5,7,3],[10,0,1,2,1],[33,0,1,4,2,3,2],[1,0,1,6,10,12,7,3],[39,0,2],[13,0,1,2,4],[4,0,1,2,3,4,8,9,6],[47,0,1,2],[1,0,1,6,10,11,7,8,9,3],[64,0,1,2,2],[12,1,1],[1,0,10,11,7,8,9,2],[0,0,11,10,7,8,9,2],[2,0,2,1,6,4,5,7,4],[20,2,0,1,4,4],[109,0,1,2],[110,0,1],[111,0,2],[0,0,1,6,5,3],[3,0,1,2,5,3,4,2],[20,0,1,4,3],[0,0,6,11,10,7,8,9,2],[6,0,2,4,7,5,3,8,9,3],[5,3,4,1],[3,0,1,6,3,4,7,8,9,2],[4,0,1,2,3,4,8,10,9,6],[100,0,1,2,3],[47,1],[0,0,6,5,10,8,9,2],[3,0,1,2,5,3,2],[37,0,6,1,2,3,4,5,1],[22,0,1,1],[1,0,6,11,7,2],[0,0,4,1,6,5,4],[2,0,2,1,6,4,5,4],[6,0,4,7,3,8,9,2],[40,0,2,3,4,2],[40,1,2,3,4,2],[42,0,2],[42,1],[108,0,2],[48,0,2],[8,0,1,2,3],[8,0,4,2,2],[34,0,2,1,1],[3,1,2,1],[14,0,2,3,4,5,2],[1,0,2,1,6,10,12,7,4],[1,0,6,10,11,8,9,2],[0,0,1,6,5,10,7,3],[2,0,1,6,4,5,3],[67,0,1,2,2],[5,0,3,2],[4,0,1,2,5,6,8,10,6],[1,0,1,10,12,7,3],[8,0,1,4,2,3],[32,0,1],[5,0,3,5,4,2],[51,0,1,2,3,4,2],[1,0,1,6,10,12,7,8,9,3],[1,0,1,6,12,7,3],[1,0,2,1,6,12,7,4],[1,0,6,11,7,8,13,9,2],[0,0,3,1,6,5,4],[0,4,6,10,13,2],[0,0,3,6,5,7,8,12,9,3],[0,0,11,5,10,2],[2,0,4,5,8,9,2],[6,0,7,5,3,8,9,2],[6,0,4,6,5,2],[30,0,1,2,3,4,3],[63,0,1,2,2],[33,0,1,2,3,2],[5,1,0,3,5,4,3],[11,1,3,1],[35,1],[3,0,1,2,11,3,2],[3,0,1,2,6,11,5,3,2],[14,2,6,3,4,5,1],[4,0,1,2,3,5,6,4,8,9,8],[4,0,1,2,3,4,8,11,10,9,6],[36,0,2,5,3,4,6,2],[101,0,1,2,4],[39,1],[102,0,1,2,3,4],[104,0,1,1],[105,0,1],[106,0,1,2,3,4,1],[107,0,1,1],[41,0,1,2,2],[41,1,2,1],[43,1,1],[43,0,1,2],[44,1],[44,0,1,3],[22,1,1],[23,1,1],[13,0,3,5,3],[9,0,2],[50,1,1],[25,0,2,3,4,2],[52,0,1,2,3,2],[1,0,1,10,11,7,8,9,3],[0,0,1,6,5,8,9,3],[0,0,2,6,5,7,3],[0,0,11,5,10,8,9,2],[2,0,1,4,5,7,3],[60,0,1,1],[5,1,0,3,6,4,3],[11,0,1,3,2,2],[3,0,1,10,2,3,4,7,8,9,2],[45,0,1,2,2],[21,0,1,3,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,30,20,21,22,23,24,25,26,27,28,29,5],[49,0,1,2,3,4],[24,0,2,3,4,5,2],[26,2,3,4,5,1],[27,0,1,2,3,4,7,8,6],[28,0,1,2,4,5,6,7,8,4],[29,2,1,1],[1,3,4,11,3],[1,0,1,6,10,12,3],[1,0,10,11,8,9,2],[0,0,11,7,8,9,2],[0,0,6,11,7,8,9,2],[0,0,1,5,7,3],[0,0,2,6,5,3],[0,0,1,6,5,12,3],[0,0,4,3,1,6,5,5],[0,0,1,11,10,7,8,9,3],[0,0,6,11,10,7,2],[0,0,6,5,10,7,8,9,2],[0,0,4,1,6,5,10,4],[2,0,1,6,4,5,7,9,3],[2,0,1,4,5,8,7,3],[2,0,1,6,4,5,8,7,3],[6,0,4,7,5,3,2],[8,0,3,2,2],[59,0,1,2,3,2],[31,0,1,2],[68,0,1,2,2],[5,0,3,6,4,2],[34,0,1,1],[3,0,1,2,5,3,4,7,8,9,2],[3,0,1,2,3,2],[12,0,1,2],[19,0,1,2,3,14,12,13,4,5,6,7,8,9,10,11,2],[49,3,1],[50,0,1,2],[16,0,1,2,3,4,5,8,7],[16,0,1,2,4,5,8,6],[24,2,3,4,5,1],[26,1,0,2,3,4,5,3],[52,1,2,3,1],[27,7,8,1],[28,4,5,6,7,8,1],[29,1,1],[54,0,2],[1,0,1,5,10,12,7,4],[1,0,6,7,2],[1,0,1,6,12,7,13,3],[1,0,1,6,12,7,8,9,3],[1,0,10,7,8,9,2],[1,0,6,7,8,13,9,2],[1,0,1,6,12,3],[1,0,6,10,8,9,2],[1,0,1,6,11,7,8,13,9,3],[1,0,1,6,10,11,8,9,3],[1,0,10,11,2],[0,0,4,2,6,5,4],[0,0,6,11,5,8,9,2],[0,0,2,6,5,7,12,3],[0,0,3,1,6,5,7,8,12,9,4],[0,0,6,11,7,2],[0,0,3,2,6,5,7,12,4],[0,0,3,2,6,5,7,8,12,9,4],[0,0,1,6,5,7,8,9,3],[0,0,2,6,5,7,8,12,9,3],[0,0,6,5,7,8,9,2],[0,0,6,5,10,2],[0,0,1,11,5,10,7,12,3],[0,0,1,6,5,10,8,9,3],[0,0,11,5,10,7,8,9,2],[0,0,11,5,10,8,12,9,2],[2,0,2,1,4,5,7,9,4],[2,0,2,1,6,4,5,7,9,4],[2,0,1,3,6,4,5,7,4],[2,0,6,4,5,2],[2,0,2,1,4,5,8,4],[2,0,1,4,5,8,3],[2,0,6,4,5,8,2],[6,0,6,3,2],[6,0,1,4,6,3,3],[6,0,4,6,3,2],[6,0,4,6,5,3,8,9,2],[55,0,1,2,3,4,5,2],[10,0,1,1],[57,0,1,2,1],[17,0,3,4,5,1,2,8,9,7],[17,0,1,6,8,4],[17,0,2,7,8,4],[18,4,1,1],[18,0,2,3,1,2],[58,0,1,2,3,3],[8,0,1,3,2,3],[70,0,1,2,3,4,5,1],[72,0,1,2,3,2],[73,0,1,2,3,4,1],[74,0,1,2,2],[75,0,1],[76,1],[77,0,1],[78,1],[5,1,0,3,6,3],[5,2,3,4,2],[5,0,3,5,2],[5,0,3,6,5,4,2],[79,0,1,2,1],[80,0,1],[11,0,1,2,2],[11,1,3,2,4,1],[11,0,1,3,2,4,2],[81,0,1],[3,0,1,10,2,6,3,2],[3,0,1,2,3,4,2],[3,0,1,2,6,3,4,7,8,9,2],[3,1,2,4,1],[3,0,1,2,5,4,2],[3,0,1,2,5,2],[82,0,1],[14,0,1,2,3,4,5,3],[14,2,3,4,5,1],[84,0,1],[12,0,1,2,2],[12,1,3,2,1],[12,0,1,3,2,2],[4,0,1,2,3,5,4,8,9,7],[4,0,1,2,7,8,11,10,5],[4,0,1,2,3,4,7,8,9,7],[4,0,1,7,8,10,4],[4,0,1,8,3],[4,0,1,2,8,10,4],[4,0,1,2,3,4,8,6],[4,0,1,2,3,4,10,9,6],[4,0,1,2,3,5,6,4,8,11,9,8],[4,0,1,2,3,5,6,4,8,11,10,9,8],[19,1,2,3,4,5,6,7,8,9,10,11,1],[19,0,1,2,3,12,13,4,5,6,7,8,9,10,11,2],[85,0,1,2,2],[86,0,1,2,3,1],[87,0,1],[88,0,1],[89,0,1,2,3,4,5,6,1],[36,1,2,3,4,2],[90,0,1,2,3,4,4],[91,1],[15,2,1,0,8,4],[15,3,4,5,6,1,0,8,9,7],[15,3,4,5,6,1,0,8,9,10,7],[15,7,2,0,8,9,10,4],[37,0,1,2,3,4,5,1],[92,0,1],[93,0,1,2,3,4,5,6,1],[94,0,1,2,3,4,5,6,7,8,9,10,11,1],[95,0,1,2,3,4,5,1],[96,0,1,2,3,4,5,1],[38,0,1,2,3,4,5,6,2],[38,1,2,3,4,5,6,1],[97,0,1,2,3,4,5,1],[98,0,1,2,3,4,5,1],[99,0,1,2,3,4,5,6,7,8,9,10,1],[20,3,0,1,4,4],[103,0,1,3],[45,1,2,1],[112,0,1,3],[46,2,3,4,5,1],[46,0,1,2,3,4,5,3],[21,0,1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,30,20,21,22,23,24,25,26,27,28,29,4],[21,0,1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,4],[113,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,3],[22,0,1],[23,0,2],[9,1,4,2,5,5],[9,3,1,4,2,5,6],[9,0,1,2,4],[9,0,3,1,2,5],[16,0,6,2,3,8,5],[16,0,1,7,8,4],[51,1,2,3,4,1],[24,1,0,2,3,4,5,3],[25,2,3,4,1],[25,1,0,2,3,4,3],[26,0,2,3,4,5,2],[27,5,0,1,6,7,8,5],[28,3,0,1,2,4,5,6,7,8,5],[29,0,2,1,2],[115,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,18],[116,0,1,2,4],[117,0,1,3],[118,0,1,2,3,4,3]],[[[[192,"main"],[193,"MainUI",33554432,"a21pQl119Bb7AG+mipSq+H",[-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19],[[[37,-1,[10,"0dngp/9gNO34wUQjZfN/CX"],[5,1080,1920]],[232,-3,[10,"3f2oTdCepERZdpmIfLsrhd"],-2],[233,45,-5.684341886080802e-14,-5.684341886080802e-14,1.1368683772161603e-13,1.1368683772161603e-13,960,-4,[10,"e8a+bU/8dPDbbJguUzLdoF"]],-5],4,4,4,1],[1,540,960.0000000000001,0]],[83,"NatoonsEncyclopedia",false,33554432,1,[-22,-23,-24,-25,-26,-27,-28],[[[30,-20],-21],4,1],[1,2.967,-40.682,0]],[83,"UnlockScreen",false,33554432,1,[-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45],[[[30,-29],-30],4,1],[1,0,-5.627,0]],[155,0,{},[19,"53vKouf8tIqrJE9sorGNMt",-53,[239,"80xhohs6VOb42xHJ40Sxv0",null,[[143,[0,["53vKouf8tIqrJE9sorGNMt"]],[-50,-51,-52]]],[[3,["_lpos"],[0,["53vKouf8tIqrJE9sorGNMt"]],[1,0,0,0]],[2,"Animal",["_name"],[0,["53vKouf8tIqrJE9sorGNMt"]]],[3,["_lrot"],[0,["53vKouf8tIqrJE9sorGNMt"]],[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],[0,["53vKouf8tIqrJE9sorGNMt"]],[1,0,180,0]],[107,["sphere"],[0,["f0+X1ZhodFgJJg4GPQVMFV"]],-46],[107,["mainCamera"],[0,["f0+X1ZhodFgJJg4GPQVMFV"]],-47],[107,["targetNode"],[0,["f0+X1ZhodFgJJg4GPQVMFV"]],-48],[107,["feedPosition"],[0,["f0+X1ZhodFgJJg4GPQVMFV"]],-49],[2,true,["_active"],[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]]],[2,true,["_active"],[0,["53vKouf8tIqrJE9sorGNMt"]]],[2,"VD302_Kangaroo_Toy",["_name"],[0,["1dRKqITCJJR6zNWur3+Cgc","5fl0cfxJ5Rs5ovU2QsXaQ9"]]],[3,["_lpos"],[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]],[1,0,0,0]],[45,["_clips","0"],[0,["1dRKqITCJJR6zNWur3+Cgc","08p3MFuydXL4oM9CbjboO3"]],37],[45,["_defaultClip"],[0,["1dRKqITCJJR6zNWur3+Cgc","08p3MFuydXL4oM9CbjboO3"]],38],[45,["_clips","1"],[0,["1dRKqITCJJR6zNWur3+Cgc","08p3MFuydXL4oM9CbjboO3"]],39],[2,4,["_clips","length"],[0,["1dRKqITCJJR6zNWur3+Cgc","08p3MFuydXL4oM9CbjboO3"]]],[45,["_clips","2"],[0,["1dRKqITCJJR6zNWur3+Cgc","08p3MFuydXL4oM9CbjboO3"]],40],[45,["_clips","3"],[0,["1dRKqITCJJR6zNWur3+Cgc","08p3MFuydXL4oM9CbjboO3"]],41],[174,["_clips","4"],[0,["1dRKqITCJJR6zNWur3+Cgc","08p3MFuydXL4oM9CbjboO3"]]],[3,["_lrot"],[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]],[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]],[1,0,180,0]]]],0]],[158,"Bip001 Head",[[-54,[22,"Bip001 R_UpEyelid",-55,[1,0.34337615966796875,0.2510550022125244,-0.2245255559682846],[3,0.12247283914442461,0.7241107318662566,0.05565574464344822,0.6764366117798485],[1,5.045205968772248,93.25085851212803,14.63514863313527]],[22,"Bip001 L_UpEyelid",-56,[1,0.34337615966796875,0.2510535717010498,0.22452694177627563],[3,-0.12247256348552801,-0.7241110299639162,0.055651747412626976,0.6764366714540253],[1,-5.045519010090419,-93.25085191470198,14.634809479074342]],[22,"Bip001 R_DownEyelid",-57,[1,0.2697715759277344,0.25691771507263184,-0.21696408092975616],[3,0.1223849945588972,0.7241674026347854,0.05572241887057009,0.6763863526884764],[1,5.031255141657216,93.26145031601891,14.633446357809548]],[22,"Bip001 L_DownEyelid",-58,[1,0.2697715759277344,0.25691652297973633,0.21696552634239197],[3,-0.12238473441172545,-0.7241676447406158,0.055718354862578263,0.6763864753417299],[1,-5.031576404901483,-93.26143307554283,14.633102810797125]],[22,"Bip001 UP_Lip",-59,[1,0.1482524871826172,0.8653846979141235,0.00001548483851365745],[3,-7.019732607805063e-7,-0.0000036544161645705422,0.8095809949645157,0.5870081878291113],[1,179.99906124463647,-179.99941869080754,71.88997265189033]],[22,"Bip001 R_Up_Lip",-60,[1,0.1558370590209961,0.813302755355835,-0.08448056876659393],[3,0.6440443531968911,-0.40946052339214933,0.5172257532139795,0.3873325071703341],[1,111.56741681299894,-82.49034886429834,-7.281525826520712]],[22,"Bip001 L_Up_Lip",-61,[1,0.1558370590209961,0.8133022785186768,0.08448508381843567],[3,0.6440443378808218,-0.4094576824341174,-0.5172280058902883,-0.3873325277614716],[1,-111.56768796709501,82.49035459539483,-7.281211700610275]],[22,"Bip001 R_Lip",-62,[1,0.1689472198486328,0.7362625598907471,-0.09580332785844803],[3,-0.5195301736970601,0.5128582682233938,0.5599839650491572,0.3917687509501342],[1,-99.65597338896119,98.85268539858689,-5.400802261110559]],[22,"Bip001 L_Lip",-63,[1,0.1689472198486328,0.7362620830535889,0.09580741077661514],[3,0.5195300528317897,-0.5128618428673297,0.5599808042180879,0.39176874970138664],[1,99.65555102296493,-98.85270528484511,-5.4011515009998945]],[22,"Bip001 R_EyeBall",-64,[1,0.31261539459228516,0.23719239234924316,-0.1390356719493866],[3,-0.6884858534158385,-0.009179707517785443,0.7106473369420088,0.14451064013900036],[1,-169.01665158428787,90.5992931168743,12.593492657351312]],[22,"Bip001 L_EyeBall",-65,[1,0.31261539459228516,0.23719167709350586,0.13903698325157166],[3,0.6884858477219524,0.009175758634226603,0.7106473906694875,0.1445106538450356],[1,169.01632871573827,-90.59929283117292,12.593175480769082]],-66,[22,"Bip001 nose",-67,[1,0.32142162322998047,0.7735657691955566,-0.00001353079187538242],[3,0.0000029573027132187497,1.9355367263776715e-7,0.055661912494588996,0.9984496739889605],[1,0.000339223991494756,0.000003302881515195641,6.381683568818498]],-68,[22,"Bip001 R_cheek",-69,[1,0.05211019515991211,0.2889235019683838,-0.1565088927745819],[3,0.05841113290049033,0.7065731926138281,0.039178192854431165,0.7041360182787445],[1,1.555941669856946,90.09031156983801,7.915762344815528]],[22,"Bip001 L_cheek",-70,[1,0.05211019515991211,0.2889225482940674,0.15651053190231323],[3,-0.05841107281476088,-0.7065734252129403,0.039174191569980386,0.7041360124793511],[1,-1.556261645997518,-90.09031325464657,7.9154330170357]],-71,[22,"Bip001 UpTeeth",-72,[1,0.1596221923828125,0.847388744354248,-0.00002852861871360801],[3,2.7861110174443624e-7,-0.000004770442341778068,0.8331330139697966,0.5530726724498041],[1,179.99878138597225,-179.99915270600772,67.15613517320901]],[22,"Bn_Mouth",-73,[1,0.1322927474975586,0.8844605684280396,0.0000019073486328125],[3,-0.06744714874232752,0.6958798219497017,0.7094951918431234,-0.08842357310848374],[1,-90.93173238028068,-178.39319594896983,-12.670413083369786]]],1,4,4,4,4,4,4,4,4,4,4,4,1,4,1,4,4,1,4,4],[1,0.5518631935119629,0.09183895587921143,2.547251369833248e-7],[3,-1.1069167078265287e-13,1.1962683563867385e-7,-0.043131225804261084,0.9990694156867217],[1,5.934478864202835e-7,0.000013746614115451107,-4.944008108247556]],[86,"PopupManager",33554432,1,[-81,-82,-83,-84,-85],[[30,-74],[240,-80,-79,-78,-77,-76,-75]]],[156,"SelectLockAnimal",33554432,1,[-88,-89,-90,-91,-92,-93,-94,-95,-96,-97],[[[30,-86],-87],4,1]],[155,0,{},[106,"94Sq0jzYtOUYIB3Izu94jQ",[],-102,[91,"46647du4RNV61Axj46mbiH",null,[[25,[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[[31],[32]]],[25,[0,["e9oEMtSEFCD72WH/ol8s2d"]],[[31],[32]]],[25,[0,["98xhROvGdIPoSg3QUf9h+y"]],[[31],[32]]],[25,[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[[92,-101]]]],[[3,["_lpos"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[1,147.2,232.106,401.3]],[2,"Slow Summon_Tornado2",["_name"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]]],[3,["_lrot"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[3,0,0,0,1]],[3,["_euler"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[1,0,0,0]],[2,"Loop",["_name"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]]],[3,["_lrot"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[3,0.7071067811865475,0,0,0.7071067811865476]],[3,["_euler"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,90,0,0]],[3,["_lscale"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,1,1,1]],[2,0,["scaleSpace"],[0,["b615rXNVZOkaAqalmbWHKY"]]],[2,0,["scaleSpace"],[0,["e4BdczZRZFsq0axbldS3nu"]]],[2,0,["scaleSpace"],[0,["85EWZgajlGWLnvVdcXcawA"]]],[2,0,["scaleSpace"],[0,["16TzDGcvxEz73JGX3bVb1A"]]],[2,0,["scaleSpace"],[0,["3f2eD7h5NG0LWRjmW56tac"]]],[2,0,["scaleSpace"],[0,["3bAwvElMpMMZjulFKgj4Ts"]]],[3,["_lscale"],[0,["5f/ln8lztNlIEDDHnPS5ks"]],[1,150,150,150]],[3,["_lpos"],[0,["5f/ln8lztNlIEDDHnPS5ks"]],[1,120.053,0,0]],[3,["_lpos"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,-1.543,0,0]],[2,524288,["_layer"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]]],[2,524288,["_layer"],[0,["e9oEMtSEFCD72WH/ol8s2d"]]],[2,524288,["_layer"],[0,["98xhROvGdIPoSg3QUf9h+y"]]],[2,524288,["_layer"],[0,["24i8e2YYtE9bOs2FiQfxsR"]]],[2,524288,["_layer"],[0,["ee32AHLDlNVrXOZIIC2QvM"]]],[2,524288,["_layer"],[0,["11L1FXudRIRZgjdFVyMQve"]]],[9,524288,["_layer"],-98],[2,524288,["_layer"],[0,["5f/ln8lztNlIEDDHnPS5ks"]]],[8,["_lscale"],-99,[1,1,1,1]],[9,true,["_active"],-100]]],237]],[241,"main",[-150,-151,1,-152,-153,4,-154,-155,-156,-157,-158,-159,-160,-161],[236,[[38,["_target"],2,[0,["4ewwOt9QZJsY2F+NqU3YyG"]],2,[0,["fcKw7GaxtECYcSJZlMX6nO"]]],[38,["_target"],3,[0,["ebxyx+i/dHUpt9pbi5K/z8"]],3,[0,["f8RgWEl+dFdqmEC9XtUBBl"]]],[38,["_target"],3,[0,["8d4BE+5iJN0Idh6DyimFDd"]],3,[0,["ffvBmgoHVBSo4YQj3mMC7U"]]],[108,["encyclopediaUI"],-136,2,[0,["afXaHe/AtAta5arjNx60zH"]]],[38,["kangarooNode"],4,[0,["f0+X1ZhodFgJJg4GPQVMFV"]],4,[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]]],[38,["feedPosition"],4,[0,["f0+X1ZhodFgJJg4GPQVMFV"]],4,[0,["b1ejwKP8BBD6UH4x6Zi3XS"]]],[108,["kangaroo"],-137,4,[0,["f0+X1ZhodFgJJg4GPQVMFV"]]],[108,["kangarooNode"],-138,4,[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]]],[108,["animalModel"],-139,4,[0,["1dRKqITCJJR6zNWur3+Cgc","8fJHyWPHhT77T0qzBIqM/Z"]]],[38,["_trailModule","_particleSystem"],8,[0,["b615rXNVZOkaAqalmbWHKY"]],8,[0,["b615rXNVZOkaAqalmbWHKY"]]],[38,["_trailModule","_particleSystem"],8,[0,["e4BdczZRZFsq0axbldS3nu"]],8,[0,["e4BdczZRZFsq0axbldS3nu"]]],[38,["_trailModule","_particleSystem"],8,[0,["85EWZgajlGWLnvVdcXcawA"]],8,[0,["85EWZgajlGWLnvVdcXcawA"]]],[38,["_trailModule","_particleSystem"],8,[0,["16TzDGcvxEz73JGX3bVb1A"]],8,[0,["16TzDGcvxEz73JGX3bVb1A"]]],[38,["_trailModule","_particleSystem"],8,[0,["3f2eD7h5NG0LWRjmW56tac"]],8,[0,["3f2eD7h5NG0LWRjmW56tac"]]],[38,["_trailModule","_particleSystem"],8,[0,["3bAwvElMpMMZjulFKgj4Ts"]],8,[0,["3bAwvElMpMMZjulFKgj4Ts"]]],[38,["_target"],-141,[0,["dbZGYUoQNBUbudEMrUrFCD"]],-140,[0,["60LXZn/xVEHpmWdnH2tQbx"]]],[38,["_target"],-143,[0,["90tjOlXItBYYeTXD5zMhct"]],-142,[0,["86xM7AC1JD4pK8JkP+CVxw"]]],[38,["_target"],-145,[0,["1fl0mehsNNV6DH+oH2kX8r"]],-144,[0,["30Y3Yt9ihPkqmbHvZiSjrv"]]],[38,["_target"],-147,[0,["90tjOlXItBYYeTXD5zMhct"]],-146,[0,["86xM7AC1JD4pK8JkP+CVxw"]]],[38,["_target"],-149,[0,["dbZGYUoQNBUbudEMrUrFCD"]],-148,[0,["60LXZn/xVEHpmWdnH2tQbx"]]]],[-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113,-114,-115,-116,-117,-118,-119,-120,-121,8,-122,-123,-124,-125,-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,4]],[242,[243,0.78125,[2,0.2,0.5019607843137255,0.8,0.520833125],[2,0.2,0.5019607843137255,0.8,0.520833125]],[244,[4,4283190348]],[245],[246,[4,4292993505]],[247]]],[83,"ChangeAnimal",false,33554432,1,[-165,-166,-167,-168,-169],[[[30,-162],-163,-164],4,1,1],[1,0,-523.271,0]],[90,"Kangaroo",33554432,[-174,-175,-176],[[[5,-170,[5,142,146]],[12,0,-171,304],-172,-173],4,4,1,1],[1,-349.242,2.083,0]],[90,"Flamingo",33554432,[-181,-182,-183],[[[5,-177,[5,142,146]],[12,0,-178,220],-179,-180],4,4,1,1],[1,-13.517,2.083,0]],[90,"Lion",33554432,[-188,-189,-190],[[[5,-184,[5,142,146]],[12,0,-185,247],-186,-187],4,4,1,1],[1,-182.20550000000003,2.0825000000000387,0]],[90,"Giraffe",33554432,[-195,-196,-197],[[[5,-191,[5,142,146]],[12,0,-192,266],-193,-194],4,4,1,1],[1,156.827,2.083,0]],[204,"AppManager",512,"32tT6WWCBDoLWGv39PtYAD",9,[[252,-198,4,1],[253,-199]]],[49,"PopupRedirectCRM",false,33554432,6,[-202,-203,-204,-205,-206,-207],[[5,-200,[5,950,600]],[12,0,-201,181]],[1,4.380999999999972,7.830000000000041,0]],[36,"PopupCompleteExplore",33554432,2,[-210,-211,-212,-213,-214,-215],[[5,-208,[5,950,600]],[12,0,-209,167]],[1,1.4139999999999873,48.51200000000006,0]],[49,"Title",false,33554432,1,[-217,-218,-219,-220],[[30,-216]],[1,0,820.068,0]],[39,"Home",33554432,1,[-223,-224,-225,-226,-227],[[[30,-221],-222],4,1],[1,0,-609.826,0]],[0,["08p3MFuydXL4oM9CbjboO3"]],[0,["08p3MFuydXL4oM9CbjboO3"]],[205,"VD297_Giraffe_Rig",4,[[-230,-231,[194,"Bn_FoodSpawn",-232,[1,2.6372758199499913e-8,0,2.4216866493225098]]],1,1,4],[[254,false,-228,[19,20,21]],[177,-229,22]],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[90,"Panel",33554432,[-235,-236,-237,-238,-239],[[[5,-233,[5,670,200]],-234],4,1],[1,-3,-2.2737367544323206e-13,0]],[20,0,{},6,[19,"6cZhWWAgFMj77FGB9Dj31n",-255,[78,"4b0tCPmthLCo+9iatwuo6t",null,[[2,"PopupChangeAnimal",["_name"],[0,["6cZhWWAgFMj77FGB9Dj31n"]]],[3,["_lpos"],[0,["6cZhWWAgFMj77FGB9Dj31n"]],[1,4.380999999999972,30.173999999999978,0]],[3,["_lrot"],[0,["6cZhWWAgFMj77FGB9Dj31n"]],[3,0,0,0,1]],[8,["_euler"],-240,[1,0,0,0]],[87,["clickEvents","0","target"],-241,6],[9,"ed6bd7rLAVBMaM/SGvjXE4O",["clickEvents","0","_componentId"],-242],[9,"closePopup",["clickEvents","0","handler"],-243],[87,["clickEvents","0","target"],-244,1],[9,"facc9jj535Fnre+IlyJZiWZ",["clickEvents","0","_componentId"],-245],[9,"gotoAnimalSelect",["clickEvents","0","handler"],-246],[9,2,["clickEvents","length"],-247],[175,["clickEvents","1"],-248,[11,"ed6bd7rLAVBMaM/SGvjXE4O","closePopup",6]],[9,false,["_active"],-249],[9,"我们再试试其他动物吧！",["_string"],-250],[3,["_contentSize"],[0,["a6GoX/EExLsJCZyV08eAPd"]],[5,550,126]],[8,["_color"],-251,[4,4280049195]],[3,["_color"],[0,["90O0/WnJhCqb6l2P/JDz8k"]],[4,4280049195]],[3,["_color"],[0,["a98AeAjiFJv4HlPPy08zjr"]],[4,4292993508]],[8,["_normalColor"],-252,[4,4292993508]],[8,["_pressedColor"],-253,[4,4286545791]],[8,["_pressedColor"],-254,[4,4286545791]]]],67]],[0,["1fl0mehsNNV6DH+oH2kX8r"]],[20,0,{},6,[19,"6cZhWWAgFMj77FGB9Dj31n",-271,[35,"95j7aPeclGxZEp2kiPC6x8",[[2,"PopupUnlockAnimal",["_name"],[0,["6cZhWWAgFMj77FGB9Dj31n"]]],[3,["_lpos"],[0,["6cZhWWAgFMj77FGB9Dj31n"]],[1,4.380999999999972,30.173999999999978,0]],[3,["_lrot"],[0,["6cZhWWAgFMj77FGB9Dj31n"]],[3,0,0,0,1]],[8,["_euler"],-256,[1,0,0,0]],[87,["clickEvents","0","target"],-257,6],[9,"ed6bd7rLAVBMaM/SGvjXE4O",["clickEvents","0","_componentId"],-258],[9,"closePopup",["clickEvents","0","handler"],-259],[87,["clickEvents","0","target"],-260,1],[9,"facc9jj535Fnre+IlyJZiWZ",["clickEvents","0","_componentId"],-261],[9,"gotoUnlockUI",["clickEvents","0","handler"],-262],[9,2,["clickEvents","length"],-263],[175,["clickEvents","1"],-264,[11,"ed6bd7rLAVBMaM/SGvjXE4O","closePopup",6]],[9,false,["_active"],-265],[9,"我们再试试其他动物吧！",["_string"],-266],[3,["_contentSize"],[0,["a6GoX/EExLsJCZyV08eAPd"]],[5,550,126]],[8,["_color"],-267,[4,4280049195]],[3,["_color"],[0,["90O0/WnJhCqb6l2P/JDz8k"]],[4,4280049195]],[3,["_color"],[0,["a98AeAjiFJv4HlPPy08zjr"]],[4,4292993508]],[8,["_normalColor"],-268,[4,4292993508]],[8,["_pressedColor"],-269,[4,4286545791]],[8,["_pressedColor"],-270,[4,4286545791]]]],69]],[142,"Board",33554432,[-274,-275,-276,-277,-278],[[5,-272,[5,1000,800]],[12,0,-273,153]],[1,0,-279.1640000000001,6.310887241768095e-30]],[70,"Image",false,33554432,27,[-280,-281,-282,-283,-284],[[5,-279,[5,280,398]]]],[39,"Kangaroo",33554432,7,[-288,-289,-290],[[[5,-285,[5,257,140]],[109,1,0,-286,[4,4294769916],209],-287],4,4,1],[1,-247.646,-630.782,0]],[36,"Content",33554432,10,[13,11,12,14,-293],[[5,-291,[5,857.5889999999999,162.163]],[257,-292]],[1,111.2055,-18.9185,0]],[39,"Flamingo",33554432,7,[-297,-298,-299],[[[5,-294,[5,257.94,140]],[109,1,0,-295,[4,4294769916],223],-296],4,4,1],[1,248.987,-630.782,0]],[39,"Flamingo",33554432,3,[-302,-303,8,-304],[[[5,-300,[5,450,150]],-301],4,1],[1,0,-500,0]],[39,"Lion",33554432,7,[-308,-309,-310],[[[5,-305,[5,257.94,140]],[109,1,0,-306,[4,4294769916],250],-307],4,4,1],[1,-241.359,54.445,0]],[39,"Lion",33554432,3,[-313,-314,-315,-316],[[[5,-311,[5,450,150]],-312],4,1],[1,0,-500,0]],[39,"Giraffe",33554432,7,[-320,-321,-322],[[[5,-317,[5,257.94,140]],[109,1,0,-318,[4,4294769916],269],-319],4,4,1],[1,248.987,54.445,0]],[83,"Giraffe",false,33554432,3,[-325,-326,-327,-328],[[[5,-323,[5,450,150]],-324],4,1],[1,0,-500,0]],[83,"Kangaroo",false,33554432,3,[-331,-332,-333,-334],[[[5,-329,[5,450,150]],-330],4,1],[1,0,-500,0]],[219,"Access",false,33554432,[-340],[[37,-335,[10,"98TYGMtwRBTYZZn4EZmhzJ"],[5,461.28875,96]],[248,1,0,-336,[10,"77BcV1zfNHo4LI4KRqZupe"]],[258,2,-338,[10,"2fOwBXUwBNvaJ4NyyrOq4C"],[[11,"75348tPWIlDzr3PoY+ONjZ9","Playing",15]],[4,4292269782],-337],[234,20,0.09850047320089966,false,-339]],[1,0,-732.4790914542726,0],[1,0.8,0.8,1]],[226,"FoodManager",[-341],[1,-540,-535.2040000000002,0]],[83,"Food",false,33554432,1,[23,-344,-345,39],[[[30,-342],-343],4,1],[1,0,-418.796,0]],[0,["08p3MFuydXL4oM9CbjboO3"]],[0,["35MaNWaVpaXITwGugCw+yp"]],[0,["49pWBJK15R+45zZnNOgfJN"]],[86,"Content",33554432,2,[-347,-348,-349,-350,27],[[30,-346]]],[220,"Food",false,33554432,27,[-352,-353,-354,-355],[[5,-351,[5,556,405]]],[1,0,-36.955,0],[1,1.7,1.7,1.7]],[168,"Habitat",33554432,27,[-357,-358,-359,-360],[[5,-356,[5,555,403]]],[1,0,-39.983,0],[1,1.7,1.7,1.7]],[168,"Map",33554432,27,[-362,-363,-364,-365],[[5,-361,[5,556,405]]],[1,0,-36.955,0],[1,1.7,1.7,1.7]],[86,"BG",33554432,7,[-368,-369,-370,-371],[[5,-366,[5,1080,1920]],[249,false,-367,205]]],[221,"PlaneBG",33554432,"684Xfo6PBJfYy7Ms6g7iAs",9,[-373,-374,-375,-376],[[30,-372]],[1,542.967,919.3180000000001,0]],[0,["35MaNWaVpaXITwGugCw+yp"]],[0,["49pWBJK15R+45zZnNOgfJN"]],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[0,["08p3MFuydXL4oM9CbjboO3"]],[39,"IconDefault",33554432,30,[-380,-381],[[[5,-377,[5,128,128]],[12,0,-378,302],-379],4,4,1],[1,-527.714,1.49,0]],[70,"CameraPermissionPopup",false,33554432,3,[-384,-385,-386,-387],[[30,-382],[264,-383]]],[159,"Bip001 Jaw",5,[[[22,"Bip001 R_Down_Lip",-388,[1,0.22414958477020264,-0.02978229522705078,-0.08345255255699158],[3,0.0379035511010869,-0.08312863876031353,-0.006381982952408379,0.9957972788300739],[1,4.269098997992235,-9.503310182423972,-1.0893766456782763]],[22,"Bip001 L_Down_Lip",-389,[1,0.22414958477020264,-0.029782772064208984,0.08345238864421844],[3,-0.037903543695988244,0.08312866121180473,-0.006381548032422486,0.9957972800249704],[1,-4.269102224069318,9.503314555275125,-1.0893270358589797]],[22,"Bip001 Down_Lip",-390,[1,0.2706289291381836,-0.04498434066772461,-0.0000031644667615182698],[3,1.3287119702936462e-8,5.713210890487879e-7,-0.0257779617757464,0.9996676931292525],[1,0.000003214003631930435,0.00006557321519133576,-2.954264076398538]],-391,[22,"Bip001 DownTeeth",-392,[1,0.2538257837295532,-0.03244733810424805,-0.000030705345125170425],[3,1.7297688071575725e-14,-2.3735439809270516e-8,0.008557617494658156,0.999963382921002],[1,2.3281093649878275e-8,-0.000002720179887652147,0.9806426997154128]]],4,4,4,1,4],[1,0.1990981101989746,0.5892319679260254,0.000001037686160998419],[3,2.504685350165249e-7,-0.000002399451695679412,0.8283695703185308,0.5601819837914038],[1,179.99934519577238,-179.99952254268467,68.1367681348831]],[39,"Berries",33554432,23,[-396],[[[5,-393,[5,140,140]],[18,1,0,-394,28],-395],4,4,1],[1,-226.563,2.2737367544323206e-13,0]],[39,"Steak",33554432,23,[-400],[[[5,-397,[5,140,140]],[18,1,0,-398,30],-399],4,4,1],[1,-77.16799999999995,2.2737367544323206e-13,0]],[39,"Twig",33554432,23,[-404],[[[5,-401,[5,140,140]],[18,1,0,-402,32],-403],4,4,1],[1,74.15500000000009,2.2737367544323206e-13,0]],[39,"Seaweed",33554432,23,[-408],[[[5,-405,[5,140,140]],[18,1,0,-406,34],-407],4,4,1],[1,228.44900000000007,2.2737367544323206e-13,0]],[39,"Panel",33554432,19,[-411,-412,-413],[[[5,-409,[5,506,200]],-410],4,1],[1,8,0,0]],[39,"Food",33554432,61,[-417],[[[5,-414,[5,140,140]],[18,1,0,-415,47],-416],4,4,1],[1,-155,0,0]],[156,"Encyclopedia",33554432,61,[-421],[[[5,-418,[5,140,140]],[18,1,0,-419,49],-420],4,4,1]],[39,"AnimalSelect",33554432,61,[-425],[[[5,-422,[5,140,140]],[18,1,0,-423,51],-424],4,4,1],[1,155,0,0]],[70,"GamePhoto",false,262144,1,[-427,-428,-429],[[30,-426]]],[36,"CRMredirect",33554432,19,[-434],[[5,-430,[5,150,180]],[18,1,0,-431,66],[55,1,-433,[[11,"ed6bd7rLAVBMaM/SGvjXE4O","showPopupRedirectCRM",6]],[4,4286545791],-432,188]],[1,400,-193.44499999999994,0]],[0,["90tjOlXItBYYeTXD5zMhct"]],[20,0,{},6,[19,"77tpR1SF1JW791bN0FX0Ek",-440,[35,"41y3b+xRBMIqabZBVB+/Br",[[9,"PopupParent",["_name"],-435],[8,["_lpos"],-436,[1,0,0,0]],[8,["_lrot"],-437,[3,0,0,0,1]],[8,["_euler"],-438,[1,0,0,0]],[9,false,["_active"],-439],[3,["_color"],[0,["ecJ+16YhdJAre3lU8WrmIN"]],[4,4294967295]],[87,["clickEvents","1","target"],25,1],[9,"facc9jj535Fnre+IlyJZiWZ",["clickEvents","1","_componentId"],25],[9,"gotoUnlockUI",["clickEvents","1","handler"],25],[87,["clickEvents","0","target"],25,6],[9,"ed6bd7rLAVBMaM/SGvjXE4O",["clickEvents","0","_componentId"],25],[9,"closePopup",["clickEvents","0","handler"],25],[9,2,["clickEvents","length"],25],[3,["_color"],[0,["8bAhzrqaVPDZg/Vpl7w190"]],[4,4280049195]],[8,["_pressedColor"],25,[4,4286545791]]]],68]],[0,["90tjOlXItBYYeTXD5zMhct"]],[36,"CRM",33554432,16,[-445],[[5,-441,[5,540,183]],[18,1,0,-442,74],[55,1,-444,[[11,"d5570+aNMNBpKsWeic7F5lj","redirectCRM",2]],[4,4286545791],-443,175]],[1,0,-285.246,0]],[36,"Title",33554432,2,[-447,-448,-449,-450],[[30,-446]],[1,-2.9669999999999845,860.7499999999999,0]],[86,"Kagaroo",33554432,71,[-452,-453,-454],[[30,-451]]],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[70,"Lion",false,33554432,71,[-456,-457,-458],[[30,-455]]],[86,"Flamingo",33554432,71,[-460,-461,-462],[[30,-459]]],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[86,"Giraffe",33554432,71,[-464,-465,-466],[[30,-463]]],[0,["49pWBJK15R+45zZnNOgfJN"]],[95,"HabitatBtn",33554432,44,[-470],[[[5,-467,[5,200,200]],[18,1,0,-468,115],-469],4,4,1],[1,-85,-740,0],[3,1,6.123233995736766e-17,6.123233995736766e-17,3.749399456654644e-33],[1,180,-7.016709298534876e-15,7.016709298534876e-15]],[95,"PictureBtn",33554432,44,[-474],[[[5,-471,[5,200,200]],[18,1,0,-472,117],-473],4,4,1],[1,297.759,-740,0],[3,1,6.123233995736766e-17,3.749399456654644e-33,6.123233995736766e-17],[1,180,0,7.016709298534876e-15]],[95,"LocationBtn",33554432,44,[-478],[[[5,-475,[5,200,200]],[18,1,0,-476,119],-477],4,4,1],[1,107.136,-740,0],[3,-6.123233995736766e-17,-6.123233995736766e-17,1,-3.749399456654644e-33],[1,180,180,0]],[95,"FoodBtn",33554432,44,[-482],[[[5,-479,[5,200,200]],[18,1,0,-480,121],-481],4,4,1],[1,-281.659,-740,0],[3,6.123233995736766e-17,6.123233995736766e-17,-1,-6.123233995736766e-17],[1,180,180,7.016709298534876e-15]],[36,"CRM",33554432,17,[-487],[[5,-483,[5,540,183]],[18,1,0,-484,160],[55,1,-486,[[11,"d5570+aNMNBpKsWeic7F5lj","redirectCRM",2]],[4,4286545791],-485,161]],[1,0,-285.246,0]],[36,"Guilde",33554432,17,[-492],[[5,-488,[5,540,183]],[18,1,0,-489,165],[55,1,-491,[[11,"d5570+aNMNBpKsWeic7F5lj","showTutorialPopup",2]],[4,4286545791],-490,166]],[1,0,-474.006,0]],[142,"CheckBtn",33554432,[-497],[[5,-493,[5,128,128]],[18,1,0,-494,169],[178,1,-496,[[11,"d5570+aNMNBpKsWeic7F5lj","hideTutorialPopup",2]],[4,4286545791],-495,170,171,172,173]],[1,0,-843.123,0]],[36,"Guilde",33554432,16,[-502],[[5,-498,[5,540,183]],[18,1,0,-499,179],[55,1,-501,[[11,"ed6bd7rLAVBMaM/SGvjXE4O","showTutorialPopup",6]],[4,4286545791],-500,180]],[1,0,-474.006,0]],[142,"CheckBtn",33554432,[-507],[[5,-503,[5,128,128]],[18,1,0,-504,183],[178,1,-506,[[11,"ed6bd7rLAVBMaM/SGvjXE4O","closePopup",6]],[4,4286545791],-505,184,185,186,187]],[1,0,-839.13,0]],[36,"CRMredirect",33554432,10,[-512],[[5,-508,[5,150,180]],[18,1,0,-509,216],[55,1,-511,[[11,"ed6bd7rLAVBMaM/SGvjXE4O","showPopupRedirectCRM",6]],[4,4286545791],-510,217]],[1,400,-280,0]],[0,["bcbBLaSAhbuZMFUUZNLvRX"]],[0,["a5Ur2McGJUfKEIm/lueZtm"]],[70,"Comfirm",false,33554432,7,[-515,-516,-517],[[5,-513,[5,600,400]],[12,0,-514,316]]],[36,"Yes",33554432,91,[-522],[[5,-518,[5,150,50]],[18,1,0,-519,306],[60,2,-521,[4,4292269782],-520,307,308,309,310]],[1,-140,-75.506,0]],[36,"No",33554432,91,[-527],[[5,-523,[5,150,50]],[18,1,0,-524,311],[60,2,-526,[4,4292269782],-525,312,313,314,315]],[1,140,-75.506,0]],[36,"Allow",33554432,55,[-532],[[5,-528,[5,100,40]],[18,1,0,-529,340],[60,2,-531,[4,4292269782],-530,341,342,343,344]],[1,-100,-55.339,0]],[36,"Deny",33554432,55,[-537],[[5,-533,[5,100,40]],[18,1,0,-534,345],[60,2,-536,[4,4292269782],-535,346,347,348,349]],[1,100,-55.339,0]],[158,"Bip001 Neck",[[-538,-539,-540,[22,"Bip001 Hair01",-541,[1,-0.06071972846984863,-0.2820974588394165,8.112858722597593e-7],[3,1.6516783028762314e-14,0.0000018647883395428245,-0.6723349568022915,0.7402470573113974],[1,0.0014976386299721703,0.0016489140950808594,-84.49506936731329]]],1,1,1,4],[1,0.9543073177337646,-0.3201141357421875,-5.500842235051095e-7],[3,1.1810981550389486e-14,6.097828807722803e-7,-0.2198525345649096,0.9755331173491822],[1,0.000017006426557973736,0.00007546117671314657,-25.40074358145492]],[96,"Close",33554432,23,[[[5,-542,[5,128,128]],[18,1,0,-543,35],-544],4,4,1],[1,399.049,0.8710000000002083,0]],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[195,"Photo",33554432,19,[[[5,-545,[5,128,128]],[18,1,0,-546,52],-547],4,4,1],[1,0,-219.15599999999995,0],[1,1.5,1.5,1]],[28,"BtnHome",false,33554432,19,[[5,-548,[5,150,178]],[18,1,0,-549,60],[259,1,-551,[[11,"facc9jj535Fnre+IlyJZiWZ","crowButton",1]],-550,61]],[1,-400,1400,0]],[21,"BtnHome",33554432,19,[[5,-552,[5,150,150]],[18,1,0,-553,62],[55,1,-555,[[11,"facc9jj535Fnre+IlyJZiWZ","giftBoxHomeButton",1]],[4,4286545791],-554,63]],[1,-421.4475,1428.859,0]],[20,0,{},66,[19,"60whtUc01AqKpk/+jyFPeB",-562,[172,"95BcMAM6BD6a96Ua4iSx4A",[[143,[0,["60whtUc01AqKpk/+jyFPeB"]],[-561]]],[[9,"Text_effect-001",["_name"],-556],[8,["_lpos"],-557,[1,0,0,0]],[8,["_lrot"],-558,[3,0,0,0,1]],[8,["_euler"],-559,[1,0,0,0]],[2,10,["_totalParticles"],[0,["89UC8wTZJKBIPn2IyJPyqJ"]]],[9,true,["_active"],-560],[3,["_lpos"],[0,["feWWPHO4RLA6LnERZbRi0y"]],[1,-12.902000000000008,-7.797,-1]],[3,["_contentSize"],[0,["89hbBDCQVH4LrOphozzWmZ"]],[5,250,100]]]],64]],[0,["60whtUc01AqKpk/+jyFPeB"]],[0,["dbZGYUoQNBUbudEMrUrFCD"]],[0,["77tpR1SF1JW791bN0FX0Ek"]],[0,["dbZGYUoQNBUbudEMrUrFCD"]],[28,"RotateL",false,33554432,2,[[5,-563,[5,128,128]],[18,1,0,-564,75],[60,2,-566,[4,4292269782],-565,76,77,78,79]],[1,-278.669,211.448,0]],[28,"RotateR",false,33554432,2,[[5,-567,[5,128,128]],[18,1,0,-568,80],[60,2,-570,[4,4292269782],-569,81,82,83,84]],[1,289.286,211.448,0]],[36,"Kangaroo",33554432,45,[-573],[[5,-571,[5,527.5752941176472,376.63]],[12,0,-572,125]],[1,-2.4005882352940655,-0.9097058823528563,0]],[49,"Flamingo",false,33554432,45,[-576],[[5,-574,[5,533.8870588235294,376.63]],[12,0,-575,127]],[1,0.7552941176471109,-0.9097058823528554,0]],[49,"Lion",false,33554432,45,[-579],[[5,-577,[5,519.4405882352941,378.27588235294115]],[12,0,-578,129]],[1,1.6667647058823531,6.580882352941262,0]],[49,"Giraffe",false,33554432,45,[-582],[[5,-580,[5,519.4405882352942,378.27588235294115]],[12,0,-581,131]],[1,1.6667647058823531,6.580882352941262,0]],[70,"Kangaroo",false,33554432,46,[-585],[[5,-583,[5,528,376]],[12,0,-584,133]]],[49,"Flamingo",false,33554432,46,[-588],[[5,-586,[5,528,376]],[12,0,-587,135]],[1,-0.25,-0.25,0]],[49,"Lion",false,33554432,46,[-591],[[5,-589,[5,528,376]],[12,0,-590,137]],[1,0.7129411764705882,2.389117647058823,0]],[49,"Giraffe",false,33554432,46,[-594],[[5,-592,[5,528,376]],[12,0,-593,139]],[1,0.7129411764705882,-1.426470588235294,0]],[49,"Kangaroo",false,33554432,47,[-597],[[5,-595,[5,556,405]],[12,0,-596,141]],[1,0,-1.78117647058815,0]],[49,"Flamingo",false,33554432,47,[-600],[[5,-598,[5,555,407]],[12,0,-599,143]],[1,0,-1.78117647058815,0]],[49,"Lion",false,33554432,47,[-603],[[5,-601,[5,554,404]],[12,0,-602,145]],[1,0,-1.78117647058815,0]],[49,"Giraffe",false,33554432,47,[-606],[[5,-604,[5,553,401]],[12,0,-605,147]],[1,0,-1.78117647058815,0]],[21,"Close",33554432,2,[[5,-607,[5,128,128]],[18,1,0,-608,154],[55,1,-610,[[11,"d5570+aNMNBpKsWeic7F5lj","hide",2]],[4,4286545791],-609,155]],[1,406.055,119.136,0]],[21,"Close",33554432,17,[[5,-611,[5,128,128]],[18,1,0,-612,162],[55,1,-614,[[11,"d5570+aNMNBpKsWeic7F5lj","hideCompletePopup",2]],[4,4286545791],-613,163]],[1,467.651,294.078,0]],[36,"Tuto",33554432,2,[-616,85],[[30,-615]],[1,-2.9669999999999845,40.682000000000016,0]],[21,"Close",33554432,16,[[5,-617,[5,128,128]],[18,1,0,-618,176],[55,1,-620,[[11,"ed6bd7rLAVBMaM/SGvjXE4O","closePopup",6]],[4,4286545791],-619,177]],[1,470,300,0]],[70,"Tuto",false,33554432,6,[-622,87],[[30,-621]]],[28,"RotateR",false,33554432,3,[[5,-623,[5,128,128]],[18,1,0,-624,190],[60,2,-626,[4,4292269782],-625,191,192,193,194]],[1,289.286,-296.087,0]],[28,"RotateL",false,33554432,3,[[5,-627,[5,128,128]],[18,1,0,-628,195],[60,2,-630,[4,4292269782],-629,196,197,198,199]],[1,-278.669,-296.087,0]],[28,"BtnBack",false,33554432,3,[[5,-631,[5,128,128]],[18,1,0,-632,200],[260,2,-634,[[11,"e1635qo31ZDXY0lR5t4Pnha","hide",3],[11,"38f24x0crREJarqw3t2YPCS","show",7]],[4,4292269782],-633,321,322,323,324]],[1,-443.086,863.329,0]],[20,0,{},88,[19,"60whtUc01AqKpk/+jyFPeB",-641,[172,"43haqL+8NAtK84ZuPVdE7G",[[143,[0,["60whtUc01AqKpk/+jyFPeB"]],[-640]]],[[9,"Text_effect-001",["_name"],-635],[8,["_lpos"],-636,[1,0,0,0]],[8,["_lrot"],-637,[3,0,0,0,1]],[8,["_euler"],-638,[1,0,0,0]],[2,10,["_totalParticles"],[0,["89UC8wTZJKBIPn2IyJPyqJ"]]],[9,true,["_active"],-639],[3,["_lpos"],[0,["feWWPHO4RLA6LnERZbRi0y"]],[1,-12.902000000000008,-7.797,-1]],[3,["_contentSize"],[0,["89hbBDCQVH4LrOphozzWmZ"]],[5,250,100]]]],214]],[0,["60whtUc01AqKpk/+jyFPeB"]],[99,"Lock",false,33554432,12,[[5,-642,[5,136.16,143.8]],[93,0,-643,[4,2315255808],219],[81,-644,[[11,"c8d65aN9XJPtacH/s2uxMQ5","addUnlockEvent",12]]]]],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[54,"Lock",33554432,13,[[5,-645,[5,136.16,143.8]],[93,0,-646,[4,2315255808],245],[261,-647,[[11,"c8d65aN9XJPtacH/s2uxMQ5","addUnlockEvent",13]],246]]],[0,["35MaNWaVpaXITwGugCw+yp"]],[0,["bcbBLaSAhbuZMFUUZNLvRX"]],[99,"Lock",false,33554432,14,[[5,-648,[5,136.16,143.8]],[93,0,-649,[4,2315255808],265],[81,-650,[[11,"c8d65aN9XJPtacH/s2uxMQ5","addUnlockEvent",14]]]]],[0,["49pWBJK15R+45zZnNOgfJN"]],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[99,"Lock",false,33554432,11,[[5,-651,[5,136.16,143.8]],[93,0,-652,[4,2315255808],300],[81,-653,[[11,"c8d65aN9XJPtacH/s2uxMQ5","addUnlockEvent",11]]]]],[96,"CameraBtn",33554432,3,[[[5,-654,[5,175,175]],[18,1,0,-655,326],-656],4,4,1],[1,0,-692.825,0]],[160,"BtnEdit",33554432,[[5,-657,[5,128,128]],[18,1,0,-658,327],[60,2,-660,[4,4292269782],-659,328,329,330,331]],[1,165.15,592.124,0]],[160,"BtnTick",33554432,[[5,-661,[5,128,128]],[18,1,0,-662,332],[60,2,-664,[4,4292269782],-663,333,334,335,336]],[1,318.216,592.124,0]],[21,"BtnHome",33554432,3,[[5,-665,[5,150,150]],[18,1,0,-666,351],[55,1,-668,[[11,"facc9jj535Fnre+IlyJZiWZ","giftBoxHomeButton",1]],[4,4286545791],-667,352]],[1,-421.4475,824.6599999999997,0]],[196,"SoundButton",33554432,1,[[[5,-669,[5,128,128]],[12,0,-670,354],-671],4,4,1],[1,433.4,820.0680000000001,0],[3,0,0,0.043619387365336,0.9990482215818578],[1,0,0,5.000000000000001]],[222,"Camera",1,[38],[[5,-672,[5,1080,1920]],[235,45,100,100,-673]]],[197,"Bip001 Spine",[-674,-675,-676],[1,0.400854229927063,0.015083789825439453,4.153639565629419e-7],[3,-0.000002052787330614699,-6.669589654747255e-7,-0.037431762275221075,0.9992991860140349],[1,-0.0002385966896096073,-0.0000854188249321574,-4.290366292445109]],[206,"Plane","fdlFjhfv5EQLWAOsKIysWY",9,[[265,"Plane<ModelComponent>",false,-677,[25],[29],26],[267,-678]],[1,0,0,-0.01],[1,2,2,2]],[96,"Reation",33554432,40,[[[5,-679,[5,941.16,106.8]],-680,[268,3,-681,[4,4278596352]]],4,1,4],[1,0,1030.402,0]],[20,0,{},18,[19,"11eNPD3O5GYoRUgAIxCkP0",-682,[35,"00+GQdIW5DMr7haNsMUCvl",[[9,"KangarooNameTag",["_name"],98],[8,["_lpos"],98,[1,0,0,0]],[8,["_lrot"],98,[3,0,0,0,1]],[8,["_euler"],98,[1,0,0,0]],[9,true,["_active"],98]]],42]],[20,0,{},18,[19,"11eNPD3O5GYoRUgAIxCkP0",-683,[35,"35bzqljjNA+4rSQELMrSqY",[[9,"LionNameTag",["_name"],99],[8,["_lpos"],99,[1,0,0,0]],[8,["_lrot"],99,[3,0,0,0,1]],[8,["_euler"],99,[1,0,0,0]],[2,"LION",["_string"],[0,["ebJnXfl+tHiJIUO67uuBpW"]]],[3,["_contentSize"],[0,["3ceulRayxKt62g5xjwaWn7"]],[5,134.55,104.8]],[2,"狮子",["_string"],[0,["e09/dbuUJBS6mikqBI1Kbs"]]],[9,false,["_active"],99]]],43]],[20,0,{},18,[19,"11eNPD3O5GYoRUgAIxCkP0",-684,[35,"d0GbmZMBhBc786ReunI4ia",[[9,"FlamingoNameTag",["_name"],100],[8,["_lpos"],100,[1,0,0,0]],[8,["_lrot"],100,[3,0,0,0,1]],[8,["_euler"],100,[1,0,0,0]],[2,"FLAMINGO",["_string"],[0,["ebJnXfl+tHiJIUO67uuBpW"]]],[3,["_contentSize"],[0,["3ceulRayxKt62g5xjwaWn7"]],[5,289.95,104.8]],[2,"火烈鸟",["_string"],[0,["e09/dbuUJBS6mikqBI1Kbs"]]],[3,["_contentSize"],[0,["c1qq9hugFEL7ITQmR5z1M4"]],[5,156,106.8]],[9,false,["_active"],100]]],44]],[20,0,{},18,[19,"11eNPD3O5GYoRUgAIxCkP0",-685,[35,"a8G04Ci5dAm4RNS107mV8M",[[9,"GiraffeNameTag",["_name"],101],[8,["_lpos"],101,[1,0,0,0]],[8,["_lrot"],101,[3,0,0,0,1]],[8,["_euler"],101,[1,0,0,0]],[2,"GIRAFFE",["_string"],[0,["ebJnXfl+tHiJIUO67uuBpW"]]],[3,["_contentSize"],[0,["3ceulRayxKt62g5xjwaWn7"]],[5,259.4,104.8]],[2,"长颈鹿",["_string"],[0,["e09/dbuUJBS6mikqBI1Kbs"]]],[3,["_contentSize"],[0,["c1qq9hugFEL7ITQmR5z1M4"]],[5,156,106.8]],[9,false,["_active"],101]]],45]],[20,0,{},72,[19,"8fJHyWPHhT77T0qzBIqM/Z",-692,[91,"5aKqa9J/BDHpyCnGodu/O/",null,[[25,[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[[31],[32]]]],[[2,"VD302_Kangaroo_Rig-Old",["_name"],[0,["8fJHyWPHhT77T0qzBIqM/Z"]]],[3,["_lpos"],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[1,0,-500,200]],[3,["_lrot"],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[3,0,0,0,1]],[8,["_euler"],-686,[1,0,0,0]],[2,4,["_clips","length"],[0,["08p3MFuydXL4oM9CbjboO3"]]],[45,["_clips","0"],[0,["08p3MFuydXL4oM9CbjboO3"]],87],[45,["_defaultClip"],[0,["08p3MFuydXL4oM9CbjboO3"]],88],[9,true,["playOnLoad"],-687],[2,"VD302_Kangaroo_Toy",["_name"],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]]],[3,["_lpos"],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[1,-5.960464477539063e-8,0,0]],[3,["_lrot"],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[3,-0.7071067811865476,0,0,0.7071067811865476]],[3,["_lscale"],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[1,1,1,1]],[3,["_euler"],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[1,-90.00000000000003,0,0]],[2,"Bip001",["_name"],[0,["61SpoqJn9XKIWNc6m3Gvr3"]]],[3,["_lpos"],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[1,-3.732301578907027e-9,1.5775775909423828,0.4474337100982666]],[3,["_lrot"],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408]],[3,["_lscale"],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[1,1,1,1]],[3,["_euler"],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[1,-90,-89.99991803772996,0]],[2,"Bn_FoodSpawn",["_name"],[0,["f3CmudYmJTjK7M6nViAmg5"]]],[3,["_lpos"],[0,["f3CmudYmJTjK7M6nViAmg5"]],[1,-5.4358654466568623e-8,0.009165484458208084,0.8870136737823486]],[3,["_lrot"],[0,["f3CmudYmJTjK7M6nViAmg5"]],[3,1.545431187269876e-8,-0.707106721581899,1.5454308319985022e-8,0.7071068407911907]],[3,["_lscale"],[0,["f3CmudYmJTjK7M6nViAmg5"]],[1,1,1,1]],[3,["_euler"],[0,["f3CmudYmJTjK7M6nViAmg5"]],[1,0.0000025044781562438738,-89.99999034065368,-7.67592264999771e-14]],[2,"Bip001 Pelvis",["_name"],[0,["f4npe4uvhfYIaPYyEku12n"]]],[3,["_lpos"],[0,["f4npe4uvhfYIaPYyEku12n"]],[1,0,0,0]],[3,["_lrot"],[0,["f4npe4uvhfYIaPYyEku12n"]],[3,-0.678948057080087,-0.19755655885105733,-0.1975572294033232,0.6789492491730041]],[3,["_lscale"],[0,["f4npe4uvhfYIaPYyEku12n"]],[1,1,1,1]],[3,["_euler"],[0,["f4npe4uvhfYIaPYyEku12n"]],[1,-89.99992243324212,-32.44732100165269,-0.00007915718266001345]],[2,"Bip001 Spine",["_name"],[0,["24QV1ABdRedL8PrNu+86Nq"]]],[3,["_lpos"],[0,["24QV1ABdRedL8PrNu+86Nq"]],[1,0.3542376756668091,0.3531496524810791,-0.0000013134826986060943]],[3,["_lrot"],[0,["24QV1ABdRedL8PrNu+86Nq"]],[3,-0.0000018851790819067795,-0.0000011795759439423908,0.06960712936962687,0.9975744821996876]],[3,["_lscale"],[0,["24QV1ABdRedL8PrNu+86Nq"]],[1,1,1,1]],[3,["_euler"],[0,["24QV1ABdRedL8PrNu+86Nq"]],[1,-0.00020810952367528602,-0.00012097697166633093,7.982844695585415]],[2,"Bip001 Spine1",["_name"],[0,["124ooP3KBc1Lk0UF5SkG6P"]]],[3,["_lpos"],[0,["124ooP3KBc1Lk0UF5SkG6P"]],[1,0.4582993984222412,-0.00035309791564941406,-9.790710464585572e-10]],[3,["_lrot"],[0,["124ooP3KBc1Lk0UF5SkG6P"]],[3,2.446313346659477e-13,-1.8054307341607132e-7,0.06509341476946535,0.9978791747268894]],[3,["_lscale"],[0,["124ooP3KBc1Lk0UF5SkG6P"]],[1,1,1,1]],[3,["_euler"],[0,["124ooP3KBc1Lk0UF5SkG6P"]],[1,0.0000013582370161722287,-0.000020821282842442467,7.46443354701361]],[2,"Bip001 L Thigh",["_name"],[0,["1aOCmC7G1QLYh3hQ/RIfCW"]]],[3,["_lpos"],[0,["1aOCmC7G1QLYh3hQ/RIfCW"]],[1,-0.39984893798828125,-0.30053311586380005,0.3836286962032318]],[3,["_lrot"],[0,["1aOCmC7G1QLYh3hQ/RIfCW"]],[3,0.7178273552306246,0.680038369359236,0.1348885996845741,0.06384958854192135]],[3,["_lscale"],[0,["1aOCmC7G1QLYh3hQ/RIfCW"]],[1,1,1,1]],[3,["_euler"],[0,["1aOCmC7G1QLYh3hQ/RIfCW"]],[1,-126.10226971349779,-70.08105235291427,83.47655542639572]],[2,"Bip001 R Thigh",["_name"],[0,["abAw8bUFFfbJbDdcCTemu+"]]],[3,["_lpos"],[0,["abAw8bUFFfbJbDdcCTemu+"]],[1,-0.399849534034729,-0.3005313277244568,-0.3836267292499542]],[3,["_lrot"],[0,["abAw8bUFFfbJbDdcCTemu+"]],[3,0.7178270792704299,0.6800386286793662,-0.134887694859659,-0.06385184057972494]],[3,["_lscale"],[0,["abAw8bUFFfbJbDdcCTemu+"]],[1,1,1,1]],[3,["_euler"],[0,["abAw8bUFFfbJbDdcCTemu+"]],[1,126.10304314074824,70.08038736689647,83.47680202680553]],[2,"Bip001 Xtra_Tail",["_name"],[0,["82O4d8FFlZfbWoM1gQ5T0P"]]],[3,["_lpos"],[0,["82O4d8FFlZfbWoM1gQ5T0P"]],[1,-0.9858397245407104,-0.43601518869400024,0.000001985863264053478]],[3,["_lrot"],[0,["82O4d8FFlZfbWoM1gQ5T0P"]],[3,9.877768196883434e-7,-0.0000026041092780163377,0.9789544108644718,-0.20407905684130798]],[3,["_lscale"],[0,["82O4d8FFlZfbWoM1gQ5T0P"]],[1,1,1,1]],[3,["_euler"],[0,["82O4d8FFlZfbWoM1gQ5T0P"]],[1,179.999706525755,-179.99994555523935,-23.551186460093533]],[2,"Bip001 Neck",["_name"],[0,["42dhuQU8NX0rXxQG7SW2YE"]]],[3,["_lpos"],[0,["42dhuQU8NX0rXxQG7SW2YE"]],[1,0.5762070417404175,-0.12533974647521973,9.96238668449223e-7]],[3,["_lrot"],[0,["42dhuQU8NX0rXxQG7SW2YE"]],[3,1.2697269418175673e-13,8.642778814821149e-7,-0.31160864818281975,0.9502105295022409]],[3,["_lscale"],[0,["42dhuQU8NX0rXxQG7SW2YE"]],[1,1,1,1]],[3,["_euler"],[0,["42dhuQU8NX0rXxQG7SW2YE"]],[1,0.000038299085695490824,0.00011678809352825268,-36.312403738338894]],[2,"Bip001 L Calf",["_name"],[0,["dbtmT0gRdSBIMmHDpIZtZm"]]],[3,["_lpos"],[0,["dbtmT0gRdSBIMmHDpIZtZm"]],[1,0.743604302406311,-1.1920928955078125e-7,-2.7755575615628914e-17]],[3,["_lrot"],[0,["dbtmT0gRdSBIMmHDpIZtZm"]],[3,0,0,-0.41653967720321833,0.909117537678951]],[3,["_lscale"],[0,["dbtmT0gRdSBIMmHDpIZtZm"]],[1,1,1,1]],[3,["_euler"],[0,["dbtmT0gRdSBIMmHDpIZtZm"]],[1,0,0,-49.23262954822765]],[2,"Bip001 R Calf",["_name"],[0,["54Lh51XGBYv7YuKOF5iKJs"]]],[3,["_lpos"],[0,["54Lh51XGBYv7YuKOF5iKJs"]],[1,0.7436041831970215,0,5.551115123125783e-17]],[3,["_lrot"],[0,["54Lh51XGBYv7YuKOF5iKJs"]],[3,-5.0466161121084984e-17,2.312259701504717e-17,-0.41653967720321833,0.909117537678951]],[3,["_lscale"],[0,["54Lh51XGBYv7YuKOF5iKJs"]],[1,1,1,1]],[3,["_euler"],[0,["54Lh51XGBYv7YuKOF5iKJs"]],[1,-6.361109362927037e-15,0,-49.23262954822765]],[2,"Bip001 Xtra_Tail1",["_name"],[0,["b98OsIwtddvaimim2Y6TQy"]]],[3,["_lpos"],[0,["b98OsIwtddvaimim2Y6TQy"]],[1,0.7776881456375122,-0.0007715225219726562,-2.1395862859208137e-9]],[3,["_lrot"],[0,["b98OsIwtddvaimim2Y6TQy"]],[3,1.7354177343170095e-13,2.4402726421175402e-8,-0.008798220935442457,0.9999612949051431]],[3,["_lscale"],[0,["b98OsIwtddvaimim2Y6TQy"]],[1,1,1,1]],[3,["_euler"],[0,["b98OsIwtddvaimim2Y6TQy"]],[1,2.4626572286066044e-8,0.000002796671380546391,-1.0082148613665045]],[2,"Bip001 Head",["_name"],[0,["bfrFfxzL1T1KmmYCwEZLjk"]]],[3,["_lpos"],[0,["bfrFfxzL1T1KmmYCwEZLjk"]],[1,0.271028995513916,0.1483471393585205,-1.397716005158145e-7]],[3,["_lrot"],[0,["bfrFfxzL1T1KmmYCwEZLjk"]],[3,-4.7459346984729076e-7,0.0000010302596964508388,-0.31471839988255196,0.9491850866791363]],[3,["_lscale"],[0,["bfrFfxzL1T1KmmYCwEZLjk"]],[1,1,1,1]],[3,["_euler"],[0,["bfrFfxzL1T1KmmYCwEZLjk"]],[1,-0.000018038935986709043,0.0001183982779817365,-36.6876293880894]],[2,"Bip001 L Clavicle",["_name"],[0,["36Y+vy/Y5QJ7jAvyy3x9XZ"]]],[3,["_lpos"],[0,["36Y+vy/Y5QJ7jAvyy3x9XZ"]],[1,-0.290891170501709,0.11437880992889404,0.056595951318740845]],[3,["_lrot"],[0,["36Y+vy/Y5QJ7jAvyy3x9XZ"]],[3,0.7404151484820694,0.19713777106521088,0.5926956475105046,-0.24826191117410562]],[3,["_lscale"],[0,["36Y+vy/Y5QJ7jAvyy3x9XZ"]],[1,1,1,1]],[3,["_euler"],[0,["36Y+vy/Y5QJ7jAvyy3x9XZ"]],[1,-143.0354460567296,-77.30871903103836,-0.13521382911142363]],[2,"Bip001 R Clavicle",["_name"],[0,["80Sxap8RleT7LfBkzDAi93"]]],[3,["_lpos"],[0,["80Sxap8RleT7LfBkzDAi93"]],[1,-0.2908914089202881,0.1143791675567627,-0.056598000228405]],[3,["_lrot"],[0,["80Sxap8RleT7LfBkzDAi93"]],[3,0.7404158188458404,0.19713941411025176,-0.5926951228460576,0.24825985974701364]],[3,["_lscale"],[0,["80Sxap8RleT7LfBkzDAi93"]],[1,1,1,1]],[3,["_euler"],[0,["80Sxap8RleT7LfBkzDAi93"]],[1,143.03551574473522,77.30872223520217,-0.1349050251337831]],[2,"Bip001 L Foot",["_name"],[0,["27lKXEzcFQsZTcP6tappE1"]]],[3,["_lpos"],[0,["27lKXEzcFQsZTcP6tappE1"]],[1,0.8391543626785278,2.9802322387695312e-8,0]],[3,["_lrot"],[0,["27lKXEzcFQsZTcP6tappE1"]],[3,0.09368384456679991,0.04668617534947475,0.18506039337690455,0.9771368323329169]],[3,["_lscale"],[0,["27lKXEzcFQsZTcP6tappE1"]],[1,1,1,1]],[3,["_euler"],[0,["27lKXEzcFQsZTcP6tappE1"]],[1,10.282468224363756,3.491167402013983,21.740666790231035]],[2,"Bip001 R Foot",["_name"],[0,["a0sQDO/bdTOryUmf6KpZ23"]]],[3,["_lpos"],[0,["a0sQDO/bdTOryUmf6KpZ23"]],[1,0.8391544222831726,-5.551115123125783e-17,1.4901161193847656e-8]],[3,["_lrot"],[0,["a0sQDO/bdTOryUmf6KpZ23"]],[3,-0.0936838530691832,-0.04668609764253182,0.1850603507511224,0.9771368433033805]],[3,["_lscale"],[0,["a0sQDO/bdTOryUmf6KpZ23"]],[1,1,1,1]],[3,["_euler"],[0,["a0sQDO/bdTOryUmf6KpZ23"]],[1,-10.282471032387543,-3.4911582401498076,21.740661053193115]],[2,"Bip001 Xtra_Tail2",["_name"],[0,["32EOimsNxW6auKvQxSU90n"]]],[3,["_lpos"],[0,["32EOimsNxW6auKvQxSU90n"]],[1,0.9689803123474121,-0.0008437633514404297,-2.9117472877260298e-9]],[3,["_lrot"],[0,["32EOimsNxW6auKvQxSU90n"]],[3,3.4403779720176436e-7,5.077550272064185e-7,-0.010108478258240874,0.9999489080282684]],[3,["_lscale"],[0,["32EOimsNxW6auKvQxSU90n"]],[1,1,1,1]],[3,["_euler"],[0,["32EOimsNxW6auKvQxSU90n"]],[1,0.00004001814766795572,0.00005859195632515687,-1.1583660107752876]],[2,"Bip001 Xtra_Eyelid_up_L",["_name"],[0,["2d7+KWFQJVFrgz3wx2r7Yn"]]],[3,["_lpos"],[0,["2d7+KWFQJVFrgz3wx2r7Yn"]],[1,0.3271970748901367,0.4205749034881592,-0.18183529376983643]],[3,["_lrot"],[0,["2d7+KWFQJVFrgz3wx2r7Yn"]],[3,-0.24522146530069025,-0.4163162103317173,0.8753637652717497,0.016897467860142394]],[3,["_lscale"],[0,["2d7+KWFQJVFrgz3wx2r7Yn"]],[1,1,1,1]],[3,["_euler"],[0,["2d7+KWFQJVFrgz3wx2r7Yn"]],[1,132.17461490430898,154.7176502037449,13.518670197215748]],[2,"Bip001 Xtra_Eyelid_up_R",["_name"],[0,["a5xYRu1R9c+4gSl9Nkoyrr"]]],[3,["_lpos"],[0,["a5xYRu1R9c+4gSl9Nkoyrr"]],[1,0.3271970748901367,0.4205739498138428,0.18183764815330505]],[3,["_lrot"],[0,["a5xYRu1R9c+4gSl9Nkoyrr"]],[3,0.24522088155166882,0.4163115567490713,0.8753661401629665,0.016897562675627805]],[3,["_lscale"],[0,["a5xYRu1R9c+4gSl9Nkoyrr"]],[1,1,1,1]],[3,["_euler"],[0,["a5xYRu1R9c+4gSl9Nkoyrr"]],[1,-132.17519821674765,-154.71765267277706,13.518521573560058]],[2,"Bip001 Xtra_Eyelid_Low_L",["_name"],[0,["bbzAt+/A5Za6JtvBJFLV6Q"]]],[3,["_lpos"],[0,["bbzAt+/A5Za6JtvBJFLV6Q"]],[1,0.21905755996704102,0.41451358795166016,-0.20157299935817719]],[3,["_lrot"],[0,["bbzAt+/A5Za6JtvBJFLV6Q"]],[3,0.4409942824246951,-0.040964274662843414,0.025457053795126677,0.8962130937908391]],[3,["_lscale"],[0,["bbzAt+/A5Za6JtvBJFLV6Q"]],[1,1,1,1]],[3,["_euler"],[0,["bbzAt+/A5Za6JtvBJFLV6Q"]],[1,52.42644045172507,-5.502120724866701,0.5443105331507334]],[2,"Bip001 Xtra_Eyelid_Low_R",["_name"],[0,["8bMDwNbY5Up6fKdikNpIQL"]]],[3,["_lpos"],[0,["8bMDwNbY5Up6fKdikNpIQL"]],[1,0.21905755996704102,0.41451263427734375,0.20157529413700104]],[3,["_lrot"],[0,["8bMDwNbY5Up6fKdikNpIQL"]],[3,-0.4409942824517709,0.040964133104330384,0.025457279176747588,0.896213093845864]],[3,["_lscale"],[0,["8bMDwNbY5Up6fKdikNpIQL"]],[1,1,1,1]],[3,["_euler"],[0,["8bMDwNbY5Up6fKdikNpIQL"]],[1,-52.426441892868866,5.502117589864751,0.5443408344453377]],[2,"Bip001 Xtra_Eye_R",["_name"],[0,["c2tjMLgltSz7/DvasIQO6O"]]],[3,["_lpos"],[0,["c2tjMLgltSz7/DvasIQO6O"]],[1,0.2641632556915283,0.35110998153686523,-0.14128649234771729]],[3,["_lrot"],[0,["c2tjMLgltSz7/DvasIQO6O"]],[3,-0.27964436716809643,0.1581443084705726,0.682003014140958,0.6570093563353323]],[3,["_lscale"],[0,["c2tjMLgltSz7/DvasIQO6O"]],[1,1,1,1]],[3,["_euler"],[0,["c2tjMLgltSz7/DvasIQO6O"]],[1,-98.45224704751105,88.08277038553146,53.873413080213766]],[2,"Bip001 Xtra_Eye_L",["_name"],[0,["6bI877qbhcC6ioHfi85K1R"]]],[3,["_lpos"],[0,["6bI877qbhcC6ioHfi85K1R"]],[1,0.2641632556915283,0.35110926628112793,0.1412884145975113]],[3,["_lrot"],[0,["6bI877qbhcC6ioHfi85K1R"]],[3,0.27964439645134875,-0.15814812287424745,0.6820021188053784,0.657009355115806]],[3,["_lscale"],[0,["6bI877qbhcC6ioHfi85K1R"]],[1,1,1,1]],[3,["_euler"],[0,["6bI877qbhcC6ioHfi85K1R"]],[1,98.4519445966391,-88.08278231192374,53.87309036235816]],[2,"Bip001 Xtra_Mouth_Cor_R",["_name"],[0,["ed/f9Db/pZuZRZD4YWAqds"]]],[3,["_lpos"],[0,["ed/f9Db/pZuZRZD4YWAqds"]],[1,-0.03132891654968262,0.5618903636932373,-0.11657057702541351]],[3,["_lrot"],[0,["ed/f9Db/pZuZRZD4YWAqds"]],[3,0.04929766191040832,-0.0604126283325885,0.7993534421572859,0.5957802693774057]],[3,["_lscale"],[0,["ed/f9Db/pZuZRZD4YWAqds"]],[1,1,1,1]],[3,["_euler"],[0,["ed/f9Db/pZuZRZD4YWAqds"]],[1,151.22228257200177,-152.1352089628443,71.17731919294856]],[2,"Bip001 Xtra_Mouth_Cor_L",["_name"],[0,["e9ki9vW3ha/oTYOTJfAkl8"]]],[3,["_lpos"],[0,["e9ki9vW3ha/oTYOTJfAkl8"]],[1,-0.03132891654968262,0.5618896484375,0.11657369136810303]],[3,["_lrot"],[0,["e9ki9vW3ha/oTYOTJfAkl8"]],[3,-0.04929762034087917,0.06040812745717985,0.7993537901967565,0.595780262230903]],[3,["_lscale"],[0,["e9ki9vW3ha/oTYOTJfAkl8"]],[1,1,1,1]],[3,["_euler"],[0,["e9ki9vW3ha/oTYOTJfAkl8"]],[1,-151.22349829367852,152.13605821250368,71.17747050798812]],[2,"Bip001 Xtra_Mouth_Up_R",["_name"],[0,["20BgvTdsleXrtRxNyWlh//"]]],[3,["_lpos"],[0,["20BgvTdsleXrtRxNyWlh//"]],[1,-0.04088473320007324,0.6360740661621094,-0.06928008049726486]],[3,["_lrot"],[0,["20BgvTdsleXrtRxNyWlh//"]],[3,-0.0038198481848174207,0.0019246733316340729,0.7995733037055219,0.6005532752336371]],[3,["_lscale"],[0,["20BgvTdsleXrtRxNyWlh//"]],[1,1,1,1]],[3,["_euler"],[0,["20BgvTdsleXrtRxNyWlh//"]],[1,-178.42422555767092,178.26911750409243,73.81321923996768]],[2,"Bip001 Xtra_Mouth_Up_L",["_name"],[0,["7cMoqyptdaSbxJ3NJe5s4D"]]],[3,["_lpos"],[0,["7cMoqyptdaSbxJ3NJe5s4D"]],[1,-0.04088473320007324,0.6360738277435303,0.0692836120724678]],[3,["_lrot"],[0,["7cMoqyptdaSbxJ3NJe5s4D"]],[3,0.003819830457478615,-0.0019290845247500956,0.7995732969633009,0.6005532701696075]],[3,["_lscale"],[0,["7cMoqyptdaSbxJ3NJe5s4D"]],[1,1,1,1]],[3,["_euler"],[0,["7cMoqyptdaSbxJ3NJe5s4D"]],[1,178.42278052602967,-178.26803494978196,73.813208998766]],[2,"Bip001 Xtra_Teath_Up",["_name"],[0,["34N3Tf3Vhf6p2OCEtjbUr5"]]],[3,["_lpos"],[0,["34N3Tf3Vhf6p2OCEtjbUr5"]],[1,0.002314329147338867,0.554196834564209,0.000004309463747631526]],[3,["_lrot"],[0,["34N3Tf3Vhf6p2OCEtjbUr5"]],[3,9.336697845026691e-7,1.9915808695504157e-7,0.8147948658617054,0.5797493652989147]],[3,["_lscale"],[0,["34N3Tf3Vhf6p2OCEtjbUr5"]],[1,1,1,1]],[3,["_euler"],[0,["34N3Tf3Vhf6p2OCEtjbUr5"]],[1,179.9998674950161,-179.99977440903933,70.86583252141891]],[2,"Bip001 Xtra_Jaw",["_name"],[0,["d7tLOit5hTsbOMYxHRvFOp"]]],[3,["_lpos"],[0,["d7tLOit5hTsbOMYxHRvFOp"]],[1,-0.020290136337280273,0.3777594566345215,-9.088580554816872e-9]],[3,["_lrot"],[0,["d7tLOit5hTsbOMYxHRvFOp"]],[3,-9.235465789091367e-8,-0.0000020748226942927456,0.7911309946054532,0.611646752112911]],[3,["_lscale"],[0,["d7tLOit5hTsbOMYxHRvFOp"]],[1,1,1,1]],[3,["_euler"],[0,["d7tLOit5hTsbOMYxHRvFOp"]],[1,179.9992786301882,-179.9994556648126,75.41733868808973]],[2,"Bip001 Xtra_EarL",["_name"],[0,["3dlgK1+6ZS+pIxXuBluE25"]]],[3,["_lpos"],[0,["3dlgK1+6ZS+pIxXuBluE25"]],[1,0.6298751831054688,-0.04161977767944336,0.21326301991939545]],[3,["_lrot"],[0,["3dlgK1+6ZS+pIxXuBluE25"]],[3,0.17229719240550637,-0.3286434668165523,0.041136212122997444,0.9276933551880974]],[3,["_lscale"],[0,["3dlgK1+6ZS+pIxXuBluE25"]],[1,1,1,1]],[3,["_euler"],[0,["3dlgK1+6ZS+pIxXuBluE25"]],[1,20.3010491465256,-38.635362133307176,-2.1161341392427624]],[2,"Bip001 Xtra_EarR",["_name"],[0,["68RNEaQ79QPq60RxDOrbld"]]],[3,["_lpos"],[0,["68RNEaQ79QPq60RxDOrbld"]],[1,0.6298751831054688,-0.04161834716796875,-0.21326324343681335]],[3,["_lrot"],[0,["68RNEaQ79QPq60RxDOrbld"]],[3,-0.17229802753627552,0.32864299124926405,0.04113777690385765,0.9276932991680245]],[3,["_lscale"],[0,["68RNEaQ79QPq60RxDOrbld"]],[1,1,1,1]],[3,["_euler"],[0,["68RNEaQ79QPq60RxDOrbld"]],[1,-20.30120120360858,38.635335030936766,-2.1159900209997105]],[2,"Bip001 Xtra_eyebrownR",["_name"],[0,["a5O6YJyIlZ0K3DMvMImW/M"]]],[3,["_lpos"],[0,["a5O6YJyIlZ0K3DMvMImW/M"]],[1,0.3929600715637207,0.4532432556152344,-0.1358882188796997]],[3,["_lrot"],[0,["a5O6YJyIlZ0K3DMvMImW/M"]],[3,-0.23773379651555063,0.542546868955643,-0.31570294536135707,0.7412537941021924]],[3,["_lscale"],[0,["a5O6YJyIlZ0K3DMvMImW/M"]],[1,1,1,1]],[3,["_euler"],[0,["a5O6YJyIlZ0K3DMvMImW/M"]],[1,-0.8227543143827625,72.04920289475375,-46.5517219786071]],[2,"Bip001 Xtra_eyebrownL",["_name"],[0,["ccJkUI+3RXpZAAZAVToHx+"]]],[3,["_lpos"],[0,["ccJkUI+3RXpZAAZAVToHx+"]],[1,0.3929600715637207,0.45324230194091797,0.13589075207710266]],[3,["_lrot"],[0,["ccJkUI+3RXpZAAZAVToHx+"]],[3,0.23773374855793258,-0.542545073389861,-0.3157059510744924,0.7412538435604459]],[3,["_lscale"],[0,["ccJkUI+3RXpZAAZAVToHx+"]],[1,1,1,1]],[3,["_euler"],[0,["ccJkUI+3RXpZAAZAVToHx+"]],[1,0.8225775813222904,-72.04909199221025,-46.55202036838682]],[2,"Bip001 Xtra11_Nose",["_name"],[0,["beBTxB4F9YIazSRhrqCQYQ"]]],[3,["_lpos"],[0,["beBTxB4F9YIazSRhrqCQYQ"]],[1,0.15001845359802246,0.7634279727935791,0.0000010193798516411334]],[3,["_lrot"],[0,["beBTxB4F9YIazSRhrqCQYQ"]],[3,1.9258151975219854e-12,-0.0000027674523216948566,0.9977835439810513,0.06654321417661394]],[3,["_lscale"],[0,["beBTxB4F9YIazSRhrqCQYQ"]],[1,1,1,1]],[3,["_euler"],[0,["beBTxB4F9YIazSRhrqCQYQ"]],[1,179.99968074891942,-179.99997870859482,7.630929361688651]],[2,"Bn_Mouth",["_name"],[0,["84hrPyzk1d1ruBlx05r4WZ"]]],[3,["_lpos"],[0,["84hrPyzk1d1ruBlx05r4WZ"]],[1,-0.07195711135864258,0.5386135578155518,0.008439688943326473]],[3,["_lrot"],[0,["84hrPyzk1d1ruBlx05r4WZ"]],[3,-0.46549811987707945,-0.5231723192550453,-0.44354066279808146,0.559351325376851]],[3,["_lscale"],[0,["84hrPyzk1d1ruBlx05r4WZ"]],[1,1,1,1]],[3,["_euler"],[0,["84hrPyzk1d1ruBlx05r4WZ"]],[1,-80.02761183493475,-86.61028004033459,-0.5224675849989031]],[2,"Bip001 L UpperArm",["_name"],[0,["57Le13NptWs5X3lanB4PyH"]]],[3,["_lpos"],[0,["57Le13NptWs5X3lanB4PyH"]],[1,0.2798118591308594,1.1920928955078125e-7,2.384185791015625e-7]],[3,["_lrot"],[0,["57Le13NptWs5X3lanB4PyH"]],[3,-0.24198095521163535,0.5819774871081226,-0.35439729720859986,0.6907604342646003]],[3,["_lscale"],[0,["57Le13NptWs5X3lanB4PyH"]],[1,1,1,1]],[3,["_euler"],[0,["57Le13NptWs5X3lanB4PyH"]],[1,7.057027719358092,83.55855063844022,-50.46736884718895]],[2,"Bip001 R UpperArm",["_name"],[0,["94nYA+SUZazqUalPScGfCg"]]],[3,["_lpos"],[0,["94nYA+SUZazqUalPScGfCg"]],[1,0.2798118591308594,4.440892098500626e-16,0]],[3,["_lrot"],[0,["94nYA+SUZazqUalPScGfCg"]],[3,0.24198129715613026,-0.5819780812733067,-0.35439678942351904,0.6907600744038257]],[3,["_lscale"],[0,["94nYA+SUZazqUalPScGfCg"]],[1,1,1,1]],[3,["_euler"],[0,["94nYA+SUZazqUalPScGfCg"]],[1,-7.056981598696757,-83.5586140647127,-50.46734445139137]],[2,"Bip001 L Toe0",["_name"],[0,["0ej8X8mtRS8IOXZwhuA0cA"]]],[3,["_lpos"],[0,["0ej8X8mtRS8IOXZwhuA0cA"]],[1,0.0993526503443718,0.3203730583190918,0.015012085437774658]],[3,["_lrot"],[0,["0ej8X8mtRS8IOXZwhuA0cA"]],[3,-0.012606775107827504,-0.004188367072502582,0.7176545698822673,0.6962725365327463]],[3,["_lscale"],[0,["0ej8X8mtRS8IOXZwhuA0cA"]],[1,1,1,1]],[3,["_euler"],[0,["0ej8X8mtRS8IOXZwhuA0cA"]],[1,-159.190288938885,157.82919259324692,88.13791814938088]],[2,"Bip001 R Toe0",["_name"],[0,["46OYGFnqVWX54eydGHqJue"]]],[3,["_lpos"],[0,["46OYGFnqVWX54eydGHqJue"]],[1,0.09935265779495239,0.320372998714447,-0.01501205563545227]],[3,["_lrot"],[0,["46OYGFnqVWX54eydGHqJue"]],[3,0.012606777493592694,0.004188363055347829,0.7176545996614502,0.6962725058200326]],[3,["_lscale"],[0,["46OYGFnqVWX54eydGHqJue"]],[1,1,1,1]],[3,["_euler"],[0,["46OYGFnqVWX54eydGHqJue"]],[1,159.19032927263092,-157.8292330582914,88.13791339787937]],[2,"Bip001 Xtra_Teath_Low",["_name"],[0,["054HrpVJ9YdrFA31Ec+dkY"]]],[3,["_lpos"],[0,["054HrpVJ9YdrFA31Ec+dkY"]],[1,0.13749122619628906,-0.031085491180419922,0.0000035714842852030415]],[3,["_lrot"],[0,["054HrpVJ9YdrFA31Ec+dkY"]],[3,0.000004232222292237529,-0.0000038132740061028115,0.03182718986028513,0.9994933866480282]],[3,["_lscale"],[0,["054HrpVJ9YdrFA31Ec+dkY"]],[1,1.0000009536743164,1,1]],[3,["_euler"],[0,["054HrpVJ9YdrFA31Ec+dkY"]],[1,0.0004996510135593257,-0.000453101048055823,3.647743322877986]],[2,"Bip001 Xtra_Tongue",["_name"],[0,["dfbHKl6RxVqLvXw6Lt14xK"]]],[3,["_lpos"],[0,["dfbHKl6RxVqLvXw6Lt14xK"]],[1,0.08936405181884766,-0.028061389923095703,0.000004445225840754574]],[3,["_lrot"],[0,["dfbHKl6RxVqLvXw6Lt14xK"]],[3,-3.0594311178264103e-7,3.817032550457581e-7,-0.048731250106838264,0.9988119268725146]],[3,["_lscale"],[0,["dfbHKl6RxVqLvXw6Lt14xK"]],[1,1,0.9999989867210388,1]],[3,["_euler"],[0,["dfbHKl6RxVqLvXw6Lt14xK"]],[1,-0.00003304227590328229,0.000042179892466667365,-5.586402449871046]],[2,"Bip001 L Forearm",["_name"],[0,["bex7q5czhZfLRNzKYoBLyx"]]],[3,["_lpos"],[0,["bex7q5czhZfLRNzKYoBLyx"]],[1,0.5204557180404663,1.1920928955078125e-7,-1.1920928955078125e-7]],[3,["_lrot"],[0,["bex7q5czhZfLRNzKYoBLyx"]],[3,-8.996704747186443e-18,-2.969889326223742e-17,-0.6873185419958124,0.7263561260351223]],[3,["_lscale"],[0,["bex7q5czhZfLRNzKYoBLyx"]],[1,1,1,1]],[3,["_euler"],[0,["bex7q5czhZfLRNzKYoBLyx"]],[1,-5.595479079571909e-14,-5.763289687687109e-14,-86.83644251224672]],[2,"Bip001 R Forearm",["_name"],[0,["39NhMc+jhSCqKPANQHLh8+"]]],[3,["_lpos"],[0,["39NhMc+jhSCqKPANQHLh8+"]],[1,0.5204557180404663,1.1920928955078125e-7,0]],[3,["_lrot"],[0,["39NhMc+jhSCqKPANQHLh8+"]],[3,4.9317570815256714e-17,-8.45495145977068e-18,-0.6873185717527179,0.7263560978774832]],[3,["_lscale"],[0,["39NhMc+jhSCqKPANQHLh8+"]],[1,1,1,1]],[3,["_euler"],[0,["39NhMc+jhSCqKPANQHLh8+"]],[1,6.231598940146356e-14,5.763298592223944e-14,-86.83644720676268]],[2,"Bip001 L Hand",["_name"],[0,["0516pAzllTEINtCBbXwvaI"]]],[3,["_lpos"],[0,["0516pAzllTEINtCBbXwvaI"]],[1,0.5944492220878601,0,-2.220446049250313e-16]],[3,["_lrot"],[0,["0516pAzllTEINtCBbXwvaI"]],[3,-0.2617311703737297,0.029688528854133044,0.3459904396792379,0.9005031934201249]],[3,["_lscale"],[0,["0516pAzllTEINtCBbXwvaI"]],[1,1,1,1]],[3,["_euler"],[0,["0516pAzllTEINtCBbXwvaI"]],[1,-38.26907185297872,17.178544816200937,37.415459422889654]],[2,"Bip001 R Hand",["_name"],[0,["04ZamzRGFcKJpv5KTVe1wf"]]],[3,["_lpos"],[0,["04ZamzRGFcKJpv5KTVe1wf"]],[1,0.5944493412971497,-1.1920928955078125e-7,0]],[3,["_lrot"],[0,["04ZamzRGFcKJpv5KTVe1wf"]],[3,0.2617312122116491,-0.029688526494057035,0.345990455589461,0.9005031752247349]],[3,["_lscale"],[0,["04ZamzRGFcKJpv5KTVe1wf"]],[1,1,1,1]],[3,["_euler"],[0,["04ZamzRGFcKJpv5KTVe1wf"]],[1,38.26907848292041,-17.178547481263575,37.41546049159831]],[2,"Bip001 L Finger0",["_name"],[0,["40GhtM2Y1bgZOrgy9wQpjf"]]],[3,["_lpos"],[0,["40GhtM2Y1bgZOrgy9wQpjf"]],[1,0.08157700300216675,0.006247282028198242,-0.12238441407680511]],[3,["_lrot"],[0,["40GhtM2Y1bgZOrgy9wQpjf"]],[3,0.9290023395148231,0.3079701645178377,-0.06974732092525232,0.19298793269681716]],[3,["_lscale"],[0,["40GhtM2Y1bgZOrgy9wQpjf"]],[1,1,1.0000009536743164,1]],[3,["_euler"],[0,["40GhtM2Y1bgZOrgy9wQpjf"]],[1,151.3789632812749,17.241735558793838,33.044430410905846]],[2,"Bip001 L Finger1",["_name"],[0,["efGIrw9kZbM5dp1NBwHMRu"]]],[3,["_lpos"],[0,["efGIrw9kZbM5dp1NBwHMRu"]],[1,0.2140156626701355,0.02871990203857422,-0.07965849339962006]],[3,["_lrot"],[0,["efGIrw9kZbM5dp1NBwHMRu"]],[3,0.14175589132700384,0.05487470977109217,0.29237341365277086,0.9441460800589339]],[3,["_lscale"],[0,["efGIrw9kZbM5dp1NBwHMRu"]],[1,1,1,1]],[3,["_euler"],[0,["efGIrw9kZbM5dp1NBwHMRu"]],[1,16.628244260928607,1.4427303831348735,34.58610116822202]],[2,"Bip001 L Finger2",["_name"],[0,["a3opXY1K1bs63KtREsU6Cj"]]],[3,["_lpos"],[0,["a3opXY1K1bs63KtREsU6Cj"]],[1,0.20017272233963013,0.027018070220947266,0.010468840599060059]],[3,["_lrot"],[0,["a3opXY1K1bs63KtREsU6Cj"]],[3,0.016227573424614575,-0.07892323415809137,0.25775862166212676,0.9628438512706079]],[3,["_lscale"],[0,["a3opXY1K1bs63KtREsU6Cj"]],[1,1.0000009536743164,1,1]],[3,["_euler"],[0,["a3opXY1K1bs63KtREsU6Cj"]],[1,4.745212621468258,-10.625984962258268,29.590727366189885]],[2,"Bn_Hand",["_name"],[0,["cdSHSn+iNTHKbOD/PLegz3"]]],[3,["_lpos"],[0,["cdSHSn+iNTHKbOD/PLegz3"]],[1,0.16577750444412231,0.06132864952087402,-0.046974703669548035]],[3,["_lrot"],[0,["cdSHSn+iNTHKbOD/PLegz3"]],[3,-0.3996487816964595,0.9162200003981678,-0.011799826171741228,-0.02612520356348691]],[3,["_lscale"],[0,["cdSHSn+iNTHKbOD/PLegz3"]],[1,1,1,1]],[3,["_euler"],[0,["cdSHSn+iNTHKbOD/PLegz3"]],[1,3.5752087539781954,-175.1773245504443,-47.03043486089243]],[2,"Bip001 R Finger0",["_name"],[0,["47JEn10QFZeY7XBihtHdxT"]]],[3,["_lpos"],[0,["47JEn10QFZeY7XBihtHdxT"]],[1,0.0954056978225708,0.005409955978393555,0.10597886145114899]],[3,["_lrot"],[0,["47JEn10QFZeY7XBihtHdxT"]],[3,0.9290023316959993,0.30797019172817003,0.06974726818416987,-0.19298794597372107]],[3,["_lscale"],[0,["47JEn10QFZeY7XBihtHdxT"]],[1,1,1,1]],[3,["_euler"],[0,["47JEn10QFZeY7XBihtHdxT"]],[1,-151.37896227054966,-17.241730691025925,33.044434802218554]],[2,"Bip001 R Finger1",["_name"],[0,["53/rmZzdJZL463F9C5r7qA"]]],[3,["_lpos"],[0,["53/rmZzdJZL463F9C5r7qA"]],[1,0.2140156626701355,0.02871990203857422,0.07965849339962006]],[3,["_lrot"],[0,["53/rmZzdJZL463F9C5r7qA"]],[3,-0.14175589118211213,-0.0548747283414547,0.2923734133539298,0.9441460790939021]],[3,["_lscale"],[0,["53/rmZzdJZL463F9C5r7qA"]],[1,1,1,1]],[3,["_euler"],[0,["53/rmZzdJZL463F9C5r7qA"]],[1,-16.628243493903444,-1.4427328337497123,34.58610145498249]],[2,"Bip001 R Finger2",["_name"],[0,["9fgNNDboxcjIG+O1o8GHRt"]]],[3,["_lpos"],[0,["9fgNNDboxcjIG+O1o8GHRt"]],[1,0.20017272233963013,0.027018070220947266,-0.010468810796737671]],[3,["_lrot"],[0,["9fgNNDboxcjIG+O1o8GHRt"]],[3,-0.016227580863691093,0.07892324155272112,0.2577586214793942,0.9628438505880201]],[3,["_lscale"],[0,["9fgNNDboxcjIG+O1o8GHRt"]],[1,1.0000009536743164,1,1]],[3,["_euler"],[0,["9fgNNDboxcjIG+O1o8GHRt"]],[1,-4.745213810691006,10.625986151481015,29.59072722663627]],[2,"Bip001 L Finger01",["_name"],[0,["a6aeXwf6BZdI+Q2cVg8FCt"]]],[3,["_lpos"],[0,["a6aeXwf6BZdI+Q2cVg8FCt"]],[1,0.1283271312713623,-2.220446049250313e-16,-5.960464477539063e-8]],[3,["_lrot"],[0,["a6aeXwf6BZdI+Q2cVg8FCt"]],[3,-0.0005510463967082443,0.04632963244924116,0.01187961922320866,0.9988554130363908]],[3,["_lscale"],[0,["a6aeXwf6BZdI+Q2cVg8FCt"]],[1,1,1,1]],[3,["_euler"],[0,["a6aeXwf6BZdI+Q2cVg8FCt"]],[1,-0.1261771947815869,5.312755955821363,1.356947306578145]],[2,"Bip001 L Finger11",["_name"],[0,["82YHmJYpNUwIRpMz6/x7rh"]]],[3,["_lpos"],[0,["82YHmJYpNUwIRpMz6/x7rh"]],[1,0.0953603982925415,-2.384185791015625e-7,5.960464477539063e-8]],[3,["_lrot"],[0,["82YHmJYpNUwIRpMz6/x7rh"]],[3,1.0302478230703421e-8,-1.3092540701434747e-8,0.2016598630980403,0.9794556139076848]],[3,["_lscale"],[0,["82YHmJYpNUwIRpMz6/x7rh"]],[1,1,1,1]],[3,["_euler"],[0,["82YHmJYpNUwIRpMz6/x7rh"]],[1,0.0000015880320747349408,-0.0000018587233107113073,23.268080227659283]],[2,"Bip001 L Finger21",["_name"],[0,["56GP/33ipbt5RscKxkRlan"]]],[3,["_lpos"],[0,["56GP/33ipbt5RscKxkRlan"]],[1,0.07172501087188721,1.1920928955078125e-7,5.960464477539063e-8]],[3,["_lrot"],[0,["56GP/33ipbt5RscKxkRlan"]],[3,-1.0171859984491851e-17,-1.4991040769140968e-17,0.13798254917676323,0.9904346601985827]],[3,["_lscale"],[0,["56GP/33ipbt5RscKxkRlan"]],[1,1,1,1]],[3,["_euler"],[0,["56GP/33ipbt5RscKxkRlan"]],[1,-9.53743987823341e-16,-1.601566231679269e-15,15.862243670868283]],[2,"Bip001 R Finger01",["_name"],[0,["84l6lm3SBYBZ8FSo3q+7NM"]]],[3,["_lpos"],[0,["84l6lm3SBYBZ8FSo3q+7NM"]],[1,0.11112487316131592,2.220446049250313e-16,-1.1920928955078125e-7]],[3,["_lrot"],[0,["84l6lm3SBYBZ8FSo3q+7NM"]],[3,0.0005510246851597509,-0.046329632441594146,0.011879634122409057,0.9988554128715231]],[3,["_lscale"],[0,["84l6lm3SBYBZ8FSo3q+7NM"]],[1,1,1,1]],[3,["_euler"],[0,["84l6lm3SBYBZ8FSo3q+7NM"]],[1,0.12617478816212,-5.3127559293270386,1.356949127499545]],[2,"Bip001 R Finger11",["_name"],[0,["e57STHoJpa0p56K4UDKx2N"]]],[3,["_lpos"],[0,["e57STHoJpa0p56K4UDKx2N"]],[1,0.09536051750183105,1.1920928955078125e-7,5.960464477539063e-8]],[3,["_lrot"],[0,["e57STHoJpa0p56K4UDKx2N"]],[3,-1.0302478230703421e-8,1.3092540701434747e-8,0.2016598630980403,0.9794556139076848]],[3,["_lscale"],[0,["e57STHoJpa0p56K4UDKx2N"]],[1,1,1,1]],[3,["_euler"],[0,["e57STHoJpa0p56K4UDKx2N"]],[1,-0.0000015880320747349408,0.0000018587233107113073,23.268080227659283]],[2,"Bip001 R Finger21",["_name"],[0,["6cklssd71bQpgcGHdZO8+Q"]]],[3,["_lpos"],[0,["6cklssd71bQpgcGHdZO8+Q"]],[1,0.07172489166259766,0,0]],[3,["_lrot"],[0,["6cklssd71bQpgcGHdZO8+Q"]],[3,4.893729611197911e-18,-3.696921671140056e-18,0.13798254917676323,0.9904346601985827]],[3,["_lscale"],[0,["6cklssd71bQpgcGHdZO8+Q"]],[1,1,1,1]],[3,["_euler"],[0,["6cklssd71bQpgcGHdZO8+Q"]],[1,6.381709387020008e-16,-5.16634253009268e-16,15.862243670868283]],[9,false,["_active"],-688],[15,["_clips","1"],-689,89],[15,["_clips","2"],-690,90],[15,["_clips","3"],-691,91]]],86]],[0,["08p3MFuydXL4oM9CbjboO3"]],[20,0,{},74,[19,"35MaNWaVpaXITwGugCw+yp",-695,[79,"7ciEJna/FKY7+GrrvIFEG+",[[25,[0,["66SXxyl+ZSLIlCH9Xjfuro"]],[[31],[32]]]],[[9,"VD289_Lion_Rig-Old",["_name"],42],[8,["_lpos"],42,[1,0,-500,200]],[8,["_lrot"],42,[3,0,0,0,1]],[8,["_euler"],42,[1,0,0,0]],[9,true,["playOnLoad"],-693],[9,524288,["_layer"],42],[2,524288,["_layer"],[0,["66SXxyl+ZSLIlCH9Xjfuro"]]],[2,524288,["_layer"],[0,["20FZ6FqZZT946EF29Au3vS"]]],[2,524288,["_layer"],[0,["35i6tXF4pRNZMhldb3mDjL"]]],[2,524288,["_layer"],[0,["05UVohVuNVcY7xAefdYL4R"]]],[2,524288,["_layer"],[0,["99aYTJuXxXjKlBCnMZKwSb"]]],[2,524288,["_layer"],[0,["04ogjBxslRvqZNn/28a2mW"]]],[2,524288,["_layer"],[0,["b0yaVeE+lf24sDuhbAjfnr"]]],[2,524288,["_layer"],[0,["e7TXJyk2pTmZxxh/3c0m7+"]]],[2,524288,["_layer"],[0,["4dRXphVyNfYYs4uOckZrgr"]]],[2,524288,["_layer"],[0,["62SLmOvJVd65B7L2G1Y1bi"]]],[2,524288,["_layer"],[0,["c5EksbV85eBLHQJ5DOQ0Il"]]],[2,524288,["_layer"],[0,["bcLaJ+TvdQl78qlF+twDsy"]]],[2,524288,["_layer"],[0,["acBVRsOHRXTZXhAUP5FR5A"]]],[2,524288,["_layer"],[0,["90JC9J3EBcF59u1d/TDnac"]]],[2,524288,["_layer"],[0,["9166HB4c9fCpJ+ndmbNclR"]]],[2,524288,["_layer"],[0,["e4/QZ1rH1f3K65N7Vtf7PY"]]],[2,524288,["_layer"],[0,["daokDkTqNZyptqI6QBb1I/"]]],[2,524288,["_layer"],[0,["24wLW8b+9UI6wK3JzbMbUF"]]],[2,524288,["_layer"],[0,["8aDq0WbNRYM4NJvJ2o74Lv"]]],[2,524288,["_layer"],[0,["42aDpB00ZY24pjtaMIy0pw"]]],[2,524288,["_layer"],[0,["9edFaLq9JUMqw4ukRK7eJe"]]],[2,524288,["_layer"],[0,["21BAg+uiNcLJ1pMuhtF2u5"]]],[2,524288,["_layer"],[0,["48il1/WABdRr0dL7mUyTUY"]]],[2,524288,["_layer"],[0,["46yLe9/LNSU4wsF36Y4EdF"]]],[2,524288,["_layer"],[0,["c67HP74fZQareDO7QzeXWD"]]],[2,524288,["_layer"],[0,["9bdMh8SI5VApTWliW7zitf"]]],[2,524288,["_layer"],[0,["11uo16DZlTM61GJXA7u+dI"]]],[2,524288,["_layer"],[0,["16nrjCCw1awrIbbFmrrLkt"]]],[2,524288,["_layer"],[0,["0c+/2xnDxak6fzczZpa12t"]]],[2,524288,["_layer"],[0,["426MOEsD5fQ52qyRgpaw43"]]],[2,524288,["_layer"],[0,["aaIJFC4GRcjrd2uk0jbYIV"]]],[2,524288,["_layer"],[0,["8b3EQn0vVbXY+9L26wjUHK"]]],[2,524288,["_layer"],[0,["78gcp2bbxVXLlxVrakCFv+"]]],[2,524288,["_layer"],[0,["b5e5H9odFf6al2+RZikwCR"]]],[2,524288,["_layer"],[0,["4fY6GcR1hSC5fYnbBbwcE3"]]],[2,524288,["_layer"],[0,["da5hRlZv9Yer2n/hky54Qh"]]],[2,524288,["_layer"],[0,["f1rzkOtcJUoouALNH9EqMW"]]],[2,524288,["_layer"],[0,["74Wy3E+Ole54e8k1nw+aEG"]]],[2,524288,["_layer"],[0,["a8dpwKFOlaFJYRtwefRwED"]]],[2,524288,["_layer"],[0,["07NdQ2IsRR84s8cj1lRGj3"]]],[2,524288,["_layer"],[0,["6ax1un7LxbuodvxEmJ7fy/"]]],[2,524288,["_layer"],[0,["bfPdLlgZtTPLDNzkErLei1"]]],[2,524288,["_layer"],[0,["75WizrvY9f4bbuYTiAsdi4"]]],[2,524288,["_layer"],[0,["55LTavoExT56Qt1yhbvz/X"]]],[2,524288,["_layer"],[0,["09TAs1TbJfg5Fft1EAp/iz"]]],[2,524288,["_layer"],[0,["9fCz99XCRUdpOH1TnEDrkD"]]],[2,524288,["_layer"],[0,["7dpmNx611fh4xXzZzkGAmI"]]],[2,524288,["_layer"],[0,["07XOU8MOJdXYdeZTz15z4c"]]],[2,524288,["_layer"],[0,["25rnbqlTNR1pQdN14WG5HL"]]],[2,524288,["_layer"],[0,["30nvpNQ2tWc6LIPcuur2vi"]]],[2,524288,["_layer"],[0,["40GD3ZPKlVUKfO5lep3+oO"]]],[2,524288,["_layer"],[0,["5cJRpZcMxdlIdscpoxZ25t"]]],[2,524288,["_layer"],[0,["3evKiZvo5TaLUHoURAeo/X"]]],[2,524288,["_layer"],[0,["b8A7ZBYvlbYJe+OTRAWqzr"]]],[2,524288,["_layer"],[0,["feQFOqHlxSwbMcaPmuycQQ"]]],[2,524288,["_layer"],[0,["c1cWylJQtd6rol0y6sh+h7"]]],[2,524288,["_layer"],[0,["b4NkXDiC1Ugpi6y1EryYfH"]]],[2,524288,["_layer"],[0,["008tQUqzhbV6wCEbIfA14v"]]],[8,["_lscale"],42,[1,100,100,100]],[9,false,["_active"],42],[15,["_clips","2"],-694,100]]],99]],[20,0,{},75,[19,"5dXI/ybWZaFrEKPI46LgaD",-696,[91,"daRW7S5wpK4o72dJyBGGPv",null,[[25,[0,["00epe3MM5V+6cyzbwFVcci"]],[[31],[32]]]],[[2,"VD295_Flamingo_Old",["_name"],[0,["5dXI/ybWZaFrEKPI46LgaD"]]],[3,["_lpos"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,0,-500,200]],[3,["_lrot"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[3,0,0,0,1]],[3,["_euler"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,0,0,0]],[2,true,["playOnLoad"],[0,["4cq3CaMM9QFplY9tFHtlLH"]]],[45,["_defaultClip"],[0,["4cq3CaMM9QFplY9tFHtlLH"]],105],[2,524288,["_layer"],[0,["5dXI/ybWZaFrEKPI46LgaD"]]],[2,524288,["_layer"],[0,["00epe3MM5V+6cyzbwFVcci"]]],[2,524288,["_layer"],[0,["c3T8xhbBlaNp7/Bly9AFlQ"]]],[2,524288,["_layer"],[0,["c4MNbS8yRXIaS6qgPgPrqT"]]],[2,524288,["_layer"],[0,["63UN7XUWBWyZZ/qkFfOZhT"]]],[2,524288,["_layer"],[0,["28HoLqRkpcfoL7nQmIgrpu"]]],[2,524288,["_layer"],[0,["74qcjuzehSf5BUatpViYMH"]]],[2,524288,["_layer"],[0,["cfwWn+4r9UDZPd2/A7BPsK"]]],[2,524288,["_layer"],[0,["11e4xaYaxdEodwfLk3pWmV"]]],[2,524288,["_layer"],[0,["b5g+r/vqNfaail1orcNRvu"]]],[2,524288,["_layer"],[0,["98ubztsaReB4SM5j0C+9XQ"]]],[2,524288,["_layer"],[0,["45seyRJhVZ2YulhZHAVFr0"]]],[2,524288,["_layer"],[0,["e1NdgXAPpT3pWeZaVw/WW/"]]],[2,524288,["_layer"],[0,["91wcoKnUdZt649Xs1K9QTt"]]],[2,524288,["_layer"],[0,["daFSmgldhVHZr6ed1FMbc2"]]],[2,524288,["_layer"],[0,["afjViuGxNakYmIONA9A7ZA"]]],[2,524288,["_layer"],[0,["23P11ouaBeNaOziPbu7lTO"]]],[2,524288,["_layer"],[0,["badzM6Hqlb27spngOq5m5/"]]],[2,524288,["_layer"],[0,["4aHFl3fHlbuaL6RN8JRXeO"]]],[2,524288,["_layer"],[0,["9eM/tvRn9fvLFlTT7ESNOv"]]],[2,524288,["_layer"],[0,["67sWnaBDZcZIOZiwUDQXR8"]]],[2,524288,["_layer"],[0,["98Sz/NQqJWj6c2DtnFVTQ6"]]],[2,524288,["_layer"],[0,["79MDogfrxY4pizj38cH188"]]],[2,524288,["_layer"],[0,["1exRZapZNcwIBXxb/0W5eY"]]],[2,524288,["_layer"],[0,["d2NS0Sd+lc/qOaGqu0ryVu"]]],[2,524288,["_layer"],[0,["46CRa2+nVSU7GAYxzrvj3h"]]],[2,524288,["_layer"],[0,["62LM705PxVL7yWO1SbD16v"]]],[2,524288,["_layer"],[0,["b72NXmqyBRSqNZecSkl4t2"]]],[2,524288,["_layer"],[0,["783hrjEJBTA6iOjJ8o6PCH"]]],[2,524288,["_layer"],[0,["cfy2dsSI5clai71SmRD+gt"]]],[2,524288,["_layer"],[0,["8df/WULSJXH4ndqHq46j6Q"]]],[2,524288,["_layer"],[0,["15bHkaVhxULoQNZ95K+rGl"]]],[2,524288,["_layer"],[0,["baXanNgPZQoZV6vIjIoTfA"]]],[2,524288,["_layer"],[0,["1eYfzhDh5bIo6wE6rROPOs"]]],[2,524288,["_layer"],[0,["30RfEJQ/xTabZjlnUgSgWc"]]],[2,524288,["_layer"],[0,["34Ruzm2H1XYYt2kEBRWij0"]]],[2,524288,["_layer"],[0,["eeJG5qN81dm4bIT7UcnztQ"]]],[2,524288,["_layer"],[0,["81v2Uyj+Vez6nrS7hhhoNT"]]],[2,524288,["_layer"],[0,["b51/1/kdFRobUfwsEeT3uH"]]],[2,524288,["_layer"],[0,["33lPB7VnpemLW23UhXTmaQ"]]],[2,524288,["_layer"],[0,["f1JuzE2exYNpMLArES2Q9R"]]],[2,524288,["_layer"],[0,["a0kNa6alVRtb1xwMgM02q9"]]],[2,524288,["_layer"],[0,["33XcvF5phc+IlA2P543Z0E"]]],[2,524288,["_layer"],[0,["d8KrAf/ApRq4ueboGh7Kiw"]]],[2,524288,["_layer"],[0,["d0xrCNmzhYj5mJfGfYioBX"]]],[2,524288,["_layer"],[0,["c5UNlN9WpelrcAagNMgB3X"]]],[2,524288,["_layer"],[0,["ec0i50qEBURauM08B13c/7"]]],[3,["_lscale"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,100,100,100]],[2,false,["_active"],[0,["5dXI/ybWZaFrEKPI46LgaD"]]]]],104]],[0,["4cq3CaMM9QFplY9tFHtlLH"]],[20,0,{},77,[19,"49pWBJK15R+45zZnNOgfJN",-699,[79,"a3YotLhhRMN7+xbZZkFxC+",[[25,[0,["e3FAH3cZhSZLsUbfJUC80S"]],[[31],[32]]]],[[9,"VD297_Giraffe_Rig-Old",["_name"],43],[8,["_lpos"],43,[1,0,-637.6299999999999,200]],[8,["_lrot"],43,[3,0,0,0,1]],[8,["_euler"],43,[1,0,0,0]],[15,["_defaultClip"],-697,111],[9,true,["playOnLoad"],-698],[9,524288,["_layer"],43],[2,524288,["_layer"],[0,["e3FAH3cZhSZLsUbfJUC80S"]]],[2,524288,["_layer"],[0,["27goImrUhSiLj/q8l+pR3q"]]],[2,524288,["_layer"],[0,["edXyveHQlamqk5Klmem7yW"]]],[2,524288,["_layer"],[0,["0bz+t64LpWRoPHsBCKwTl/"]]],[2,524288,["_layer"],[0,["f2uk/fraBW44RrsLTmM1qH"]]],[2,524288,["_layer"],[0,["76JitRG4Bb6IWeWws2pnXN"]]],[2,524288,["_layer"],[0,["11BAfAQWVSDq0Huwsgvaqy"]]],[2,524288,["_layer"],[0,["80xBgp43xZAaNnhTprLbP3"]]],[2,524288,["_layer"],[0,["cf54cUQTFQdaEFKgi0tXhy"]]],[2,524288,["_layer"],[0,["dayS5tevFSZqR9L49DlLE1"]]],[2,524288,["_layer"],[0,["35suY1tUlZY6a8OdTLav2m"]]],[2,524288,["_layer"],[0,["56D6KHIFhfjJguAA9oJ5nd"]]],[2,524288,["_layer"],[0,["e8IZExt/9Zj4U6ZKChzAp8"]]],[2,524288,["_layer"],[0,["7c+r1SaXFbJIz1+lTaGNL8"]]],[2,524288,["_layer"],[0,["05vzGOWtNStKzQvyWde+Ao"]]],[2,524288,["_layer"],[0,["4eZ9lbh79WQ7KnvB+7+zxC"]]],[2,524288,["_layer"],[0,["a8Hm0zESxYv6gYOiTo0hxR"]]],[2,524288,["_layer"],[0,["4eUfYIsfZUlrwpmZtd7TvP"]]],[2,524288,["_layer"],[0,["14Ad035ANcloqi0mJImlLj"]]],[2,524288,["_layer"],[0,["d4y+2xk59a2r6WSeI/vdA+"]]],[2,524288,["_layer"],[0,["27MQcNugdU3YnRBSyPx/OP"]]],[2,524288,["_layer"],[0,["27d7tBW79d3Krcc+XS9kjS"]]],[2,524288,["_layer"],[0,["c4UT6iM6ZavIrWG+TU0Tk4"]]],[2,524288,["_layer"],[0,["a84YD19Gdc1L3jl37FEJEs"]]],[2,524288,["_layer"],[0,["14c21KloFeW4TnZpqdpSeQ"]]],[2,524288,["_layer"],[0,["feam7ruXVQvZy90w4OSN1y"]]],[2,524288,["_layer"],[0,["1aix5QZVtffaZlYVrLXuzk"]]],[2,524288,["_layer"],[0,["9eXV3vCA5TaIZGzjUDTB7g"]]],[2,524288,["_layer"],[0,["49XHXwZQJSX7a3Ea2snvla"]]],[2,524288,["_layer"],[0,["d2RYeAmwZVVbYhAqdc4wDo"]]],[2,524288,["_layer"],[0,["35776kuEBeLZHUS0fLbjDm"]]],[2,524288,["_layer"],[0,["99+llp6yNf0pX1/DQ9+tgW"]]],[2,524288,["_layer"],[0,["2eX9kiozNTCYTR1C6h7sEi"]]],[2,524288,["_layer"],[0,["72SZVCrg1a2LbK96LcowhX"]]],[2,524288,["_layer"],[0,["35HbIUuotdQaMkFrCYzRIQ"]]],[2,524288,["_layer"],[0,["17RB3ykLBUm6je9HRIuOn/"]]],[2,524288,["_layer"],[0,["df+haHFsFdPpoeUvr0OVYf"]]],[2,524288,["_layer"],[0,["dexMSBu/Vc6oaq6wAV+avX"]]],[2,524288,["_layer"],[0,["51H6UXMFxVxreAZ4YjFABg"]]],[2,524288,["_layer"],[0,["2evjecQFZRbpov5tGjlFBH"]]],[2,524288,["_layer"],[0,["07HB7bVs5fSK0GCLwvrUvV"]]],[2,524288,["_layer"],[0,["5bcRdelBNcnqSCWgDkZn2m"]]],[2,524288,["_layer"],[0,["04PkZ8dHRVzZYNqb8TRcv7"]]],[2,524288,["_layer"],[0,["fd1KRbHfVdb5Q/fJ5w91SW"]]],[2,524288,["_layer"],[0,["e7FwbyyURWBqR0qzpv6MFQ"]]],[2,524288,["_layer"],[0,["7ft6QxtctagqdyecDLAhlN"]]],[2,524288,["_layer"],[0,["754t+mjF9VIpOTs7KdhAPA"]]],[2,524288,["_layer"],[0,["bcMI6QptlSGKEmSrWoPjmO"]]],[2,524288,["_layer"],[0,["89CoNx03Fe95p6c3PgddFh"]]],[2,524288,["_layer"],[0,["1arjDVWixWE6C/bv+TdkwO"]]],[2,524288,["_layer"],[0,["65Hr4qA4tY9J8Jvd+K0x5F"]]],[2,524288,["_layer"],[0,["7c7vkHe8taurwV9/b63dyq"]]],[2,524288,["_layer"],[0,["c6PyF6E9Fejpf+FhJZKAVH"]]],[2,524288,["_layer"],[0,["57n9xYdK5ZWIvmtHeYAceX"]]],[2,524288,["_layer"],[0,["1cIIaKZ1pcGLS4H52SXjPZ"]]],[2,524288,["_layer"],[0,["5fP7MY0KRScq+eqbAl68XC"]]],[2,524288,["_layer"],[0,["d42HOx4B5W6oKyikGCD94J"]]],[2,524288,["_layer"],[0,["4bY2R+ZuhfRbqPseCyF6kY"]]],[2,524288,["_layer"],[0,["16zFfly2pUNYXtnr5x4XBX"]]],[2,524288,["_layer"],[0,["3byxQ4HQJX6rqKO+WPtPaP"]]],[2,524288,["_layer"],[0,["528DScHiFfopPcfjRBeca+"]]],[2,524288,["_layer"],[0,["d4iQC7nKxUyoITQdTj5HN0"]]],[2,524288,["_layer"],[0,["55lY+R+5VfcL3MRr4OPaf/"]]],[2,524288,["_layer"],[0,["14ITHPHChYjbDoBqTnlyOE"]]],[2,524288,["_layer"],[0,["37bpu2CtdYWYgYXX1+Fi7a"]]],[2,524288,["_layer"],[0,["d9Du9LEYtYd6fEY+RDtLSd"]]],[8,["_lscale"],43,[1,100,100,100]],[9,false,["_active"],43]]],110]],[36,"TitilePanel",33554432,27,[-702],[[5,-700,[5,800,128]],[12,0,-701,123]],[1,0,357.0000000000001,-6.310887241768095e-30]],[34,"AnimalTypeTitle",33554432,112,[[5,-703,[5,396,74.56]],[42,"袋鼠是食草动物",56,56,56,false,-704,124],[46,-705]],[1,2.4005882352940375,232.6479411764705,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"AnimalTypeTitle",33554432,113,[[5,-706,[5,224,70.56]],[42,"火烈鸟是杂食动物",56,56,56,false,-707,126],[46,-708]],[1,-0.7552941176471109,232.6479411764705,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"AnimalTypeTitle",33554432,114,[[5,-709,[5,224,70.56]],[42,"狮子是食肉动物",56,56,56,false,-710,128],[46,-711]],[1,-1.666764705882315,225.1573529411765,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"AnimalTypeTitle",33554432,115,[[5,-712,[5,224,70.56]],[42,"长颈鹿是食草动物",56,56,56,false,-713,130],[46,-714]],[1,-1.666764705882315,225.1573529411765,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"HabitatTitle",33554432,116,[[5,-715,[5,508,74.56]],[42,"主要生活在澳洲沙漠",56,56,56,false,-716,132],[46,-717]],[1,0,233.51941176470592,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"HabitatTitle",33554432,117,[[5,-718,[5,508,74.56]],[42,"主要生活在热带草原",56,56,56,false,-719,134],[46,-720]],[1,0.24999999999994316,233.76941176470586,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"HabitatTitle",33554432,118,[[5,-721,[5,508,74.56]],[42,"主要生活在热带草原",56,56,56,false,-722,136],[46,-723]],[1,-0.7129411764705651,231.1302941176471,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"HabitatTitle",33554432,119,[[5,-724,[5,508,74.56]],[42,"主要生活在热带草原",56,56,56,false,-725,138],[46,-726]],[1,-0.7129411764705651,234.94588235294128,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"MapTitle",33554432,120,[[5,-727,[5,452,74.56]],[42,"主要生活在大洋洲",56,56,56,false,-728,140],[46,-729]],[1,0,233.51941176470604,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"MapTitle",33554432,121,[[5,-730,[5,620,74.56]],[42,"主要生活在南美洲和非洲",56,56,56,false,-731,142],[46,-732]],[1,0,233.51941176470604,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"MapTitle",33554432,122,[[5,-733,[5,396,74.56]],[42,"主要生活在非洲",56,56,56,false,-734,144],[46,-735]],[1,0,233.51941176470604,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[34,"MapTitle",33554432,123,[[5,-736,[5,396,74.56]],[42,"主要生活在非洲",56,56,56,false,-737,146],[46,-738]],[1,0,233.51941176470604,-3.7122866128047616e-30],[1,0.5882352941176471,0.5882352941176471,0.5882352941176471]],[21,"ImageTitle",33554432,28,[[5,-739,[5,116,74.56]],[42,"图片",56,56,56,false,-740,148],[46,-741]],[1,0,357.0000000000001,-6.310887241768095e-30]],[28,"Kangaroo",false,33554432,28,[[5,-742,[5,893,653]],[12,0,-743,149]],[1,0,-39.98299999999995,0]],[28,"Flamingo",false,33554432,28,[[5,-744,[5,893,653]],[12,0,-745,150]],[1,0,-39.98299999999995,0]],[28,"Lion",false,33554432,28,[[5,-746,[5,893,653]],[12,0,-747,151]],[1,0,-39.98299999999995,0]],[28,"Giraffe",false,33554432,28,[[5,-748,[5,893,653]],[12,0,-749,152]],[1,-1.556000000000001,-39.98299999999995,0]],[28,"KangarooUnlock",false,33554432,29,[[5,-750,[5,280,398]],[59,-751,206]],[1,-41.259,294.416,0]],[96,"BtnClose",33554432,10,[[[5,-752,[5,128,128]],[12,0,-753,211],-754],4,4,1],[1,0,-281.328,0]],[28,"CrownCRMBtn",false,33554432,10,[[5,-755,[5,173,139]],[59,-756,212],[262,1,-757,[[11,"d5570+aNMNBpKsWeic7F5lj","redirectCRM",2]],[4,4286545791],213]],[1,369,-269,0]],[28,"FlamingoUnlock",false,33554432,31,[[5,-758,[5,392,382]],[59,-759,224]],[1,-39.744,297.341,0]],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[0,["4cq3CaMM9QFplY9tFHtlLH"]],[0,["00epe3MM5V+6cyzbwFVcci"]],[28,"LionUnlock",false,33554432,33,[[5,-760,[5,308,385]],[59,-761,251]],[1,-2.991,297.36,0]],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[20,0,{},34,[19,"35MaNWaVpaXITwGugCw+yp",-763,[79,"51ZVybBA9Dt6xK+AlpUF2i",[[25,[0,["35MaNWaVpaXITwGugCw+yp"]],[[177,-762,254]]],[25,[0,["66SXxyl+ZSLIlCH9Xjfuro"]],[[31],[32]]]],[[8,["_lpos"],50,[1,0,500,100]],[9,"VD289_Lion_Rig-canvas",["_name"],50],[8,["_lrot"],50,[3,0,0,0,1]],[8,["_euler"],50,[1,0,0,0]],[9,3,["_clips","length"],89],[15,["_clips","0"],89,255],[15,["_clips","1"],89,256],[15,["_clips","2"],89,257],[15,["_defaultClip"],89,258],[9,true,["playOnLoad"],89],[9,false,["_active"],50],[8,["_lscale"],50,[1,200,200,200]],[9,524288,["_layer"],50],[2,524288,["_layer"],[0,["66SXxyl+ZSLIlCH9Xjfuro"]]],[2,524288,["_layer"],[0,["20FZ6FqZZT946EF29Au3vS"]]],[2,524288,["_layer"],[0,["35i6tXF4pRNZMhldb3mDjL"]]],[2,524288,["_layer"],[0,["05UVohVuNVcY7xAefdYL4R"]]],[2,524288,["_layer"],[0,["99aYTJuXxXjKlBCnMZKwSb"]]],[2,524288,["_layer"],[0,["04ogjBxslRvqZNn/28a2mW"]]],[2,524288,["_layer"],[0,["b0yaVeE+lf24sDuhbAjfnr"]]],[2,524288,["_layer"],[0,["e7TXJyk2pTmZxxh/3c0m7+"]]],[2,524288,["_layer"],[0,["4dRXphVyNfYYs4uOckZrgr"]]],[2,524288,["_layer"],[0,["62SLmOvJVd65B7L2G1Y1bi"]]],[2,524288,["_layer"],[0,["c5EksbV85eBLHQJ5DOQ0Il"]]],[2,524288,["_layer"],[0,["bcLaJ+TvdQl78qlF+twDsy"]]],[2,524288,["_layer"],[0,["acBVRsOHRXTZXhAUP5FR5A"]]],[2,524288,["_layer"],[0,["90JC9J3EBcF59u1d/TDnac"]]],[2,524288,["_layer"],[0,["9166HB4c9fCpJ+ndmbNclR"]]],[2,524288,["_layer"],[0,["e4/QZ1rH1f3K65N7Vtf7PY"]]],[2,524288,["_layer"],[0,["daokDkTqNZyptqI6QBb1I/"]]],[2,524288,["_layer"],[0,["24wLW8b+9UI6wK3JzbMbUF"]]],[2,524288,["_layer"],[0,["8aDq0WbNRYM4NJvJ2o74Lv"]]],[2,524288,["_layer"],[0,["42aDpB00ZY24pjtaMIy0pw"]]],[2,524288,["_layer"],[0,["9edFaLq9JUMqw4ukRK7eJe"]]],[2,524288,["_layer"],[0,["21BAg+uiNcLJ1pMuhtF2u5"]]],[2,524288,["_layer"],[0,["48il1/WABdRr0dL7mUyTUY"]]],[2,524288,["_layer"],[0,["46yLe9/LNSU4wsF36Y4EdF"]]],[2,524288,["_layer"],[0,["c67HP74fZQareDO7QzeXWD"]]],[2,524288,["_layer"],[0,["9bdMh8SI5VApTWliW7zitf"]]],[2,524288,["_layer"],[0,["11uo16DZlTM61GJXA7u+dI"]]],[2,524288,["_layer"],[0,["16nrjCCw1awrIbbFmrrLkt"]]],[2,524288,["_layer"],[0,["0c+/2xnDxak6fzczZpa12t"]]],[2,524288,["_layer"],[0,["426MOEsD5fQ52qyRgpaw43"]]],[2,524288,["_layer"],[0,["aaIJFC4GRcjrd2uk0jbYIV"]]],[2,524288,["_layer"],[0,["8b3EQn0vVbXY+9L26wjUHK"]]],[2,524288,["_layer"],[0,["78gcp2bbxVXLlxVrakCFv+"]]],[2,524288,["_layer"],[0,["b5e5H9odFf6al2+RZikwCR"]]],[2,524288,["_layer"],[0,["4fY6GcR1hSC5fYnbBbwcE3"]]],[2,524288,["_layer"],[0,["da5hRlZv9Yer2n/hky54Qh"]]],[2,524288,["_layer"],[0,["f1rzkOtcJUoouALNH9EqMW"]]],[2,524288,["_layer"],[0,["74Wy3E+Ole54e8k1nw+aEG"]]],[2,524288,["_layer"],[0,["a8dpwKFOlaFJYRtwefRwED"]]],[2,524288,["_layer"],[0,["07NdQ2IsRR84s8cj1lRGj3"]]],[2,524288,["_layer"],[0,["6ax1un7LxbuodvxEmJ7fy/"]]],[2,524288,["_layer"],[0,["bfPdLlgZtTPLDNzkErLei1"]]],[2,524288,["_layer"],[0,["75WizrvY9f4bbuYTiAsdi4"]]],[2,524288,["_layer"],[0,["55LTavoExT56Qt1yhbvz/X"]]],[2,524288,["_layer"],[0,["09TAs1TbJfg5Fft1EAp/iz"]]],[2,524288,["_layer"],[0,["9fCz99XCRUdpOH1TnEDrkD"]]],[2,524288,["_layer"],[0,["7dpmNx611fh4xXzZzkGAmI"]]],[2,524288,["_layer"],[0,["07XOU8MOJdXYdeZTz15z4c"]]],[2,524288,["_layer"],[0,["25rnbqlTNR1pQdN14WG5HL"]]],[2,524288,["_layer"],[0,["30nvpNQ2tWc6LIPcuur2vi"]]],[2,524288,["_layer"],[0,["40GD3ZPKlVUKfO5lep3+oO"]]],[2,524288,["_layer"],[0,["5cJRpZcMxdlIdscpoxZ25t"]]],[2,524288,["_layer"],[0,["3evKiZvo5TaLUHoURAeo/X"]]],[2,524288,["_layer"],[0,["b8A7ZBYvlbYJe+OTRAWqzr"]]],[2,524288,["_layer"],[0,["feQFOqHlxSwbMcaPmuycQQ"]]],[2,524288,["_layer"],[0,["c1cWylJQtd6rol0y6sh+h7"]]],[2,524288,["_layer"],[0,["b4NkXDiC1Ugpi6y1EryYfH"]]],[2,524288,["_layer"],[0,["008tQUqzhbV6wCEbIfA14v"]]]]],253]],[20,0,{},34,[106,"94Sq0jzYtOUYIB3Izu94jQ",[],-765,[91,"fbKaV9aQdJErFcOonEsyKm",null,[[25,[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[[31],[32]]],[25,[0,["e9oEMtSEFCD72WH/ol8s2d"]],[[31],[32]]],[25,[0,["98xhROvGdIPoSg3QUf9h+y"]],[[31],[32]]],[25,[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[[92,-764]]]],[[3,["_lpos"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[1,234.407,186.442,401.3]],[2,"Slow Summon_Tornado4",["_name"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]]],[3,["_lrot"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[3,0,0,0,1]],[3,["_euler"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[1,0,0,0]],[2,"Loop",["_name"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]]],[3,["_lrot"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[3,0.7071067811865475,0,0,0.7071067811865476]],[3,["_euler"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,90,0,0]],[3,["_lscale"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,1,1,1]],[2,0,["scaleSpace"],[0,["b615rXNVZOkaAqalmbWHKY"]]],[2,0,["scaleSpace"],[0,["e4BdczZRZFsq0axbldS3nu"]]],[2,0,["scaleSpace"],[0,["85EWZgajlGWLnvVdcXcawA"]]],[2,0,["scaleSpace"],[0,["16TzDGcvxEz73JGX3bVb1A"]]],[2,0,["scaleSpace"],[0,["3f2eD7h5NG0LWRjmW56tac"]]],[2,0,["scaleSpace"],[0,["3bAwvElMpMMZjulFKgj4Ts"]]],[3,["_lscale"],[0,["5f/ln8lztNlIEDDHnPS5ks"]],[1,150,150,150]],[3,["_lpos"],[0,["5f/ln8lztNlIEDDHnPS5ks"]],[1,0,0,0]],[3,["_lpos"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,-1.543,0,0]],[2,524288,["_layer"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]]],[2,524288,["_layer"],[0,["e9oEMtSEFCD72WH/ol8s2d"]]],[2,524288,["_layer"],[0,["98xhROvGdIPoSg3QUf9h+y"]]],[2,524288,["_layer"],[0,["24i8e2YYtE9bOs2FiQfxsR"]]],[2,524288,["_layer"],[0,["ee32AHLDlNVrXOZIIC2QvM"]]],[2,524288,["_layer"],[0,["11L1FXudRIRZgjdFVyMQve"]]],[2,524288,["_layer"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]]],[2,524288,["_layer"],[0,["5f/ln8lztNlIEDDHnPS5ks"]]],[3,["_lscale"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[1,1,1,1]],[2,true,["_active"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]]]]],259]],[28,"GiraffeUnlock",false,33554432,35,[[5,-766,[5,351,587]],[59,-767,270]],[1,26.496,391.548,0]],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[20,0,{},36,[106,"94Sq0jzYtOUYIB3Izu94jQ",[],-772,[79,"8a4M4hWPJLT4flDa+CmBZJ",[[25,[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[[31],[32]]],[25,[0,["e9oEMtSEFCD72WH/ol8s2d"]],[[31],[32]]],[25,[0,["98xhROvGdIPoSg3QUf9h+y"]],[[31],[32]]],[25,[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[[92,-771]]]],[[3,["_lpos"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[1,147.2,232.314,-4.331]],[2,"Slow Summon_Tornado5",["_name"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]]],[3,["_lrot"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[3,0,0,0,1]],[3,["_euler"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[1,0,0,0]],[2,"Loop",["_name"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]]],[3,["_lrot"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[3,0.7071067811865475,0,0,0.7071067811865476]],[3,["_euler"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,90,0,0]],[3,["_lscale"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,1,1,1]],[2,0,["scaleSpace"],[0,["b615rXNVZOkaAqalmbWHKY"]]],[2,0,["scaleSpace"],[0,["e4BdczZRZFsq0axbldS3nu"]]],[2,0,["scaleSpace"],[0,["85EWZgajlGWLnvVdcXcawA"]]],[2,0,["scaleSpace"],[0,["16TzDGcvxEz73JGX3bVb1A"]]],[2,0,["scaleSpace"],[0,["3f2eD7h5NG0LWRjmW56tac"]]],[2,0,["scaleSpace"],[0,["3bAwvElMpMMZjulFKgj4Ts"]]],[3,["_lscale"],[0,["5f/ln8lztNlIEDDHnPS5ks"]],[1,200,200,100]],[3,["_lpos"],[0,["5f/ln8lztNlIEDDHnPS5ks"]],[1,0,180.309,0]],[3,["_lpos"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,-0.7,-1.124,0]],[2,524288,["_layer"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]]],[2,524288,["_layer"],[0,["e9oEMtSEFCD72WH/ol8s2d"]]],[2,524288,["_layer"],[0,["98xhROvGdIPoSg3QUf9h+y"]]],[2,524288,["_layer"],[0,["24i8e2YYtE9bOs2FiQfxsR"]]],[2,524288,["_layer"],[0,["ee32AHLDlNVrXOZIIC2QvM"]]],[2,524288,["_layer"],[0,["11L1FXudRIRZgjdFVyMQve"]]],[9,524288,["_layer"],-768],[2,524288,["_layer"],[0,["5f/ln8lztNlIEDDHnPS5ks"]]],[8,["_lscale"],-769,[1,1,1,1]],[9,true,["_active"],-770]]],277]],[0,["a5Ur2McGJUfKEIm/lueZtm"]],[281,11,152,180,37,142,72,156,116,176,112,120],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[20,0,{},37,[19,"8fJHyWPHhT77T0qzBIqM/Z",-783,[79,"02HUn7mqBPfJm2E49t7Y/m",[[25,[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[[80,-782,[10,"71SN8zFoFC/5gBHzxRLc1H"],287]]],[25,[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[[31]]]],[[8,["_lpos"],52,[1,0,256.581,100]],[9,"VD302_Kangaroo_Rig-canvas",["_name"],52],[8,["_lrot"],52,[3,0,-1.2246467991473532e-16,0,1]],[8,["_euler"],52,[1,0,-1.4033418597069752e-14,0]],[9,4,["_clips","length"],21],[15,["_clips","0"],21,288],[15,["_defaultClip"],21,289],[9,false,["playOnLoad"],21],[15,["_clips","1"],21,290],[9,false,["_useBakedAnimation"],21],[8,["_lrot"],-773,[3,0,0,0,1]],[8,["_euler"],-774,[1,0,0,0]],[8,["_lrot"],-775,[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001]],[8,["_euler"],-776,[1,-90,-90,0]],[8,["_lrot"],-777,[3,0,0,-6.698506168543417e-16,1]],[8,["_euler"],-778,[1,0,0,-7.67592264999771e-14]],[9,true,["_enabled"],21],[8,["_lscale"],52,[1,200,200,200]],[9,false,["_active"],52],[9,524288,["_layer"],52],[9,524288,["_layer"],-779],[9,524288,["_layer"],-780],[9,524288,["_layer"],-781],[2,524288,["_layer"],[0,["f4npe4uvhfYIaPYyEku12n"]]],[2,524288,["_layer"],[0,["24QV1ABdRedL8PrNu+86Nq"]]],[2,524288,["_layer"],[0,["124ooP3KBc1Lk0UF5SkG6P"]]],[2,524288,["_layer"],[0,["1aOCmC7G1QLYh3hQ/RIfCW"]]],[2,524288,["_layer"],[0,["abAw8bUFFfbJbDdcCTemu+"]]],[2,524288,["_layer"],[0,["82O4d8FFlZfbWoM1gQ5T0P"]]],[2,524288,["_layer"],[0,["42dhuQU8NX0rXxQG7SW2YE"]]],[2,524288,["_layer"],[0,["dbtmT0gRdSBIMmHDpIZtZm"]]],[2,524288,["_layer"],[0,["54Lh51XGBYv7YuKOF5iKJs"]]],[2,524288,["_layer"],[0,["b98OsIwtddvaimim2Y6TQy"]]],[2,524288,["_layer"],[0,["bfrFfxzL1T1KmmYCwEZLjk"]]],[2,524288,["_layer"],[0,["36Y+vy/Y5QJ7jAvyy3x9XZ"]]],[2,524288,["_layer"],[0,["80Sxap8RleT7LfBkzDAi93"]]],[2,524288,["_layer"],[0,["27lKXEzcFQsZTcP6tappE1"]]],[2,524288,["_layer"],[0,["a0sQDO/bdTOryUmf6KpZ23"]]],[2,524288,["_layer"],[0,["32EOimsNxW6auKvQxSU90n"]]],[2,524288,["_layer"],[0,["2d7+KWFQJVFrgz3wx2r7Yn"]]],[2,524288,["_layer"],[0,["a5xYRu1R9c+4gSl9Nkoyrr"]]],[2,524288,["_layer"],[0,["bbzAt+/A5Za6JtvBJFLV6Q"]]],[2,524288,["_layer"],[0,["8bMDwNbY5Up6fKdikNpIQL"]]],[2,524288,["_layer"],[0,["c2tjMLgltSz7/DvasIQO6O"]]],[2,524288,["_layer"],[0,["6bI877qbhcC6ioHfi85K1R"]]],[2,524288,["_layer"],[0,["ed/f9Db/pZuZRZD4YWAqds"]]],[2,524288,["_layer"],[0,["e9ki9vW3ha/oTYOTJfAkl8"]]],[2,524288,["_layer"],[0,["20BgvTdsleXrtRxNyWlh//"]]],[2,524288,["_layer"],[0,["7cMoqyptdaSbxJ3NJe5s4D"]]],[2,524288,["_layer"],[0,["34N3Tf3Vhf6p2OCEtjbUr5"]]],[2,524288,["_layer"],[0,["d7tLOit5hTsbOMYxHRvFOp"]]],[2,524288,["_layer"],[0,["3dlgK1+6ZS+pIxXuBluE25"]]],[2,524288,["_layer"],[0,["68RNEaQ79QPq60RxDOrbld"]]],[2,524288,["_layer"],[0,["a5O6YJyIlZ0K3DMvMImW/M"]]],[2,524288,["_layer"],[0,["ccJkUI+3RXpZAAZAVToHx+"]]],[2,524288,["_layer"],[0,["beBTxB4F9YIazSRhrqCQYQ"]]],[2,524288,["_layer"],[0,["84hrPyzk1d1ruBlx05r4WZ"]]],[2,524288,["_layer"],[0,["57Le13NptWs5X3lanB4PyH"]]],[2,524288,["_layer"],[0,["94nYA+SUZazqUalPScGfCg"]]],[2,524288,["_layer"],[0,["0ej8X8mtRS8IOXZwhuA0cA"]]],[2,524288,["_layer"],[0,["46OYGFnqVWX54eydGHqJue"]]],[2,524288,["_layer"],[0,["054HrpVJ9YdrFA31Ec+dkY"]]],[2,524288,["_layer"],[0,["dfbHKl6RxVqLvXw6Lt14xK"]]],[2,524288,["_layer"],[0,["bex7q5czhZfLRNzKYoBLyx"]]],[2,524288,["_layer"],[0,["39NhMc+jhSCqKPANQHLh8+"]]],[2,524288,["_layer"],[0,["0516pAzllTEINtCBbXwvaI"]]],[2,524288,["_layer"],[0,["04ZamzRGFcKJpv5KTVe1wf"]]],[2,524288,["_layer"],[0,["40GhtM2Y1bgZOrgy9wQpjf"]]],[2,524288,["_layer"],[0,["efGIrw9kZbM5dp1NBwHMRu"]]],[2,524288,["_layer"],[0,["a3opXY1K1bs63KtREsU6Cj"]]],[2,524288,["_layer"],[0,["cdSHSn+iNTHKbOD/PLegz3"]]],[2,524288,["_layer"],[0,["47JEn10QFZeY7XBihtHdxT"]]],[2,524288,["_layer"],[0,["53/rmZzdJZL463F9C5r7qA"]]],[2,524288,["_layer"],[0,["9fgNNDboxcjIG+O1o8GHRt"]]],[2,524288,["_layer"],[0,["a6aeXwf6BZdI+Q2cVg8FCt"]]],[2,524288,["_layer"],[0,["82YHmJYpNUwIRpMz6/x7rh"]]],[2,524288,["_layer"],[0,["56GP/33ipbt5RscKxkRlan"]]],[2,524288,["_layer"],[0,["84l6lm3SBYBZ8FSo3q+7NM"]]],[2,524288,["_layer"],[0,["e57STHoJpa0p56K4UDKx2N"]]],[2,524288,["_layer"],[0,["6cklssd71bQpgcGHdZO8+Q"]]],[15,["_clips","2"],21,291],[15,["_clips","3"],21,292]]],286]],[20,0,{},37,[106,"94Sq0jzYtOUYIB3Izu94jQ",[],-788,[79,"f4noyNu9lJIbBiihG3F22o",[[25,[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[[31],[32]]],[25,[0,["e9oEMtSEFCD72WH/ol8s2d"]],[[31],[32]]],[25,[0,["98xhROvGdIPoSg3QUf9h+y"]],[[31],[32]]],[25,[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[[92,-787]]]],[[3,["_lpos"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[1,147.2,206.286,401.3]],[2,"Slow Summon_Tornado3",["_name"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]]],[3,["_lrot"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[3,0,0,0,1]],[3,["_euler"],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[1,0,0,0]],[2,"Loop",["_name"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]]],[3,["_lrot"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[3,0.7071067811865475,0,0,0.7071067811865476]],[3,["_euler"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,90,0,0]],[3,["_lscale"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,1,1,1]],[2,0,["scaleSpace"],[0,["b615rXNVZOkaAqalmbWHKY"]]],[2,0,["scaleSpace"],[0,["e4BdczZRZFsq0axbldS3nu"]]],[2,0,["scaleSpace"],[0,["85EWZgajlGWLnvVdcXcawA"]]],[2,0,["scaleSpace"],[0,["16TzDGcvxEz73JGX3bVb1A"]]],[2,0,["scaleSpace"],[0,["3f2eD7h5NG0LWRjmW56tac"]]],[2,0,["scaleSpace"],[0,["3bAwvElMpMMZjulFKgj4Ts"]]],[3,["_lscale"],[0,["5f/ln8lztNlIEDDHnPS5ks"]],[1,150,150,150]],[3,["_lpos"],[0,["5f/ln8lztNlIEDDHnPS5ks"]],[1,100.137,0,0]],[3,["_lpos"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]],[1,-1.543,0,0]],[2,524288,["_layer"],[0,["f35g/bv2JDHYtdTW2F0OpQ"]]],[2,524288,["_layer"],[0,["e9oEMtSEFCD72WH/ol8s2d"]]],[2,524288,["_layer"],[0,["98xhROvGdIPoSg3QUf9h+y"]]],[2,524288,["_layer"],[0,["24i8e2YYtE9bOs2FiQfxsR"]]],[2,524288,["_layer"],[0,["ee32AHLDlNVrXOZIIC2QvM"]]],[2,524288,["_layer"],[0,["11L1FXudRIRZgjdFVyMQve"]]],[9,524288,["_layer"],-784],[2,524288,["_layer"],[0,["5f/ln8lztNlIEDDHnPS5ks"]]],[8,["_lscale"],-785,[1,1,1,1]],[9,true,["_active"],-786]]],293]],[21,"Title",33554432,7,[[5,-789,[5,646,186.8]],[42,"请点击并解锁\n你和孩子最喜欢的动物",64,64,80,false,-790,305],[180,3,-791]],[1,0,-850,0]],[21,"Title",33554432,3,[[5,-792,[5,594.56,108.8]],[271,"新动物解锁！",80,80,80,1,false,-793,325],[180,4,-794]],[1,44.406,736.504,0]],[70,"CaptureImage",false,33554432,3,[144,145],[[30,-795]]],[207,"Node",false,33554432,3,[[30,-796],[266,-797,[337],[29],338],[92,-798]],[1,-67.86,0,252.195],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,100,100,100],[1,-90,0,0]],[0,["60whtUc01AqKpk/+jyFPeB"]],[161,"Audio","d49OQiySdJuaDuQBiZDoRm",9,[[283,true,-799,355],[284,-801,-800,356,357]]],[28,"RichText",false,33554432,1,[[5,-802,[5,153.38,50.4]],[285,-803],[286,-804]],[1,-28.839,935.65,0]],[54,"Label",33554432,38,[[37,-805,[10,"c68UOAlNhN171Umca6yVvF"],[5,441.7,50.4]],[272,"ACCESS CAMERA",50,50,true,-806,[10,"2frm37uaJHQr0AEEaYyM82"],[4,4278767337]]]],[100,0,4,[19,"35MaNWaVpaXITwGugCw+yp",-807,[78,"08rkLw8pROl6x37xzaFxdh",null,[[3,["_lpos"],[0,["35MaNWaVpaXITwGugCw+yp"]],[1,0,0,0]],[2,"VD289_Lion_Rig",["_name"],[0,["35MaNWaVpaXITwGugCw+yp"]]],[3,["_lrot"],[0,["35MaNWaVpaXITwGugCw+yp"]],[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],[0,["35MaNWaVpaXITwGugCw+yp"]],[1,0,180,0]],[45,["_clips","2"],[0,["bcbBLaSAhbuZMFUUZNLvRX"]],2]]],1],[{},"mountedRoot",1,4]],[100,0,4,[19,"5dXI/ybWZaFrEKPI46LgaD",-808,[78,"3aWwplyaJLEbF51kOAbVwH",null,[[3,["_lpos"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,0,0,0]],[2,"VD295_Flamingo_Rig",["_name"],[0,["5dXI/ybWZaFrEKPI46LgaD"]]],[3,["_lrot"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[3,0,1,0,6.123233995736766e-17]],[3,["_euler"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,0,180,0]]]],3],[{},"mountedRoot",1,4]],[159,"Bip001 Neck1",96,[[-809,[198,"Bip001 Hair02",-810,[1,-0.017128705978393555,-0.21748805046081543,-5.193219294596929e-7],[3,-7.012453917385995e-13,0.0000019041008676043273,-0.6865084912899153,0.7271217857987882],[1,0.9999989867210388,0.9999989867210388,1],[1,0.002609061184881379,0.0027634112797080704,-86.70871443960806]]],1,4],[1,0.6923840045928955,-0.00044989585876464844,-1.2480541045079008e-9],[3,5.735766379024929e-14,8.440700028776635e-8,-0.03043228257955449,0.9995368308256535],[1,2.949038769998187e-7,0.000009685790513410704,-3.487821205901098]],[208,"Bip001 Neck2",209,[[5,[22,"Bip001 Hair03",-811,[1,0.22313594818115234,-0.1733543872833252,-0.0000010999831374647329],[3,-5.501903323788317e-13,0.0000018955203604483748,-0.683414953116773,0.7300301376332389],[1,0.0022529890159768756,0.00240666367779299,-86.22215868172809]]],1,4],[1,0.5660121440887451,-0.0004042387008666992,-1.1214069672860205e-9]],[209,"Sphere",false,"40R1fuXgNGEbnuRcOCvlTi",9,[[82,"Sphere<ModelComponent>",-812,[23],[29],24]],[1,0,0,1.189],[1,0.3,0.3,0.3]],[54,"Sprite",33554432,57,[[5,-813,[5,128,128]],[12,0,-814,27]]],[54,"Sprite",33554432,58,[[5,-815,[5,128,128]],[12,0,-816,29]]],[54,"Sprite",33554432,59,[[5,-817,[5,128,128]],[12,0,-818,31]]],[54,"Sprite",33554432,60,[[5,-819,[5,128,128]],[12,0,-820,33]]],[28,"Panel-lock",false,33554432,40,[[5,-821,[5,800,200]],[93,0,-822,[4,2566914048],36]],[1,-9.796,0,0]],[54,"Sprite",33554432,62,[[5,-823,[5,128,128]],[12,0,-824,46]]],[54,"Sprite",33554432,63,[[5,-825,[5,128,128]],[12,0,-826,48]]],[54,"Sprite",33554432,64,[[5,-827,[5,128,128]],[12,0,-828,50]]],[161,"@CaptureScreen","70fuo19dNP2Y1RaTahvGGH",9,[[287,-830,-829,65,18,19,53,54]]],[210,"ImageBG",false,"72HTnJhPVGJ7/XJpf9DH6G",9,[[82,"Plane<ModelComponent>",-831,[55],[29],56]],[1,0,2.5,-25],[3,0.7071067811865475,0,0,0.7071067811865476],[1,3.42,1,6],[1,90,0,0]],[34,"GameName",262144,65,[[5,-832,[5,407,290]],[12,2,-833,57]],[1,-392.953,828.964,0],[1,0.7,0.7,0.7]],[34,"GameLogo",262144,65,[[5,-834,[5,706,496]],[12,2,-835,58]],[1,-97.379,828.512,0],[1,0.4,0.4,0.4]],[34,"QRGame",262144,65,[[5,-836,[5,713,711]],[12,2,-837,59]],[1,389.671,-792.359,0],[1,0.4,0.4,0.4]],[28,"Label",false,33554432,16,[[5,-838,[5,900,126]],[61,"恭喜你和孩子解锁了动物新知识！",60,60,100,false,-839,[4,4280049195],70]],[1,0,156.963,0]],[21,"Label-001",33554432,16,[[5,-840,[5,540,180.8]],[61,"加入健达会员\n获取入会积分享好礼",60,60,80,false,-841,[4,4280049195],71]],[1,0,64.572,0]],[21,"Label-002",33554432,16,[[5,-842,[5,540,72.32]],[61,"会员积分及礼品兑换规则详见\n“健达福利社”微信小程序“会员规则”",30,30,32,false,-843,[4,4280049195],72]],[1,0,-133,0]],[69,"Label",512,33554432,70,[[5,-844,[5,400,50]],[115,"成为健达会员",50,50,60,1,false,false,-845,73]]],[28,"BG",false,33554432,72,[[5,-846,[5,1118.683,2048]],[12,0,-847,85]],[1,0.0014999999999645297,-825.6949999999998,0]],[20,0,{},72,[19,"8fJHyWPHhT77T0qzBIqM/Z",-848,[35,"f8aHuDYTlLU7dAOrBOmAYs",[[9,"VD302_Kangaroo_Rig",["_name"],73],[8,["_lpos"],73,[1,-530,-1700,-775.915]],[8,["_lrot"],73,[3,0.043619387365336,0,0,0.9990482215818578]],[8,["_euler"],73,[1,5,0,0]],[8,["_lscale"],73,[1,70,70,70]],[9,4,["_clips","length"],41],[15,["_clips","2"],41,93],[15,["_clips","3"],41,94],[15,["_defaultClip"],41,95],[9,true,["playOnLoad"],41],[9,33554432,["_layer"],73],[15,["_clips","0"],41,96],[15,["_clips","1"],41,97]]],92]],[28,"BG",false,33554432,74,[[5,-849,[5,1118.683,2048]],[12,0,-850,98]],[1,0.0014999999999645297,-825.6949999999998,0]],[20,0,{},74,[19,"35MaNWaVpaXITwGugCw+yp",-853,[78,"92A6izLOlEMIxvGVamhEo0",null,[[2,"VD289_Lion_Rig",["_name"],[0,["35MaNWaVpaXITwGugCw+yp"]]],[3,["_lpos"],[0,["35MaNWaVpaXITwGugCw+yp"]],[1,-510,-1660,-770.249]],[3,["_lrot"],[0,["35MaNWaVpaXITwGugCw+yp"]],[3,0.0697564737441253,0,0,0.9975640502598242]],[3,["_euler"],[0,["35MaNWaVpaXITwGugCw+yp"]],[1,8,0,0]],[3,["_lscale"],[0,["35MaNWaVpaXITwGugCw+yp"]],[1,70,70,70]],[2,3,["_clips","length"],[0,["bcbBLaSAhbuZMFUUZNLvRX"]]],[174,["_clips","3"],[0,["bcbBLaSAhbuZMFUUZNLvRX"]]],[9,true,["playOnLoad"],-851],[2,33554432,["_layer"],[0,["35MaNWaVpaXITwGugCw+yp"]]],[15,["_clips","2"],-852,102]]],101]],[28,"BG",false,33554432,75,[[5,-854,[5,1118.683,2048]],[12,0,-855,103]],[1,0.0014999999999645297,-825.6949999999998,0]],[20,0,{},75,[19,"5dXI/ybWZaFrEKPI46LgaD",-856,[35,"62sA1cIN9MWYkP1Qlp16vo",[[8,["_lpos"],76,[1,-530,-1700,-775.915]],[9,"VD295_Flamingo_Rig",["_name"],76],[8,["_lrot"],76,[3,0,0,0,1]],[8,["_euler"],76,[1,0,0,0]],[8,["_lscale"],76,[1,100,100,100]],[9,4,["_clips","length"],160],[15,["_clips","3"],160,107],[15,["_defaultClip"],160,108],[9,true,["playOnLoad"],160],[9,33554432,["_layer"],76]]],106]],[28,"BG",false,33554432,77,[[5,-857,[5,1118.683,2048]],[12,0,-858,109]],[1,0.0014999999999645297,-825.6949999999998,0]],[20,0,{},77,[19,"49pWBJK15R+45zZnNOgfJN",-861,[35,"05IqriwrpG9b7PW3dTSMkL",[[9,"VD297_Giraffe_Rig-002",["_name"],78],[8,["_lpos"],78,[1,-520,-1700,-775.915]],[8,["_lrot"],78,[3,0.06104853953485687,0,0,0.9981347984218669]],[8,["_euler"],78,[1,7,0,0]],[8,["_lscale"],78,[1,45,45,45]],[15,["_defaultClip"],-859,113],[9,true,["playOnLoad"],-860],[9,33554432,["_layer"],78]]],112]],[139,"Sprite",33554432,79,[[5,-862,[5,128,128]],[12,0,-863,114]],[3,-1,6.123233995736766e-17,-6.123233995736766e-17,3.749399456654644e-33],[1,0,180,-180]],[211,"Sprite",33554432,80,[[5,-864,[5,128,128]],[12,0,-865,116]],[1,-1.472,-2.944,1.632],[3,0.07845909572784494,4.8042340223550544e-18,0.996917333733128,6.104358108853945e-17],[1,0,9,180]],[139,"Sprite",33554432,81,[[5,-866,[5,128,128]],[12,0,-867,118]],[3,0,0,-1,6.123233995736766e-17],[1,0,0,-180]],[139,"Sprite",33554432,82,[[5,-868,[5,128,128]],[12,0,-869,120]],[3,0,0,-1,6.123233995736766e-17],[1,0,0,-180]],[99,"Title",false,33554432,162,[[5,-870,[5,364.84,70.56]],[273,"HERBIVORE",56,56,56,false,true,-871,122]]],[21,"Label",33554432,17,[[5,-872,[5,900,126]],[61,"恭喜你和孩子解锁了动物新知识！",60,60,100,false,-873,[4,4280049195],156]],[1,0,156.963,0]],[21,"Label-001",33554432,17,[[5,-874,[5,450,113]],[61,"加入健达会员\n获取入会积分享好礼",50,50,50,false,-875,[4,4280049195],157]],[1,0,-0.777,0]],[21,"Label-002",33554432,17,[[5,-876,[5,540,72.32]],[61,"会员积分及礼品兑换规则详见\n“健达福利社”微信小程序“会员规则”",30,30,32,false,-877,[4,4280049195],158]],[1,0,-133.426,0]],[69,"Label",512,33554432,83,[[5,-878,[5,400,50]],[115,"成为健达会员",50,50,60,1,false,false,-879,159]]],[69,"Label",512,33554432,84,[[5,-880,[5,400,50]],[115,"学习更多动物知识",50,50,60,1,false,false,-881,164]]],[162,"BG",33554432,126,[[5,-882,[5,937,1857]],[12,0,-883,168]],[1,1.137,1,1.137]],[163,"Label",512,false,33554432,85,[[5,-884,[5,100,40]],[89,"button",20,20,1,false,-885,[4,4278190080]]]],[69,"Label",512,33554432,86,[[5,-886,[5,400,50]],[115,"学习更多动物知识",50,50,60,1,false,false,-887,178]]],[162,"BG",33554432,128,[[5,-888,[5,937,1857]],[12,0,-889,182]],[1,1.111,1.001,1.111]],[163,"Label",512,false,33554432,87,[[5,-890,[5,100,40]],[89,"button",20,20,1,false,-891,[4,4278190080]]]],[28,"BG",false,33554432,3,[[5,-892,[5,1118.683,2048]],[12,0,-893,189]],[1,0.0014999999999645297,0,0]],[21,"Kangaroo-2",33554432,48,[[5,-894,[5,280,398]],[59,-895,201]],[1,-289.862,-335.27,0]],[21,"Flomingo-2",33554432,48,[[5,-896,[5,392,383]],[59,-897,202]],[1,208,-335.588,0]],[21,"Lion-2",33554432,48,[[5,-898,[5,308,385]],[59,-899,203]],[1,-245.296,348.799,0]],[21,"Giraffe-2",33554432,48,[[5,-900,[5,351,586]],[59,-901,204]],[1,276.021,447.434,0]],[21,"GiftBox",33554432,29,[[5,-902,[5,80,100]],[12,0,-903,207]],[1,-58.879,0,0]],[21,"Label",33554432,29,[[5,-904,[5,112,100.8]],[61,"解锁",56,56,80,false,-905,[4,4284881681],208]],[1,50,0,0]],[54,"Panel",33554432,10,[[5,-906,[5,1080,200]],[12,0,-907,210]]],[117,false,11,[[11,"c8d65aN9XJPtacH/s2uxMQ5","unlock",11]],[4,4292269782],11,[[11,"eb8b7+ixMxD2KAScxnIdYKz","changeAnimal",10],[11,"48620PnKRFFB6jQjEJujCIK","init",4]]],[97,"Checkmark",false,33554432,11,[[[5,-908,[5,40,40]],-909],4,1],[1,-70.416,62.667,0]],[117,false,12,[[11,"c8d65aN9XJPtacH/s2uxMQ5","unlock",12]],[4,4292269782],12,[[11,"eb8b7+ixMxD2KAScxnIdYKz","changeAnimal",10],[11,"48620PnKRFFB6jQjEJujCIK","init",4]]],[97,"Checkmark",false,33554432,12,[[[5,-910,[5,40,40]],-911],4,1],[1,-70.416,62.667,0]],[21,"Sprite",33554432,12,[[5,-912,[5,117.45,132.86]],[12,0,-913,218]],[1,-3.01,1.693,0]],[282,1,12,154,183,262,208,32,134,75,159,117,177,113,121],[21,"GiftBox",33554432,31,[[5,-914,[5,80,100]],[12,0,-915,221]],[1,-58.506,0,0]],[21,"Label",33554432,31,[[5,-916,[5,112,100.8]],[61,"解锁",56,56,80,false,-917,[4,4284881681],222]],[1,50.373,0,0]],[101,"PlaneBGUnlockFlamingo",false,49,[[82,"Plane<ModelComponent>",-918,[231],[29],232]],[1,-535.9449999999999,-909.3180000000001,-975.151],[3,0.7071067811865475,0,0,0.7071067811865477],[1,98,1,140],[1,89.99999999999999,0,0]],[101,"PlaneBGUnlockKangaroo",false,49,[[82,"Plane<ModelComponent>",-919,[225],[29],226]],[1,-535.9449999999999,-909.3180000000001,-975.151],[3,0.7071067811865475,0,0,0.7071067811865477],[1,98,1,159],[1,89.99999999999999,0,0]],[101,"PlaneBGUnlockLion",false,49,[[82,"Plane<ModelComponent>",-920,[227],[29],228]],[1,-535.9449999999999,-909.3180000000001,-975.151],[3,0.7071067811865475,0,0,0.7071067811865477],[1,98,1,159],[1,89.99999999999999,0,0]],[101,"PlaneBGUnlockGiraffe",false,49,[[82,"Plane<ModelComponent>",-921,[229],[29],230]],[1,-535.9449999999999,-909.3180000000001,-975.151],[3,0.7071067811865475,0,0,0.7071067811865477],[1,98,1,159],[1,89.99999999999999,0,0]],[20,0,{},32,[19,"11eNPD3O5GYoRUgAIxCkP0",-922,[35,"96kekmPcxK748Nxjk6H9ly",[[9,"NameTag",["_name"],184],[8,["_lpos"],184,[1,0,0,0]],[8,["_lrot"],184,[3,0,0,0,1]],[8,["_euler"],184,[1,0,0,0]],[2,"FLAMINGO",["_string"],[0,["ebJnXfl+tHiJIUO67uuBpW"]]],[3,["_contentSize"],[0,["3ceulRayxKt62g5xjwaWn7"]],[5,289.95,104.8]],[2,"火烈鸟",["_string"],[0,["e09/dbuUJBS6mikqBI1Kbs"]]],[3,["_contentSize"],[0,["c1qq9hugFEL7ITQmR5z1M4"]],[5,156,106.8]]]],233]],[20,0,{},32,[19,"5dXI/ybWZaFrEKPI46LgaD",-923,[35,"74Ek/NdWdKMo8GnIFuF4NF",[[8,["_lpos"],135,[1,-530,-620,-700]],[9,"VD295_Flamingo_Rig",["_name"],135],[8,["_lrot"],135,[3,0,0.7071067811865475,0,0.7071067811865476]],[8,["_euler"],135,[1,0,90,0]],[8,["_lscale"],135,[1,100,100,100]],[9,4,["_clips","length"],185],[15,["_clips","3"],185,235],[15,["_defaultClip"],185,236],[9,true,["playOnLoad"],185]]],234]],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[20,0,{},32,[19,"5dXI/ybWZaFrEKPI46LgaD",-928,[91,"fegi+T25tGoZae7dFFosxU",null,[[25,[0,["00epe3MM5V+6cyzbwFVcci"]],[[31],[32]]]],[[3,["_lpos"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,0,500,100]],[2,"VD295_Flamingo_Rig-canvas",["_name"],[0,["5dXI/ybWZaFrEKPI46LgaD"]]],[3,["_lrot"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[3,0,0,0,1]],[3,["_euler"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,0,0,0]],[3,["_lscale"],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[1,200,200,200]],[2,4,["_clips","length"],[0,["4cq3CaMM9QFplY9tFHtlLH"]]],[45,["_clips","0"],[0,["4cq3CaMM9QFplY9tFHtlLH"]],239],[45,["_defaultClip"],[0,["4cq3CaMM9QFplY9tFHtlLH"]],240],[45,["_clips","1"],[0,["4cq3CaMM9QFplY9tFHtlLH"]],241],[45,["_clips","2"],[0,["4cq3CaMM9QFplY9tFHtlLH"]],242],[9,true,["playOnLoad"],-924],[9,false,["_active"],-925],[9,"VD295_Flamingo_Toy",["_name"],186],[8,["_lrot"],186,[3,-0.7071067811865477,0,0,0.7071067811865474]],[8,["_euler"],186,[1,-90.00000000000003,0,0]],[9,524288,["_layer"],-926],[9,524288,["_layer"],186],[2,524288,["_layer"],[0,["c3T8xhbBlaNp7/Bly9AFlQ"]]],[2,524288,["_layer"],[0,["c4MNbS8yRXIaS6qgPgPrqT"]]],[2,524288,["_layer"],[0,["63UN7XUWBWyZZ/qkFfOZhT"]]],[2,524288,["_layer"],[0,["28HoLqRkpcfoL7nQmIgrpu"]]],[2,524288,["_layer"],[0,["74qcjuzehSf5BUatpViYMH"]]],[2,524288,["_layer"],[0,["cfwWn+4r9UDZPd2/A7BPsK"]]],[2,524288,["_layer"],[0,["11e4xaYaxdEodwfLk3pWmV"]]],[2,524288,["_layer"],[0,["b5g+r/vqNfaail1orcNRvu"]]],[2,524288,["_layer"],[0,["98ubztsaReB4SM5j0C+9XQ"]]],[2,524288,["_layer"],[0,["45seyRJhVZ2YulhZHAVFr0"]]],[2,524288,["_layer"],[0,["e1NdgXAPpT3pWeZaVw/WW/"]]],[2,524288,["_layer"],[0,["91wcoKnUdZt649Xs1K9QTt"]]],[2,524288,["_layer"],[0,["daFSmgldhVHZr6ed1FMbc2"]]],[2,524288,["_layer"],[0,["afjViuGxNakYmIONA9A7ZA"]]],[2,524288,["_layer"],[0,["23P11ouaBeNaOziPbu7lTO"]]],[2,524288,["_layer"],[0,["badzM6Hqlb27spngOq5m5/"]]],[2,524288,["_layer"],[0,["4aHFl3fHlbuaL6RN8JRXeO"]]],[2,524288,["_layer"],[0,["9eM/tvRn9fvLFlTT7ESNOv"]]],[2,524288,["_layer"],[0,["67sWnaBDZcZIOZiwUDQXR8"]]],[2,524288,["_layer"],[0,["98Sz/NQqJWj6c2DtnFVTQ6"]]],[2,524288,["_layer"],[0,["79MDogfrxY4pizj38cH188"]]],[2,524288,["_layer"],[0,["1exRZapZNcwIBXxb/0W5eY"]]],[2,524288,["_layer"],[0,["d2NS0Sd+lc/qOaGqu0ryVu"]]],[2,524288,["_layer"],[0,["46CRa2+nVSU7GAYxzrvj3h"]]],[2,524288,["_layer"],[0,["62LM705PxVL7yWO1SbD16v"]]],[2,524288,["_layer"],[0,["b72NXmqyBRSqNZecSkl4t2"]]],[2,524288,["_layer"],[0,["783hrjEJBTA6iOjJ8o6PCH"]]],[2,524288,["_layer"],[0,["cfy2dsSI5clai71SmRD+gt"]]],[2,524288,["_layer"],[0,["8df/WULSJXH4ndqHq46j6Q"]]],[2,524288,["_layer"],[0,["15bHkaVhxULoQNZ95K+rGl"]]],[2,524288,["_layer"],[0,["baXanNgPZQoZV6vIjIoTfA"]]],[2,524288,["_layer"],[0,["1eYfzhDh5bIo6wE6rROPOs"]]],[2,524288,["_layer"],[0,["30RfEJQ/xTabZjlnUgSgWc"]]],[2,524288,["_layer"],[0,["34Ruzm2H1XYYt2kEBRWij0"]]],[2,524288,["_layer"],[0,["eeJG5qN81dm4bIT7UcnztQ"]]],[2,524288,["_layer"],[0,["81v2Uyj+Vez6nrS7hhhoNT"]]],[2,524288,["_layer"],[0,["b51/1/kdFRobUfwsEeT3uH"]]],[2,524288,["_layer"],[0,["33lPB7VnpemLW23UhXTmaQ"]]],[2,524288,["_layer"],[0,["f1JuzE2exYNpMLArES2Q9R"]]],[2,524288,["_layer"],[0,["a0kNa6alVRtb1xwMgM02q9"]]],[2,524288,["_layer"],[0,["33XcvF5phc+IlA2P543Z0E"]]],[2,524288,["_layer"],[0,["d8KrAf/ApRq4ueboGh7Kiw"]]],[2,524288,["_layer"],[0,["d0xrCNmzhYj5mJfGfYioBX"]]],[2,524288,["_layer"],[0,["c5UNlN9WpelrcAagNMgB3X"]]],[2,524288,["_layer"],[0,["ec0i50qEBURauM08B13c/7"]]],[15,["_clips","3"],-927,243]]],238]],[117,false,13,[[11,"c8d65aN9XJPtacH/s2uxMQ5","unlock",13]],[4,4292269782],13,[[11,"eb8b7+ixMxD2KAScxnIdYKz","changeAnimal",10],[11,"48620PnKRFFB6jQjEJujCIK","init",4]]],[97,"Checkmark",false,33554432,13,[[[5,-929,[5,40,40]],-930],4,1],[1,-70.416,62.667,0]],[21,"Sprite",33554432,13,[[5,-931,[5,117.45,132.86]],[12,0,-932,244]],[1,0.264,-0.49,0]],[181,2,13,153,187,270,276,207,34,136,74,158,118,178,114,122],[21,"Label",33554432,33,[[5,-933,[5,112,100.8]],[61,"解锁",56,56,80,false,-934,[4,4284881681],248]],[1,49.574,-0.146,0]],[21,"GiftBox",33554432,33,[[5,-935,[5,80,100]],[12,0,-936,249]],[1,-59.305,-0.146,0]],[20,0,{},34,[19,"11eNPD3O5GYoRUgAIxCkP0",-937,[35,"29i4e+gTBAyJbe9fR9kvWl",[[9,"NameTag",["_name"],188],[8,["_lpos"],188,[1,0,0,0]],[8,["_lrot"],188,[3,0,0,0,1]],[8,["_euler"],188,[1,0,0,0]],[2,"LION",["_string"],[0,["ebJnXfl+tHiJIUO67uuBpW"]]],[3,["_contentSize"],[0,["3ceulRayxKt62g5xjwaWn7"]],[5,134.55,104.8]],[2,"狮子",["_string"],[0,["e09/dbuUJBS6mikqBI1Kbs"]]]]],252]],[20,0,{},34,[19,"35MaNWaVpaXITwGugCw+yp",-938,[35,"f1L3PRUKpPJ4U+jzQhWtMz",[[9,"VD289_Lion_Rig",["_name"],137],[8,["_lpos"],137,[1,-530,-600,-700]],[8,["_lrot"],137,[3,0,0,0,1]],[8,["_euler"],137,[1,0,0,0]],[8,["_lscale"],137,[1,60,60,60]],[9,4,["_clips","length"],138],[15,["_clips","3"],138,261],[9,true,["playOnLoad"],138],[15,["_clips","2"],138,262],[15,["_defaultClip"],138,263]]],260]],[117,false,14,[[11,"c8d65aN9XJPtacH/s2uxMQ5","unlock",14]],[4,4292269782],14,[[11,"eb8b7+ixMxD2KAScxnIdYKz","changeAnimal",10],[11,"48620PnKRFFB6jQjEJujCIK","init",4]]],[97,"Checkmark",false,33554432,14,[[[5,-939,[5,40,40]],-940],4,1],[1,-70.416,62.667,0]],[21,"Sprite",33554432,14,[[5,-941,[5,117.45,132.86]],[12,0,-942,264]],[1,-3.009,0.602,0]],[181,3,14,155,191,271,284,22,36,139,77,161,119,179,115,123],[21,"GiftBox",33554432,35,[[5,-943,[5,80,100]],[12,0,-944,267]],[1,-58.506,-0.146,0]],[21,"Label",33554432,35,[[5,-945,[5,112,100.8]],[61,"解锁",56,56,80,false,-946,[4,4284881681],268]],[1,50.373,-0.146,0]],[20,0,{},36,[19,"11eNPD3O5GYoRUgAIxCkP0",-947,[35,"8fHCgjZvxIKaz8xooyc6Z6",[[9,"NameTag",["_name"],192],[8,["_lpos"],192,[1,0,0,0]],[8,["_lrot"],192,[3,0,0,0,1]],[8,["_euler"],192,[1,0,0,0]],[2,"GIRAFFE",["_string"],[0,["ebJnXfl+tHiJIUO67uuBpW"]]],[3,["_contentSize"],[0,["3ceulRayxKt62g5xjwaWn7"]],[5,259.4,104.8]],[2,"长颈鹿",["_string"],[0,["e09/dbuUJBS6mikqBI1Kbs"]]],[3,["_contentSize"],[0,["c1qq9hugFEL7ITQmR5z1M4"]],[5,156,106.8]]]],271]],[20,0,{},36,[19,"49pWBJK15R+45zZnNOgfJN",-950,[79,"8fMnZVdF5LZp31FR0YZpHH",[[25,[0,["e3FAH3cZhSZLsUbfJUC80S"]],[[31],[32]]]],[[8,["_lpos"],51,[1,0,200,100]],[9,"VD297_Giraffe_Rig-001",["_name"],51],[8,["_lrot"],51,[3,0,0,0,1]],[8,["_euler"],51,[1,0,0,0]],[9,3,["_clips","length"],90],[15,["_clips","1"],90,273],[15,["_defaultClip"],90,274],[15,["_clips","2"],90,275],[15,["_clips","0"],90,276],[9,true,["playOnLoad"],90],[9,false,["_active"],51],[8,["_lscale"],51,[1,150,150,150]],[8,["_lpos"],-948,[1,0,0,0]],[9,524288,["_layer"],51],[9,524288,["_layer"],-949],[2,524288,["_layer"],[0,["27goImrUhSiLj/q8l+pR3q"]]],[2,524288,["_layer"],[0,["edXyveHQlamqk5Klmem7yW"]]],[2,524288,["_layer"],[0,["0bz+t64LpWRoPHsBCKwTl/"]]],[2,524288,["_layer"],[0,["f2uk/fraBW44RrsLTmM1qH"]]],[2,524288,["_layer"],[0,["76JitRG4Bb6IWeWws2pnXN"]]],[2,524288,["_layer"],[0,["11BAfAQWVSDq0Huwsgvaqy"]]],[2,524288,["_layer"],[0,["80xBgp43xZAaNnhTprLbP3"]]],[2,524288,["_layer"],[0,["cf54cUQTFQdaEFKgi0tXhy"]]],[2,524288,["_layer"],[0,["dayS5tevFSZqR9L49DlLE1"]]],[2,524288,["_layer"],[0,["35suY1tUlZY6a8OdTLav2m"]]],[2,524288,["_layer"],[0,["56D6KHIFhfjJguAA9oJ5nd"]]],[2,524288,["_layer"],[0,["e8IZExt/9Zj4U6ZKChzAp8"]]],[2,524288,["_layer"],[0,["7c+r1SaXFbJIz1+lTaGNL8"]]],[2,524288,["_layer"],[0,["05vzGOWtNStKzQvyWde+Ao"]]],[2,524288,["_layer"],[0,["4eZ9lbh79WQ7KnvB+7+zxC"]]],[2,524288,["_layer"],[0,["a8Hm0zESxYv6gYOiTo0hxR"]]],[2,524288,["_layer"],[0,["4eUfYIsfZUlrwpmZtd7TvP"]]],[2,524288,["_layer"],[0,["14Ad035ANcloqi0mJImlLj"]]],[2,524288,["_layer"],[0,["d4y+2xk59a2r6WSeI/vdA+"]]],[2,524288,["_layer"],[0,["27MQcNugdU3YnRBSyPx/OP"]]],[2,524288,["_layer"],[0,["27d7tBW79d3Krcc+XS9kjS"]]],[2,524288,["_layer"],[0,["c4UT6iM6ZavIrWG+TU0Tk4"]]],[2,524288,["_layer"],[0,["a84YD19Gdc1L3jl37FEJEs"]]],[2,524288,["_layer"],[0,["14c21KloFeW4TnZpqdpSeQ"]]],[2,524288,["_layer"],[0,["feam7ruXVQvZy90w4OSN1y"]]],[2,524288,["_layer"],[0,["1aix5QZVtffaZlYVrLXuzk"]]],[2,524288,["_layer"],[0,["9eXV3vCA5TaIZGzjUDTB7g"]]],[2,524288,["_layer"],[0,["49XHXwZQJSX7a3Ea2snvla"]]],[2,524288,["_layer"],[0,["d2RYeAmwZVVbYhAqdc4wDo"]]],[2,524288,["_layer"],[0,["35776kuEBeLZHUS0fLbjDm"]]],[2,524288,["_layer"],[0,["99+llp6yNf0pX1/DQ9+tgW"]]],[2,524288,["_layer"],[0,["2eX9kiozNTCYTR1C6h7sEi"]]],[2,524288,["_layer"],[0,["72SZVCrg1a2LbK96LcowhX"]]],[2,524288,["_layer"],[0,["35HbIUuotdQaMkFrCYzRIQ"]]],[2,524288,["_layer"],[0,["17RB3ykLBUm6je9HRIuOn/"]]],[2,524288,["_layer"],[0,["df+haHFsFdPpoeUvr0OVYf"]]],[2,524288,["_layer"],[0,["dexMSBu/Vc6oaq6wAV+avX"]]],[2,524288,["_layer"],[0,["51H6UXMFxVxreAZ4YjFABg"]]],[2,524288,["_layer"],[0,["2evjecQFZRbpov5tGjlFBH"]]],[2,524288,["_layer"],[0,["07HB7bVs5fSK0GCLwvrUvV"]]],[2,524288,["_layer"],[0,["5bcRdelBNcnqSCWgDkZn2m"]]],[2,524288,["_layer"],[0,["04PkZ8dHRVzZYNqb8TRcv7"]]],[2,524288,["_layer"],[0,["fd1KRbHfVdb5Q/fJ5w91SW"]]],[2,524288,["_layer"],[0,["e7FwbyyURWBqR0qzpv6MFQ"]]],[2,524288,["_layer"],[0,["7ft6QxtctagqdyecDLAhlN"]]],[2,524288,["_layer"],[0,["754t+mjF9VIpOTs7KdhAPA"]]],[2,524288,["_layer"],[0,["bcMI6QptlSGKEmSrWoPjmO"]]],[2,524288,["_layer"],[0,["89CoNx03Fe95p6c3PgddFh"]]],[2,524288,["_layer"],[0,["1arjDVWixWE6C/bv+TdkwO"]]],[2,524288,["_layer"],[0,["65Hr4qA4tY9J8Jvd+K0x5F"]]],[2,524288,["_layer"],[0,["7c7vkHe8taurwV9/b63dyq"]]],[2,524288,["_layer"],[0,["c6PyF6E9Fejpf+FhJZKAVH"]]],[2,524288,["_layer"],[0,["57n9xYdK5ZWIvmtHeYAceX"]]],[2,524288,["_layer"],[0,["1cIIaKZ1pcGLS4H52SXjPZ"]]],[2,524288,["_layer"],[0,["5fP7MY0KRScq+eqbAl68XC"]]],[2,524288,["_layer"],[0,["d42HOx4B5W6oKyikGCD94J"]]],[2,524288,["_layer"],[0,["4bY2R+ZuhfRbqPseCyF6kY"]]],[2,524288,["_layer"],[0,["16zFfly2pUNYXtnr5x4XBX"]]],[2,524288,["_layer"],[0,["3byxQ4HQJX6rqKO+WPtPaP"]]],[2,524288,["_layer"],[0,["528DScHiFfopPcfjRBeca+"]]],[2,524288,["_layer"],[0,["d4iQC7nKxUyoITQdTj5HN0"]]],[2,524288,["_layer"],[0,["55lY+R+5VfcL3MRr4OPaf/"]]],[2,524288,["_layer"],[0,["14ITHPHChYjbDoBqTnlyOE"]]],[2,524288,["_layer"],[0,["37bpu2CtdYWYgYXX1+Fi7a"]]],[2,524288,["_layer"],[0,["d9Du9LEYtYd6fEY+RDtLSd"]]]]],272]],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[20,0,{},36,[19,"49pWBJK15R+45zZnNOgfJN",-951,[35,"55Jwq5Xa5F54L0aMC7zAdw",[[9,"VD297_Giraffe_Rig",["_name"],140],[8,["_lpos"],140,[1,-530,-600,-700]],[8,["_lrot"],140,[3,0,0,0,1]],[8,["_euler"],140,[1,0,0,0]],[8,["_lscale"],140,[1,70,70,70]],[15,["_defaultClip"],194,279],[9,true,["playOnLoad"],194],[9,4,["_clips","length"],194],[15,["_clips","3"],194,280]]],278]],[20,0,null,4,[19,"8fJHyWPHhT77T0qzBIqM/Z",-959,[173,"1dRKqITCJJR6zNWur3+Cgc",4,[[25,[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[[80,-958,[10,"71SN8zFoFC/5gBHzxRLc1H"],282]]]],[[8,["_lpos"],196,[1,0,0,0]],[9,"VD302_Kangaroo_Rig",["_name"],196],[8,["_lrot"],196,[3,0,1,0,6.123233995736766e-17]],[8,["_euler"],196,[1,0,180,0]],[9,2,["_clips","length"],20],[15,["_clips","0"],20,283],[9,null,["_defaultClip"],20],[9,false,["playOnLoad"],20],[15,["_clips","1"],20,284],[9,false,["_useBakedAnimation"],20],[8,["_lrot"],-952,[3,0,0,0,1]],[8,["_euler"],-953,[1,0,0,0]],[8,["_lrot"],-954,[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001]],[8,["_euler"],-955,[1,-90,-90,0]],[8,["_lrot"],-956,[3,0,0,-6.698506168543417e-16,1]],[8,["_euler"],-957,[1,0,0,-7.67592264999771e-14]],[9,true,["_enabled"],20],[9,null,["_clips","2"],20],[9,null,["_clips","3"],20]]],281]],[20,0,null,37,[19,"11eNPD3O5GYoRUgAIxCkP0",-960,[78,"2ax0j5EJpNca+b8PDgvCG4",null,[[2,"NameTag",["_name"],[0,["11eNPD3O5GYoRUgAIxCkP0"]]],[3,["_lpos"],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[1,0,0,0]],[3,["_lrot"],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[3,0,0,0,1]],[3,["_euler"],[0,["11eNPD3O5GYoRUgAIxCkP0"]],[1,0,0,0]]]],285]],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[0,["f3CmudYmJTjK7M6nViAmg5"]],[0,["94Sq0jzYtOUYIB3Izu94jQ"]],[20,0,{},37,[19,"8fJHyWPHhT77T0qzBIqM/Z",-961,[35,"58exp71aBILYVyVIjxkd8E",[[9,"VD302_Kangaroo_Rig",["_name"],141],[8,["_lpos"],141,[1,-530,-600,-700]],[8,["_lrot"],141,[3,0,0,0,1]],[8,["_euler"],141,[1,0,0,0]],[8,["_lscale"],141,[1,100,100,100]],[9,4,["_clips","length"],53],[15,["_clips","2"],53,295],[15,["_clips","3"],53,296],[15,["_defaultClip"],53,297],[9,true,["playOnLoad"],53],[15,["_clips","0"],53,298],[15,["_clips","1"],53,299]]],294]],[288,false,54,[4,4292269782],54],[28,"Icon",false,33554432,54,[[5,-962,[5,128,128]],[12,0,-963,301]],[1,57.723,-48.029,0]],[199,"Checkmark",33554432,54,[[[5,-964,[5,26,26]],-965],4,1]],[21,"Sprite",33554432,11,[[5,-966,[5,117.45,132.86]],[12,0,-967,303]],[1,-3.01,1.693,0]],[21,"Label",33554432,91,[[5,-968,[5,440,50.4]],[274,"你想要解锁这个动物吗？",40,true,-969,[4,4278190080]]],[1,0,103.8,0]],[69,"Label",512,33554432,92,[[5,-970,[5,100,40]],[89,"是",20,20,1,false,-971,[4,4279488003]]]],[69,"Label",512,33554432,93,[[5,-972,[5,100,40]],[89,"否",20,20,1,false,-973,[4,4278190080]]]],[34,"KJLogo",33554432,7,[[5,-974,[5,407,290]],[12,2,-975,317]],[1,-182.854,837.929,0],[1,0.6,0.6,0.6]],[34,"NatoonsLogo",33554432,7,[[5,-976,[5,706,496]],[12,2,-977,318]],[1,165.414,837.929,0],[1,0.4,0.4,0.4]],[28,"Version",false,33554432,7,[[5,-978,[5,131.21,50.4]],[275,"1.0.1bx",40,-979]],[1,268.211,-933.491,0]],[212,"PlaneBGSelectUnlockAnimal","2c45jCpmlLHbePhawZA6cZ",9,[[82,"Plane<ModelComponent>",-980,[319],[29],320]],[1,7.022000000000048,2.911,-975.151],[3,0.7071067811865475,0,0,0.7071067811865476],[1,98,1,140],[1,89.99999999999999,0,0]],[54,"BG",33554432,55,[[5,-981,[5,504,284]],[59,-982,339]]],[21,"Label",33554432,55,[[5,-983,[5,293.47,50.4]],[276,"Allow app to access your camera",20,20,-984,[4,4278190080]]],[1,0,51.523,0]],[69,"Label",512,33554432,94,[[5,-985,[5,100,40]],[89,"Allow",20,20,1,false,-986,[4,4278190080]]]],[69,"Label",512,33554432,95,[[5,-987,[5,100,40]],[89,"Deny",20,20,1,false,-988,[4,4278190080]]]],[20,0,{},3,[19,"60whtUc01AqKpk/+jyFPeB",-989,[35,"26zSQzmMdNDbYeyPUOU8C+",[[9,"Text_effect",["_name"],203],[8,["_lpos"],203,[1,0,730.572,0]],[8,["_lrot"],203,[3,0,0,0,1]],[8,["_euler"],203,[1,0,0,0]],[2,10,["_totalParticles"],[0,["89UC8wTZJKBIPn2IyJPyqJ"]]]]],350]],[140,"Main Light","c0y6F5f+pAvI805TdmxIjx",9,[[289,0.1,1,30,-990,[290]]],[1,0,0,220.15]],[227,"Main Camera","c9DMICJLFO5IeO07EPon7U",9,[-991],[1,0,2.911,12.371]],[291,65.985,6,1083179008,318],[228,"Camera",1,[-992],[1,0,0,1000]],[292,0,1073741824,960.0000000000001,2000,6,42729472,320,[4,4278190080]],[213,"VD297_Giraffe_Toy",22,[[295,-993,[4,5,6,7,8,9,10,11,12,13,14,15,16],[29],22,17,18]],[1,0,-0.00011903722770512104,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[33,"Bip001",22,[-994],[1,-4.356060401278228e-9,2.378934383392334,-0.8954776525497437],[3,0,4.329780375814312e-17,-0.7071067811865476,0.7071067811865476],[1,0,0,-90]],[200,"Bip001 Pelvis",323,[149],[3,-0.49999999254917427,-0.49999999254917427,-0.49999930709576956,0.5000007078049009],[1,-89.99991974527727,-89.99991974527727,-0.0000017074910602964197]],[33,"Bip001 Spine1",149,[96],[1,0.6363147497177124,-0.0006434917449951172,-1.7844286048784852e-9],[3,-5.001003109185003e-14,6.055923869577305e-7,-0.21834164731705358,0.9758723917841453],[1,0.000016748928224149575,0.00007485893130099625,-25.2232972333355]],[71,"Bip001 R_Ear",5,[[22,"Bip001 R_Ear02",-995,[1,0.24279451370239258,-0.00015926361083984375,-0.00006985664367675781],[3,0.1943117099157505,-0.021092375925360597,0.2231939752599514,0.9549777591520656],[1,24.76597094901678,-8.038122542265535,24.71428519601091]]],[1,0.29334402084350586,0.004457592964172363,-0.16000939905643463],[3,0.16336328288055393,0.39462871559616325,-0.6255358051764845,0.6529054840293637],[1,76.93816074345585,97.44558932195352,-43.46377554217515]],[33,"Bip001 Tongue01",56,[-996],[1,0.09311747550964355,-0.010273933410644531,-7.956077752169222e-8],[3,-1.3280751676258093e-7,-5.582045435328034e-7,-0.11713972903232928,0.9931154433810317],[1,-0.000023244665055349306,-0.00006715070549894516,-13.454113569998423]],[71,"Bip001 Tongue02",327,[[22,"Bip001 Tongue03",-997,[1,0.057037353515625,0.000232696533203125,-1.6103513189591467e-7],[3,-0.0000014086552937428342,1.1217554662923372e-9,1.490116297018971e-8,0.9999999999990077],[1,-0.0001614200062424202,1.2854611307425332e-7,0.0000017075473149815245]]],[1,0.06330013275146484,0.0005035400390625,1.3969838619232178e-9],[3,2.34142972213993e-13,-1.4840483635151933e-7,0.05350618418461001,0.9985675181248289],[1,9.151900506504044e-7,-0.00001707937578821318,6.134286427783285]],[33,"Bip001 Tail_01",5,[-998],[1,-3.099538564682007,-1.777132272720337,-0.0000052145178415230475],[3,2.8648892559348733e-7,0.000003959627048611977,-0.7996029223990082,0.6005290721315704],[1,179.99862760717215,179.9989282292747,-73.81559809876565]],[33,"Bip001 Tail_02",329,[-999],[1,0.276302695274353,0.0013399124145507812,-8.407732821069658e-8],[3,-1.6811053228192466e-7,-1.8257904405254525e-7,-0.06674220435377931,0.9977702531935582],[1,-0.000020802808719429435,-0.000022360300422630196,-7.653782761696829]],[33,"Bip001 Tail_03",330,[-1000],[1,0.3749101161956787,0.010757684707641602,-8.89989678398706e-7],[3,-0.0000015325682318977173,0.0000016193943924228711,-0.017069453032498388,0.9998543062707688],[1,-0.00017252677321186527,0.00018265060150047768,-1.9561102335835894]],[71,"Bip001 Tail_04",331,[[22,"Bip001 Tail_05",-1001,[1,0.3159787654876709,-0.00016641616821289062,-8.189126674551517e-7],[3,-0.0000014061682804794182,-0.0000014202421425551375,1.0151216400779641e-7,0.9999999999979976],[1,-0.00016113499899229333,-0.0001627477449527858,0.000011632665984489571]]],[1,0.3840022087097168,-0.013496160507202148,-0.0000010278017725795507],[3,-0.0000014331359352548016,0.0000014222537174612764,-7.976756251063611e-7,0.9999999999976437],[1,-0.00016422515111352108,0.00016297813981618533,-0.00009140712704794832]],[71,"Bip001 L_Ear",5,[[22,"Bip001 L_Ear02",-1002,[1,0.24279439449310303,-0.00015878677368164062,0.0000699758529663086],[3,-0.19431173719916414,0.02109113885556124,0.22319412137824649,0.9549777467724632],[1,-24.765946391686672,8.037979485146726,24.714332699889397]]],[1,0.29334354400634766,0.0044564008712768555,0.16000941395759583],[3,-0.16336253074214327,-0.3946245857720451,-0.6255386986925687,0.6529053961270129],[1,-76.93861022551313,-97.44570159305196,-43.46421850753999]],[33,"Bip001 L Clavicle",96,[-1003],[1,-0.6252610683441162,-0.15536224842071533,0.3209458291530609],[3,0.6218016091848645,0.3824239934956703,0.39082494027587333,0.5606875369332697],[1,101.18437273864923,-8.096527187598403,66.04223841119425]],[33,"Bip001 L UpperArm",334,[-1004],[1,0.4305196702480316,5.960464477539063e-8,0],[3,-0.4766226478125026,0.5748613557875564,0.4806062944999592,0.45976392083471496],[1,-85.17161138936022,97.09950957592135,-6.087838604977945]],[33,"Bip001 L Forearm",335,[-1005],[1,0.5732908248901367,0,1.4901161193847656e-8],[3,1.8073457900254473e-18,-3.619298562452549e-18,-0.10238340452658577,0.9947450117882197],[1,1.6705795063605852e-16,-3.99737720120276e-16,-11.752868225791161]],[71,"Bip001 L Hand",336,[[22,"Bip001 L Finger0",-1006,[1,0.825505793094635,0.00021010637283325195,-0.016567260026931763],[3,-0.003084158369715048,0.013701365674395385,0.019711368282363303,0.9997070683486458],[1,-0.38456341678652844,1.5779873400313138,2.253833657637567]]],[1,1.0205600261688232,-5.960464477539063e-8,0],[3,-0.706795399661755,-0.0019021578041327138,-0.062264722302334395,0.7046699576179485],[1,-90.39524475854142,-5.222724049499616,-4.879664052241934]],[33,"Bip001 R Clavicle",96,[-1007],[1,-0.6252610683441162,-0.15536046028137207,-0.3209473192691803],[3,-0.621800054529036,-0.3824250931463723,0.3908238642904015,0.5606892610178962],[1,-101.18359469678377,8.095814037152945,66.04228349204378]],[33,"Bip001 R UpperArm",338,[-1008],[1,0.4305196702480316,5.960464477539063e-8,-4.440892098500626e-16],[3,-0.4766226478125026,0.5748613557875564,-0.4806062944999592,-0.45976392083471496],[1,85.17161138936022,-97.09950957592135,-6.087838604977945]],[33,"Bip001 R Forearm",339,[-1009],[1,0.5732908248901367,1.1102230246251565e-16,-1.4901161193847656e-8],[3,1.1160960807208764e-18,4.490079861320526e-18,-0.10238340452658577,0.9947450117882197],[1,1.8375430731814063e-16,5.361561372211306e-16,-11.752868225791161]],[71,"Bip001 R Hand",340,[[22,"Bip001 R Finger0",-1010,[1,0.825505793094635,0.00021010637283325195,0.016567260026931763],[3,0.003084158369715048,-0.013701365674395385,0.019711368282363303,0.9997070683486458],[1,0.38456341678652844,-1.5779873400313138,2.253833657637567]]],[1,1.0205599069595337,-5.960464477539063e-8,-5.551115123125783e-17],[3,0.706795399661755,0.0019021578041327138,-0.062264722302334395,0.7046699576179485],[1,90.39524475854142,5.222724049499616,-4.879664052241934]],[33,"Bip001 L Thigh",149,[-1011],[1,-0.39860236644744873,-0.045030832290649414,0.31775563955307007],[3,0.6697904583392761,0.7425501474978701,0.0000828426578436208,-0.00011621380163828846],[1,-0.15539599845470578,-179.84189640298345,84.10176769549689]],[33,"Bip001 L Calf",342,[-1012],[1,0.6152560710906982,-5.960464477539063e-8,0],[3,2.3134668868276776e-24,-5.182844774448237e-20,-0.19607236564834585,0.9805894285729687],[1,-1.2612065319290729e-18,-6.308848736250139e-18,-22.614750028058115]],[33,"Bip001 L HorseLink",343,[-1013],[1,0.6745597720146179,4.440892098500626e-16,-2.9802322387695312e-8],[3,1.1641626586293666e-11,1.7558664120709856e-11,0.22098652425649812,0.9752768612537837],[1,9.4910882731769e-10,1.8480233733852806e-9,25.53396581578114]],[71,"Bip001 L Foot",344,[[22,"Bip001 L Toe0",-1014,[1,0.06374531984329224,-0.008129239082336426,-2.9802322387695312e-8],[3,7.147154967240356e-14,1.130674135800072e-13,-0.008726830662804639,0.9999619204882667],[1,8.304059067177777e-12,1.3029535472831268e-11,-1.0000338246402656]]],[1,0.8986997008323669,1.1920928955078125e-7,0],[3,-0.000024228231144416933,-0.00014043359188703749,-0.0027167782979811692,0.9999962993966922],[1,-0.0028201019021005386,-0.016100225290632233,-0.31131985060473577]],[33,"Bip001 R Thigh",149,[-1015],[1,-0.39860236644744873,-0.0450291633605957,-0.31775563955307007],[3,0.6697904585943798,0.7425501477806858,-0.00008071986082393435,0.00011441641456539929],[1,0.15229580824553335,179.84497019075718,84.1017685548488]],[33,"Bip001 R Calf",346,[-1016],[1,0.6152560710906982,-5.960464477539063e-8,-5.551115123125783e-17],[3,-9.964784720143505e-22,-4.9835490194608505e-21,-0.19607236564834585,0.9805894285729687],[1,-2.4259603755906904e-19,-6.308848663652707e-19,-22.614750028058115]],[33,"Bip001 R HorseLink",347,[-1017],[1,0.6745598316192627,1.1920928955078125e-7,2.9802322387695312e-8],[3,-2.12874833573142e-11,-3.4665110129492556e-11,0.22098652425649812,0.9752768612537837],[1,-1.6637217959020381e-9,-3.6960467942528948e-9,25.53396581578114]],[71,"Bip001 R Foot",348,[[22,"Bip001 R Toe0",-1018,[1,0.06374531984329224,-0.008129239082336426,2.9802322387695312e-8],[3,-7.423691575647812e-14,6.478770305492795e-16,-0.00872682880030133,0.999961920504521],[1,-8.507247866030362e-12,-5.670285097220125e-20,-1.0000336112049801]]],[1,0.8986997008323669,1.1920928955078125e-7,5.551115123125783e-17],[3,0.000024315635403754084,0.00014043181655312579,-0.0027167782979760826,0.9999962993948199],[1,0.0028301172505327196,0.01610004906114549,-0.3113198492019426]],[65,1,57,[[11,"48028piprRLMaVhc/TgnTtM","spawnBerries",39]],[4,4286545791],57],[65,1,58,[[11,"48028piprRLMaVhc/TgnTtM","spawnSteak",39]],[4,4286545791],58],[65,1,59,[[11,"48028piprRLMaVhc/TgnTtM","spawnTwigs",39]],[4,4286545791],59],[65,1,60,[[11,"48028piprRLMaVhc/TgnTtM","spawnSeaweed",39]],[4,4286545791],60],[65,1,97,[[11,"facc9jj535Fnre+IlyJZiWZ","gotoHome",1]],[4,4286545791],97],[88,0,23],[277,"KANGAROO LIKES THE FOOD",60,60,80,false,151],[296,40],[297,39,350,351,352,353,354,356],[65,2,62,[[11,"facc9jj535Fnre+IlyJZiWZ","gotoFeedAnimal",1]],[4,4285690482],62],[179,2,63,[[11,"facc9jj535Fnre+IlyJZiWZ","gotoEncyclopedia",1]],63],[179,2,64,[[11,"facc9jj535Fnre+IlyJZiWZ","gotoChangeAnimalUI",1],[11,"75348tPWIlDzr3PoY+ONjZ9","activeAnimal",15]],64],[88,0,61],[65,1,102,[[11,"d08376zPztHyYCFCQIDFW0A","CaptureScreenShot",220]],[4,4286545791],102],[100,0,105,[19,"60whtUc01AqKpk/+jyFPeB",-1019,[78,"a54RX98Y9JG4VvG6Iui27e",null,[[2,"Text_effect-001",["_name"],[0,["60whtUc01AqKpk/+jyFPeB"]]],[3,["_lpos"],[0,["60whtUc01AqKpk/+jyFPeB"]],[1,0,0,0]],[3,["_lrot"],[0,["60whtUc01AqKpk/+jyFPeB"]],[3,0,0,0,1]],[3,["_euler"],[0,["60whtUc01AqKpk/+jyFPeB"]],[1,0,0,0]],[2,10,["_totalParticles"],[0,["89UC8wTZJKBIPn2IyJPyqJ"]]],[3,["_contentSize"],[0,["89hbBDCQVH4LrOphozzWmZ"]],[5,150,100]],[3,["_lpos"],[0,["feWWPHO4RLA6LnERZbRi0y"]],[1,0,0,-1]]]],65],[{},"mountedRoot",1,105]],[0,["6cZhWWAgFMj77FGB9Dj31n"]],[0,["d1DE4+SDlJB4nBBDNCRdsx"]],[0,["6cZhWWAgFMj77FGB9Dj31n"]],[0,["d1DE4+SDlJB4nBBDNCRdsx"]],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[0,["bcbBLaSAhbuZMFUUZNLvRX"]],[0,["bcbBLaSAhbuZMFUUZNLvRX"]],[0,["a5Ur2McGJUfKEIm/lueZtm"]],[0,["a5Ur2McGJUfKEIm/lueZtm"]],[112,1,79,[[11,"d5570+aNMNBpKsWeic7F5lj","gotoHabitat",2]],[4,4294967295],79],[112,1,80,[[11,"d5570+aNMNBpKsWeic7F5lj","gotoPicture",2]],[4,4294967295],80],[112,1,81,[[11,"d5570+aNMNBpKsWeic7F5lj","gotoMap",2]],[4,4294967295],81],[112,1,82,[[11,"d5570+aNMNBpKsWeic7F5lj","gotoFood",2]],[4,4294967295],82],[298,2,17,126,[278,"KANGAROO",60,60,80,false,[4,4279637536],174],376,374,375,377,47,46,28,45],[299,19,18,359,360,361,363],[113,1,29,[[11,"c8d65aN9XJPtacH/s2uxMQ5","unlock",11],[11,"38f24x0crREJarqw3t2YPCS","showParentPopup",7]],[4,4294769916],[4,4290493371],[4,4286677377],29],[263,1,181,[[11,"2b974OfW8lHy6X91zIaDTZD","hide",10],[11,"facc9jj535Fnre+IlyJZiWZ","gotoHome",1]],[4,4286545791]],[100,0,132,[19,"60whtUc01AqKpk/+jyFPeB",-1020,[78,"a54RX98Y9JG4VvG6Iui27e",null,[[2,"Text_effect-001",["_name"],[0,["60whtUc01AqKpk/+jyFPeB"]]],[3,["_lpos"],[0,["60whtUc01AqKpk/+jyFPeB"]],[1,0,0,0]],[3,["_lrot"],[0,["60whtUc01AqKpk/+jyFPeB"]],[3,0,0,0,1]],[3,["_euler"],[0,["60whtUc01AqKpk/+jyFPeB"]],[1,0,0,0]],[2,10,["_totalParticles"],[0,["89UC8wTZJKBIPn2IyJPyqJ"]]],[3,["_contentSize"],[0,["89hbBDCQVH4LrOphozzWmZ"]],[5,150,100]],[3,["_lpos"],[0,["feWWPHO4RLA6LnERZbRi0y"]],[1,0,0,-1]]]],215],[{},"mountedRoot",1,132]],[300,10,260,262,276,284,381],[88,0,261],[88,0,263],[113,1,31,[[11,"c8d65aN9XJPtacH/s2uxMQ5","unlock",12],[11,"38f24x0crREJarqw3t2YPCS","showParentPopup",7]],[4,4294769916],[4,4290493371],[4,4286677377],31],[0,["4cq3CaMM9QFplY9tFHtlLH"]],[0,["5dXI/ybWZaFrEKPI46LgaD"]],[81,32,[[11,"75348tPWIlDzr3PoY+ONjZ9","Playing",15]]],[88,0,277],[113,1,33,[[11,"c8d65aN9XJPtacH/s2uxMQ5","unlock",13],[11,"38f24x0crREJarqw3t2YPCS","showParentPopup",7]],[4,4294769916],[4,4290493371],[4,4286677377],33],[81,34,[[11,"75348tPWIlDzr3PoY+ONjZ9","Playing",15]]],[88,0,285],[113,1,35,[[11,"c8d65aN9XJPtacH/s2uxMQ5","unlock",14],[11,"38f24x0crREJarqw3t2YPCS","showParentPopup",7]],[4,4294769916],[4,4290493371],[4,4286677377],35],[0,["e3FAH3cZhSZLsUbfJUC80S"]],[81,36,[[11,"75348tPWIlDzr3PoY+ONjZ9","Playing",15]]],[301,false,10,195,279,265,287,301],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[0,["f3CmudYmJTjK7M6nViAmg5"]],[81,37,[[11,"75348tPWIlDzr3PoY+ONjZ9","Playing",15]]],[250,0,303,[4,16777215]],[303,7,311,380,386,391,394],[65,1,143,[[11,"75348tPWIlDzr3PoY+ONjZ9","Playing",15]],[4,4286545791],143],[304,3,404,401,389,392,396],[21,"CCUI",33554432,1,[[293,0,1073741824,960.0000000000001,2000,6,262144,-1021,[4,4278190080],353]],[1,0,0,1000]],[65,1,147,[[11,"c77dbLCyX5LurO0ldLEomso","switchVolume",204]],[4,4286545791],147],[305,1,357,403,405,379,378,383,18,362,355,49],[140,"AnimalManager","10e3SzIH1MJpT3NfydXRY8",9,[[302,-1022,195,279,265,287,301]],[1,0,6,0]],[140,"CCMain","4aTYgvOpJFPK8YJt0Qj29A",9,[[294,"Camera<CameraComponent>",65.985,1074266112,-1023,[4,4286073907],358]],[1,0,2.911,12.371]]],0,[0,0,1,0,35,321,0,0,1,0,0,1,0,-4,408,0,-1,320,0,-2,148,0,-3,18,0,-4,19,0,-5,40,0,-6,2,0,-7,3,0,-8,7,0,-9,10,0,-10,406,0,-11,65,0,-12,6,0,-13,147,0,-14,205,0,0,2,0,-2,378,0,-1,110,0,-2,111,0,-3,71,0,-4,44,0,-5,124,0,-6,17,0,-7,126,0,0,3,0,-2,405,0,-1,252,0,-2,129,0,-3,130,0,-4,131,0,-5,200,0,-6,143,0,-7,201,0,-8,202,0,-9,37,0,-10,32,0,-11,34,0,-12,36,0,-13,55,0,-14,316,0,-15,146,0,5,211,0,5,319,0,5,150,0,5,39,0,-1,207,0,-2,208,0,-3,22,0,4,4,0,-1,326,0,1,5,0,1,5,0,1,5,0,1,5,0,1,5,0,1,5,0,1,5,0,1,5,0,1,5,0,1,5,0,1,5,0,-13,56,0,1,5,0,-15,329,0,1,5,0,1,5,0,-18,333,0,1,5,0,1,5,0,0,6,0,36,128,0,37,16,0,38,26,0,39,68,0,40,24,0,0,6,0,-1,24,0,-2,68,0,-3,26,0,-4,16,0,-5,128,0,0,7,0,-2,403,0,-1,48,0,-2,29,0,-3,31,0,-4,35,0,-5,33,0,-6,199,0,-7,91,0,-8,308,0,-9,309,0,-10,310,0,3,274,0,3,274,0,3,274,0,0,8,0,4,8,0,-1,152,0,-2,153,0,-3,154,0,-4,155,0,-5,105,0,-6,156,0,-7,230,0,-8,158,0,-9,232,0,-10,159,0,-11,234,0,-12,161,0,-13,236,0,-14,295,0,-15,197,0,-16,198,0,-17,300,0,-18,272,0,-19,273,0,-21,275,0,-22,282,0,-23,189,0,-24,190,0,-25,283,0,-26,290,0,-27,291,0,-28,193,0,-29,293,0,-30,316,0,-31,132,0,-32,24,0,-33,68,0,-34,26,0,21,408,0,21,358,0,21,397,0,21,195,0,26,24,0,21,24,0,26,24,0,21,24,0,26,68,0,21,68,0,26,26,0,21,26,0,26,26,0,21,26,0,-1,317,0,-2,318,0,-4,150,0,-5,211,0,-7,15,0,-8,409,0,-9,311,0,-10,49,0,-11,204,0,-12,220,0,-13,221,0,-14,410,0,0,10,0,-2,383,0,-3,397,0,-1,259,0,-2,181,0,-3,30,0,-4,182,0,-5,88,0,0,11,0,0,11,0,-3,260,0,-4,195,0,-1,261,0,-2,304,0,-3,142,0,0,12,0,0,12,0,-3,262,0,-4,265,0,-1,263,0,-2,264,0,-3,134,0,0,13,0,0,13,0,-3,276,0,-4,279,0,-1,277,0,-2,278,0,-3,136,0,0,14,0,0,14,0,-3,284,0,-4,287,0,-1,285,0,-2,286,0,-3,139,0,0,15,0,0,15,0,0,16,0,0,16,0,-1,225,0,-2,226,0,-3,227,0,-4,70,0,-5,127,0,-6,86,0,0,17,0,0,17,0,-1,242,0,-2,243,0,-3,244,0,-4,83,0,-5,125,0,-6,84,0,0,18,0,-1,152,0,-2,153,0,-3,154,0,-4,155,0,0,19,0,-2,379,0,-1,61,0,-2,102,0,-3,103,0,-4,104,0,-5,66,0,0,22,0,0,22,0,-1,322,0,-2,323,0,1,22,0,0,23,0,-2,355,0,-1,57,0,-2,58,0,-3,59,0,-4,60,0,-5,97,0,3,365,0,3,107,0,3,107,0,3,107,0,3,67,0,3,67,0,3,67,0,3,67,0,3,67,0,3,365,0,3,366,0,3,366,0,3,107,0,3,67,0,3,107,0,4,24,0,3,367,0,3,109,0,3,109,0,3,109,0,3,69,0,3,69,0,3,69,0,3,69,0,3,69,0,3,367,0,3,368,0,3,368,0,3,109,0,3,69,0,3,109,0,4,26,0,0,27,0,0,27,0,-1,162,0,-2,45,0,-3,46,0,-4,47,0,-5,28,0,0,28,0,-1,175,0,-2,176,0,-3,177,0,-4,178,0,-5,179,0,0,29,0,0,29,0,-3,380,0,-1,180,0,-2,257,0,-3,258,0,0,30,0,0,30,0,-5,54,0,0,31,0,0,31,0,-3,386,0,-1,183,0,-2,266,0,-3,267,0,0,32,0,-2,389,0,-1,272,0,-2,273,0,-4,275,0,0,33,0,0,33,0,-3,391,0,-1,187,0,-2,280,0,-3,281,0,0,34,0,-2,392,0,-1,282,0,-2,189,0,-3,190,0,-4,283,0,0,35,0,0,35,0,-3,394,0,-1,191,0,-2,288,0,-3,289,0,0,36,0,-2,396,0,-1,290,0,-2,291,0,-3,193,0,-4,293,0,0,37,0,-2,401,0,-1,295,0,-2,197,0,-3,198,0,-4,300,0,0,38,0,0,38,0,11,38,0,0,38,0,0,38,0,-1,206,0,-1,358,0,0,40,0,-2,357,0,-2,151,0,-3,216,0,0,44,0,-1,79,0,-2,80,0,-3,81,0,-4,82,0,0,45,0,-1,112,0,-2,113,0,-3,114,0,-4,115,0,0,46,0,-1,116,0,-2,117,0,-3,118,0,-4,119,0,0,47,0,-1,120,0,-2,121,0,-3,122,0,-4,123,0,0,48,0,0,48,0,-1,253,0,-2,254,0,-3,255,0,-4,256,0,0,49,0,-1,268,0,-2,269,0,-3,270,0,-4,271,0,0,54,0,0,54,0,-3,301,0,-1,302,0,-2,303,0,0,55,0,0,55,0,-1,312,0,-2,313,0,-3,94,0,-4,95,0,1,56,0,1,56,0,1,56,0,-4,327,0,1,56,0,0,57,0,0,57,0,-3,350,0,-1,212,0,0,58,0,0,58,0,-3,351,0,-1,213,0,0,59,0,0,59,0,-3,352,0,-1,214,0,0,60,0,0,60,0,-3,353,0,-1,215,0,0,61,0,-2,362,0,-1,62,0,-2,63,0,-3,64,0,0,62,0,0,62,0,-3,359,0,-1,217,0,0,63,0,0,63,0,-3,360,0,-1,218,0,0,64,0,0,64,0,-3,361,0,-1,219,0,0,65,0,-1,222,0,-2,223,0,-3,224,0,0,66,0,0,66,0,11,66,0,0,66,0,-1,105,0,3,108,0,3,108,0,3,108,0,3,108,0,3,108,0,4,68,0,0,70,0,0,70,0,11,70,0,0,70,0,-1,228,0,0,71,0,-1,72,0,-2,74,0,-3,75,0,-4,77,0,0,72,0,-1,229,0,-2,156,0,-3,230,0,0,74,0,-1,231,0,-2,158,0,-3,232,0,0,75,0,-1,233,0,-2,159,0,-3,234,0,0,77,0,-1,235,0,-2,161,0,-3,236,0,0,79,0,0,79,0,-3,374,0,-1,237,0,0,80,0,0,80,0,-3,375,0,-1,238,0,0,81,0,0,81,0,-3,376,0,-1,239,0,0,82,0,0,82,0,-3,377,0,-1,240,0,0,83,0,0,83,0,11,83,0,0,83,0,-1,245,0,0,84,0,0,84,0,11,84,0,0,84,0,-1,246,0,0,85,0,0,85,0,11,85,0,0,85,0,-1,248,0,0,86,0,0,86,0,11,86,0,0,86,0,-1,249,0,0,87,0,0,87,0,11,87,0,0,87,0,-1,251,0,0,88,0,0,88,0,11,88,0,0,88,0,-1,132,0,0,91,0,0,91,0,-1,305,0,-2,92,0,-3,93,0,0,92,0,0,92,0,11,92,0,0,92,0,-1,306,0,0,93,0,0,93,0,11,93,0,0,93,0,-1,307,0,0,94,0,0,94,0,11,94,0,0,94,0,-1,314,0,0,95,0,0,95,0,11,95,0,0,95,0,-1,315,0,-1,209,0,-2,334,0,-3,338,0,1,96,0,0,97,0,0,97,0,-3,354,0,0,102,0,0,102,0,-3,363,0,0,103,0,0,103,0,11,103,0,0,103,0,0,104,0,0,104,0,11,104,0,0,104,0,3,106,0,3,106,0,3,106,0,3,106,0,3,106,0,-1,364,0,4,105,0,0,110,0,0,110,0,11,110,0,0,110,0,0,111,0,0,111,0,11,111,0,0,111,0,0,112,0,0,112,0,-1,163,0,0,113,0,0,113,0,-1,164,0,0,114,0,0,114,0,-1,165,0,0,115,0,0,115,0,-1,166,0,0,116,0,0,116,0,-1,167,0,0,117,0,0,117,0,-1,168,0,0,118,0,0,118,0,-1,169,0,0,119,0,0,119,0,-1,170,0,0,120,0,0,120,0,-1,171,0,0,121,0,0,121,0,-1,172,0,0,122,0,0,122,0,-1,173,0,0,123,0,0,123,0,-1,174,0,0,124,0,0,124,0,11,124,0,0,124,0,0,125,0,0,125,0,11,125,0,0,125,0,0,126,0,-1,247,0,0,127,0,0,127,0,11,127,0,0,127,0,0,128,0,-1,250,0,0,129,0,0,129,0,11,129,0,0,129,0,0,130,0,0,130,0,11,130,0,0,130,0,0,131,0,0,131,0,11,131,0,0,131,0,3,133,0,3,133,0,3,133,0,3,133,0,3,133,0,-1,382,0,4,132,0,0,134,0,0,134,0,0,134,0,0,136,0,0,136,0,0,136,0,0,139,0,0,139,0,0,139,0,0,142,0,0,142,0,0,142,0,0,143,0,0,143,0,-3,404,0,0,144,0,0,144,0,11,144,0,0,144,0,0,145,0,0,145,0,11,145,0,0,145,0,0,146,0,0,146,0,11,146,0,0,146,0,0,147,0,0,147,0,-3,407,0,0,148,0,0,148,0,-1,325,0,-2,342,0,-3,346,0,0,150,0,0,150,0,0,151,0,-2,356,0,0,151,0,4,152,0,4,153,0,4,154,0,4,155,0,3,369,0,3,157,0,3,369,0,3,157,0,3,157,0,3,157,0,4,156,0,3,370,0,3,370,0,4,158,0,4,159,0,3,372,0,3,372,0,4,161,0,0,162,0,0,162,0,-1,241,0,0,163,0,0,163,0,0,163,0,0,164,0,0,164,0,0,164,0,0,165,0,0,165,0,0,165,0,0,166,0,0,166,0,0,166,0,0,167,0,0,167,0,0,167,0,0,168,0,0,168,0,0,168,0,0,169,0,0,169,0,0,169,0,0,170,0,0,170,0,0,170,0,0,171,0,0,171,0,0,171,0,0,172,0,0,172,0,0,172,0,0,173,0,0,173,0,0,173,0,0,174,0,0,174,0,0,174,0,0,175,0,0,175,0,0,175,0,0,176,0,0,176,0,0,177,0,0,177,0,0,178,0,0,178,0,0,179,0,0,179,0,0,180,0,0,180,0,0,181,0,0,181,0,-3,381,0,0,182,0,0,182,0,0,182,0,0,183,0,0,183,0,0,187,0,0,187,0,0,189,0,4,189,0,0,190,0,4,190,0,0,191,0,0,191,0,3,292,0,3,292,0,3,292,0,0,193,0,4,193,0,3,296,0,3,296,0,3,297,0,3,297,0,3,298,0,3,298,0,3,296,0,3,297,0,3,298,0,0,197,0,4,197,0,3,299,0,3,299,0,3,299,0,0,198,0,4,198,0,0,199,0,0,199,0,0,199,0,0,200,0,0,200,0,0,200,0,0,201,0,0,202,0,0,202,0,0,202,0,0,204,0,41,407,0,0,204,0,0,205,0,0,205,0,0,205,0,0,206,0,0,206,0,4,207,0,4,208,0,-1,210,0,1,209,0,1,210,0,0,211,0,0,212,0,0,212,0,0,213,0,0,213,0,0,214,0,0,214,0,0,215,0,0,215,0,0,216,0,0,216,0,0,217,0,0,217,0,0,218,0,0,218,0,0,219,0,0,219,0,42,221,0,0,220,0,0,221,0,0,222,0,0,222,0,0,223,0,0,223,0,0,224,0,0,224,0,0,225,0,0,225,0,0,226,0,0,226,0,0,227,0,0,227,0,0,228,0,0,228,0,0,229,0,0,229,0,4,230,0,0,231,0,0,231,0,3,371,0,3,371,0,4,232,0,0,233,0,0,233,0,4,234,0,0,235,0,0,235,0,3,373,0,3,373,0,4,236,0,0,237,0,0,237,0,0,238,0,0,238,0,0,239,0,0,239,0,0,240,0,0,240,0,0,241,0,0,241,0,0,242,0,0,242,0,0,243,0,0,243,0,0,244,0,0,244,0,0,245,0,0,245,0,0,246,0,0,246,0,0,247,0,0,247,0,0,248,0,0,248,0,0,249,0,0,249,0,0,250,0,0,250,0,0,251,0,0,251,0,0,252,0,0,252,0,0,253,0,0,253,0,0,254,0,0,254,0,0,255,0,0,255,0,0,256,0,0,256,0,0,257,0,0,257,0,0,258,0,0,258,0,0,259,0,0,259,0,0,261,0,-2,384,0,0,263,0,-2,385,0,0,264,0,0,264,0,0,266,0,0,266,0,0,267,0,0,267,0,0,268,0,0,269,0,0,270,0,0,271,0,4,272,0,4,273,0,3,387,0,3,388,0,3,388,0,3,387,0,4,275,0,0,277,0,-2,390,0,0,278,0,0,278,0,0,280,0,0,280,0,0,281,0,0,281,0,4,282,0,4,283,0,0,285,0,-2,393,0,0,286,0,0,286,0,0,288,0,0,288,0,0,289,0,0,289,0,4,290,0,3,395,0,3,395,0,4,291,0,4,293,0,3,398,0,3,398,0,3,399,0,3,399,0,3,400,0,3,400,0,0,294,0,4,294,0,4,295,0,4,300,0,0,302,0,0,302,0,0,303,0,-2,402,0,0,304,0,0,304,0,0,305,0,0,305,0,0,306,0,0,306,0,0,307,0,0,307,0,0,308,0,0,308,0,0,309,0,0,309,0,0,310,0,0,310,0,0,311,0,0,312,0,0,312,0,0,313,0,0,313,0,0,314,0,0,314,0,0,315,0,0,315,0,4,316,0,0,317,0,-1,319,0,-1,321,0,0,322,0,-1,324,0,1,326,0,-1,328,0,1,328,0,-1,330,0,-1,331,0,-1,332,0,1,332,0,1,333,0,-1,335,0,-1,336,0,-1,337,0,1,337,0,-1,339,0,-1,340,0,-1,341,0,1,341,0,-1,343,0,-1,344,0,-1,345,0,1,345,0,-1,347,0,-1,348,0,-1,349,0,1,349,0,4,364,0,4,382,0,0,406,0,0,409,0,0,410,0,43,9,1,1,9,4,1,9,5,1,210,8,1,32,11,1,30,12,1,30,13,1,30,14,1,30,23,1,40,27,1,44,38,1,148,39,1,40,85,1,126,87,1,128,96,1,325,144,1,201,145,1,201,149,1,324,195,44,294,195,45,260,195,33,269,260,27,384,262,27,385,265,33,268,276,27,390,284,27,393,301,27,402,1023],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,350,350,350,351,351,351,351,352,352,352,352,353,353,353,353,354,354,354,354,355,356,358,358,358,358,359,359,359,360,360,360,361,361,361,362,363,363,363,363,374,375,375,375,376,376,376,377,377,377,378,378,379,379,381,260,384,385,386,262,390,391,391,391,391,276,393,394,394,394,394,284,402,301,380,380,380,380,404,407,407,407,407],[7,7,5,7,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,12,20,-1,-2,-3,22,-1,12,-1,12,2,2,2,2,2,2,2,2,2,2,5,5,5,5,5,7,7,7,7,2,2,2,2,2,2,2,46,47,-1,12,2,2,2,2,6,2,6,7,7,2,7,7,7,8,8,8,8,2,2,6,9,10,13,2,6,9,10,13,2,7,5,5,5,5,5,7,5,5,5,5,5,2,7,5,7,5,2,7,5,7,5,5,2,7,5,7,5,2,2,2,2,2,2,2,2,8,2,8,2,8,2,8,2,8,2,8,2,8,2,8,2,8,2,8,2,8,2,8,2,8,2,8,2,2,2,2,2,2,6,8,8,8,8,2,6,2,6,8,2,6,2,2,2,6,9,10,13,8,6,2,6,8,2,6,2,2,2,6,9,10,13,6,2,2,6,9,10,13,2,6,9,10,13,2,2,2,2,2,2,2,2,8,2,2,2,2,6,7,7,2,6,2,2,2,2,8,2,2,-1,12,-1,12,-1,12,-1,12,7,7,5,5,7,7,5,5,5,5,5,2,2,6,2,8,2,2,2,7,7,22,5,5,5,5,7,7,5,5,5,2,2,2,2,8,2,2,7,7,5,5,5,5,7,7,5,5,7,22,5,5,7,7,22,5,5,5,5,5,7,7,5,5,5,5,5,2,2,2,2,2,8,2,6,9,10,13,2,6,9,10,13,2,2,2,-1,12,6,9,10,13,8,2,2,6,9,10,13,2,6,9,10,13,-1,12,2,2,6,9,10,13,2,6,9,10,13,7,2,6,34,2,48,49,50,34,6,9,10,13,6,9,10,13,6,9,10,13,6,9,10,13,6,9,10,13,2,8,51,52,53,54,6,9,10,6,9,10,6,9,10,2,6,9,10,13,6,6,9,10,6,9,10,6,9,10,55,56,57,58,6,6,2,2,6,6,2,6,9,10,13,6,2,6,9,10,13,6,2,6,6,9,10,13,6,6,9,10,13],[100,37,38,39,1,1,1,1,1,1,1,1,1,1,1,1,53,54,55,17,40,41,64,101,30,102,18,103,6,104,6,105,6,106,6,11,107,9,9,14,22,19,16,16,16,16,108,6,109,6,42,6,65,43,66,66,18,67,68,110,23,23,44,44,31,31,45,69,111,69,0,0,0,0,12,46,46,2,3,4,47,47,2,3,4,70,112,9,19,14,22,19,71,22,19,9,9,14,72,37,24,37,24,73,39,32,39,33,32,72,56,17,56,17,113,15,114,20,115,20,116,20,0,117,0,118,0,119,0,120,0,121,0,122,0,123,0,74,0,74,0,124,0,125,0,126,0,127,0,128,129,130,131,132,11,11,0,0,0,0,12,12,11,11,0,12,12,25,75,26,26,2,3,4,0,12,11,11,0,12,12,25,75,26,26,2,3,4,45,70,47,47,2,3,4,46,46,2,3,4,76,133,134,135,136,73,137,23,0,13,138,11,77,77,31,31,45,45,139,7,7,23,0,13,140,141,18,78,18,78,18,79,18,16,39,33,33,48,142,32,33,57,58,33,143,7,7,7,0,23,13,144,16,145,80,34,38,24,34,48,37,81,24,81,146,7,7,23,0,13,147,16,148,40,17,41,17,48,56,82,82,59,49,9,14,16,59,49,9,9,14,22,19,48,71,22,19,19,9,14,7,42,42,149,7,0,2,2,2,3,4,2,2,2,3,4,25,67,68,79,18,76,2,3,4,0,83,50,50,2,3,4,50,50,2,3,4,8,51,25,2,2,2,3,4,2,2,2,3,4,31,44,44,43,60,150,60,151,43,6,2,3,4,6,2,3,4,6,2,3,4,6,2,3,4,11,2,3,4,152,0,153,154,155,156,6,21,21,6,21,21,6,21,21,157,65,2,3,4,15,20,15,15,20,15,15,20,15,15,20,15,6,21,11,7,35,35,13,7,35,13,2,3,4,7,35,13,2,3,4,7,35,42,13,61,61,61,83,60,2,3,4]],[[[62,".bin",3429205708,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":72464,"length":28560,"count":7140,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":72464,"count":1294,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.49748557806015015,-0.5,-0.4989933371543884],"maxPosition",8,[1,0.49949654936790466,0.5,0.49899348616600037]]],-1],0,0,[],[],[]],[[[62,".bin",3219909449,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[[118,"builtin-particle-trail",[{"hash":2502358098,"name":"builtin-particle-trail|particle-trail:vs_main|tinted-fs:add","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":44,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"vBarycentric","type":15,"count":1,"stageFlags":17,"location":2,"defines":["CC_DRAW_WIRE_FRAME"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  layout(location = 2) out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\n  precision mediump float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  vec4 CCFragOutput (vec4 color) {\n    return color;\n  }\n  layout(location = 0) in vec2 uv;\n  layout(location = 1) in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    layout(location = 2) in vec3 vBarycentric;\n  #endif\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n  layout(set = 1, binding = 1) uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision mediump float;\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\n  precision mediump float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  vec4 CCFragOutput (vec4 color) {\n    return color;\n  }\n  in vec2 uv;\n  in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    in vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  layout(std140) uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision mediump float;\n   uniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\n  precision mediump float;\n  vec4 CCFragOutput (vec4 color) {\n    return color;\n  }\n  varying vec2 uv;\n  varying vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    varying vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n      uniform vec4 tintColor;\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_DRAW_WIRE_FRAME","type":"boolean","defines":[]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]}]},{"hash":2543411830,"name":"builtin-particle-trail|particle-trail:vs_main|tinted-fs:multiply","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":44,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"vBarycentric","type":15,"count":1,"stageFlags":17,"location":2,"defines":["CC_DRAW_WIRE_FRAME"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  layout(location = 2) out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\n  precision mediump float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  vec4 CCFragOutput (vec4 color) {\n    return color;\n  }\n  layout(location = 0) in vec2 uv;\n  layout(location = 1) in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    layout(location = 2) in vec3 vBarycentric;\n  #endif\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n  layout(set = 1, binding = 1) uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 multiply () {\n    vec4 col;\n    vec4 texColor = texture(mainTexture, uv);\n    col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n    col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., col.a);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision mediump float;\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\n  precision mediump float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  vec4 CCFragOutput (vec4 color) {\n    return color;\n  }\n  in vec2 uv;\n  in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    in vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  layout(std140) uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 multiply () {\n    vec4 col;\n    vec4 texColor = texture(mainTexture, uv);\n    col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n    col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., col.a);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision mediump float;\n   uniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\n  precision mediump float;\n  vec4 CCFragOutput (vec4 color) {\n    return color;\n  }\n  varying vec2 uv;\n  varying vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    varying vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n      uniform vec4 tintColor;\n  vec4 multiply () {\n    vec4 col;\n    vec4 texColor = texture2D(mainTexture, uv);\n    col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n    col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., col.a);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_DRAW_WIRE_FRAME","type":"boolean","defines":[]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]}]},{"hash":1579485357,"name":"builtin-particle-trail|particle-trail:vs_main|no-tint-fs:addSmooth","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":44,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"vBarycentric","type":15,"count":1,"stageFlags":1,"location":2,"defines":["CC_DRAW_WIRE_FRAME"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  layout(location = 2) out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision mediump float;\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision mediump float;\n   uniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_DRAW_WIRE_FRAME","type":"boolean","defines":[]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]}]},{"hash":2581776267,"name":"builtin-particle-trail|particle-trail:vs_main|no-tint-fs:premultiplied","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":44,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"vBarycentric","type":15,"count":1,"stageFlags":1,"location":2,"defines":["CC_DRAW_WIRE_FRAME"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  layout(location = 2) out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision mediump float;\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision mediump float;\n   uniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_DRAW_WIRE_FRAME","type":"boolean","defines":[]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle-trail|particle-trail:vs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"frameTile_velLenScale":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle-trail|particle-trail:vs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":4,"blendSrcAlpha":1,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"frameTile_velLenScale":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle-trail|particle-trail:vs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":4,"blendSrcAlpha":1,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"frameTile_velLenScale":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle-trail|particle-trail:vs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":4,"blendSrcAlpha":1,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"frameTile_velLenScale":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle-trail|particle-trail:vs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":4,"blendSrcAlpha":1,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"frameTile_velLenScale":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[{"base":"2,2,0,0,0,0","w":1440,"h":2048,"n":""}],[53],0,[],[],[]],[[[119],[102,"VD295_Flamingo_Rig",[[-3,-4,[68,"Bn_FoodSpawn",-6,[1,"c4MNbS8yRXIaS6qgPgPrqT",-5,0],[1,-0.020412404090166092,0,1.4832285642623901]]],1,1,4],[[110,-2,[10,"4cq3CaMM9QFplY9tFHtlLH"]]],[1,"5dXI/ybWZaFrEKPI46LgaD",-1,0]],[104,"Bip001 Head",[[4,"Bip001 Mouth",-7,[1,"15bHkaVhxULoQNZ95K+rGl",1,0],[1,0.1853790134191513,0.02393317222595215,2.3913526092655957e-7],[3,3.6327741156443087e-13,-3.631222933645755e-7,0.13092161595638818,0.9913927226257192],[1,0.000005641172556479641,-0.0000427169780191864,15.045704420963872]],[4,"Bip001 eye_L",-8,[1,"baXanNgPZQoZV6vIjIoTfA",1,0],[1,0.10343153774738312,-0.04911351203918457,0.05298836901783943],[3,-0.00024194813402205606,-0.6087613167009532,0.0003147253914729629,0.7933533271484717],[1,-0.00004099095042321951,-74.9999906904734,0.04549022969239943]],[4,"Bip001 eye_R",-9,[1,"1eYfzhDh5bIo6wE6rROPOs",1,0],[1,0.10257671773433685,-0.04911303520202637,-0.04994485154747963],[3,0.00024194823562694417,0.6087613160504972,0.00031810219219961393,0.7933533263007808],[1,-0.00019456181980478671,74.99999078450371,0.045797227167488165]],[4,"Bip001 eyelid_L_up",-10,[1,"30RfEJQ/xTabZjlnUgSgWc",1,0],[1,0.10343153774738312,-0.04911351203918457,0.05298838019371033],[3,0.14415553349210042,-0.5914464649160642,-0.18848307609929205,0.7706389500447322],[1,-0.04981721459010648,-75.02287479330846,-27.453291992450442]],[4,"Bip001 eyelid_L_down",-11,[1,"34Ruzm2H1XYYt2kEBRWij0",1,0],[1,0.10343150794506073,-0.04911351203918457,0.05298838019371033],[3,-0.14445081285955402,-0.5913755270136265,0.18763612123418558,0.7708447539691502],[1,-0.04978601366354341,-74.97715566447208,27.395237742743113]],[4,"Bip001 eyelid_R_down",-12,[1,"eeJG5qN81dm4bIT7UcnztQ",1,0],[1,0.10257671773433685,-0.04911303520202637,-0.049944858998060226],[3,0.14445078097891403,0.5913745052261379,0.18763941169109033,0.7708447428784502],[1,0.049556368854709015,74.97711667339797,27.39554335799152]],[4,"Bip001 eyelid_R_up",-13,[1,"81v2Uyj+Vez6nrS7hhhoNT",1,0],[1,0.10257671773433685,-0.04911303520202637,-0.04994484782218933],[3,-0.1441554573227101,0.5914475309742541,-0.1884798254710249,0.7706389411514001],[1,0.04960249879584121,75.02292260137546,-27.452982316206292]],[4,"Bip001 L_lips_point",-14,[1,"b51/1/kdFRobUfwsEeT3uH",1,0],[1,0.2125636488199234,0.0004966259002685547,0.06602133065462112],[3,-0.0002447514480468828,-0.6158146653236611,0.00031252725290150497,0.7878909444813742],[1,-0.000043382534688888074,-76.0222854335002,0.045488146695362]],[4,"Bip001 L_lips_pointOpp",-15,[1,"33lPB7VnpemLW23UhXTmaQ",1,0],[1,0.2125636488199234,0.0004971027374267578,-0.06602133065462112],[3,0.0002447515641994772,0.6158146646626275,0.0003159431690293676,0.7878909436356288],[1,-0.00019765856372147501,76.02228552971563,0.045796563154277055]],[4,"Bn_Mouth",-16,[1,"f1JuzE2exYNpMLArES2Q9R",1,0],[1,0.35302335023880005,0.03254532814025879,0.000400304765207693],[3,-0.17419363444136365,0.6794313743888158,0.17440272753386546,0.691095705271695],[1,-28.539391285878086,89.08818266132725,0.24939276046124864]]],[1,"783hrjEJBTA6iOjJ8o6PCH",1,0],[1,0.34503018856048584,0.05807298421859741,-3.204622771590948e-7],[3,0.000007283078974909878,-0.000002044906528056778,0.7926253695146028,0.6097089662655573],[1,179.99729216877995,-179.99686413223276,75.13692459404484]],[57,"Bip001",1,[[[4,"Bip001 Footsteps",-17,[1,"63UN7XUWBWyZZ/qkFfOZhT",1,0],[1,0,0,-1.2544288635253906],[3,-6.9210348904225676e-34,6.921044533149829e-34,0.7071063043492204,0.7071072580235531],[1,0,-1.1216009582263197e-31,90]],-18,-19],4,1,1],[1,"c3T8xhbBlaNp7/Bly9AFlQ",1,0],[1,0,1.2599310874938965,-0.03170289844274521],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[47,"Bip001 Spine",[-20,-21,-22],[1,"cfwWn+4r9UDZPd2/A7BPsK",1,0],[1,0.006523013114929199,0.007367122918367386,-2.466515525156865e-8],[3,-0.000003644542704351234,-0.0000032234625650382653,0.7079508448334461,0.706261708770861],[1,-179.98599514327807,179.9854386389328,89.8631318550418]],[6,"Bip001 Neck",4,[-23,-24,-25],[1,"45seyRJhVZ2YulhZHAVFr0",1,0],[1,0.31526342034339905,-0.00016570091247558594,8.220013114623725e-9],[3,-2.557486891979508e-7,0.0000019258948303804823,-0.1736482836955129,0.9848077343145861],[1,0.000010068460395121748,0.00022587115662259883,-20.000012337433215]],[64,"VD295_Flamingo_Toy",1,[[66,-26,[10,"ea68U0IKpXTa0akVc+P+6u"],[0,1,2,3],[29],1,4,5]],[1,"00epe3MM5V+6cyzbwFVcci",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[84,"Bip001 Pelvis",3,[4],[1,"28HoLqRkpcfoL7nQmIgrpu",1,0],[3,-0.49999999254917427,-0.49999999254917427,-0.49999930709576956,0.5000007078049009],[1,-89.99991974527727,-89.99991974527727,-0.0000017074910602964197]],[6,"Bip001 L Thigh",4,[-27],[1,"b5g+r/vqNfaail1orcNRvu",1,0],[1,-0.007351363077759743,0.006539463996887207,0.13554731011390686],[3,-0.025361888339490553,-0.04286933728992652,0.7657588789419875,0.6411960182827777],[1,169.22300015928454,-174.77584462709845,79.79416966078732]],[6,"Bip001 L Calf",8,[-28],[1,"91wcoKnUdZt649Xs1K9QTt",1,0],[1,0.6679134964942932,0,1.4901161193847656e-8],[3,7.532819370050671e-18,5.867785891590635e-18,-0.09536687107671847,0.9954421931488723],[1,9.404950962710234e-16,7.65580174507929e-16,-10.944871697898266]],[14,"Bip001 L Foot",9,[[4,"Bip001 L Toe0",-29,[1,"1exRZapZNcwIBXxb/0W5eY",1,0],[1,0.13152936100959778,0.11558839678764343,-1.4901161193847656e-8],[3,-0.008638708737303427,0.00863873947094798,0.7070540095677645,0.7070540095677645],[1,-89.99999875475658,90.0000012452424,88.60000000522456]]],[1,"4aHFl3fHlbuaL6RN8JRXeO",1,0],[1,0.4661397933959961,1.4901161193847656e-8,2.7755575615628914e-17],[3,0.9987407161553962,0.006006529921066466,-0.01697614202145063,-0.046826425165511394],[1,-174.64423896868865,1.9111731418192246,0.7785473263659639]],[6,"Bip001 R Thigh",4,[-30],[1,"98ubztsaReB4SM5j0C+9XQ",1,0],[1,-0.007351571694016457,0.006541728973388672,-0.13554713129997253],[3,0.02536777561468011,0.042863532364716884,0.7657592200826986,0.6411957660589462],[1,-169.22830858380843,174.78115939262284,79.79425420282486]],[6,"Bip001 R Calf",11,[-31],[1,"daFSmgldhVHZr6ed1FMbc2",1,0],[1,0.667913556098938,-2.7755575615628914e-17,2.9802322387695312e-8],[3,-2.779450550826024e-17,9.201456661039556e-19,-0.09536687845953706,0.995442192441572],[1,-3.2189959742186506e-15,-2.0246747923220863e-16,-10.944872547780557]],[14,"Bip001 R Foot",12,[[4,"Bip001 R Toe0",-32,[1,"d2NS0Sd+lc/qOaGqu0ryVu",1,0],[1,0.13152936100959778,0.11558838188648224,-1.4901161193847656e-8],[3,0.008638708737303427,-0.00863873947094798,0.7070540095677645,0.7070540095677645],[1,89.99999875475658,-90.0000012452424,88.60000000522456]]],[1,"9eM/tvRn9fvLFlTT7ESNOv",1,0],[1,0.4661397933959961,0,-2.9802322387695312e-8],[3,0.9987407144373609,0.006006534567346813,0.016976231399213774,0.04682642881025074],[1,174.64423862852755,-1.9111833471561586,0.7785483437149364]],[6,"Bip001 Neck1",5,[-33],[1,"afjViuGxNakYmIONA9A7ZA",1,0],[1,0.22764748334884644,0,1.8435457604937255e-9],[3,-0.0000026654889098749952,0.000004630969749150401,-0.7071069003857348,0.7071066619671517],[1,0,0.00043196104092464374,-90]],[6,"Bip001 Neck2",14,[-34],[1,"67sWnaBDZcZIOZiwUDQXR8",1,0],[1,0.3070821762084961,-0.00020182132720947266,-4.199591785436496e-10],[3,-4.569298452752026e-7,-0.0000010582180974791515,-0.08715570552516055,0.9961947013476246],[1,-0.00006369751454585079,-0.0001272988736324793,-9.999995718259875]],[6,"Bip001 Neck3",15,[2],[1,"46CRa2+nVSU7GAYxzrvj3h",1,0],[1,0.2573540210723877,-0.0001957416534423828,-1.0545591067057103e-9],[3,0.0000015830806458502071,-0.0000026928886834355856,0.1305262113000271,0.9914448588569629],[1,0.00022789927277829786,-0.0003412485708389339,15.000002204688592]],[6,"Bip001 L Clavicle",5,[-35],[1,"23P11ouaBeNaOziPbu7lTO",1,0],[1,-0.11201411485671997,-0.08999741077423096,0.10659269988536835],[3,0.5995536471749696,0.10547037466949456,0.7813563379675971,-0.1374543463995759],[1,-160.67440442491954,-104.13681493443396,-5.06761835750432]],[6,"Bip001 L UpperArm",17,[-36],[1,"98Sz/NQqJWj6c2DtnFVTQ6",1,0],[1,0.148685485124588,2.220446049250313e-16,2.7755575615628914e-17],[3,0.6768576592153223,-0.05294709722558723,0.07699565691071343,0.7301588750907755],[1,85.8751213326478,-10.468842676701874,2.336185274871858]],[6,"Bip001 L Forearm",18,[-37],[1,"62LM705PxVL7yWO1SbD16v",1,0],[1,0.20733222365379333,0,-1.1920928955078125e-7],[3,-3.4350338633823554e-18,9.825177174135079e-18,0.3300270242447469,0.9439714843511731],[1,-9.501113700203277e-16,1.52488165384648e-15,38.54083152151289]],[6,"Bip001 L Hand",19,[-38],[1,"cfy2dsSI5clai71SmRD+gt",1,0],[1,0.22722017765045166,1.4901161193847656e-8,1.1920928955078125e-7],[3,0.005361270470880891,-0.003487623196326396,-0.11797415870719775,0.9929960680388957],[1,0.5790368821413306,-0.3336672155888319,-13.55231738015595]],[6,"Bip001 L Finger0",20,[-39],[1,"a0kNa6alVRtb1xwMgM02q9",1,0],[1,0.34348487854003906,-1.1175870895385742e-8,0],[3,-0.0003921142787962037,-0.00006913842677759943,-0.1736481789614351,0.9848076722942647],[1,-0.048554295186474965,-0.016606331514334754,-19.999995140234756]],[14,"Bip001 L Finger01",21,[[4,"Bip001 L Finger02",-40,[1,"c5UNlN9WpelrcAagNMgB3X",1,0],[1,0.3262892961502075,-4.470348358154297e-8,2.220446049250313e-16],[3,-9.249915348858104e-10,-1.0840800562367162e-10,0.11640220969456343,0.993202157457495],[1,-1.0672169928760527e-7,-7.610714278330366e-16,13.369017926888654]]],[1,"d8KrAf/ApRq4ueboGh7Kiw",1,0],[1,0.23077142238616943,0,0],[3,3.916782039768282e-9,-1.4163511582992378e-9,0.11640220969456343,0.993202157457495],[1,4.776142253299043e-7,-2.193886077792847e-7,13.369017926888654]],[6,"Bip001 R Clavicle",5,[-41],[1,"badzM6Hqlb27spngOq5m5/",1,0],[1,-0.11201351881027222,-0.08999669551849365,-0.10659399628639221],[3,-0.5995562764385542,-0.10547293884070662,0.7813543200880798,-0.13745238097295803],[1,160.67429869662922,104.13649568648655,-5.067201018483602]],[6,"Bip001 R UpperArm",23,[-42],[1,"79MDogfrxY4pizj38cH188",1,0],[1,0.14868545532226562,2.220446049250313e-16,1.4901161193847656e-8],[3,-0.6768584984316969,0.052950271544657895,0.07699113494868529,0.7301583437744505],[1,-85.87517376343968,10.468755495047693,2.3355504078641744]],[6,"Bip001 R Forearm",24,[-43],[1,"b72NXmqyBRSqNZecSkl4t2",1,0],[1,0.20733219385147095,-2.7755575615628914e-17,1.1920928955078125e-7],[3,-7.695128976785288e-18,9.850361528872603e-19,0.3300270773573828,0.943971465782173],[1,-1.1118424875021456e-15,5.082939182817443e-16,38.54083796901678]],[6,"Bip001 R Hand",25,[-44],[1,"8df/WULSJXH4ndqHq46j6Q",1,0],[1,0.22722017765045166,2.7755575615628914e-17,-1.1920928955078125e-7],[3,-0.00536126909286529,0.00348761901771416,-0.1179741293222698,0.9929960715521252],[1,-0.5790367849833785,0.33366676089575653,-13.55231398635651]],[6,"Bip001 R Finger0",26,[-45],[1,"33XcvF5phc+IlA2P543Z0E",1,0],[1,0.3434847593307495,3.725290298461914e-9,1.1920928955078125e-7],[3,0.0003921099734592463,0.000069135407613098,-0.17364815005809198,0.9848076773926302],[1,0.04855371317484482,0.01660587607116881,-19.999991777283306]],[14,"Bip001 R Finger01",27,[[4,"Bip001 R Finger02",-46,[1,"ec0i50qEBURauM08B13c/7",1,0],[1,0.32628965377807617,7.450580596923828e-8,-1.1920928955078125e-7],[3,3.243936652636153e-18,2.126782492110894e-18,0.11640221704419262,0.9932021565961265],[1,3.503257335078032e-16,2.0432157548678967e-16,13.369018774858489]]],[1,"d0xrCNmzhYj5mJfGfYioBX",1,0],[1,0.23077142238616943,-2.9802322387695312e-8,1.1920928955078125e-7],[3,-3.6999665836324554e-9,-4.336320502502623e-10,0.11640220969456343,0.993202157457495],[1,-4.268868487206369e-7,-2.0263625574909182e-16,13.369017926888654]],[6,"Bip001 Tail",3,[-47],[1,"74qcjuzehSf5BUatpViYMH",1,0],[1,-0.13302025198936462,1.881728195485266e-7,0.055188775062561035],[3,0.00028152588657601635,0.7071057416663604,0.7071077086195986,-0.00028152510077260974],[1,-90.00015937922115,-179.9543768396282,2.176542928445588e-10]],[171,"Bip001 Tail02",29,[[68,"Bip001 Tail03",-48,[1,"e1NdgXAPpT3pWeZaVw/WW/",1,0],[1,0.19411420822143555,-0.00015807151794433594,-4.388311936054379e-10]]],[1,"11e4xaYaxdEodwfLk3pWmV",1,0],[1,0.16504977643489838,-0.00015473365783691406,-4.2882675188593566e-10]]],0,[0,4,1,0,0,1,0,-1,6,0,-2,3,0,4,1,0,1,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,3,0,-2,7,0,-3,29,0,-1,8,0,-2,11,0,-3,5,0,-1,14,0,-2,17,0,-3,23,0,0,6,0,-1,9,0,-1,10,0,1,10,0,-1,12,0,-1,13,0,1,13,0,-1,15,0,-1,16,0,-1,18,0,-1,19,0,-1,20,0,-1,21,0,-1,22,0,1,22,0,-1,24,0,-1,25,0,-1,26,0,-1,27,0,-1,28,0,1,28,0,-1,30,0,1,30,0,18,1,2,1,16,4,1,7,48],[0,0,0,0,0,0],[-1,-2,-3,-4,12,20],[27,27,27,84,85,86]],[[[120,"Skin-0",1239566898,["Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head","Bip001/Bip001 Pelvis/Bip001 Spine","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 Mouth","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle","Bip001/Bip001 Pelvis","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 L_lips_point","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eyelid_L_up","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eyelid_L_down","Bip001/Bip001 Tail","Bip001/Bip001 Tail/Bip001 Tail02","Bip001/Bip001 Tail/Bip001 Tail02/Bip001 Tail03","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot/Bip001 L Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eye_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0/Bip001 L Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0/Bip001 L Finger01/Bip001 L Finger02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 L_lips_pointOpp","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eyelid_R_up","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eyelid_R_down","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot/Bip001 R Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Neck3/Bip001 Head/Bip001 eye_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0/Bip001 R Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0/Bip001 R Finger01/Bip001 R Finger02"],[[[7,0.0000030424041597143514,-0.000004132580670557218,1,0,-1,-1.2573040698848903e-11,0.0000030424041597143514,0,6.123234262925839e-17,-1,-0.000004132580670557218,0,-0.2398141473531723,2.2034265995025635,0.0000015171889344856027,1],[7,0.000001930401822392014,-0.00000832868227007566,1,0,-0.9999971389770508,0.0023888333234936,0.0000019502922441461124,0,-0.0023888335563242435,-0.999997079372406,-0.000008324048394570127,0,0.027361053973436356,1.2663922309875488,0.000010507958904781844,1],[7,0.000002283533603986143,-0.000004794641426997259,1,0,-0.96571946144104,0.25958818197250366,0.0000034498850709496764,0,-0.25958818197250366,-0.96571946144104,-0.000004037500275444472,0,0.15515349805355072,2.2151544094085693,0.0000013020177220823825,1],[7,0.000005444416274258401,-0.000008405558219237719,1,0,0.3397749066352844,-0.9405069351196289,-0.000009755360224517062,0,0.9405068755149841,0.3397749364376068,-0.0000022645131139142904,0,-1.0917065143585205,-0.9313760995864868,-0.000002709541149670258,1],[7,0.00000900934355740901,-0.000008058368621277623,1,0,0.4979301691055298,-0.8672171831130981,-0.000011474379789433442,0,0.8672171831130981,0.4979301691055298,-0.000003800553031396703,0,-1.215841293334961,-1.1599246263504028,-8.908377253646904e-7,1],[7,9.581116273693624e-7,-0.000008338747647940181,1,0,-0.9405069947242737,-0.33977460861206055,-0.0000019321842046338134,0,0.33977463841438293,-0.9405069351196289,-0.000008168191925506108,0,-0.7037283778190613,1.09170663356781,0.000009172928002953995,1],[7,0.000012369667274469975,-0.000007679476766497828,1,0,0.2565113306045532,-0.9665413498878479,-0.000010595489584375173,0,0.9665412902832031,0.2565113604068756,-0.000009985920769395307,0,-1.7231574058532715,-0.7389211654663086,0.000010823569937201682,1],[7,0.9960461258888245,0.07587630301713943,0.04620738327503204,0,0.07887280732393265,-0.9946370124816895,-0.06690642982721329,0,0.04088296368718147,0.07028640061616898,-0.996688723564148,0,-0.29369306564331055,-0.22712749242782593,1.2888065576553345,1],[7,0.9659253358840942,0.0000055422333389287814,0.2588210105895996,0,0.25882068276405334,-0.0015925184125080705,-0.965924084186554,0,0.00040682387771084905,0.9999986886978149,-0.0015396883245557547,0,-0.06337890774011612,-1.3126951456069946,-0.17528468370437622,1],[7,0.0000013868000223737909,0.0000027577070795814507,1,0,6.123234262925839e-17,-1,0.0000027577070795814507,0,1,-3.8243271396898315e-12,-0.0000013868001360606286,0,-1.2599310874938965,0.03170290216803551,0.0000016598452248217654,1],[7,0.9703902006149292,-0.0007747258641757071,0.24154186248779297,0,-0.241541787981987,0.0001896858011605218,0.9703904986381531,0,-0.0007976036868058145,-0.9999996423721313,-0.0000030594369491154794,0,-0.17158611118793488,2.203066110610962,0.42304059863090515,1],[7,0.8572441935539246,0.4451356828212738,0.2588178515434265,0,-0.22932744026184082,-0.11998414993286133,0.965925931930542,0,0.46102210879325867,-0.887388288974762,-0.0007738911081105471,0,-1.1626179218292236,1.9341028928756714,0.3195762634277344,1],[7,0.8575078248977661,-0.44462910294532776,0.2588152289390564,0,-0.23013357818126678,0.1184248998761177,0.9659265875816345,0,-0.4601292610168457,-0.8878515958786011,-0.0007738028652966022,0,0.9120217561721802,2.064134120941162,0.3195764422416687,1],[7,-0.0000013709064887734712,-0.000002772508651105454,1,0,0.9999997019767761,-0.0007962742820382118,0.0000013686983493244043,0,0.0007962743402458727,0.9999996423721313,0.000002773599590000231,0,-0.16577030718326569,-1.3149882555007935,-0.000003878886673192028,1],[7,-0.0000013709064887734712,-0.000002772508651105454,1,0,0.9999997019767761,-0.0007962742820382118,0.0000013686983493244043,0,0.0007962743402458727,0.9999996423721313,0.000002773599590000231,0,-0.33082008361816406,-1.314833641052246,-0.000003878457846440142,1],[7,-0.0000013709064887734712,-0.000002772508651105454,1,0,0.9999997019767761,-0.0007962742820382118,0.0000013686983493244043,0,0.0007962743402458727,0.9999996423721313,0.000002773599590000231,0,-0.5249342322349548,-1.3146754503250122,-0.000003878019015246537,1],[7,0.016124535351991653,-0.0981796458363533,0.9950380325317383,0,0.17879940569400787,0.9794098138809204,0.09374018013477325,0,-0.9837534427642822,0.17640069127082825,0.033346988260746,0,1.231607437133789,-0.23999500274658203,-0.179861381649971,1],[7,0.03447207435965538,-0.09333253651857376,0.9950380325317383,0,-0.010407977737486362,0.9955422878265381,0.09374039620161057,0,-0.9993515014648438,-0.013587758876383305,0.033347003161907196,0,0.5990071296691895,-0.12860408425331116,-0.1798614263534546,1],[7,4.371138828673793e-8,0.000001370906943520822,-1,0,-6.123234262925839e-17,-1,-0.000001370906943520822,0,-1,5.998547741425247e-14,-4.371139183945161e-8,0,0.13703155517578125,0.14627376198768616,0.16238602995872498,1],[7,0.024433551356196404,-4.3711402497592644e-8,-0.9997015595436096,0,-0.9997015595436096,-4.371144868287047e-8,-0.024433551356196404,0,-4.263037922669355e-8,1,-4.476638082451245e-8,0,0.026708750054240227,-0.005502187181264162,0.16308726370334625,1],[7,0.9659262895584106,-0.000771219318266958,0.25881654024124146,0,-0.2588164508342743,0.00020345357188489288,0.9659265875816345,0,-0.0007975983899086714,-0.9999996423721313,-0.000003083108140344848,0,-0.13823232054710388,2.252650022506714,0.3178403079509735,1],[7,0.8263481855392456,-0.5612609386444092,0.04620740935206413,0,-0.5580392479896545,-0.8271130323410034,-0.0669063925743103,0,0.07577069848775864,0.029502427205443382,-0.996688723564148,0,-0.5334008932113647,0.13452394306659698,1.2888065576553345,1],[7,0.9351096749305725,-0.35149654746055603,0.04494882747530937,0,-0.34905096888542175,-0.9355349540710449,-0.05420380085706711,0,0.06110365316271782,0.03499706834554672,-0.9975176453590393,0,-0.7636570930480957,-0.03262715041637421,1.293609857559204,1],[7,0.9989467859268188,-0.010505893267691135,0.04466891288757324,0,-0.008043651469051838,-0.9984568953514099,-0.05494876950979233,0,0.04517727345228195,0.05453159660100937,-0.9974894523620605,0,-1.02886164188385,-0.4102923274040222,1.293583631515503,1],[7,0.9694471955299377,-0.24119950830936432,0.04466891288757324,0,-0.23869074881076813,-0.9695398807525635,-0.05494876578450203,0,0.0565619133412838,0.0426078699529171,-0.9974894523620605,0,-1.3203669786453247,-0.1079191043972969,1.2935835123062134,1],[7,0.8874055743217468,-0.458820641040802,0.044668909162282944,0,-0.4564013183116913,-0.8880758881568909,-0.05494876950979233,0,0.06488101929426193,0.028374895453453064,-0.9974894523620605,0,-1.6269869804382324,0.27574828267097473,1.2935835123062134,1],[7,-0.01612519659101963,0.0981769934296608,0.9950383305549622,0,0.17879937589168549,0.9794101119041443,-0.09373744577169418,0,-0.9837534427642822,0.17640069127082825,-0.03334716334939003,0,1.231607437133789,-0.23999500274658203,0.17986151576042175,1],[7,-0.9960463643074036,-0.07587357610464096,0.04620720073580742,0,0.07887007296085358,-0.9946371912956238,0.06690655648708344,0,0.040882959961891174,0.07028639316558838,0.996688723564148,0,-0.2936924397945404,-0.22712792456150055,-1.2888092994689941,1],[7,-0.9659263491630554,0.000005564841558225453,0.25881728529930115,0,0.2588169574737549,-0.0015925185289233923,0.9659250974655151,0,0.000417546572862193,0.9999986886978149,0.0015368153108283877,0,-0.06339242309331894,-1.3126952648162842,0.17528831958770752,1],[7,-0.8263466358184814,0.5612632036209106,0.04620722681283951,0,-0.558041512966156,-0.827111542224884,0.06690651923418045,0,0.07577069848775864,0.029502427205443382,0.996688723564148,0,-0.5334007143974304,0.13452324271202087,-1.2888092994689941,1],[7,-0.9703888297080994,0.0007706669275648892,0.24154716730117798,0,-0.24154707789421082,0.0001950729638338089,-0.970389187335968,0,-0.0007949661812745035,-0.9999996423721313,-0.000003144270976918051,0,-0.17157705128192902,2.203068494796753,-0.4230306148529053,1],[7,-0.857241690158844,-0.4451388716697693,0.25882065296173096,0,-0.2293321192264557,-0.11998122185468674,-0.9659251570701599,0,0.4610244333744049,-0.8873870968818665,0.000768264988437295,0,-1.1598045825958252,1.9355660676956177,-0.31953006982803345,1],[7,-0.8575078248977661,0.4446246027946472,0.2588229775428772,0,-0.23013824224472046,0.11843268573284149,-0.9659245610237122,0,-0.4601269066333771,-0.8878527879714966,0.0007681744173169136,0,0.9148365259170532,2.0626771450042725,-0.31952956318855286,1],[7,-0.03447222337126732,0.09332985430955887,0.9950382709503174,0,-0.010408071801066399,0.9955425262451172,-0.09373772144317627,0,-0.9993515014648438,-0.013587778434157372,-0.03334718197584152,0,0.5990070700645447,-0.12860406935214996,0.17986156046390533,1],[7,4.371138828673793e-8,0.000001370906943520822,-1,0,-6.123234262925839e-17,-1,-0.000001370906943520822,0,-1,5.998547741425247e-14,-4.371139183945161e-8,0,0.13703155517578125,0.14627376198768616,-0.16238611936569214,1],[7,-0.024430807679891586,4.3711395392165286e-8,-0.9997015595436096,0,-0.9997015595436096,-4.371132789060539e-8,0.024430807679891586,0,-4.263037922669355e-8,1,4.4766252926820016e-8,0,0.026708759367465973,-0.005502187181264162,-0.16308735311031342,1],[7,-0.9659249186515808,0.0007670645136386156,0.2588218152523041,0,-0.2588217258453369,0.0002088159235427156,-0.9659252166748047,0,-0.0007949730497784913,-0.9999996423721313,-0.000003167551994920359,0,-0.13506197929382324,2.2526490688323975,-0.3177923560142517,1],[7,-0.9351087212562561,0.35149917006492615,0.044948678463697433,0,-0.34905359148979187,-0.9355340003967285,0.054203931242227554,0,0.06110365688800812,0.03499707207083702,0.9975176453590393,0,-0.7636567950248718,-0.03262774273753166,-1.2936127185821533,1],[7,-0.9989467859268188,0.010508663952350616,0.044668760150671005,0,-0.008046424016356468,-0.9984568953514099,0.054948896169662476,0,0.04517727717757225,0.05453159660100937,0.9974894523620605,0,-1.0288610458374023,-0.41029274463653564,-1.2935863733291626,1],[7,-0.9694465398788452,0.2412022203207016,0.044668760150671005,0,-0.2386934608221054,-0.969539225101471,0.054948896169662476,0,0.056561920791864395,0.0426078736782074,0.9974894523620605,0,-1.3203665018081665,-0.10791964828968048,-1.2935863733291626,1],[7,-0.8874043226242065,0.45882314443588257,0.044668760150671005,0,-0.45640379190444946,-0.8880746364593506,0.054948896169662476,0,0.06488101929426193,0.028374899178743362,0.9974894523620605,0,-1.6269866228103638,0.2757476270198822,-1.2935863733291626,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[62,".bin",2022797851,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":137984,"length":13896,"count":6948,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":290040,"length":14184,"count":7092,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":431032,"length":12276,"count":6138,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[3],"indexView":{"offset":462844,"length":4800,"count":1200,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":137984,"count":1568,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":151880,"length":138160,"count":1570,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":304224,"length":126808,"count":1441,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":443308,"length":19536,"count":222,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,26,28,36],[0,1,2,3,4,5,6,7,8,9,13,14,15,16,19,21,22,23,24,25,26,27,28,30,31,32,33,34],[0,1,2,9,13,14,15,27,28,29,30,31,32,33,34,35,37,38,39,40]]},"minPosition",8,[1,-2.100203037261963,-0.7660994529724121,-1.1920928955078125e-7],"maxPosition",8,[1,2.100203037261963,0.7660994529724121,2.3443918228149414]]],-1],0,0,[],[],[]],[[[50,"VD295_Flamingo_Eye",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[158,10]],[[[50,"VD295_Flamingo_Toy",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[159,10]],[[[118,"builtin-standard",[{"hash":4079105024,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":["HAS_SECOND_UV"]},{"name":"v_shadowBias","type":14,"count":1,"stageFlags":17,"location":7,"defines":["CC_RECEIVE_SHADOW"]},{"name":"v_tangent","type":16,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out lowp vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out mediump vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) in mediump vec2 v_uv1;\n#endif\nlayout(location = 4) in mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 2) in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) in mediump vec4 v_tangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nout vec3 v_position;\nout mediump vec3 v_normal;\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":223,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":3928335406,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":["HAS_SECOND_UV"]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) out vec2 v_uv1;\n#endif\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) in vec2 v_uv1;\n#endif\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out vec2 v_uv1;\n#endif\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in vec2 v_uv1;\n#endif\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":184,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[50,"Food_AssetsA",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":0.5,"metallic":0,"roughness":0.5,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[160,10]],[[[62,".bin",1642054354,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":9744,"length":3420,"count":855,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":9744,"count":203,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.4428846836090088,-1.2968734502792358,-1.911558747291565],"maxPosition",8,[1,1.4428846836090088,1.2968732118606567,1.911558747291565]]],-1],0,0,[],[],[]],[[[121,[[122,[123,[-14,-15,-16,-17,-18,-19],[[124,-5,-4],[72,0,-7,-6,[[125,1,[74,"velocity"],[75]]]],[72,0,-9,-8,[[126,[74,"velocity"],[75]]]],[73,false,-11,-10,[[127,[76,"EatFood"]]]],[73,false,-13,-12,[[128,1,[76,"EatFood"]]]]],-3,-2,-1]]],[{},"velocity",4,[129],"EatFood",4,[130,1,false]]],[51,"Idle",[52,0]],[53,"Entry"],[51,"Run",[52,1]],[51,"Eat",[52,2]],[53,"Exit"],[53,"Any"]],0,[0,28,6,0,29,5,0,30,2,0,16,1,0,17,2,0,16,3,0,17,1,0,16,1,0,17,3,0,16,4,0,17,1,0,16,1,0,17,4,0,-1,2,0,-2,5,0,-3,6,0,-4,1,0,-5,3,0,-6,4,19],[0,0,0],[19,19,19],[17,40,41]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[87,28]],[[{"name":"UI_Customization_Panel","rect":{"x":0,"y":9,"width":2732,"height":423},"offset":{"x":0,"y":-4.5},"originalSize":{"width":2732,"height":432},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[7],0,[0],[23],[161]],[[[118,"dcc/imported-metallic-roughness",[{"hash":1794525484,"name":"dcc/imported-metallic-roughness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"baseWeightMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_WEIGHT_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_NORMAL_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"roughnessMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_OCCLUSION_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"transparencyColorMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_TRANSPARENCYCOLOR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"alphaSourceMap","type":28,"count":1,"stageFlags":16,"binding":11,"defines":["USE_OPACITY_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":12,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":13,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":14,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_shadowBias","type":14,"count":1,"stageFlags":17,"location":7,"defines":["CC_RECEIVE_SHADOW"]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":9,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":10,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) out vec3 v_tangent;\n  layout(location = 9) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 10) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 10) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  layout(set = 1, binding = 2) uniform sampler2D baseWeightMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) in vec3 v_tangent;\n  layout(location = 9) in vec3 v_bitangent;\n  layout(set = 1, binding = 3) uniform sampler2D normalMap;\n#endif\n#if USE_METALLIC_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  layout(set = 1, binding = 5) uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 6) uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  layout(set = 1, binding = 7) uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  layout(set = 1, binding = 8) uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 9) uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  layout(set = 1, binding = 10) uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  layout(set = 1, binding = 11) uniform sampler2D alphaSourceMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor = texColor;\n  #endif\n  #if USE_WEIGHT_MAP\n      vec4 weightColor = texture(baseWeightMap, TEXTURE_UV);\n      weightColor.rgb = SRGBToLinear(weightColor.rgb);\n      baseColor.rgb *= weightColor.rgb;\n  #else\n      baseColor.rgb *= albedoScale;\n  #endif\n  float metallicValue = metallic;\n  #if USE_METALLIC_MAP\n     vec4 metallicColor = texture(metallicMap, TEXTURE_UV);\n     metallicValue = discolor(metallicColor.rgb);\n     #if USE_METALLIC_CHANNEL\n         metallicColor.rgb = SRGBToLinear(metallicColor.rgb);\n         metallicValue = metallicColor.METALLIC_CHANNEL;\n     #endif\n  #endif\n  s.metallic = metallicValue;\n  float roughnessValue = roughness;\n  #if USE_ROUGHNESS_MAP\n     vec4 roughnessColor = texture(roughnessMap, TEXTURE_UV);\n     roughnessValue = discolor(roughnessColor.rgb);\n     #if USE_ROUGHNESS_CHANNEL\n         roughnessColor.rgb = SRGBToLinear(roughnessColor.rgb);\n         roughnessValue = roughnessColor.ROUGHNESS_CHANNEL;\n     #endif\n  #endif\n  s.roughness = max(0.02, roughnessValue);\n  float occlusionValue = occlusion;\n  #if USE_OCCLUSION_MAP\n     vec4 occlusionColor = texture(occlusionMap, TEXTURE_UV);\n     occlusionValue = discolor(occlusionColor.rgb);\n     #if USE_OCCLUSION_CHANNEL\n         occlusionColor.rgb = SRGBToLinear(occlusionColor.rgb);\n         occlusionValue = occlusionColor.OCCLUSION_CHANNEL;\n     #endif\n  #endif\n  s.occlusion = occlusionValue;\n  #if ALPHA_SOURCE_IS_OPACITY\n    #if USE_OPACITY_MAP\n      baseColor.a = 1.0 - texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = 1.0 - alphaSource;\n    #endif\n  #else\n    #if USE_OPACITY_MAP\n      baseColor.a = texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = alphaSource;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.albedo = baseColor;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalStrength) * normalize(v_tangent) +\n      (nmmp.y * normalStrength) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specularIntensity = 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 12) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 13) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 14) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if CC_RECEIVE_SHADOW\n  out vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor = texColor;\n  #endif\n  #if USE_WEIGHT_MAP\n      vec4 weightColor = texture(baseWeightMap, TEXTURE_UV);\n      weightColor.rgb = SRGBToLinear(weightColor.rgb);\n      baseColor.rgb *= weightColor.rgb;\n  #else\n      baseColor.rgb *= albedoScale;\n  #endif\n  float metallicValue = metallic;\n  #if USE_METALLIC_MAP\n     vec4 metallicColor = texture(metallicMap, TEXTURE_UV);\n     metallicValue = discolor(metallicColor.rgb);\n     #if USE_METALLIC_CHANNEL\n         metallicColor.rgb = SRGBToLinear(metallicColor.rgb);\n         metallicValue = metallicColor.METALLIC_CHANNEL;\n     #endif\n  #endif\n  s.metallic = metallicValue;\n  float roughnessValue = roughness;\n  #if USE_ROUGHNESS_MAP\n     vec4 roughnessColor = texture(roughnessMap, TEXTURE_UV);\n     roughnessValue = discolor(roughnessColor.rgb);\n     #if USE_ROUGHNESS_CHANNEL\n         roughnessColor.rgb = SRGBToLinear(roughnessColor.rgb);\n         roughnessValue = roughnessColor.ROUGHNESS_CHANNEL;\n     #endif\n  #endif\n  s.roughness = max(0.02, roughnessValue);\n  float occlusionValue = occlusion;\n  #if USE_OCCLUSION_MAP\n     vec4 occlusionColor = texture(occlusionMap, TEXTURE_UV);\n     occlusionValue = discolor(occlusionColor.rgb);\n     #if USE_OCCLUSION_CHANNEL\n         occlusionColor.rgb = SRGBToLinear(occlusionColor.rgb);\n         occlusionValue = occlusionColor.OCCLUSION_CHANNEL;\n     #endif\n  #endif\n  s.occlusion = occlusionValue;\n  #if ALPHA_SOURCE_IS_OPACITY\n    #if USE_OPACITY_MAP\n      baseColor.a = 1.0 - texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = 1.0 - alphaSource;\n    #endif\n  #else\n    #if USE_OPACITY_MAP\n      baseColor.a = texture(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = alphaSource;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.albedo = baseColor;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalStrength) * normalize(v_tangent) +\n      (nmmp.y * normalStrength) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specularIntensity = 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if CC_RECEIVE_SHADOW\n  varying vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 emissive;\n     uniform float emissiveScale;\n     uniform float occlusion;\n     uniform float roughness;\n     uniform float metallic;\n     uniform float normalStrength;\n     uniform float alphaSource;\n     uniform float albedoScale;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_WEIGHT_MAP\n  uniform sampler2D baseWeightMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ROUGHNESS_MAP\n  uniform sampler2D roughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_TRANSPARENCYCOLOR_MAP\n  uniform sampler2D transparencyColorMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_OPACITY_MAP\n  uniform sampler2D alphaSourceMap;\n#endif\nfloat discolor(vec3 srcColor) {\n  return dot(GRAY_VECTOR, srcColor);\n}\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor = texColor;\n  #endif\n  #if USE_WEIGHT_MAP\n      vec4 weightColor = texture2D(baseWeightMap, TEXTURE_UV);\n      weightColor.rgb = SRGBToLinear(weightColor.rgb);\n      baseColor.rgb *= weightColor.rgb;\n  #else\n      baseColor.rgb *= albedoScale;\n  #endif\n  float metallicValue = metallic;\n  #if USE_METALLIC_MAP\n     vec4 metallicColor = texture2D(metallicMap, TEXTURE_UV);\n     metallicValue = discolor(metallicColor.rgb);\n     #if USE_METALLIC_CHANNEL\n         metallicColor.rgb = SRGBToLinear(metallicColor.rgb);\n         metallicValue = metallicColor.METALLIC_CHANNEL;\n     #endif\n  #endif\n  s.metallic = metallicValue;\n  float roughnessValue = roughness;\n  #if USE_ROUGHNESS_MAP\n     vec4 roughnessColor = texture2D(roughnessMap, TEXTURE_UV);\n     roughnessValue = discolor(roughnessColor.rgb);\n     #if USE_ROUGHNESS_CHANNEL\n         roughnessColor.rgb = SRGBToLinear(roughnessColor.rgb);\n         roughnessValue = roughnessColor.ROUGHNESS_CHANNEL;\n     #endif\n  #endif\n  s.roughness = max(0.02, roughnessValue);\n  float occlusionValue = occlusion;\n  #if USE_OCCLUSION_MAP\n     vec4 occlusionColor = texture2D(occlusionMap, TEXTURE_UV);\n     occlusionValue = discolor(occlusionColor.rgb);\n     #if USE_OCCLUSION_CHANNEL\n         occlusionColor.rgb = SRGBToLinear(occlusionColor.rgb);\n         occlusionValue = occlusionColor.OCCLUSION_CHANNEL;\n     #endif\n  #endif\n  s.occlusion = occlusionValue;\n  #if ALPHA_SOURCE_IS_OPACITY\n    #if USE_OPACITY_MAP\n      baseColor.a = 1.0 - texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = 1.0 - alphaSource;\n    #endif\n  #else\n    #if USE_OPACITY_MAP\n      baseColor.a = texture2D(alphaSourceMap, TEXTURE_UV).ALPHA_SOURCE_CHANNEL;\n    #else\n      baseColor.a = alphaSource;\n    #endif\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.albedo = baseColor;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * normalStrength) * normalize(v_tangent) +\n      (nmmp.y * normalStrength) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specularIntensity = 0.5;\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  s.emissive = emissiveColor.rgb;\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":228,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":80}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"TEXTURE_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"USE_WEIGHT_MAP","type":"boolean","defines":[]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_METALLIC_MAP","type":"boolean","defines":[]},{"name":"METALLIC_CHANNEL","type":"string","defines":["USE_METALLIC_MAP"],"options":["r","g","b","a"]},{"name":"USE_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"ROUGHNESS_CHANNEL","type":"string","defines":["USE_ROUGHNESS_MAP"],"options":["r","g","b","a"]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"OCCLUSION_CHANNEL","type":"string","defines":["USE_OCCLUSION_MAP"],"options":["r","g","b","a"]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean","defines":[]},{"name":"USE_TRANSPARENCYCOLOR_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean","defines":[]},{"name":"USE_OPACITY_MAP","type":"boolean","defines":[]},{"name":"ALPHA_SOURCE_CHANNEL","type":"string","defines":["USE_OPACITY_MAP"],"options":["r","g","b","a"]},{"name":"USE_METALLIC_CHANNEL","type":"boolean","defines":["USE_METALLIC_MAP"]},{"name":"USE_ROUGHNESS_CHANNEL","type":"boolean","defines":["USE_ROUGHNESS_MAP"]},{"name":"USE_OCCLUSION_CHANNEL","type":"boolean","defines":["USE_OCCLUSION_MAP"]},{"name":"ALPHA_SOURCE_IS_OPACITY","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":2529058441,"name":"dcc/imported-metallic-roughness|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"occlusion","type":13,"count":1},{"name":"roughness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalStrength","type":13,"count":1},{"name":"alphaSource","type":13,"count":1},{"name":"albedoScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 emissive;\n  float emissiveScale;\n  float occlusion;\n  float roughness;\n  float metallic;\n  float normalStrength;\n  float alphaSource;\n  float albedoScale;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":189,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":80}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"dcc/imported-metallic-roughness|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["albedo",0,16]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["albedoMap",0,28]},"baseWeightMap":{"value":"grey","type":28},"albedoScale":{"type":13,"value":[1],"editor":{"displayName":"BaseWeight"}},"roughness":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"roughnessMap":{"value":"grey","type":28},"metallic":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"metallicMap":{"value":"grey","type":28},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"occlusionMap":{"value":"white","type":28},"emissiveScale":{"type":13,"value":[1],"editor":{"displayName":"Emissive"}},"emissiveScaleMap":{"value":"grey","type":28,"editor":{"displayName":"EmissiveMap"}},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"displayName":"EmissiveColor","type":"color"}},"emissiveMap":{"value":"grey","type":28,"editor":{"displayName":"EmissiveColorMap"}},"alphaSource":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"alphaSourceMap":{"value":"grey","type":28,"editor":{"parent":"USE_OPACITY_MAP"}},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]}},"normalMap":{"value":"normal","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0,0,0,0.5]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-metallic-roughness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["albedo",0,16]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["albedoMap",0,28]},"baseWeightMap":{"value":"grey","type":28},"albedoScale":{"type":13,"value":[1],"editor":{"displayName":"BaseWeight"}},"roughness":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"roughnessMap":{"value":"grey","type":28},"metallic":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"metallicMap":{"value":"grey","type":28},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"occlusionMap":{"value":"white","type":28},"emissiveScale":{"type":13,"value":[1],"editor":{"displayName":"Emissive"}},"emissiveScaleMap":{"value":"grey","type":28,"editor":{"displayName":"EmissiveMap"}},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"displayName":"EmissiveColor","type":"color"}},"emissiveMap":{"value":"grey","type":28,"editor":{"displayName":"EmissiveColorMap"}},"alphaSource":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"alphaSourceMap":{"value":"grey","type":28,"editor":{"parent":"USE_OPACITY_MAP"}},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]}},"normalMap":{"value":"normal","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0,0,0,0.5]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-metallic-roughness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-metallic-roughness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[40,"PopupParent"],[223,"PopupParent",false,33554432,[-4,-5],[[37,-2,[10,"26PTf7m8tAjYy2SKJJBheG"],[5,900,600]],[251,0,-3,[10,"ecJ+16YhdJAre3lU8WrmIN"],[4,3707764735],6]],[1,"77tpR1SF1JW791bN0FX0Ek",-1,0]],[85,"Button",33554432,1,[[37,-6,[10,"6d/P08r05H0Zmnsn/i1sIF"],[5,128,128]],[144,1,0,-7,[10,"a5P1uA3plAe5hdwzK6hEKV"],1],[146,1,-9,[10,"1fl0mehsNNV6DH+oH2kX8r"],[[111],[111]],-8,2,3,4,5]],[1,"30Y3Yt9ihPkqmbHvZiSjrv",1,0],[1,0,-111.871,0]],[85,"Label",33554432,1,[[37,-10,[10,"a8LSc/GQBPDLSpj8GmrdvT"],[5,720,126]],[116,"建议家长陪同孩子共同体验",60,60,100,false,-11,[10,"8bAhzrqaVPDZg/Vpl7w190"],[4,4278190080],0]],[1,"2aVbDeqWBCIYk9fG8R5X3S",1,0],[1,0,67.866,0]]],0,[0,4,1,0,0,1,0,0,1,0,-1,3,0,-2,2,0,0,2,0,0,2,0,11,2,0,0,2,0,0,3,0,0,3,0,18,1,11],[0,0,0,0,0,0,0],[8,2,6,9,10,13,2],[0,26,26,2,3,4,25]],[[[40,"VD302_Kangaroo_Rig"],[141,"VD302_Kangaroo_Rig",[[-4,-5,[68,"Bn_FoodSpawn",-7,[1,"f3CmudYmJTjK7M6nViAmg5",-6,0],[1,-5.4358654466568623e-8,0.009165484458208084,0.8870136737823486]]],1,1,4],[[145,false,-2,[10,"08p3MFuydXL4oM9CbjboO3"],[7,8]],[80,-3,[10,"71SN8zFoFC/5gBHzxRLc1H"],9]],[1,"8fJHyWPHhT77T0qzBIqM/Z",-1,0],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[48,"Bip001 Head",[[[4,"Bip001 Xtra_Eyelid_up_L",-8,[1,"2d7+KWFQJVFrgz3wx2r7Yn",1,0],[1,0.3271970748901367,0.4205749034881592,-0.18183529376983643],[3,-0.24522146530069025,-0.4163162103317173,0.8753637652717497,0.016897467860142394],[1,132.17461490430898,154.7176502037449,13.518670197215748]],[4,"Bip001 Xtra_Eyelid_up_R",-9,[1,"a5xYRu1R9c+4gSl9Nkoyrr",1,0],[1,0.3271970748901367,0.4205739498138428,0.18183764815330505],[3,0.24522088155166882,0.4163115567490713,0.8753661401629665,0.016897562675627805],[1,-132.17519821674765,-154.71765267277706,13.518521573560058]],[4,"Bip001 Xtra_Eyelid_Low_L",-10,[1,"bbzAt+/A5Za6JtvBJFLV6Q",1,0],[1,0.21905755996704102,0.41451358795166016,-0.20157299935817719],[3,0.4409942824246951,-0.040964274662843414,0.025457053795126677,0.8962130937908391],[1,52.42644045172507,-5.502120724866701,0.5443105331507334]],[4,"Bip001 Xtra_Eyelid_Low_R",-11,[1,"8bMDwNbY5Up6fKdikNpIQL",1,0],[1,0.21905755996704102,0.41451263427734375,0.20157529413700104],[3,-0.4409942824517709,0.040964133104330384,0.025457279176747588,0.896213093845864],[1,-52.426441892868866,5.502117589864751,0.5443408344453377]],[4,"Bip001 Xtra_Eye_R",-12,[1,"c2tjMLgltSz7/DvasIQO6O",1,0],[1,0.2641632556915283,0.35110998153686523,-0.14128649234771729],[3,-0.27964436716809643,0.1581443084705726,0.682003014140958,0.6570093563353323],[1,-98.45224704751105,88.08277038553146,53.873413080213766]],[4,"Bip001 Xtra_Eye_L",-13,[1,"6bI877qbhcC6ioHfi85K1R",1,0],[1,0.2641632556915283,0.35110926628112793,0.1412884145975113],[3,0.27964439645134875,-0.15814812287424745,0.6820021188053784,0.657009355115806],[1,98.4519445966391,-88.08278231192374,53.87309036235816]],[4,"Bip001 Xtra_Mouth_Cor_R",-14,[1,"ed/f9Db/pZuZRZD4YWAqds",1,0],[1,-0.03132891654968262,0.5618903636932373,-0.11657057702541351],[3,0.04929766191040832,-0.0604126283325885,0.7993534421572859,0.5957802693774057],[1,151.22228257200177,-152.1352089628443,71.17731919294856]],[4,"Bip001 Xtra_Mouth_Cor_L",-15,[1,"e9ki9vW3ha/oTYOTJfAkl8",1,0],[1,-0.03132891654968262,0.5618896484375,0.11657369136810303],[3,-0.04929762034087917,0.06040812745717985,0.7993537901967565,0.595780262230903],[1,-151.22349829367852,152.13605821250368,71.17747050798812]],[4,"Bip001 Xtra_Mouth_Up_R",-16,[1,"20BgvTdsleXrtRxNyWlh//",1,0],[1,-0.04088473320007324,0.6360740661621094,-0.06928008049726486],[3,-0.0038198481848174207,0.0019246733316340729,0.7995733037055219,0.6005532752336371],[1,-178.42422555767092,178.26911750409243,73.81321923996768]],[4,"Bip001 Xtra_Mouth_Up_L",-17,[1,"7cMoqyptdaSbxJ3NJe5s4D",1,0],[1,-0.04088473320007324,0.6360738277435303,0.0692836120724678],[3,0.003819830457478615,-0.0019290845247500956,0.7995732969633009,0.6005532701696075],[1,178.42278052602967,-178.26803494978196,73.813208998766]],[4,"Bip001 Xtra_Teath_Up",-18,[1,"34N3Tf3Vhf6p2OCEtjbUr5",1,0],[1,0.002314329147338867,0.554196834564209,0.000004309463747631526],[3,9.336697845026691e-7,1.9915808695504157e-7,0.8147948658617054,0.5797493652989147],[1,179.9998674950161,-179.99977440903933,70.86583252141891]],-19,[4,"Bip001 Xtra_EarL",-20,[1,"3dlgK1+6ZS+pIxXuBluE25",1,0],[1,0.6298751831054688,-0.04161977767944336,0.21326301991939545],[3,0.17229719240550637,-0.3286434668165523,0.041136212122997444,0.9276933551880974],[1,20.3010491465256,-38.635362133307176,-2.1161341392427624]],[4,"Bip001 Xtra_EarR",-21,[1,"68RNEaQ79QPq60RxDOrbld",1,0],[1,0.6298751831054688,-0.04161834716796875,-0.21326324343681335],[3,-0.17229802753627552,0.32864299124926405,0.04113777690385765,0.9276932991680245],[1,-20.30120120360858,38.635335030936766,-2.1159900209997105]],[4,"Bip001 Xtra_eyebrownR",-22,[1,"a5O6YJyIlZ0K3DMvMImW/M",1,0],[1,0.3929600715637207,0.4532432556152344,-0.1358882188796997],[3,-0.23773379651555063,0.542546868955643,-0.31570294536135707,0.7412537941021924],[1,-0.8227543143827625,72.04920289475375,-46.5517219786071]],[4,"Bip001 Xtra_eyebrownL",-23,[1,"ccJkUI+3RXpZAAZAVToHx+",1,0],[1,0.3929600715637207,0.45324230194091797,0.13589075207710266],[3,0.23773374855793258,-0.542545073389861,-0.3157059510744924,0.7412538435604459],[1,0.8225775813222904,-72.04909199221025,-46.55202036838682]],[4,"Bip001 Xtra11_Nose",-24,[1,"beBTxB4F9YIazSRhrqCQYQ",1,0],[1,0.15001845359802246,0.7634279727935791,0.0000010193798516411334],[3,1.9258151975219854e-12,-0.0000027674523216948566,0.9977835439810513,0.06654321417661394],[1,179.99968074891942,-179.99997870859482,7.630929361688651]],[4,"Bn_Mouth",-25,[1,"84hrPyzk1d1ruBlx05r4WZ",1,0],[1,-0.07195711135864258,0.5386135578155518,0.008439688943326473],[3,-0.46549811987707945,-0.5231723192550453,-0.44354066279808146,0.559351325376851],[1,-80.02761183493475,-86.61028004033459,-0.5224675849989031]]],4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,4,4],[1,"bfrFfxzL1T1KmmYCwEZLjk",1,0],[1,0.271028995513916,0.1483471393585205,-1.397716005158145e-7],[3,-4.7459346984729076e-7,0.0000010302596964508388,-0.31471839988255196,0.9491850866791363],[1,-0.000018038935986709043,0.0001183982779817365,-36.6876293880894]],[47,"Bip001 Spine",[-26,-27,-28,-29],[1,"24QV1ABdRedL8PrNu+86Nq",1,0],[1,0.3542376756668091,0.3531496524810791,-0.0000013134826986060943],[3,-0.0000018851790819067795,-0.0000011795759439423908,0.06960712936962687,0.9975744821996876],[1,-0.00020810952367528602,-0.00012097697166633093,7.982844695585415]],[48,"Bip001 L Hand",[[-30,-31,-32,[4,"Bn_Hand",-33,[1,"cdSHSn+iNTHKbOD/PLegz3",1,0],[1,0.16577750444412231,0.06132864952087402,-0.046974703669548035],[3,-0.3996487816964595,0.9162200003981678,-0.011799826171741228,-0.02612520356348691],[1,3.5752087539781954,-175.1773245504443,-47.03043486089243]]],1,1,1,4],[1,"0516pAzllTEINtCBbXwvaI",1,0],[1,0.5944492220878601,0,-2.220446049250313e-16],[3,-0.2617311703737297,0.029688528854133044,0.3459904396792379,0.9005031934201249],[1,-38.26907185297872,17.178544816200937,37.415459422889654]],[47,"Bip001 Neck",[2,-34,-35],[1,"42dhuQU8NX0rXxQG7SW2YE",1,0],[1,0.5762070417404175,-0.12533974647521973,9.96238668449223e-7],[3,1.2697269418175673e-13,8.642778814821149e-7,-0.31160864818281975,0.9502105295022409],[1,0.000038299085695490824,0.00011678809352825268,-36.312403738338894]],[47,"Bip001 R Hand",[-36,-37,-38],[1,"04ZamzRGFcKJpv5KTVe1wf",1,0],[1,0.5944493412971497,-1.1920928955078125e-7,0],[3,0.2617312122116491,-0.029688526494057035,0.345990455589461,0.9005031752247349],[1,38.26907848292041,-17.178547481263575,37.41546049159831]],[14,"Bip001 Xtra_Jaw",2,[[4,"Bip001 Xtra_Teath_Low",-39,[1,"054HrpVJ9YdrFA31Ec+dkY",1,0],[1,0.13749122619628906,-0.031085491180419922,0.0000035714842852030415],[3,0.000004232222292237529,-0.0000038132740061028115,0.03182718986028513,0.9994933866480282],[1,0.0004996510135593257,-0.000453101048055823,3.647743322877986]],[98,"Bip001 Xtra_Tongue",-40,[1,"dfbHKl6RxVqLvXw6Lt14xK",1,0],[1,0.08936405181884766,-0.028061389923095703,0.000004445225840754574],[3,-3.0594311178264103e-7,3.817032550457581e-7,-0.048731250106838264,0.9988119268725146],[1,1,0.9999989867210388,1],[1,-0.00003304227590328229,0.000042179892466667365,-5.586402449871046]]],[1,"d7tLOit5hTsbOMYxHRvFOp",1,0],[1,-0.020290136337280273,0.3777594566345215,-9.088580554816872e-9],[3,-9.235465789091367e-8,-0.0000020748226942927456,0.7911309946054532,0.611646752112911],[1,179.9992786301882,-179.9994556648126,75.41733868808973]],[214,"VD302_Kangaroo_Toy",1,[[66,-41,[10,"08oWDW2JpSa5Knf6tUbF/f"],[0,1,2,3,4],[29],1,5,6]],[1,"5fl0cfxJ5Rs5ovU2QsXaQ9",1,0]],[6,"Bip001",1,[-42],[1,"61SpoqJn9XKIWNc6m3Gvr3",1,0],[1,-3.732301578907027e-9,1.5775775909423828,0.4474337100982666],[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001],[1,-90,-90,0]],[84,"Bip001 Pelvis",9,[3],[1,"f4npe4uvhfYIaPYyEku12n",1,0],[3,-0.678948057080087,-0.19755655885105733,-0.1975572294033232,0.6789492491730041],[1,-89.99992243324212,-32.44732100165269,-0.00007915718266001345]],[6,"Bip001 Spine1",3,[5],[1,"124ooP3KBc1Lk0UF5SkG6P",1,0],[1,0.4582993984222412,-0.00035309791564941406,-9.790710464585572e-10],[3,2.446313346659477e-13,-1.8054307341607132e-7,0.06509341476946535,0.9978791747268894],[1,0.0000013582370161722287,-0.000020821282842442467,7.46443354701361]],[6,"Bip001 L Clavicle",5,[-43],[1,"36Y+vy/Y5QJ7jAvyy3x9XZ",1,0],[1,-0.290891170501709,0.11437880992889404,0.056595951318740845],[3,0.7404151484820694,0.19713777106521088,0.5926956475105046,-0.24826191117410562],[1,-143.0354460567296,-77.30871903103836,-0.13521382911142363]],[6,"Bip001 L UpperArm",12,[-44],[1,"57Le13NptWs5X3lanB4PyH",1,0],[1,0.2798118591308594,1.1920928955078125e-7,2.384185791015625e-7],[3,-0.24198095521163535,0.5819774871081226,-0.35439729720859986,0.6907604342646003],[1,7.057027719358092,83.55855063844022,-50.46736884718895]],[6,"Bip001 L Forearm",13,[4],[1,"bex7q5czhZfLRNzKYoBLyx",1,0],[1,0.5204557180404663,1.1920928955078125e-7,-1.1920928955078125e-7],[3,-8.996704747186443e-18,-2.969889326223742e-17,-0.6873185419958124,0.7263561260351223],[1,-5.595479079571909e-14,-5.763289687687109e-14,-86.83644251224672]],[14,"Bip001 L Finger0",4,[[4,"Bip001 L Finger01",-45,[1,"a6aeXwf6BZdI+Q2cVg8FCt",1,0],[1,0.1283271312713623,-2.220446049250313e-16,-5.960464477539063e-8],[3,-0.0005510463967082443,0.04632963244924116,0.01187961922320866,0.9988554130363908],[1,-0.1261771947815869,5.312755955821363,1.356947306578145]]],[1,"40GhtM2Y1bgZOrgy9wQpjf",1,0],[1,0.08157700300216675,0.006247282028198242,-0.12238441407680511],[3,0.9290023395148231,0.3079701645178377,-0.06974732092525232,0.19298793269681716],[1,151.3789632812749,17.241735558793838,33.044430410905846]],[14,"Bip001 L Finger1",4,[[4,"Bip001 L Finger11",-46,[1,"82YHmJYpNUwIRpMz6/x7rh",1,0],[1,0.0953603982925415,-2.384185791015625e-7,5.960464477539063e-8],[3,1.0302478230703421e-8,-1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,0.0000015880320747349408,-0.0000018587233107113073,23.268080227659283]]],[1,"efGIrw9kZbM5dp1NBwHMRu",1,0],[1,0.2140156626701355,0.02871990203857422,-0.07965849339962006],[3,0.14175589132700384,0.05487470977109217,0.29237341365277086,0.9441460800589339],[1,16.628244260928607,1.4427303831348735,34.58610116822202]],[14,"Bip001 L Finger2",4,[[4,"Bip001 L Finger21",-47,[1,"56GP/33ipbt5RscKxkRlan",1,0],[1,0.07172501087188721,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0171859984491851e-17,-1.4991040769140968e-17,0.13798254917676323,0.9904346601985827],[1,-9.53743987823341e-16,-1.601566231679269e-15,15.862243670868283]]],[1,"a3opXY1K1bs63KtREsU6Cj",1,0],[1,0.20017272233963013,0.027018070220947266,0.010468840599060059],[3,0.016227573424614575,-0.07892323415809137,0.25775862166212676,0.9628438512706079],[1,4.745212621468258,-10.625984962258268,29.590727366189885]],[6,"Bip001 R Clavicle",5,[-48],[1,"80Sxap8RleT7LfBkzDAi93",1,0],[1,-0.2908914089202881,0.1143791675567627,-0.056598000228405],[3,0.7404158188458404,0.19713941411025176,-0.5926951228460576,0.24825985974701364],[1,143.03551574473522,77.30872223520217,-0.1349050251337831]],[6,"Bip001 R UpperArm",18,[-49],[1,"94nYA+SUZazqUalPScGfCg",1,0],[1,0.2798118591308594,4.440892098500626e-16,0],[3,0.24198129715613026,-0.5819780812733067,-0.35439678942351904,0.6907600744038257],[1,-7.056981598696757,-83.5586140647127,-50.46734445139137]],[6,"Bip001 R Forearm",19,[6],[1,"39NhMc+jhSCqKPANQHLh8+",1,0],[1,0.5204557180404663,1.1920928955078125e-7,0],[3,4.9317570815256714e-17,-8.45495145977068e-18,-0.6873185717527179,0.7263560978774832],[1,6.231598940146356e-14,5.763298592223944e-14,-86.83644720676268]],[14,"Bip001 R Finger0",6,[[4,"Bip001 R Finger01",-50,[1,"84l6lm3SBYBZ8FSo3q+7NM",1,0],[1,0.11112487316131592,2.220446049250313e-16,-1.1920928955078125e-7],[3,0.0005510246851597509,-0.046329632441594146,0.011879634122409057,0.9988554128715231],[1,0.12617478816212,-5.3127559293270386,1.356949127499545]]],[1,"47JEn10QFZeY7XBihtHdxT",1,0],[1,0.0954056978225708,0.005409955978393555,0.10597886145114899],[3,0.9290023316959993,0.30797019172817003,0.06974726818416987,-0.19298794597372107],[1,-151.37896227054966,-17.241730691025925,33.044434802218554]],[14,"Bip001 R Finger1",6,[[4,"Bip001 R Finger11",-51,[1,"e57STHoJpa0p56K4UDKx2N",1,0],[1,0.09536051750183105,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0302478230703421e-8,1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,-0.0000015880320747349408,0.0000018587233107113073,23.268080227659283]]],[1,"53/rmZzdJZL463F9C5r7qA",1,0],[1,0.2140156626701355,0.02871990203857422,0.07965849339962006],[3,-0.14175589118211213,-0.0548747283414547,0.2923734133539298,0.9441460790939021],[1,-16.628243493903444,-1.4427328337497123,34.58610145498249]],[14,"Bip001 R Finger2",6,[[4,"Bip001 R Finger21",-52,[1,"6cklssd71bQpgcGHdZO8+Q",1,0],[1,0.07172489166259766,0,0],[3,4.893729611197911e-18,-3.696921671140056e-18,0.13798254917676323,0.9904346601985827],[1,6.381709387020008e-16,-5.16634253009268e-16,15.862243670868283]]],[1,"9fgNNDboxcjIG+O1o8GHRt",1,0],[1,0.20017272233963013,0.027018070220947266,-0.010468810796737671],[3,-0.016227580863691093,0.07892324155272112,0.2577586214793942,0.9628438505880201],[1,-4.745213810691006,10.625986151481015,29.59072722663627]],[6,"Bip001 L Thigh",3,[-53],[1,"1aOCmC7G1QLYh3hQ/RIfCW",1,0],[1,-0.39984893798828125,-0.30053311586380005,0.3836286962032318],[3,0.7178273552306246,0.680038369359236,0.1348885996845741,0.06384958854192135],[1,-126.10226971349779,-70.08105235291427,83.47655542639572]],[6,"Bip001 L Calf",24,[-54],[1,"dbtmT0gRdSBIMmHDpIZtZm",1,0],[1,0.743604302406311,-1.1920928955078125e-7,-2.7755575615628914e-17],[3,0,0,-0.41653967720321833,0.909117537678951],[1,0,0,-49.23262954822765]],[14,"Bip001 L Foot",25,[[4,"Bip001 L Toe0",-55,[1,"0ej8X8mtRS8IOXZwhuA0cA",1,0],[1,0.0993526503443718,0.3203730583190918,0.015012085437774658],[3,-0.012606775107827504,-0.004188367072502582,0.7176545698822673,0.6962725365327463],[1,-159.190288938885,157.82919259324692,88.13791814938088]]],[1,"27lKXEzcFQsZTcP6tappE1",1,0],[1,0.8391543626785278,2.9802322387695312e-8,0],[3,0.09368384456679991,0.04668617534947475,0.18506039337690455,0.9771368323329169],[1,10.282468224363756,3.491167402013983,21.740666790231035]],[6,"Bip001 R Thigh",3,[-56],[1,"abAw8bUFFfbJbDdcCTemu+",1,0],[1,-0.399849534034729,-0.3005313277244568,-0.3836267292499542],[3,0.7178270792704299,0.6800386286793662,-0.134887694859659,-0.06385184057972494],[1,126.10304314074824,70.08038736689647,83.47680202680553]],[6,"Bip001 R Calf",27,[-57],[1,"54Lh51XGBYv7YuKOF5iKJs",1,0],[1,0.7436041831970215,0,5.551115123125783e-17],[3,-5.0466161121084984e-17,2.312259701504717e-17,-0.41653967720321833,0.909117537678951],[1,-6.361109362927037e-15,0,-49.23262954822765]],[14,"Bip001 R Foot",28,[[4,"Bip001 R Toe0",-58,[1,"46OYGFnqVWX54eydGHqJue",1,0],[1,0.09935265779495239,0.320372998714447,-0.01501205563545227],[3,0.012606777493592694,0.004188363055347829,0.7176545996614502,0.6962725058200326],[1,159.19032927263092,-157.8292330582914,88.13791339787937]]],[1,"a0sQDO/bdTOryUmf6KpZ23",1,0],[1,0.8391544222831726,-5.551115123125783e-17,1.4901161193847656e-8],[3,-0.0936838530691832,-0.04668609764253182,0.1850603507511224,0.9771368433033805],[1,-10.282471032387543,-3.4911582401498076,21.740661053193115]],[6,"Bip001 Xtra_Tail",3,[-59],[1,"82O4d8FFlZfbWoM1gQ5T0P",1,0],[1,-0.9858397245407104,-0.43601518869400024,0.000001985863264053478],[3,9.877768196883434e-7,-0.0000026041092780163377,0.9789544108644718,-0.20407905684130798],[1,179.999706525755,-179.99994555523935,-23.551186460093533]],[14,"Bip001 Xtra_Tail1",30,[[4,"Bip001 Xtra_Tail2",-60,[1,"32EOimsNxW6auKvQxSU90n",1,0],[1,0.9689803123474121,-0.0008437633514404297,-2.9117472877260298e-9],[3,3.4403779720176436e-7,5.077550272064185e-7,-0.010108478258240874,0.9999489080282684],[1,0.00004001814766795572,0.00005859195632515687,-1.1583660107752876]]],[1,"b98OsIwtddvaimim2Y6TQy",1,0],[1,0.7776881456375122,-0.0007715225219726562,-2.1395862859208137e-9],[3,1.7354177343170095e-13,2.4402726421175402e-8,-0.008798220935442457,0.9999612949051431],[1,2.4626572286066044e-8,0.000002796671380546391,-1.0082148613665045]]],0,[0,4,1,0,0,1,0,0,1,0,-1,8,0,-2,9,0,4,1,0,1,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-12,7,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-1,11,0,-2,24,0,-3,27,0,-4,30,0,-1,15,0,-2,16,0,-3,17,0,1,4,0,-2,12,0,-3,18,0,-1,21,0,-2,22,0,-3,23,0,1,7,0,1,7,0,0,8,0,-1,10,0,-1,13,0,-1,14,0,1,15,0,1,16,0,1,17,0,-1,19,0,-1,20,0,1,21,0,1,22,0,1,23,0,-1,25,0,-1,26,0,1,26,0,-1,28,0,-1,29,0,1,29,0,-1,31,0,1,31,0,18,1,2,1,5,3,1,10,4,1,14,5,1,11,6,1,20,60],[0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,12,20,-1,-2,22],[8,8,8,8,62,51,63,9,14,49]],[[[40,"Food_Berries"],[103,"Food_Berries",[-3],[[308,-2,[10,"66LJ7WJtBF/6SM1AKu7OOs"]]],[1,"deyd1rjS9YuJ4yxHjx4EDa",-1,0],[1,0.2,0.2,0.2]],[64,"Berries",1,[[114,-4,[10,"50QEQTRvRV2awMagNtfvQh"],[0],[29],1]],[1,"f6PMXD2thWI4IggEkzNpfD",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,4,1,0,0,1,0,-1,2,0,0,2,0,18,1,4],[0,0],[-1,12],[162,163]],[[[309,"china","china.ttf"],-1],0,0,[],[],[]],[[[121,[[122,[123,[-14,-15,-16,-17,-18,-19],[[124,-5,-4],[72,0,-7,-6,[[125,1,[74,"velocity"],[75]]]],[72,0,-9,-8,[[126,[74,"velocity"],[75]]]],[73,false,-11,-10,[[127,[76,"EatFood"]]]],[73,false,-13,-12,[[128,1,[76,"EatFood"]]]]],-3,-2,-1]]],[{},"velocity",4,[129],"EatFood",4,[130,1,false]]],[51,"Idle",[52,0]],[53,"Entry"],[51,"Run",[52,1]],[51,"Eat",[52,2]],[53,"Exit"],[53,"Any"]],0,[0,28,6,0,29,5,0,30,2,0,16,1,0,17,2,0,16,3,0,17,1,0,16,1,0,17,3,0,16,4,0,17,1,0,16,1,0,17,4,0,-1,2,0,-2,5,0,-3,6,0,-4,1,0,-5,3,0,-6,4,19],[0,0,0],[19,19,19],[32,57,58]],[[{"name":"Bg-1","rect":{"x":0,"y":0,"width":1080,"height":1920},"offset":{"x":0,"y":0},"originalSize":{"width":1080,"height":1920},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[7],0,[0],[23],[36]],[[[40,"NameTag"],[224,"NameTag",33554432,[-4,-5],[[37,-2,[10,"d3MSKDMsBG+qcR+hsg3J51"],[5,448.14599999999996,150]],[176,0,-3,[10,"39Evswlz5NxbZrS6PGWf+m"],2]],[1,"11eNPD3O5GYoRUgAIxCkP0",-1,0]],[85,"LabelEN",33554432,1,[[37,-6,[10,"3ceulRayxKt62g5xjwaWn7"],[5,300,104.8]],[116,"KANGAROO",50,50,80,false,-7,[10,"ebJnXfl+tHiJIUO67uuBpW"],[4,4280049195],0],[269,-8,[10,"6cpKFBmKFLk6hkn75oMzB+"],[4,4294967295]]],[1,"9eBx1ptI9KCbSCHrQkXh2W",1,0],[1,0,-30,0]],[85,"LabelCN",33554432,1,[[37,-9,[10,"c1qq9hugFEL7ITQmR5z1M4"],[5,106,106.8]],[116,"袋鼠",50,50,80,false,-10,[10,"e09/dbuUJBS6mikqBI1Kbs"],[4,4280049195],1],[270,3,-11,[10,"cbrHWu6H1FbYUrRv4G6BI3"],[4,4294967295]]],[1,"72kFUehMNDGo4ebBbSHvtm",1,0],[1,0,30,0]]],0,[0,4,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,0,2,0,0,2,0,0,2,0,0,3,0,0,3,0,0,3,0,18,1,11],[0,0,0],[8,8,2],[0,0,164]],[[{"name":"Bg-2","rect":{"x":0,"y":0,"width":1080,"height":1920},"offset":{"x":0,"y":0},"originalSize":{"width":1080,"height":1920},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[7],0,[0],[23],[88]],[[[62,".bin",3576210858,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":68400,"length":15300,"count":3825,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":68400,"count":1425,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.8554086685180664,-2.2476742267608643,-2.310732364654541],"maxPosition",8,[1,1.855408787727356,2.2476747035980225,2.310732364654541]]],-1],0,0,[],[],[]],[[[50,"Food_AssetsC",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[165,10]],[[{"name":"Sparkle","rect":{"x":0,"y":0,"width":128,"height":128},"offset":{"x":0,"y":0},"originalSize":{"width":128,"height":128},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[7],0,[0],[23],[166]],[[[40,"VD302_Kangaroo_Rig"],[215,"VD302_Kangaroo_Rig",524288,[[-3,-4,[24,"Bn_FoodSpawn",524288,-6,[1,"f3CmudYmJTjK7M6nViAmg5",-5,0],[1,-5.4358654466568623e-8,0.009165484458208084,0.8870136737823486],[3,1.545431187269876e-8,-0.707106721581899,1.5454308319985022e-8,0.7071068407911907],[1,0.0000025044781562438738,-89.99999034065368,-7.67592264999771e-14]]],1,1,4],[[110,-2,[10,"08p3MFuydXL4oM9CbjboO3"]]],[1,"8fJHyWPHhT77T0qzBIqM/Z",-1,0],[1,135.802,0,223.307],[1,100,100,100]],[164,"Bip001 Head",524288,[[[24,"Bip001 Xtra_Eyelid_up_L",524288,-7,[1,"2d7+KWFQJVFrgz3wx2r7Yn",1,0],[1,0.3271970748901367,0.4205749034881592,-0.18183529376983643],[3,-0.24522146530069025,-0.4163162103317173,0.8753637652717497,0.016897467860142394],[1,132.17461490430898,154.7176502037449,13.518670197215748]],[24,"Bip001 Xtra_Eyelid_up_R",524288,-8,[1,"a5xYRu1R9c+4gSl9Nkoyrr",1,0],[1,0.3271970748901367,0.4205739498138428,0.18183764815330505],[3,0.24522088155166882,0.4163115567490713,0.8753661401629665,0.016897562675627805],[1,-132.17519821674765,-154.71765267277706,13.518521573560058]],[24,"Bip001 Xtra_Eyelid_Low_L",524288,-9,[1,"bbzAt+/A5Za6JtvBJFLV6Q",1,0],[1,0.21905755996704102,0.41451358795166016,-0.20157299935817719],[3,0.4409942824246951,-0.040964274662843414,0.025457053795126677,0.8962130937908391],[1,52.42644045172507,-5.502120724866701,0.5443105331507334]],[24,"Bip001 Xtra_Eyelid_Low_R",524288,-10,[1,"8bMDwNbY5Up6fKdikNpIQL",1,0],[1,0.21905755996704102,0.41451263427734375,0.20157529413700104],[3,-0.4409942824517709,0.040964133104330384,0.025457279176747588,0.896213093845864],[1,-52.426441892868866,5.502117589864751,0.5443408344453377]],[24,"Bip001 Xtra_Eye_R",524288,-11,[1,"c2tjMLgltSz7/DvasIQO6O",1,0],[1,0.2641632556915283,0.35110998153686523,-0.14128649234771729],[3,-0.27964436716809643,0.1581443084705726,0.682003014140958,0.6570093563353323],[1,-98.45224704751105,88.08277038553146,53.873413080213766]],[24,"Bip001 Xtra_Eye_L",524288,-12,[1,"6bI877qbhcC6ioHfi85K1R",1,0],[1,0.2641632556915283,0.35110926628112793,0.1412884145975113],[3,0.27964439645134875,-0.15814812287424745,0.6820021188053784,0.657009355115806],[1,98.4519445966391,-88.08278231192374,53.87309036235816]],[24,"Bip001 Xtra_Mouth_Cor_R",524288,-13,[1,"ed/f9Db/pZuZRZD4YWAqds",1,0],[1,-0.03132891654968262,0.5618903636932373,-0.11657057702541351],[3,0.04929766191040832,-0.0604126283325885,0.7993534421572859,0.5957802693774057],[1,151.22228257200177,-152.1352089628443,71.17731919294856]],[24,"Bip001 Xtra_Mouth_Cor_L",524288,-14,[1,"e9ki9vW3ha/oTYOTJfAkl8",1,0],[1,-0.03132891654968262,0.5618896484375,0.11657369136810303],[3,-0.04929762034087917,0.06040812745717985,0.7993537901967565,0.595780262230903],[1,-151.22349829367852,152.13605821250368,71.17747050798812]],[24,"Bip001 Xtra_Mouth_Up_R",524288,-15,[1,"20BgvTdsleXrtRxNyWlh//",1,0],[1,-0.04088473320007324,0.6360740661621094,-0.06928008049726486],[3,-0.0038198481848174207,0.0019246733316340729,0.7995733037055219,0.6005532752336371],[1,-178.42422555767092,178.26911750409243,73.81321923996768]],[24,"Bip001 Xtra_Mouth_Up_L",524288,-16,[1,"7cMoqyptdaSbxJ3NJe5s4D",1,0],[1,-0.04088473320007324,0.6360738277435303,0.0692836120724678],[3,0.003819830457478615,-0.0019290845247500956,0.7995732969633009,0.6005532701696075],[1,178.42278052602967,-178.26803494978196,73.813208998766]],[24,"Bip001 Xtra_Teath_Up",524288,-17,[1,"34N3Tf3Vhf6p2OCEtjbUr5",1,0],[1,0.002314329147338867,0.554196834564209,0.000004309463747631526],[3,9.336697845026691e-7,1.9915808695504157e-7,0.8147948658617054,0.5797493652989147],[1,179.9998674950161,-179.99977440903933,70.86583252141891]],-18,[24,"Bip001 Xtra_EarL",524288,-19,[1,"3dlgK1+6ZS+pIxXuBluE25",1,0],[1,0.6298751831054688,-0.04161977767944336,0.21326301991939545],[3,0.17229719240550637,-0.3286434668165523,0.041136212122997444,0.9276933551880974],[1,20.3010491465256,-38.635362133307176,-2.1161341392427624]],[24,"Bip001 Xtra_EarR",524288,-20,[1,"68RNEaQ79QPq60RxDOrbld",1,0],[1,0.6298751831054688,-0.04161834716796875,-0.21326324343681335],[3,-0.17229802753627552,0.32864299124926405,0.04113777690385765,0.9276932991680245],[1,-20.30120120360858,38.635335030936766,-2.1159900209997105]],[24,"Bip001 Xtra_eyebrownR",524288,-21,[1,"a5O6YJyIlZ0K3DMvMImW/M",1,0],[1,0.3929600715637207,0.4532432556152344,-0.1358882188796997],[3,-0.23773379651555063,0.542546868955643,-0.31570294536135707,0.7412537941021924],[1,-0.8227543143827625,72.04920289475375,-46.5517219786071]],[24,"Bip001 Xtra_eyebrownL",524288,-22,[1,"ccJkUI+3RXpZAAZAVToHx+",1,0],[1,0.3929600715637207,0.45324230194091797,0.13589075207710266],[3,0.23773374855793258,-0.542545073389861,-0.3157059510744924,0.7412538435604459],[1,0.8225775813222904,-72.04909199221025,-46.55202036838682]],[24,"Bip001 Xtra11_Nose",524288,-23,[1,"beBTxB4F9YIazSRhrqCQYQ",1,0],[1,0.15001845359802246,0.7634279727935791,0.0000010193798516411334],[3,1.9258151975219854e-12,-0.0000027674523216948566,0.9977835439810513,0.06654321417661394],[1,179.99968074891942,-179.99997870859482,7.630929361688651]],[24,"Bn_Mouth",524288,-24,[1,"84hrPyzk1d1ruBlx05r4WZ",1,0],[1,-0.07195711135864258,0.5386135578155518,0.008439688943326473],[3,-0.46549811987707945,-0.5231723192550453,-0.44354066279808146,0.559351325376851],[1,-80.02761183493475,-86.61028004033459,-0.5224675849989031]]],4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,4,4],[1,"bfrFfxzL1T1KmmYCwEZLjk",1,0],[1,0.271028995513916,0.1483471393585205,-1.397716005158145e-7],[3,-4.7459346984729076e-7,0.0000010302596964508388,-0.31471839988255196,0.9491850866791363],[1,-0.000018038935986709043,0.0001183982779817365,-36.6876293880894]],[138,"Bip001 Spine",524288,[-25,-26,-27,-28],[1,"24QV1ABdRedL8PrNu+86Nq",1,0],[1,0.3542376756668091,0.3531496524810791,-0.0000013134826986060943],[3,-0.0000018851790819067795,-0.0000011795759439423908,0.06960712936962687,0.9975744821996876],[1,-0.00020810952367528602,-0.00012097697166633093,7.982844695585415]],[164,"Bip001 L Hand",524288,[[-29,-30,-31,[24,"Bn_Hand",524288,-32,[1,"cdSHSn+iNTHKbOD/PLegz3",1,0],[1,0.16577750444412231,0.06132864952087402,-0.046974703669548035],[3,-0.3996487816964595,0.9162200003981678,-0.011799826171741228,-0.02612520356348691],[1,3.5752087539781954,-175.1773245504443,-47.03043486089243]]],1,1,1,4],[1,"0516pAzllTEINtCBbXwvaI",1,0],[1,0.5944492220878601,0,-2.220446049250313e-16],[3,-0.2617311703737297,0.029688528854133044,0.3459904396792379,0.9005031934201249],[1,-38.26907185297872,17.178544816200937,37.415459422889654]],[138,"Bip001 Neck",524288,[2,-33,-34],[1,"42dhuQU8NX0rXxQG7SW2YE",1,0],[1,0.5762070417404175,-0.12533974647521973,9.96238668449223e-7],[3,1.2697269418175673e-13,8.642778814821149e-7,-0.31160864818281975,0.9502105295022409],[1,0.000038299085695490824,0.00011678809352825268,-36.312403738338894]],[138,"Bip001 R Hand",524288,[-35,-36,-37],[1,"04ZamzRGFcKJpv5KTVe1wf",1,0],[1,0.5944493412971497,-1.1920928955078125e-7,0],[3,0.2617312122116491,-0.029688526494057035,0.345990455589461,0.9005031752247349],[1,38.26907848292041,-17.178547481263575,37.41546049159831]],[58,"Bip001 Xtra_Jaw",524288,2,[[24,"Bip001 Xtra_Teath_Low",524288,-38,[1,"054HrpVJ9YdrFA31Ec+dkY",1,0],[1,0.13749122619628906,-0.031085491180419922,0.0000035714842852030415],[3,0.000004232222292237529,-0.0000038132740061028115,0.03182718986028513,0.9994933866480282],[1,0.0004996510135593257,-0.000453101048055823,3.647743322877986]],[201,"Bip001 Xtra_Tongue",524288,-39,[1,"dfbHKl6RxVqLvXw6Lt14xK",1,0],[1,0.08936405181884766,-0.028061389923095703,0.000004445225840754574],[3,-3.0594311178264103e-7,3.817032550457581e-7,-0.048731250106838264,0.9988119268725146],[1,1,0.9999989867210388,1],[1,-0.00003304227590328229,0.000042179892466667365,-5.586402449871046]]],[1,"d7tLOit5hTsbOMYxHRvFOp",1,0],[1,-0.020290136337280273,0.3777594566345215,-9.088580554816872e-9],[3,-9.235465789091367e-8,-0.0000020748226942927456,0.7911309946054532,0.611646752112911],[1,179.9992786301882,-179.9994556648126,75.41733868808973]],[216,"VD302_Kangaroo_Toy",524288,1,[[66,-40,[10,"08oWDW2JpSa5Knf6tUbF/f"],[0,1,2,3,4],[29],1,5,6]],[1,"5fl0cfxJ5Rs5ovU2QsXaQ9",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[44,"Bip001",524288,1,[-41],[1,"61SpoqJn9XKIWNc6m3Gvr3",1,0],[1,-3.732301578907027e-9,1.5775775909423828,0.4474337100982666],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[202,"Bip001 Pelvis",524288,9,[3],[1,"f4npe4uvhfYIaPYyEku12n",1,0],[3,-0.678948057080087,-0.19755655885105733,-0.1975572294033232,0.6789492491730041],[1,-89.99992243324212,-32.44732100165269,-0.00007915718266001345]],[44,"Bip001 Spine1",524288,3,[5],[1,"124ooP3KBc1Lk0UF5SkG6P",1,0],[1,0.4582993984222412,-0.00035309791564941406,-9.790710464585572e-10],[3,2.446313346659477e-13,-1.8054307341607132e-7,0.06509341476946535,0.9978791747268894],[1,0.0000013582370161722287,-0.000020821282842442467,7.46443354701361]],[44,"Bip001 L Clavicle",524288,5,[-42],[1,"36Y+vy/Y5QJ7jAvyy3x9XZ",1,0],[1,-0.290891170501709,0.11437880992889404,0.056595951318740845],[3,0.7404151484820694,0.19713777106521088,0.5926956475105046,-0.24826191117410562],[1,-143.0354460567296,-77.30871903103836,-0.13521382911142363]],[44,"Bip001 L UpperArm",524288,12,[-43],[1,"57Le13NptWs5X3lanB4PyH",1,0],[1,0.2798118591308594,1.1920928955078125e-7,2.384185791015625e-7],[3,-0.24198095521163535,0.5819774871081226,-0.35439729720859986,0.6907604342646003],[1,7.057027719358092,83.55855063844022,-50.46736884718895]],[44,"Bip001 L Forearm",524288,13,[4],[1,"bex7q5czhZfLRNzKYoBLyx",1,0],[1,0.5204557180404663,1.1920928955078125e-7,-1.1920928955078125e-7],[3,-8.996704747186443e-18,-2.969889326223742e-17,-0.6873185419958124,0.7263561260351223],[1,-5.595479079571909e-14,-5.763289687687109e-14,-86.83644251224672]],[58,"Bip001 L Finger0",524288,4,[[24,"Bip001 L Finger01",524288,-44,[1,"a6aeXwf6BZdI+Q2cVg8FCt",1,0],[1,0.1283271312713623,-2.220446049250313e-16,-5.960464477539063e-8],[3,-0.0005510463967082443,0.04632963244924116,0.01187961922320866,0.9988554130363908],[1,-0.1261771947815869,5.312755955821363,1.356947306578145]]],[1,"40GhtM2Y1bgZOrgy9wQpjf",1,0],[1,0.08157700300216675,0.006247282028198242,-0.12238441407680511],[3,0.9290023395148231,0.3079701645178377,-0.06974732092525232,0.19298793269681716],[1,151.3789632812749,17.241735558793838,33.044430410905846]],[58,"Bip001 L Finger1",524288,4,[[24,"Bip001 L Finger11",524288,-45,[1,"82YHmJYpNUwIRpMz6/x7rh",1,0],[1,0.0953603982925415,-2.384185791015625e-7,5.960464477539063e-8],[3,1.0302478230703421e-8,-1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,0.0000015880320747349408,-0.0000018587233107113073,23.268080227659283]]],[1,"efGIrw9kZbM5dp1NBwHMRu",1,0],[1,0.2140156626701355,0.02871990203857422,-0.07965849339962006],[3,0.14175589132700384,0.05487470977109217,0.29237341365277086,0.9441460800589339],[1,16.628244260928607,1.4427303831348735,34.58610116822202]],[58,"Bip001 L Finger2",524288,4,[[24,"Bip001 L Finger21",524288,-46,[1,"56GP/33ipbt5RscKxkRlan",1,0],[1,0.07172501087188721,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0171859984491851e-17,-1.4991040769140968e-17,0.13798254917676323,0.9904346601985827],[1,-9.53743987823341e-16,-1.601566231679269e-15,15.862243670868283]]],[1,"a3opXY1K1bs63KtREsU6Cj",1,0],[1,0.20017272233963013,0.027018070220947266,0.010468840599060059],[3,0.016227573424614575,-0.07892323415809137,0.25775862166212676,0.9628438512706079],[1,4.745212621468258,-10.625984962258268,29.590727366189885]],[44,"Bip001 R Clavicle",524288,5,[-47],[1,"80Sxap8RleT7LfBkzDAi93",1,0],[1,-0.2908914089202881,0.1143791675567627,-0.056598000228405],[3,0.7404158188458404,0.19713941411025176,-0.5926951228460576,0.24825985974701364],[1,143.03551574473522,77.30872223520217,-0.1349050251337831]],[44,"Bip001 R UpperArm",524288,18,[-48],[1,"94nYA+SUZazqUalPScGfCg",1,0],[1,0.2798118591308594,4.440892098500626e-16,0],[3,0.24198129715613026,-0.5819780812733067,-0.35439678942351904,0.6907600744038257],[1,-7.056981598696757,-83.5586140647127,-50.46734445139137]],[44,"Bip001 R Forearm",524288,19,[6],[1,"39NhMc+jhSCqKPANQHLh8+",1,0],[1,0.5204557180404663,1.1920928955078125e-7,0],[3,4.9317570815256714e-17,-8.45495145977068e-18,-0.6873185717527179,0.7263560978774832],[1,6.231598940146356e-14,5.763298592223944e-14,-86.83644720676268]],[58,"Bip001 R Finger0",524288,6,[[24,"Bip001 R Finger01",524288,-49,[1,"84l6lm3SBYBZ8FSo3q+7NM",1,0],[1,0.11112487316131592,2.220446049250313e-16,-1.1920928955078125e-7],[3,0.0005510246851597509,-0.046329632441594146,0.011879634122409057,0.9988554128715231],[1,0.12617478816212,-5.3127559293270386,1.356949127499545]]],[1,"47JEn10QFZeY7XBihtHdxT",1,0],[1,0.0954056978225708,0.005409955978393555,0.10597886145114899],[3,0.9290023316959993,0.30797019172817003,0.06974726818416987,-0.19298794597372107],[1,-151.37896227054966,-17.241730691025925,33.044434802218554]],[58,"Bip001 R Finger1",524288,6,[[24,"Bip001 R Finger11",524288,-50,[1,"e57STHoJpa0p56K4UDKx2N",1,0],[1,0.09536051750183105,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0302478230703421e-8,1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,-0.0000015880320747349408,0.0000018587233107113073,23.268080227659283]]],[1,"53/rmZzdJZL463F9C5r7qA",1,0],[1,0.2140156626701355,0.02871990203857422,0.07965849339962006],[3,-0.14175589118211213,-0.0548747283414547,0.2923734133539298,0.9441460790939021],[1,-16.628243493903444,-1.4427328337497123,34.58610145498249]],[58,"Bip001 R Finger2",524288,6,[[24,"Bip001 R Finger21",524288,-51,[1,"6cklssd71bQpgcGHdZO8+Q",1,0],[1,0.07172489166259766,0,0],[3,4.893729611197911e-18,-3.696921671140056e-18,0.13798254917676323,0.9904346601985827],[1,6.381709387020008e-16,-5.16634253009268e-16,15.862243670868283]]],[1,"9fgNNDboxcjIG+O1o8GHRt",1,0],[1,0.20017272233963013,0.027018070220947266,-0.010468810796737671],[3,-0.016227580863691093,0.07892324155272112,0.2577586214793942,0.9628438505880201],[1,-4.745213810691006,10.625986151481015,29.59072722663627]],[44,"Bip001 L Thigh",524288,3,[-52],[1,"1aOCmC7G1QLYh3hQ/RIfCW",1,0],[1,-0.39984893798828125,-0.30053311586380005,0.3836286962032318],[3,0.7178273552306246,0.680038369359236,0.1348885996845741,0.06384958854192135],[1,-126.10226971349779,-70.08105235291427,83.47655542639572]],[44,"Bip001 L Calf",524288,24,[-53],[1,"dbtmT0gRdSBIMmHDpIZtZm",1,0],[1,0.743604302406311,-1.1920928955078125e-7,-2.7755575615628914e-17],[3,0,0,-0.41653967720321833,0.909117537678951],[1,0,0,-49.23262954822765]],[58,"Bip001 L Foot",524288,25,[[24,"Bip001 L Toe0",524288,-54,[1,"0ej8X8mtRS8IOXZwhuA0cA",1,0],[1,0.0993526503443718,0.3203730583190918,0.015012085437774658],[3,-0.012606775107827504,-0.004188367072502582,0.7176545698822673,0.6962725365327463],[1,-159.190288938885,157.82919259324692,88.13791814938088]]],[1,"27lKXEzcFQsZTcP6tappE1",1,0],[1,0.8391543626785278,2.9802322387695312e-8,0],[3,0.09368384456679991,0.04668617534947475,0.18506039337690455,0.9771368323329169],[1,10.282468224363756,3.491167402013983,21.740666790231035]],[44,"Bip001 R Thigh",524288,3,[-55],[1,"abAw8bUFFfbJbDdcCTemu+",1,0],[1,-0.399849534034729,-0.3005313277244568,-0.3836267292499542],[3,0.7178270792704299,0.6800386286793662,-0.134887694859659,-0.06385184057972494],[1,126.10304314074824,70.08038736689647,83.47680202680553]],[44,"Bip001 R Calf",524288,27,[-56],[1,"54Lh51XGBYv7YuKOF5iKJs",1,0],[1,0.7436041831970215,0,5.551115123125783e-17],[3,-5.0466161121084984e-17,2.312259701504717e-17,-0.41653967720321833,0.909117537678951],[1,-6.361109362927037e-15,0,-49.23262954822765]],[58,"Bip001 R Foot",524288,28,[[24,"Bip001 R Toe0",524288,-57,[1,"46OYGFnqVWX54eydGHqJue",1,0],[1,0.09935265779495239,0.320372998714447,-0.01501205563545227],[3,0.012606777493592694,0.004188363055347829,0.7176545996614502,0.6962725058200326],[1,159.19032927263092,-157.8292330582914,88.13791339787937]]],[1,"a0sQDO/bdTOryUmf6KpZ23",1,0],[1,0.8391544222831726,-5.551115123125783e-17,1.4901161193847656e-8],[3,-0.0936838530691832,-0.04668609764253182,0.1850603507511224,0.9771368433033805],[1,-10.282471032387543,-3.4911582401498076,21.740661053193115]],[44,"Bip001 Xtra_Tail",524288,3,[-58],[1,"82O4d8FFlZfbWoM1gQ5T0P",1,0],[1,-0.9858397245407104,-0.43601518869400024,0.000001985863264053478],[3,9.877768196883434e-7,-0.0000026041092780163377,0.9789544108644718,-0.20407905684130798],[1,179.999706525755,-179.99994555523935,-23.551186460093533]],[58,"Bip001 Xtra_Tail1",524288,30,[[24,"Bip001 Xtra_Tail2",524288,-59,[1,"32EOimsNxW6auKvQxSU90n",1,0],[1,0.9689803123474121,-0.0008437633514404297,-2.9117472877260298e-9],[3,3.4403779720176436e-7,5.077550272064185e-7,-0.010108478258240874,0.9999489080282684],[1,0.00004001814766795572,0.00005859195632515687,-1.1583660107752876]]],[1,"b98OsIwtddvaimim2Y6TQy",1,0],[1,0.7776881456375122,-0.0007715225219726562,-2.1395862859208137e-9],[3,1.7354177343170095e-13,2.4402726421175402e-8,-0.008798220935442457,0.9999612949051431],[1,2.4626572286066044e-8,0.000002796671380546391,-1.0082148613665045]]],0,[0,4,1,0,0,1,0,-1,8,0,-2,9,0,4,1,0,1,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-12,7,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-1,11,0,-2,24,0,-3,27,0,-4,30,0,-1,15,0,-2,16,0,-3,17,0,1,4,0,-2,12,0,-3,18,0,-1,21,0,-2,22,0,-3,23,0,1,7,0,1,7,0,0,8,0,-1,10,0,-1,13,0,-1,14,0,1,15,0,1,16,0,1,17,0,-1,19,0,-1,20,0,1,21,0,1,22,0,1,23,0,-1,25,0,-1,26,0,1,26,0,-1,28,0,-1,29,0,1,29,0,-1,31,0,1,31,0,18,1,2,1,5,3,1,10,4,1,14,5,1,11,6,1,20,59],[0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,12,20],[8,8,8,8,62,51,63]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[15,14],[43,29]],[[[40,"Slow Summon_Tornado2"],[203,"Slow Summon_Tornado2",[-2],[238,"94Sq0jzYtOUYIB3Izu94jQ",[],-1,0]],[230,"Loop",[-4,-5,-6,-7,-8],[-3],[1,"f35g/bv2JDHYtdTW2F0OpQ",1,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[225,"Particle",1,[2],[[310,-9,[10,"77KixY10lOU7vdyRQEobBi"],[20],21]],[1,"5f/ln8lztNlIEDDHnPS5ks",1,0]],[105,"Confetti_Particle",2,[-10],[1,"e9oEMtSEFCD72WH/ol8s2d",1,0]],[148,1,false,0.5,10,4,[10,"b615rXNVZOkaAqalmbWHKY"],[0,1],[43,1,[67,[[132,[4,4282203647]],[26,0.16294642857142858,[4,4281769471]],[26,0.36607142857142855,[4,4284546303]],[26,0.638,[4,4282185886]],[26,0.8861607142857143,[4,4294961453]]],[[77,255],[17,255,0.004464285714285714]]]],[41,3,0.1,0.8],[7],[7],[41,3,5,8],[7],[7],[133,1,180,[23,[0,1],[[13,2,-0.8296296296296297],[13,2,1]]]],[7],[41,3,0.5,1],[7],[16,5],[7],[[149,2,20,10,[7]]],[183,true,[43,1,[67,[[26,0.3058035714285714,[4,33554431]],[26,0.4575892857142857,[4,30670591]]],[[77,0],[17,255,0.13616071428571427],[17,255,0.5848214285714286],[17,0,0.9821428571428571]]]]],[184,true,0,1.594,3,0,0.39941859931890233,[16,1]],[94,true,[27,1,[23,[0,0.21025641025641026,0.8179487179487179],[[13,2,-0.014814814814814814],[13,2,0.5851851851851851],[13,2,0.8888888888888888]]]],[7],[7],[7]],[150,0,[7],[7],[16,5],[16,1]],[136,0,[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]],[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]],[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]]],[187,true,0.3,[7],[7],[7],[27,1,[23,[0,1],[[13,2,1],[13,2,0.007407407407407408]]]]],[137,true,[7],[7],[16,3.141592653589793]],[152,5,1,1,true,1,[27,1,[23,[0,0.9897435897435898],[[13,2,1],[134,2]]]],[7]],[153,1,true,1,[16,1],[16,0.05],[63],[43,1,[131,[[17,7,0.004464285714285714],[17,255,0.17633928571428573],[17,255,0.8013392857142857],[17,12,0.9866071428571429]]]],-11],[154,2,3]],[105,"Confetti_Particle-001",2,[-12],[1,"98xhROvGdIPoSg3QUf9h+y",1,0]],[148,1,false,0.5,10,6,[10,"e4BdczZRZFsq0axbldS3nu"],[4,5],[43,1,[67,[[132,[4,4282203647]],[26,0.16294642857142858,[4,4281769471]],[26,0.36607142857142855,[4,4284546303]],[26,0.638,[4,4282185886]],[26,0.8861607142857143,[4,4294961453]]],[[77,255],[17,255,0.004464285714285714]]]],[41,3,0.1,0.8],[7],[7],[41,3,5,8],[7],[7],[133,1,180,[23,[0,1],[[13,2,-0.8296296296296297],[13,2,1]]]],[7],[41,3,0.5,1],[7],[16,5],[7],[[149,2,20,10,[7]]],[135,[43,1,[67,[[26,0.3058035714285714,[4,33554431]],[26,0.4575892857142857,[4,30670591]]],[[77,0],[17,255,0.13616071428571427],[17,255,0.5848214285714286],[17,0,0.9821428571428571]]]]],[185,true,0,0.892,1,0.39941859931890233,[16,1]],[94,true,[27,1,[23,[0,0.18205128205128204,0.782051282051282],[[13,2,-0.014814814814814814],[13,2,0.8592592592592593],[13,2,0.9851851851851852]]]],[7],[7],[7]],[324,true,0,[7],[7],[16,10],[16,-2]],[136,0,[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]],[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]],[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]]],[327,0.3,[7],[7],[7],[27,1,[23,[0,1],[[13,2,1],[13,2,0.007407407407407408]]]]],[137,true,[7],[7],[16,3.141592653589793]],[152,5,1,1,true,1,[27,1,[23,[0,0.9897435897435898],[[13,2,1],[134,2]]]],[7]],[153,1,true,1,[16,1],[16,0.05],[63],[43,1,[131,[[17,7,0.004464285714285714],[17,255,0.17633928571428573],[17,255,0.8013392857142857],[17,12,0.9866071428571429]]]],-13],[154,6,7]],[105,"Confetti_Particle-002",2,[-14],[1,"24i8e2YYtE9bOs2FiQfxsR",1,0]],[148,1,false,0.5,10,8,[10,"85EWZgajlGWLnvVdcXcawA"],[8,9],[43,1,[67,[[132,[4,4282203647]],[26,0.16294642857142858,[4,4281769471]],[26,0.36607142857142855,[4,4284546303]],[26,0.638,[4,4282185886]],[26,0.8861607142857143,[4,4294961453]]],[[77,255],[17,255,0.004464285714285714]]]],[41,3,0.1,0.8],[7],[7],[41,3,6,9],[7],[7],[133,1,180,[23,[0,1],[[13,2,-0.8296296296296297],[13,2,1]]]],[7],[41,3,0.5,1],[7],[16,5],[7],[[149,2,5,5,[7]]],[135,[43,1,[67,[[26,0.3058035714285714,[4,33554431]],[26,0.4575892857142857,[4,30670591]]],[[77,0],[17,255,0.13616071428571427],[17,255,0.5848214285714286],[17,0,0.9821428571428571]]]]],[185,true,0,2,0,0.39941859931890233,[16,1]],[94,true,[27,1,[23,[0,0.18205128205128204,0.782051282051282],[[13,2,-0.014814814814814814],[13,2,0.8592592592592593],[13,2,0.9851851851851852]]]],[7],[7],[7]],[150,0,[7],[7],[16,10],[7]],[136,0,[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]],[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]],[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]]],[187,true,0.3,[7],[7],[7],[27,1,[23,[0,1],[[13,2,1],[13,2,0.007407407407407408]]]]],[137,true,[7],[7],[16,3.141592653589793]],[152,5,1,1,true,1,[27,1,[23,[0,0.9897435897435898],[[13,2,1],[134,2]]]],[7]],[153,1,true,1,[16,1],[16,0.05],[63],[43,1,[131,[[17,7,0.004464285714285714],[17,255,0.17633928571428573],[17,255,0.8013392857142857],[17,12,0.9866071428571429]]]],-15],[154,10,11]],[229,"Particle",2,[-16],[1,"ee32AHLDlNVrXOZIIC2QvM",1,0],[1,0,0,-2.308],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,-89.99999999999999,0,0]],[312,3,false,1,10,[10,"16TzDGcvxEz73JGX3bVb1A"],[12],[63],[16,6],[7],[7],[7],[7],[7],[7],[7],[16,3],[7],[16,0.5],[7],[[182,[16,1]]],[135,[63]],[321,true,3,0,0,[16,1]],[323,[7],[7],[7],[7]],[186,[7],[7],[7],[16,1]],[325,[7],[7],[7]],[151,[7],[7],[7],[7]],[188,[7],[7],[7]],[328,true,6,6,1,[27,1,[23,[0,1],[[317,1,1,1,1],[318,1,1,1,1,1]]]],[7]],[190,[16,1],[7],[63],[63],-17],[191,13]],[105,"Star",2,[-18],[1,"11L1FXudRIRZgjdFVyMQve",1,0]],[314,3,false,12,[10,"3f2eD7h5NG0LWRjmW56tac"],[[14,null],6,0],[43,1,[315,[[26,0.18526785714285715,[4,4281769471]],[26,0.296875,[4,4284546303]],[26,0.6875,[4,4282185886]]]]],[41,3,0.1,2],[7],[7],[41,3,2,3],[7],[7],[7],[7],[41,3,2.5,3],[7],[16,1],[7],[[182,[16,20]]],[183,true,[43,1,[67,[[316,0.03571428571428571]],[[17,0,0.07589285714285714],[17,255,0.1875],[17,138,0.3125],[17,255,0.43973214285714285],[17,168,0.5491071428571429],[17,255,0.6049107142857143],[17,255,0.7321428571428571],[17,0,0.8683035714285714]]]]],[322,true,0,true,[16,1]],[94,true,[27,1,[23,[0.02564102564102564,0.18205128205128204,0.6076923076923076,1],[[13,2,0.3148148148148148],[13,2,1],[13,2,0.9592592592592593],[13,2,0.362962962962963]]]],[7],[7],[7]],[186,[7],[7],[7],[16,1]],[326,true,0,[7],[7],[16,2]],[151,[7],[7],[7],[7]],[137,true,[7],[7],[41,3,0.8726646259971648,1.3962634015954636]],[189,[27,1,[23,[0,1],[[13,2,1],[13,2,1]]]],[7]],[190,[16,1],[7],[63],[63],-19],[191,15]],[313,2,false,10,2,[10,"3bAwvElMpMMZjulFKgj4Ts"],[16,17],[43,1,[67,[[132,[4,4282203647]],[26,0.16294642857142858,[4,4281769471]],[26,0.36607142857142855,[4,4284546303]],[26,0.638,[4,4282185886]],[26,0.8861607142857143,[4,4294961453]]],[[77,255],[17,255,0.004464285714285714]]]],[16,5],[7],[7],[41,3,0.8,1.8],[7],[7],[133,1,180,[23,[0,1],[[13,2,-0.8296296296296297],[13,2,1]]]],[7],[41,3,0.8,1.2],[7],[16,2],[7],[135,[43,1,[67,[[26,0.3058035714285714,[4,33554431]],[26,0.4575892857142857,[4,30670591]]],[[77,0],[17,255,0.13616071428571427],[17,255,0.5848214285714286],[17,0,0.9821428571428571]]]]],[184,true,0,0,3,9.226,0.39941859931890233,[16,1]],[94,true,[27,1,[23,[0,0.23076923076923078,0.4641025641025641,0.7051282051282052,1],[[319,2,-0.057777777777777775,-0.057777777777777775],[320,2,0.7222222222222222,0.5555555555555556,0.5555555555555556],[13,2,0.4185185185185185],[13,2,1],[134,2]]]],[7],[7],[7]],[150,0,[7],[7],[16,5],[16,1]],[136,0,[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]],[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]],[27,1,[23,[0,1],[[13,2,1],[13,2,-1]]]]],[151,[7],[7],[7],[7]],[188,[7],[7],[16,0.8726646259971648]],[189,[27,1,[23,[0,1],[[13,2,1],[13,2,1]]]],[7]],[329,true,1,true,1,[16,1],[16,0.05],[63],[43,1,[131,[[17,7,0.004464285714285714],[17,255,0.17633928571428573],[17,255,0.8013392857142857],[17,12,0.9866071428571429]]]],-20],[330,2,18,19]]],0,[0,4,1,0,-1,3,0,-1,14,0,-1,4,0,-2,6,0,-3,8,0,-4,10,0,-5,12,0,0,3,0,-1,5,0,24,5,0,-1,7,0,24,7,0,-1,9,0,24,9,0,-1,11,0,24,11,0,-1,13,0,24,13,0,24,14,0,18,1,2,1,3,20],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,12,25,-1,-2,12,25,-1,-2,12,25,-1,25,-1,25,-1,-2,12,25,-1,31],[167,52,30,89,168,52,30,90,169,52,30,91,170,92,171,93,172,52,30,87,94,94]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{},{}],[[[{},"mainColor",8,[4,16777215]],{},{}],11,0,0]]],0,0,[0],[14],[29]],[[[121,[[122,[123,[-14,-15,-16,-17,-18,-19],[[124,-5,-4],[72,0,-7,-6,[[125,1,[74,"velocity"],[75]]]],[72,0,-9,-8,[[126,[74,"velocity"],[75]]]],[73,false,-11,-10,[[128,1,[76,"EatFood"]]]],[73,false,-13,-12,[[127,[76,"EatFood"]]]]],-3,-2,-1]]],[{},"velocity",4,[129],"EatFood",4,[130,1,false]]],[51,"Idle",[52,0]],[53,"Entry"],[51,"Run",[52,1]],[51,"Eat",[52,2]],[53,"Exit"],[53,"Any"]],0,[0,28,6,0,29,5,0,30,2,0,16,1,0,17,2,0,16,3,0,17,1,0,16,1,0,17,3,0,16,1,0,17,4,0,16,4,0,17,1,0,-1,2,0,-2,5,0,-3,6,0,-4,1,0,-5,3,0,-6,4,19],[0,0,0],[19,19,19],[9,14,22]],[[[40,"Food_Seaweed"],[103,"Food_Seaweed",[-3],[[147,1,-2,[10,"18XFFtjY9BUY7wZ1m9PaDG"]]],[1,"ee9LrN7tNcaYoON4jeTkFo",-1,0],[1,0.2,0.2,0.2]],[64,"Food_Seaweed",1,[[114,-4,[10,"92zFs6bT1SKoRdwKB4Y0AR"],[0],[29],1]],[1,"a9DNsBItRSZLYa2jQjPOIE",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,4,1,0,0,1,0,-1,2,0,0,2,0,18,1,4],[0,0],[-1,12],[173,174]],[[[119],[102,"VD302_Kangaroo_Rig",[[-3,-4,[4,"Bn_FoodSpawn",-6,[1,"f3CmudYmJTjK7M6nViAmg5",-5,0],[1,-5.4358654466568623e-8,0.009165484458208084,0.8870136737823486],[3,1.545431187269876e-8,-0.707106721581899,1.5454308319985022e-8,0.7071068407911907],[1,0.0000025044781562438738,-89.99999034065368,-7.67592264999771e-14]]],1,1,4],[[110,-2,[10,"08p3MFuydXL4oM9CbjboO3"]]],[1,"8fJHyWPHhT77T0qzBIqM/Z",-1,0]],[48,"Bip001 Head",[[[4,"Bip001 Xtra_Eyelid_up_L",-7,[1,"2d7+KWFQJVFrgz3wx2r7Yn",1,0],[1,0.3271970748901367,0.4205749034881592,-0.18183529376983643],[3,-0.24522146530069025,-0.4163162103317173,0.8753637652717497,0.016897467860142394],[1,132.17461490430898,154.7176502037449,13.518670197215748]],[4,"Bip001 Xtra_Eyelid_up_R",-8,[1,"a5xYRu1R9c+4gSl9Nkoyrr",1,0],[1,0.3271970748901367,0.4205739498138428,0.18183764815330505],[3,0.24522088155166882,0.4163115567490713,0.8753661401629665,0.016897562675627805],[1,-132.17519821674765,-154.71765267277706,13.518521573560058]],[4,"Bip001 Xtra_Eyelid_Low_L",-9,[1,"bbzAt+/A5Za6JtvBJFLV6Q",1,0],[1,0.21905755996704102,0.41451358795166016,-0.20157299935817719],[3,0.4409942824246951,-0.040964274662843414,0.025457053795126677,0.8962130937908391],[1,52.42644045172507,-5.502120724866701,0.5443105331507334]],[4,"Bip001 Xtra_Eyelid_Low_R",-10,[1,"8bMDwNbY5Up6fKdikNpIQL",1,0],[1,0.21905755996704102,0.41451263427734375,0.20157529413700104],[3,-0.4409942824517709,0.040964133104330384,0.025457279176747588,0.896213093845864],[1,-52.426441892868866,5.502117589864751,0.5443408344453377]],[4,"Bip001 Xtra_Eye_R",-11,[1,"c2tjMLgltSz7/DvasIQO6O",1,0],[1,0.2641632556915283,0.35110998153686523,-0.14128649234771729],[3,-0.27964436716809643,0.1581443084705726,0.682003014140958,0.6570093563353323],[1,-98.45224704751105,88.08277038553146,53.873413080213766]],[4,"Bip001 Xtra_Eye_L",-12,[1,"6bI877qbhcC6ioHfi85K1R",1,0],[1,0.2641632556915283,0.35110926628112793,0.1412884145975113],[3,0.27964439645134875,-0.15814812287424745,0.6820021188053784,0.657009355115806],[1,98.4519445966391,-88.08278231192374,53.87309036235816]],[4,"Bip001 Xtra_Mouth_Cor_R",-13,[1,"ed/f9Db/pZuZRZD4YWAqds",1,0],[1,-0.03132891654968262,0.5618903636932373,-0.11657057702541351],[3,0.04929766191040832,-0.0604126283325885,0.7993534421572859,0.5957802693774057],[1,151.22228257200177,-152.1352089628443,71.17731919294856]],[4,"Bip001 Xtra_Mouth_Cor_L",-14,[1,"e9ki9vW3ha/oTYOTJfAkl8",1,0],[1,-0.03132891654968262,0.5618896484375,0.11657369136810303],[3,-0.04929762034087917,0.06040812745717985,0.7993537901967565,0.595780262230903],[1,-151.22349829367852,152.13605821250368,71.17747050798812]],[4,"Bip001 Xtra_Mouth_Up_R",-15,[1,"20BgvTdsleXrtRxNyWlh//",1,0],[1,-0.04088473320007324,0.6360740661621094,-0.06928008049726486],[3,-0.0038198481848174207,0.0019246733316340729,0.7995733037055219,0.6005532752336371],[1,-178.42422555767092,178.26911750409243,73.81321923996768]],[4,"Bip001 Xtra_Mouth_Up_L",-16,[1,"7cMoqyptdaSbxJ3NJe5s4D",1,0],[1,-0.04088473320007324,0.6360738277435303,0.0692836120724678],[3,0.003819830457478615,-0.0019290845247500956,0.7995732969633009,0.6005532701696075],[1,178.42278052602967,-178.26803494978196,73.813208998766]],[4,"Bip001 Xtra_Teath_Up",-17,[1,"34N3Tf3Vhf6p2OCEtjbUr5",1,0],[1,0.002314329147338867,0.554196834564209,0.000004309463747631526],[3,9.336697845026691e-7,1.9915808695504157e-7,0.8147948658617054,0.5797493652989147],[1,179.9998674950161,-179.99977440903933,70.86583252141891]],-18,[4,"Bip001 Xtra_EarL",-19,[1,"3dlgK1+6ZS+pIxXuBluE25",1,0],[1,0.6298751831054688,-0.04161977767944336,0.21326301991939545],[3,0.17229719240550637,-0.3286434668165523,0.041136212122997444,0.9276933551880974],[1,20.3010491465256,-38.635362133307176,-2.1161341392427624]],[4,"Bip001 Xtra_EarR",-20,[1,"68RNEaQ79QPq60RxDOrbld",1,0],[1,0.6298751831054688,-0.04161834716796875,-0.21326324343681335],[3,-0.17229802753627552,0.32864299124926405,0.04113777690385765,0.9276932991680245],[1,-20.30120120360858,38.635335030936766,-2.1159900209997105]],[4,"Bip001 Xtra_eyebrownR",-21,[1,"a5O6YJyIlZ0K3DMvMImW/M",1,0],[1,0.3929600715637207,0.4532432556152344,-0.1358882188796997],[3,-0.23773379651555063,0.542546868955643,-0.31570294536135707,0.7412537941021924],[1,-0.8227543143827625,72.04920289475375,-46.5517219786071]],[4,"Bip001 Xtra_eyebrownL",-22,[1,"ccJkUI+3RXpZAAZAVToHx+",1,0],[1,0.3929600715637207,0.45324230194091797,0.13589075207710266],[3,0.23773374855793258,-0.542545073389861,-0.3157059510744924,0.7412538435604459],[1,0.8225775813222904,-72.04909199221025,-46.55202036838682]],[4,"Bip001 Xtra11_Nose",-23,[1,"beBTxB4F9YIazSRhrqCQYQ",1,0],[1,0.15001845359802246,0.7634279727935791,0.0000010193798516411334],[3,1.9258151975219854e-12,-0.0000027674523216948566,0.9977835439810513,0.06654321417661394],[1,179.99968074891942,-179.99997870859482,7.630929361688651]],[4,"Bn_Mouth",-24,[1,"84hrPyzk1d1ruBlx05r4WZ",1,0],[1,-0.07195711135864258,0.5386135578155518,0.008439688943326473],[3,-0.46549811987707945,-0.5231723192550453,-0.44354066279808146,0.559351325376851],[1,-80.02761183493475,-86.61028004033459,-0.5224675849989031]]],4,4,4,4,4,4,4,4,4,4,4,1,4,4,4,4,4,4],[1,"bfrFfxzL1T1KmmYCwEZLjk",1,0],[1,0.271028995513916,0.1483471393585205,-1.397716005158145e-7],[3,-4.7459346984729076e-7,0.0000010302596964508388,-0.31471839988255196,0.9491850866791363],[1,-0.000018038935986709043,0.0001183982779817365,-36.6876293880894]],[47,"Bip001 Spine",[-25,-26,-27,-28],[1,"24QV1ABdRedL8PrNu+86Nq",1,0],[1,0.3542376756668091,0.3531496524810791,-0.0000013134826986060943],[3,-0.0000018851790819067795,-0.0000011795759439423908,0.06960712936962687,0.9975744821996876],[1,-0.00020810952367528602,-0.00012097697166633093,7.982844695585415]],[48,"Bip001 L Hand",[[-29,-30,-31,[4,"Bn_Hand",-32,[1,"cdSHSn+iNTHKbOD/PLegz3",1,0],[1,0.16577750444412231,0.06132864952087402,-0.046974703669548035],[3,-0.3996487816964595,0.9162200003981678,-0.011799826171741228,-0.02612520356348691],[1,3.5752087539781954,-175.1773245504443,-47.03043486089243]]],1,1,1,4],[1,"0516pAzllTEINtCBbXwvaI",1,0],[1,0.5944492220878601,0,-2.220446049250313e-16],[3,-0.2617311703737297,0.029688528854133044,0.3459904396792379,0.9005031934201249],[1,-38.26907185297872,17.178544816200937,37.415459422889654]],[47,"Bip001 Neck",[2,-33,-34],[1,"42dhuQU8NX0rXxQG7SW2YE",1,0],[1,0.5762070417404175,-0.12533974647521973,9.96238668449223e-7],[3,1.2697269418175673e-13,8.642778814821149e-7,-0.31160864818281975,0.9502105295022409],[1,0.000038299085695490824,0.00011678809352825268,-36.312403738338894]],[47,"Bip001 R Hand",[-35,-36,-37],[1,"04ZamzRGFcKJpv5KTVe1wf",1,0],[1,0.5944493412971497,-1.1920928955078125e-7,0],[3,0.2617312122116491,-0.029688526494057035,0.345990455589461,0.9005031752247349],[1,38.26907848292041,-17.178547481263575,37.41546049159831]],[14,"Bip001 Xtra_Jaw",2,[[4,"Bip001 Xtra_Teath_Low",-38,[1,"054HrpVJ9YdrFA31Ec+dkY",1,0],[1,0.13749122619628906,-0.031085491180419922,0.0000035714842852030415],[3,0.000004232222292237529,-0.0000038132740061028115,0.03182718986028513,0.9994933866480282],[1,0.0004996510135593257,-0.000453101048055823,3.647743322877986]],[98,"Bip001 Xtra_Tongue",-39,[1,"dfbHKl6RxVqLvXw6Lt14xK",1,0],[1,0.08936405181884766,-0.028061389923095703,0.000004445225840754574],[3,-3.0594311178264103e-7,3.817032550457581e-7,-0.048731250106838264,0.9988119268725146],[1,1,0.9999989867210388,1],[1,-0.00003304227590328229,0.000042179892466667365,-5.586402449871046]]],[1,"d7tLOit5hTsbOMYxHRvFOp",1,0],[1,-0.020290136337280273,0.3777594566345215,-9.088580554816872e-9],[3,-9.235465789091367e-8,-0.0000020748226942927456,0.7911309946054532,0.611646752112911],[1,179.9992786301882,-179.9994556648126,75.41733868808973]],[64,"VD302_Kangaroo_Toy",1,[[66,-40,[10,"08oWDW2JpSa5Knf6tUbF/f"],[0,1,2,3,4],[29],1,5,6]],[1,"5fl0cfxJ5Rs5ovU2QsXaQ9",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Bip001",1,[-41],[1,"61SpoqJn9XKIWNc6m3Gvr3",1,0],[1,-3.732301578907027e-9,1.5775775909423828,0.4474337100982666],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[84,"Bip001 Pelvis",9,[3],[1,"f4npe4uvhfYIaPYyEku12n",1,0],[3,-0.678948057080087,-0.19755655885105733,-0.1975572294033232,0.6789492491730041],[1,-89.99992243324212,-32.44732100165269,-0.00007915718266001345]],[6,"Bip001 Spine1",3,[5],[1,"124ooP3KBc1Lk0UF5SkG6P",1,0],[1,0.4582993984222412,-0.00035309791564941406,-9.790710464585572e-10],[3,2.446313346659477e-13,-1.8054307341607132e-7,0.06509341476946535,0.9978791747268894],[1,0.0000013582370161722287,-0.000020821282842442467,7.46443354701361]],[6,"Bip001 L Clavicle",5,[-42],[1,"36Y+vy/Y5QJ7jAvyy3x9XZ",1,0],[1,-0.290891170501709,0.11437880992889404,0.056595951318740845],[3,0.7404151484820694,0.19713777106521088,0.5926956475105046,-0.24826191117410562],[1,-143.0354460567296,-77.30871903103836,-0.13521382911142363]],[6,"Bip001 L UpperArm",12,[-43],[1,"57Le13NptWs5X3lanB4PyH",1,0],[1,0.2798118591308594,1.1920928955078125e-7,2.384185791015625e-7],[3,-0.24198095521163535,0.5819774871081226,-0.35439729720859986,0.6907604342646003],[1,7.057027719358092,83.55855063844022,-50.46736884718895]],[6,"Bip001 L Forearm",13,[4],[1,"bex7q5czhZfLRNzKYoBLyx",1,0],[1,0.5204557180404663,1.1920928955078125e-7,-1.1920928955078125e-7],[3,-8.996704747186443e-18,-2.969889326223742e-17,-0.6873185419958124,0.7263561260351223],[1,-5.595479079571909e-14,-5.763289687687109e-14,-86.83644251224672]],[14,"Bip001 L Finger0",4,[[4,"Bip001 L Finger01",-44,[1,"a6aeXwf6BZdI+Q2cVg8FCt",1,0],[1,0.1283271312713623,-2.220446049250313e-16,-5.960464477539063e-8],[3,-0.0005510463967082443,0.04632963244924116,0.01187961922320866,0.9988554130363908],[1,-0.1261771947815869,5.312755955821363,1.356947306578145]]],[1,"40GhtM2Y1bgZOrgy9wQpjf",1,0],[1,0.08157700300216675,0.006247282028198242,-0.12238441407680511],[3,0.9290023395148231,0.3079701645178377,-0.06974732092525232,0.19298793269681716],[1,151.3789632812749,17.241735558793838,33.044430410905846]],[14,"Bip001 L Finger1",4,[[4,"Bip001 L Finger11",-45,[1,"82YHmJYpNUwIRpMz6/x7rh",1,0],[1,0.0953603982925415,-2.384185791015625e-7,5.960464477539063e-8],[3,1.0302478230703421e-8,-1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,0.0000015880320747349408,-0.0000018587233107113073,23.268080227659283]]],[1,"efGIrw9kZbM5dp1NBwHMRu",1,0],[1,0.2140156626701355,0.02871990203857422,-0.07965849339962006],[3,0.14175589132700384,0.05487470977109217,0.29237341365277086,0.9441460800589339],[1,16.628244260928607,1.4427303831348735,34.58610116822202]],[14,"Bip001 L Finger2",4,[[4,"Bip001 L Finger21",-46,[1,"56GP/33ipbt5RscKxkRlan",1,0],[1,0.07172501087188721,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0171859984491851e-17,-1.4991040769140968e-17,0.13798254917676323,0.9904346601985827],[1,-9.53743987823341e-16,-1.601566231679269e-15,15.862243670868283]]],[1,"a3opXY1K1bs63KtREsU6Cj",1,0],[1,0.20017272233963013,0.027018070220947266,0.010468840599060059],[3,0.016227573424614575,-0.07892323415809137,0.25775862166212676,0.9628438512706079],[1,4.745212621468258,-10.625984962258268,29.590727366189885]],[6,"Bip001 R Clavicle",5,[-47],[1,"80Sxap8RleT7LfBkzDAi93",1,0],[1,-0.2908914089202881,0.1143791675567627,-0.056598000228405],[3,0.7404158188458404,0.19713941411025176,-0.5926951228460576,0.24825985974701364],[1,143.03551574473522,77.30872223520217,-0.1349050251337831]],[6,"Bip001 R UpperArm",18,[-48],[1,"94nYA+SUZazqUalPScGfCg",1,0],[1,0.2798118591308594,4.440892098500626e-16,0],[3,0.24198129715613026,-0.5819780812733067,-0.35439678942351904,0.6907600744038257],[1,-7.056981598696757,-83.5586140647127,-50.46734445139137]],[6,"Bip001 R Forearm",19,[6],[1,"39NhMc+jhSCqKPANQHLh8+",1,0],[1,0.5204557180404663,1.1920928955078125e-7,0],[3,4.9317570815256714e-17,-8.45495145977068e-18,-0.6873185717527179,0.7263560978774832],[1,6.231598940146356e-14,5.763298592223944e-14,-86.83644720676268]],[14,"Bip001 R Finger0",6,[[4,"Bip001 R Finger01",-49,[1,"84l6lm3SBYBZ8FSo3q+7NM",1,0],[1,0.11112487316131592,2.220446049250313e-16,-1.1920928955078125e-7],[3,0.0005510246851597509,-0.046329632441594146,0.011879634122409057,0.9988554128715231],[1,0.12617478816212,-5.3127559293270386,1.356949127499545]]],[1,"47JEn10QFZeY7XBihtHdxT",1,0],[1,0.0954056978225708,0.005409955978393555,0.10597886145114899],[3,0.9290023316959993,0.30797019172817003,0.06974726818416987,-0.19298794597372107],[1,-151.37896227054966,-17.241730691025925,33.044434802218554]],[14,"Bip001 R Finger1",6,[[4,"Bip001 R Finger11",-50,[1,"e57STHoJpa0p56K4UDKx2N",1,0],[1,0.09536051750183105,1.1920928955078125e-7,5.960464477539063e-8],[3,-1.0302478230703421e-8,1.3092540701434747e-8,0.2016598630980403,0.9794556139076848],[1,-0.0000015880320747349408,0.0000018587233107113073,23.268080227659283]]],[1,"53/rmZzdJZL463F9C5r7qA",1,0],[1,0.2140156626701355,0.02871990203857422,0.07965849339962006],[3,-0.14175589118211213,-0.0548747283414547,0.2923734133539298,0.9441460790939021],[1,-16.628243493903444,-1.4427328337497123,34.58610145498249]],[14,"Bip001 R Finger2",6,[[4,"Bip001 R Finger21",-51,[1,"6cklssd71bQpgcGHdZO8+Q",1,0],[1,0.07172489166259766,0,0],[3,4.893729611197911e-18,-3.696921671140056e-18,0.13798254917676323,0.9904346601985827],[1,6.381709387020008e-16,-5.16634253009268e-16,15.862243670868283]]],[1,"9fgNNDboxcjIG+O1o8GHRt",1,0],[1,0.20017272233963013,0.027018070220947266,-0.010468810796737671],[3,-0.016227580863691093,0.07892324155272112,0.2577586214793942,0.9628438505880201],[1,-4.745213810691006,10.625986151481015,29.59072722663627]],[6,"Bip001 L Thigh",3,[-52],[1,"1aOCmC7G1QLYh3hQ/RIfCW",1,0],[1,-0.39984893798828125,-0.30053311586380005,0.3836286962032318],[3,0.7178273552306246,0.680038369359236,0.1348885996845741,0.06384958854192135],[1,-126.10226971349779,-70.08105235291427,83.47655542639572]],[6,"Bip001 L Calf",24,[-53],[1,"dbtmT0gRdSBIMmHDpIZtZm",1,0],[1,0.743604302406311,-1.1920928955078125e-7,-2.7755575615628914e-17],[3,0,0,-0.41653967720321833,0.909117537678951],[1,0,0,-49.23262954822765]],[14,"Bip001 L Foot",25,[[4,"Bip001 L Toe0",-54,[1,"0ej8X8mtRS8IOXZwhuA0cA",1,0],[1,0.0993526503443718,0.3203730583190918,0.015012085437774658],[3,-0.012606775107827504,-0.004188367072502582,0.7176545698822673,0.6962725365327463],[1,-159.190288938885,157.82919259324692,88.13791814938088]]],[1,"27lKXEzcFQsZTcP6tappE1",1,0],[1,0.8391543626785278,2.9802322387695312e-8,0],[3,0.09368384456679991,0.04668617534947475,0.18506039337690455,0.9771368323329169],[1,10.282468224363756,3.491167402013983,21.740666790231035]],[6,"Bip001 R Thigh",3,[-55],[1,"abAw8bUFFfbJbDdcCTemu+",1,0],[1,-0.399849534034729,-0.3005313277244568,-0.3836267292499542],[3,0.7178270792704299,0.6800386286793662,-0.134887694859659,-0.06385184057972494],[1,126.10304314074824,70.08038736689647,83.47680202680553]],[6,"Bip001 R Calf",27,[-56],[1,"54Lh51XGBYv7YuKOF5iKJs",1,0],[1,0.7436041831970215,0,5.551115123125783e-17],[3,-5.0466161121084984e-17,2.312259701504717e-17,-0.41653967720321833,0.909117537678951],[1,-6.361109362927037e-15,0,-49.23262954822765]],[14,"Bip001 R Foot",28,[[4,"Bip001 R Toe0",-57,[1,"46OYGFnqVWX54eydGHqJue",1,0],[1,0.09935265779495239,0.320372998714447,-0.01501205563545227],[3,0.012606777493592694,0.004188363055347829,0.7176545996614502,0.6962725058200326],[1,159.19032927263092,-157.8292330582914,88.13791339787937]]],[1,"a0sQDO/bdTOryUmf6KpZ23",1,0],[1,0.8391544222831726,-5.551115123125783e-17,1.4901161193847656e-8],[3,-0.0936838530691832,-0.04668609764253182,0.1850603507511224,0.9771368433033805],[1,-10.282471032387543,-3.4911582401498076,21.740661053193115]],[6,"Bip001 Xtra_Tail",3,[-58],[1,"82O4d8FFlZfbWoM1gQ5T0P",1,0],[1,-0.9858397245407104,-0.43601518869400024,0.000001985863264053478],[3,9.877768196883434e-7,-0.0000026041092780163377,0.9789544108644718,-0.20407905684130798],[1,179.999706525755,-179.99994555523935,-23.551186460093533]],[14,"Bip001 Xtra_Tail1",30,[[4,"Bip001 Xtra_Tail2",-59,[1,"32EOimsNxW6auKvQxSU90n",1,0],[1,0.9689803123474121,-0.0008437633514404297,-2.9117472877260298e-9],[3,3.4403779720176436e-7,5.077550272064185e-7,-0.010108478258240874,0.9999489080282684],[1,0.00004001814766795572,0.00005859195632515687,-1.1583660107752876]]],[1,"b98OsIwtddvaimim2Y6TQy",1,0],[1,0.7776881456375122,-0.0007715225219726562,-2.1395862859208137e-9],[3,1.7354177343170095e-13,2.4402726421175402e-8,-0.008798220935442457,0.9999612949051431],[1,2.4626572286066044e-8,0.000002796671380546391,-1.0082148613665045]]],0,[0,4,1,0,0,1,0,-1,8,0,-2,9,0,4,1,0,1,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-12,7,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-1,11,0,-2,24,0,-3,27,0,-4,30,0,-1,15,0,-2,16,0,-3,17,0,1,4,0,-2,12,0,-3,18,0,-1,21,0,-2,22,0,-3,23,0,1,7,0,1,7,0,0,8,0,-1,10,0,-1,13,0,-1,14,0,1,15,0,1,16,0,1,17,0,-1,19,0,-1,20,0,1,21,0,1,22,0,1,23,0,-1,25,0,-1,26,0,1,26,0,-1,28,0,-1,29,0,1,29,0,-1,31,0,1,31,0,18,1,2,1,5,3,1,10,4,1,14,5,1,11,6,1,20,59],[0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,12,20],[8,8,8,8,62,51,63]],[[[120,"Skin-0",498196334,["Bip001/Bip001 Pelvis","Bip001/Bip001 Pelvis/Bip001 Spine","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_EarL","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot/Bip001 L Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Xtra_Tail","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Xtra_Tail/Bip001 Xtra_Tail1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Xtra_Tail/Bip001 Xtra_Tail1/Bip001 Xtra_Tail2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Teath_Up","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra11_Nose","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Mouth_Cor_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Mouth_Up_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eye_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Jaw","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eyelid_up_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eyelid_Low_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_eyebrownL","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_EarR","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0/Bip001 L Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger2/Bip001 L Finger21","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger1/Bip001 L Finger11","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Jaw/Bip001 Xtra_Teath_Low","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Jaw/Bip001 Xtra_Tongue","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot/Bip001 R Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Mouth_Cor_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Mouth_Up_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eye_R","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eyelid_up_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_eyebrownR","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Xtra_Eyelid_Low_L","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0/Bip001 R Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger2/Bip001 R Finger21","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1/Bip001 R Finger11"],[[[7,-2.2991228831870103e-7,0.0000021223245312285144,1,0,-0.843885064125061,-0.5365239381790161,9.446583248973184e-7,0,0.5365239381790161,-0.843885064125061,0.000001914351514642476,0,-1.223990797996521,1.0912352800369263,-0.000002653238425409654,1],[7,0.0000021580426619038917,-0.0000017917390096044983,1,0,-0.9102181792259216,-0.41412901878356934,0.000001222278569912305,0,0.41412901878356934,-0.9102181792259216,-0.000002524581532270531,0,-1.4604322910308838,0.9501123428344727,0.000005443584086606279,1],[7,0.0000022673089006275404,-0.0000020804122868867125,1,0,-0.9563044905662537,-0.292372465133667,0.0000015599825928802602,0,0.292372465133667,-0.9563044905662537,-0.0000026524064651312074,0,-1.7789958715438843,1.1916745901107788,0.000006113581548561342,1],[7,0.10681141912937164,0.27512702345848083,-0.9554561376571655,0,-0.4466782212257385,-0.8452445864677429,-0.29332584142684937,0,-0.8882960677146912,0.458111971616745,0.03261147439479828,0,1.160521388053894,-1.2064440250396729,0.18384863436222076,1],[7,-0.10681033879518509,-0.2751246392726898,-0.9554569125175476,0,-0.44667848944664,-0.845245361328125,0.29332321882247925,0,-0.8882960081100464,0.45811203122138977,-0.03261130675673485,0,1.1605212688446045,-1.206444501876831,-0.18384996056556702,1],[7,0.0000013430887975118821,-0.0000014026934422872728,1,0,6.123234262925839e-17,-1,-0.0000014026934422872728,0,1,1.8840031531380808e-12,-0.0000013430887975118821,0,-2.076772928237915,-2.1481194496154785,-0.000003301154720247723,1],[7,0.623935878276825,0.2926383912563324,0.7246147394180298,0,0.03692517429590225,-0.9372434616088867,0.34671449661254883,0,0.7806026339530945,-0.18957112729549408,-0.5955855250358582,0,-2.168097972869873,-1.5236104726791382,2.1878583431243896,1],[7,0.02202714793384075,0.0956166461110115,-0.9951744675636292,0,0.009938792325556278,-0.995387852191925,-0.09541713446378708,0,-0.9997080564498901,-0.007789065130054951,-0.022875864058732986,0,0.13629859685897827,-0.5169750452041626,0.3017520010471344,1],[7,0.10710428655147552,-0.0014616863336414099,-0.994246780872345,0,-0.993991494178772,0.022551216185092926,-0.1071099266409874,0,0.022578034549951553,0.9997446537017822,0.0009624279337003827,0,-0.8415331840515137,-0.01824263297021389,0.27608951926231384,1],[7,-0.13862541317939758,0.26055049896240234,-0.9554561376571655,0,0.3484842777252197,-0.890235185623169,-0.29332584142684937,0,-0.9270067811012268,-0.37362387776374817,0.03261147066950798,0,1.1859633922576904,-0.4720359742641449,0.18384864926338196,1],[7,-3.912690829110943e-7,-0.000002997001274707145,1,0,0.9998729825019836,0.015939252451062202,4.389893035749992e-7,0,-0.015939252451062202,0.9998729825019836,0.0000029903837912570452,0,-0.11879183351993561,-1.460300087928772,-0.000004473049102671212,1],[7,-3.872775948821072e-7,-0.000003003851134053548,1,0,0.999437689781189,0.03353030979633331,4.877799142377626e-7,0,-0.03353030979633331,0.999437689781189,0.0000029891764370404417,0,-0.870659589767456,-1.4750769138336182,-0.000004514033662417205,1],[7,0.9755656123161316,-0.13394685089588165,-0.17415523529052734,0,-0.1293656975030899,0.2904920279979706,-0.9480922818183899,0,0.1775846928358078,0.9474558234214783,0.26606589555740356,0,-0.5785400867462158,-1.0337923765182495,-2.120706558227539,1],[7,0.2831258773803711,0.24831736087799072,0.9263790845870972,0,0.3663841784000397,0.8646398186683655,-0.34374475479125977,0,-0.8863420486450195,0.4367336332798004,0.1538223773241043,0,2.077375650405884,0.7522141337394714,-1.1922980546951294,1],[7,-0.23231428861618042,0.29639819264411926,0.9263790249824524,0,-0.843102753162384,0.4135422110557556,-0.34374481439590454,0,-0.4849821925163269,-0.8608895540237427,0.1538223773241043,0,-0.6651468276977539,1.5960592031478882,-1.1922980546951294,1],[7,-0.213507741689682,-0.08444567769765854,0.9732848405838013,0,-0.30786123871803284,0.9513128995895386,0.015004347078502178,0,-0.9271654486656189,-0.29643312096595764,-0.2291102409362793,0,0.29363712668418884,2.337261199951172,-0.08092508465051651,1],[7,0.0000014165001402943744,-8.723572477720154e-7,1,0,-0.597450852394104,-0.8019054532051086,1.4674117210233817e-7,0,0.8019054532051086,-0.597450852394104,-0.000001657090024309582,0,-2.6777422428131104,-0.33347174525260925,5.395536391006317e-7,1],[7,-0.9755649566650391,0.13394547998905182,-0.1741597205400467,0,-0.12937031686306,0.2904926538467407,0.948091447353363,0,0.1775846779346466,0.9474558234214783,-0.26606592535972595,0,-0.5785455107688904,-1.0337915420532227,2.1207056045532227,1],[7,-0.0000013488855756804696,-0.0000023332913769991137,1,0,0.9985556602478027,0.05372799560427666,0.0000014723001413585735,0,-0.05372799560427666,0.9985556602478027,0.0000022574481590709183,0,-1.809460997581482,-1.5111218690872192,-0.0000053369362831290346,1],[7,-1.2642155411413114e-7,0.0000018987676639881101,1,0,-0.9447540640830994,0.3277801275253296,-7.418154837068869e-7,0,-0.3277801275253296,-0.9447540640830994,0.0000017524298527860083,0,-1.8715406656265259,2.849992513656616,-0.000012257460184628144,1],[7,1.820463069179823e-7,-0.000004132366029807599,1,0,-0.13279256224632263,0.9911437630653381,0.000004119944151170785,0,-0.9911437630653381,-0.13279256224632263,-3.683135219034739e-7,0,1.8204394578933716,3.1814632415771484,0.000009789751857169904,1],[7,-0.1507934033870697,0.03783423453569412,0.987841010093689,0,-0.9465226531028748,0.282792329788208,-0.15531708300113678,0,-0.28523018956184387,-0.9584346413612366,-0.006832254584878683,0,-1.9640837907791138,2.722384452819824,-0.5220943093299866,1],[7,0.008424214087426662,0.001503507373854518,0.9999633431434631,0,-0.9603582620620728,0.278662770986557,0.007671574596315622,0,-0.2786410450935364,-0.9603877067565918,0.0037914214190095663,0,-2.1071245670318604,2.730989933013916,-0.055643029510974884,1],[7,0.5892452001571655,0.15174312889575958,0.7935767769813538,0,-0.8077134490013123,0.08665431290864944,0.5831723809242249,0,0.019725549966096878,-0.9846141338348389,0.17362560331821442,0,-2.148092031478882,2.5000483989715576,0.9389092922210693,1],[7,0.0000010344812153562088,-0.00000304272657558613,1,0,-0.9677857756614685,0.25177520513534546,0.0000017672391550149769,0,-0.25177520513534546,-0.9677857756614685,-0.000002684250603124383,0,-1.9267382621765137,2.6261889934539795,0.000007445625215041218,1],[7,0.4152470529079437,0.7371376752853394,0.5331021547317505,0,-0.2337615191936493,0.6527981162071228,-0.7205623388290405,0,-0.8791617155075073,0.17459262907505035,0.4433869421482086,0,1.4375085830688477,1.1230813264846802,-3.0137319564819336,1],[7,-0.0958782434463501,-0.788364827632904,0.6076908707618713,0,-0.00949897337704897,-0.6097509264945984,-0.7925361394882202,0,0.9953477382659912,-0.08175940811634064,0.05097319558262825,0,-2.290165662765503,-1.2159446477890015,-2.2705013751983643,1],[7,0.6542202830314636,0.6950106024742126,0.29825499653816223,0,0.7259984016418457,-0.6876254677772522,0.00987104419618845,0,0.2119482159614563,0.21007481217384338,-0.9544351696968079,0,1.2762246131896973,-2.40203857421875,2.342348098754883,1],[7,-0.4587996006011963,0.24139876663684845,-0.8551197052001953,0,0.2685454785823822,-0.8797081112861633,-0.3924235999584198,0,-0.8469869494438171,-0.4096819758415222,0.33878323435783386,0,1.4305472373962402,-1.5750685930252075,-0.976220428943634,1],[7,-0.6239359378814697,-0.29264163970947266,0.7246133685112,0,0.036924704909324646,-0.937241792678833,-0.3467191755771637,0,0.7806023955345154,-0.1895744502544403,0.5955846905708313,0,-2.1680946350097656,-1.523597240447998,-2.187870740890503,1],[7,-0.24382926523685455,0.33969470858573914,0.9083805084228516,0,0.28632235527038574,0.9201139211654663,-0.2672272026538849,0,-0.9265890717506409,0.19493180513381958,-0.32161274552345276,0,1.375985860824585,1.7779854536056519,-0.5302243828773499,1],[7,-0.06811316311359406,0.02415967918932438,0.9973849654197693,0,0.20904749631881714,0.9778598546981812,-0.009410499595105648,0,-0.9755297899246216,0.20785993337631226,-0.07165571302175522,0,1.2060257196426392,1.9562736749649048,-0.2698199152946472,1],[7,-0.3718286454677582,0.25224223732948303,-0.8933741450309753,0,0.28280961513519287,-0.8858461976051331,-0.3678242564201355,0,-0.8841734528541565,-0.38942211866378784,0.2580465078353882,0,1.3493281602859497,-1.6055940389633179,-0.8549889922142029,1],[7,-0.05891624465584755,0.04185635223984718,0.9973849654197693,0,0.4683610796928406,0.8834865689277649,-0.009410044178366661,0,-0.8815698623657227,0.4665820896625519,-0.07165566831827164,0,1.625807523727417,1.5717490911483765,-0.2698189914226532,1],[7,-0.08980692923069,0.4083864986896515,0.9083806872367859,0,0.6265106797218323,0.7321711778640747,-0.26722678542137146,0,-0.7742215991020203,0.5451115369796753,-0.32161247730255127,0,1.8788316249847412,1.1274861097335815,-0.5302237272262573,1],[7,0.000008730880836083088,0.000005115045496495441,1,0,-0.9498062133789062,0.31283774971961975,0.000006692473107250407,0,-0.31283754110336304,-0.949806809425354,0.000007589652796013979,0,-1.8909850120544434,2.783221960067749,-0.0000040729460124566685,1],[7,5.930592124059331e-7,-0.0000035909574762627017,1,0,-0.9876986742019653,0.15636876225471497,0.0000011472766345832497,0,-0.15636862814426422,-0.9876995086669922,-0.000003454045781836612,0,-2.264909029006958,2.4453847408294678,0.0000029631078177771997,1],[7,0.13862431049346924,-0.2605481743812561,-0.9554569125175476,0,0.3484846353530884,-0.8902359008789062,0.293323278427124,0,-0.9270068407058716,-0.3736238479614258,-0.03261130675673485,0,1.18596351146698,-0.4720363914966583,-0.18384990096092224,1],[7,-0.02202717401087284,-0.09561396390199661,-0.995174765586853,0,0.009938732720911503,-0.9953881502151489,0.09541445970535278,0,-0.9997080564498901,-0.007789065130054951,0.022875864058732986,0,0.13629856705665588,-0.5169752240180969,-0.30175334215164185,1],[7,-0.10710158199071884,0.0014616352273151278,-0.9942470788955688,0,-0.9939919114112854,0.0225512832403183,0.10710721462965012,0,0.022578099742531776,0.999744713306427,-0.0009624242084100842,0,-0.8415333032608032,-0.018242577090859413,-0.2760908901691437,1],[7,-0.2831268906593323,-0.24831974506378174,0.9263781309127808,0,0.3663834035396576,0.864639163017273,0.3437473177909851,0,-0.8863420486450195,0.4367336630821228,-0.1538223773241043,0,2.0773754119873047,0.7522141933441162,1.1923000812530518,1],[7,0.23231659829616547,-0.2963992953300476,0.9263781309127808,0,-0.8431020975112915,0.41354137659072876,0.3437473475933075,0,-0.4849821627140045,-0.8608895540237427,-0.1538223773241043,0,-0.6651470065116882,1.596058964729309,1.1923000812530518,1],[7,0.21350860595703125,0.08444306999444962,0.9732848405838013,0,-0.30786067247390747,0.9513130187988281,-0.015001680701971054,0,-0.9271654486656189,-0.29643312096595764,0.2291102558374405,0,0.2936372756958008,2.337261915206909,0.08092702180147171,1],[7,0.15079596638679504,-0.03784048184752464,0.987840473651886,0,-0.9465222358703613,0.2827913463115692,0.15532134473323822,0,-0.2852301597595215,-0.9584347009658813,0.006826938595622778,0,-1.9640837907791138,2.722381591796875,0.5221090912818909,1],[7,-0.008421581238508224,-0.0015098185976967216,0.9999634027481079,0,-0.9603583216667175,0.2786628305912018,-0.007667286787182093,0,-0.27864107489585876,-0.960387647151947,-0.003796749282628298,0,-2.1071248054504395,2.730989456176758,0.05565791204571724,1],[7,-0.5892429351806641,-0.15174777805805206,0.7935775518417358,0,-0.8077150583267212,0.08665712177753448,-0.5831696391105652,0,0.019725549966096878,-0.9846131801605225,-0.17363105714321136,0,-2.1480917930603027,2.500053644180298,-0.938895583152771,1],[7,-0.4152464270591736,-0.7371426224708557,0.5330958962440491,0,-0.23376278579235077,0.6527919769287109,0.7205675840377808,0,-0.8791617155075073,0.17459513247013092,-0.4433860778808594,0,1.4375083446502686,1.1230642795562744,3.0137386322021484,1],[7,-0.654222309589386,-0.6950103044509888,0.29825112223625183,0,0.7259965538978577,-0.6876273155212402,-0.009874043054878712,0,0.2119482010602951,0.21006949245929718,0.9544363021850586,0,1.2762247323989868,-2.4020254611968994,-2.3423614501953125,1],[7,0.09587827324867249,0.7883630990982056,0.6076930165290833,0,-0.009498710744082928,-0.6097531318664551,0.792534351348877,0,0.9953477382659912,-0.08175912499427795,-0.050973646342754364,0,-2.290165662765503,-1.2159574031829834,2.270494222640991,1],[7,0.4587988257408142,-0.24139617383480072,-0.855120837688446,0,0.26854678988456726,-0.8797087669372559,0.3924211263656616,0,-0.8469869494438171,-0.40968194603919983,-0.33878326416015625,0,1.424010157585144,-1.5891488790512085,0.9613828063011169,1],[7,0.24382849037647247,-0.3396972119808197,0.9083797335624695,0,0.28632304072380066,0.9201129078865051,0.26722967624664307,0,-0.9265890717506409,0.1949317902326584,0.32161277532577515,0,1.3759866952896118,1.7779853343963623,0.5302263498306274,1],[7,0.06811259686946869,-0.02416236512362957,0.9973849654197693,0,0.20904769003391266,0.977859616279602,0.009413241408765316,0,-0.9755297899246216,0.20785990357398987,0.07165572792291641,0,1.2060259580612183,1.9562740325927734,0.2698219418525696,1],[7,0.3718278110027313,-0.25223955512046814,-0.8933753371238708,0,0.2828107178211212,-0.8858469128608704,0.3678215742111206,0,-0.8841734528541565,-0.38942208886146545,-0.25804653763771057,0,1.3582377433776855,-1.6199241876602173,0.8392590284347534,1],[7,0.05891496315598488,-0.04185879975557327,0.9973850250244141,0,0.4683612585067749,0.8834863305091858,0.009412799961864948,0,-0.8815698027610779,0.4665820598602295,0.07165569067001343,0,1.6258078813552856,1.571749210357666,0.26982104778289795,1],[7,0.0898052304983139,-0.4083884656429291,0.9083799719810486,0,0.6265109181404114,0.7321699857711792,0.26722925901412964,0,-0.7742215394973755,0.5451115369796753,0.32161247730255127,0,1.878832221031189,1.1274856328964233,0.5302256345748901,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[50,"VD302_Kangaroo_Eye",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[175,10]],[[[50,"VD302_Kangaroo_Toy",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":1,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[176,10]],[[[62,".bin",677989383,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":184512,"length":16002,"count":8001,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":329346,"length":8946,"count":4473,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":477108,"length":10176,"count":5088,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[3],"indexView":{"offset":509940,"length":1008,"count":504,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[4],"indexView":{"offset":528420,"length":3840,"count":960,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":184512,"count":1922,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":200514,"length":128832,"count":1342,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":338292,"length":138816,"count":1446,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":487284,"length":22656,"count":236,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":510948,"length":17472,"count":182,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,18,21,23,24,25,26,28,31,32,33,34,37,45],[0,1,2,3,4,5,6,9,10,11,12,16,17,18,19,24,29,31,33,34,35,36,37,38,39,40,41,43,46],[0,1,2,3,4,5,9,10,11,16,17,19,24,29,35,36,37,38,39,40,41,42,43,46,48,49,51,52,53,54]]},"minPosition",8,[1,-0.633299708366394,-2.9354195594787598,0],"maxPosition",8,[1,0.633299708366394,2.9354195594787598,3.0187833309173584]]],-1],0,0,[],[],[]],[[[40,"Text_effect"],[169,"Text_effect",33554432,[-3],[[231,-2,[10,"412NYONbhPIJ71nH1n06JO"]]],[1,"60whtUc01AqKpk/+jyFPeB",-1,0],[1,0,730.572,0]],[85,"Particle2D",33554432,1,[[37,-4,[10,"89hbBDCQVH4LrOphozzWmZ"],[5,500,100]],[331,"Node<ParticleSystem2D>",999.999985098839,0.5,0.8,10,10,60,30.31999969482422,30,-47.369998931884766,-142.11000061035156,10,90,0,true,true,5,-5,[10,"89UC8wTZJKBIPn2IyJPyqJ"],[0,150,80],[0,10,10],[4,4292410111],[4,4278190080],[4,4294967295],[4,4278190080],0,1],[311,false,true,-6,[10,"c7n4vGx69N5q/pdVVfvFxt"],[2],3]],[1,"feWWPHO4RLA6LnERZbRi0y",1,0],[1,17.035,-7.797,-1]]],0,[0,4,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,0,2,0,18,1,6],[0,0,0,0],[59,2,-1,31],[177,178,95,95]],[[[50,"VD289_Lion_Toy",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":1,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[179,10]],[[[120,"Skin-0",2148985371,["Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","Bip001/Bip001 Pelvis","Bip001/Bip001 Pelvis/Bip001 Spine","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink","Bip001/Bip001 Pelvis/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03","Bip001/Bip001 Pelvis/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03/Bip001 Tail_04","Bip001/Bip001 Pelvis/Bip001 Tail_01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001Neck Giggle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Xtra_Hair","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Chest Giggle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink/Bip001 L Foot","Bip001/Bip001 Pelvis/Bip001 Tail_01/Bip001 Tail_02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Bip001 L_Ear","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink/Bip001 L Foot/Bip001 L Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Upper_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Eye Ball","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 Tongue_01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Upper_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink/Bip001 R Foot/Bip001 R Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Lower_Eye","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 L_Upper_Eye","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Bip001 L_Ear/Bip001 Xtra_Lear1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 L_Lower_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 R_Lower_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Ear","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink/Bip001 R Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Upper_Eye","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Lower_Eye","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Ear/Bip001 Xtra_Rear1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 Lower_Teeth","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 Jaw/Bip001 Tongue_01/Bip001 Tongue_02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 R_Eye Ball"],[[[7,-3.053580428513669e-7,0.0000013296380529936869,-1,0,0.256775826215744,-0.9664709568023682,-0.0000013634652304972406,0,-0.9664709568023682,-0.256775826215744,-4.629919558851725e-8,0,1.3855551481246948,1.015037178993225,0.2612881660461426,1],[7,-0.000004271163561497815,0.0000027876039894181304,1,0,-0.9998416304588318,-0.017792878672480583,-0.00000422088805862586,0,0.017792878672480583,-0.9998416304588318,0.000002863159124899539,0,0.5966652631759644,1.6106069087982178,-0.0000020572379071381874,1],[7,0.000002188548705817084,-0.000004311048542149365,1,0,-0.9932107329368591,0.11632832884788513,0.000002675187715794891,0,-0.11632832884788513,-0.9932107329368591,-0.000004027190243505174,0,0.5168375372886658,1.4000802040100098,0.00000435832316725282,1],[7,-5.676564001078077e-7,0.0000012753492910633213,-1,0,0.256775826215744,-0.9664709568023682,-0.000001378348542857566,0,-0.9664709568023682,-0.256775826215744,2.2114463149591757e-7,0,1.3855538368225098,1.0150392055511475,-0.26128649711608887,1],[7,0.000002346306700928835,-0.000004057476871821564,1,0,-0.9999880790710449,0.004876255057752132,0.000002366064336456475,0,-0.004876255057752132,-0.9999880790710449,-0.000004045987680001417,0,-0.42657774686813354,1.361762285232544,0.000004252044618624495,1],[7,-5.987060944789846e-7,0.0000012258595916136983,-1,0,0.4690953195095062,-0.8831474781036377,-0.0000013634652304972406,0,-0.8831474781036377,-0.4690953195095062,-4.629919558851725e-8,0,0.33147427439689636,1.1192612648010254,0.2612881660461426,1],[7,5.818359838372089e-8,0.0000013630082094095997,-1,0,-0.00871762353926897,-0.9999619722366333,-0.0000013634636388815125,0,-0.9999619722366333,0.00871762353926897,-4.629919558851725e-8,0,0.5982152223587036,0.9488317370414734,0.26128819584846497,1],[7,-0.000004236486347508617,-0.000002751383590293699,1,0,0.9999504685401917,-0.009945729747414589,0.000004208912741887616,0,0.009945729747414589,0.9999504685401917,0.00000279338269137952,0,-1.8848037719726562,-1.8109633922576904,-0.000010619799468258861,1],[7,-0.000003647768835435272,-5.04460501815629e-7,1,0,0.9999739527702332,-0.007211687974631786,0.0000036440360418055207,0,0.007211687974631786,0.9999739527702332,5.307539936438843e-7,0,-2.4394681453704834,-1.8218427896499634,-0.0000050889152589661535,1],[7,-0.0000013709058066524449,-0.000002772508651105454,1,0,0.9999995231628418,-0.0007962750387378037,0.0000013686978945770534,0,0.0007962750387378037,0.9999995231628418,0.0000027735998173739063,0,-0.9221391677856445,-1.8173305988311768,-0.00000605868035563617,1],[7,-0.05474542826414108,-0.009147865697741508,0.9984584450721741,0,0.10459691286087036,0.9944038987159729,0.014845762401819229,0,-0.9930067658424377,0.10524840652942657,-0.05348222702741623,0,1.502079963684082,0.9243525862693787,-0.23913556337356567,1],[7,0.000001879893147815892,-0.000004676097432820825,1,0,-0.9566370844841003,0.2912822365760803,0.00000316043997372617,0,-0.2912822365760803,-0.9566370844841003,-0.00000392574929719558,0,-1.0982829332351685,1.5582553148269653,0.000004133215043111704,1],[7,-0.0000013096339444018668,-0.0000031788708838575985,1,0,0.9553048014640808,0.2956223487854004,0.0000021908451799390605,0,-0.2956223487854004,0.9553048014640808,0.000002649634097906528,0,1.6887753009796143,-1.6293219327926636,-0.0000028921190278197173,1],[7,0.4700365364551544,0.8689171075820923,0.15507622063159943,0,0.31667274236679077,-0.002017348539084196,-0.9485326409339905,0,-0.8238834142684937,0.494953453540802,-0.27611061930656433,0,1.5526994466781616,-0.9722108840942383,-0.6871752142906189,1],[7,0.0000013239805412013084,-0.0000031292283892980777,1,0,-0.9657670855522156,0.25941088795661926,0.0000020904124085063813,0,-0.25941088795661926,-0.9657670855522156,-0.0000026786506168718915,0,-0.9883826971054077,2.2811074256896973,0.000002281797605974134,1],[7,-0.47004011273384094,-0.868915855884552,0.15507251024246216,0,0.3166705369949341,-0.002021381864324212,0.9485333561897278,0,-0.8238822221755981,0.4949556887149811,0.2761102020740509,0,1.5526989698410034,-0.9722117185592651,0.687175452709198,1],[7,-0.05373343080282211,-0.013909182511270046,0.9984584450721741,0,0.01707155816257,0.9997439980506897,0.014845822006464005,0,-0.9984093308448792,0.017842955887317657,-0.05348222330212593,0,0.6888176798820496,0.9885033965110779,-0.2391355037689209,1],[7,-0.000001743067855386471,-0.000004802195689990185,1,0,0.21240085363388062,0.9771825075149536,0.000005062851869297447,0,-0.9771825075149536,0.21240085363388062,-6.833050747445668e-7,0,0.9301970601081848,0.2071494460105896,-0.0000011898994216608116,1],[7,0.0031883339397609234,-0.05161985009908676,0.9986617565155029,0,-0.9999527335166931,-0.009327254258096218,0.002710339380428195,0,0.009174864739179611,-0.9986231327056885,-0.051647163927555084,0,-1.1554360389709473,0.06005057319998741,-0.2441503405570984,1],[7,-0.05164109915494919,-0.002028260612860322,0.998663604259491,0,-0.0022602304816246033,0.9999955892562866,0.001914088730700314,0,-0.9986631274223328,-0.002158364513888955,-0.05164545774459839,0,0.17847582697868347,0.9889724850654602,-0.2522744834423065,1],[7,-0.0000026164243536186405,0.000003467642045507091,-1,0,0.0025842629838734865,-0.9999967217445374,-0.0000034743916330626234,0,-0.9999967217445374,-0.0025842629838734865,0.0000026074542347487295,0,0.1560952514410019,0.9506561160087585,0.2612897455692291,1],[7,-0.00000279784057966026,-0.0000041826997403404675,1,0,0.9999812841415405,0.006104842759668827,0.000002823323256961885,0,-0.006104842759668827,0.9999812841415405,0.00000416554166804417,0,-1.4490381479263306,-1.8334659337997437,-0.000010504343663342297,1],[7,0.648626983165741,0.36859947443008423,0.6658961176872253,0,-0.13380439579486847,-0.8060548305511475,0.5765172243118286,0,0.7492526769638062,-0.4630443751811981,-0.47350868582725525,0,-2.0276529788970947,-0.5765734314918518,1.9002386331558228,1],[7,0.000002442543518554885,8.428528417425696e-7,-1,0,-0.9999925494194031,0.003880994161590934,-0.0000024392538762185723,0,0.003880994161590934,0.9999925494194031,8.52325911182561e-7,0,0.7298500537872314,-0.024920398369431496,0.26128894090652466,1],[7,8.315606123687758e-7,-0.0000034833960853575263,1,0,-0.8579292297363281,0.5137678384780884,0.0000025030772121681366,0,-0.5137678384780884,-0.8579292297363281,-0.0000025612785066186916,0,-0.8776954412460327,2.4470114707946777,0.0000023768395749357296,1],[7,-0.5365011692047119,0.00042451475746929646,0.8438995480537415,0,-0.8148033618927002,0.2600625455379486,-0.5181342959403992,0,-0.21968664228916168,-0.9655916690826416,-0.13917796313762665,0,-1.2727903127670288,2.059884786605835,-0.9937133193016052,1],[7,0.34839677810668945,-0.047688424587249756,0.9361332654953003,0,-0.9061119556427002,0.2385333776473999,0.3493751883506775,0,-0.2399601936340332,-0.9699627161026001,0.03989320248365402,0,-1.7183424234390259,2.049438953399658,0.6295999884605408,1],[7,-0.9999998807907104,0.000421671022195369,-0.00013032501738052815,0,-0.00013061740901321173,-0.0006934906705282629,0.9999997615814209,0,0.0004215805674903095,0.9999995827674866,0.000693545734975487,0,0.1608973741531372,-1.9572935104370117,2.0454792976379395,1],[7,0.0000012741526234094636,-0.0000029701839139306685,1,0,-0.974692165851593,0.22355152666568756,0.0000019058954876527423,0,-0.22355152666568756,-0.974692165851593,-0.000002610175897643785,0,-1.5861706733703613,2.0291032791137695,0.000001656215317780152,1],[7,-0.3483942747116089,0.04768257588148117,0.9361345171928406,0,-0.9061129093170166,0.23853544890880585,-0.3493712842464447,0,-0.2399601936340332,-0.969962477684021,-0.0398985855281353,0,-1.7183395624160767,2.0494420528411865,-0.6295961141586304,1],[7,2.9924990485596936e-7,-8.534938160664751e-7,-1,0,-0.9999925494194031,0.0038810239639133215,-3.0256003924478136e-7,0,0.0038810239639133215,0.9999925494194031,-8.52325911182561e-7,0,0.7298523187637329,-0.02491971291601658,-0.26128724217414856,1],[7,0.02177341841161251,0.3172408938407898,0.9480950236320496,0,-0.9997456669807434,0.0013370864326134324,0.022512199357151985,0,0.005874105263501406,-0.9483439922332764,0.31718936562538147,0,-2.1322848796844482,1.7667109966278076,-0.730063259601593,1],[7,0.021649478003382683,0.31680187582969666,0.9482446312904358,0,-0.9997476935386658,0.001172898686490953,0.022433491423726082,0,0.005994777195155621,-0.9484910368919373,0.3167473077774048,0,-2.147172689437866,1.823690414428711,-0.7367159724235535,1],[7,0.6489221453666687,0.36808302998542786,0.6658942699432373,0,-0.13385029137134552,-0.806315541267395,0.576141893863678,0,0.748988926410675,-0.46300122141838074,-0.4739679992198944,0,-2.192505359649658,-0.5692633390426636,1.894734263420105,1],[7,0.29832497239112854,-0.0400119386613369,0.9536253213882446,0,-0.8621978163719177,0.41726866364479065,0.2872311472892761,0,-0.40941065549850464,-0.9079018831253052,0.08998347073793411,0,-1.3292657136917114,2.3362574577331543,0.4230286478996277,1],[7,-0.2983228862285614,0.04000537842512131,0.953626275062561,0,-0.8621985912322998,0.41727036237716675,-0.2872264087200165,0,-0.40941059589385986,-0.9079013466835022,-0.08998873084783554,0,-1.3292632102966309,2.336259365081787,-0.42302340269088745,1],[7,-0.6486266255378723,-0.368600994348526,0.6658955812454224,0,-0.13380618393421173,-0.8060526251792908,-0.5765198469161987,0,0.7492526769638062,-0.4630470275878906,0.47350606322288513,0,-2.0276477336883545,-0.576559841632843,-1.9002472162246704,1],[7,-8.418801940024423e-7,0.0000011135471140732989,-1,0,0.4690953195095062,-0.8831474781036377,-0.000001378348542857566,0,-0.8831474781036377,-0.4690953195095062,2.2114463149591757e-7,0,0.3314725458621979,1.119262933731079,-0.26128649711608887,1],[7,0.0547451451420784,0.009145164862275124,0.9984585046768188,0,0.1045970618724823,0.9944038987159729,-0.014843050390481949,0,-0.9930067658424377,0.10524840652942657,0.05348223075270653,0,1.5020805597305298,0.9243530035018921,0.23913080990314484,1],[7,0.05373338609933853,0.013906423933804035,0.9984585046768188,0,0.017071707174181938,0.9997440576553345,-0.014843067154288292,0,-0.9984093308448792,0.017842957749962807,0.05348223075270653,0,0.6888182759284973,0.9885038733482361,0.23913079500198364,1],[7,-2.0912028730890597e-7,0.0000013802249441141612,-1,0,-0.00871762353926897,-0.9999619722366333,-0.0000013783495660391054,0,-0.9999619722366333,0.00871762353926897,2.2114463149591757e-7,0,0.5982144474983215,0.9488340020179749,-0.26128649711608887,1],[7,0.051641110330820084,0.0020254631526768208,0.9986636638641357,0,-0.0022600863594561815,0.9999956488609314,-0.0019112949958071113,0,-0.9986631274223328,-0.0021583649795502424,0.05164546146988869,0,0.17847642302513123,0.988973081111908,0.25226980447769165,1],[7,-0.0031855928245931864,0.05161987617611885,0.9986617565155029,0,-0.9999527931213379,-0.009327113628387451,-0.002707601524889469,0,0.00917486660182476,-0.9986231327056885,0.051647163927555084,0,-1.155436635017395,0.06005116179585457,0.24414563179016113,1],[7,0.0000026093389351444785,-7.258095706674794e-7,-1,0,0.0025842629838734865,-0.9999967217445374,7.325502906496695e-7,0,-0.9999967217445374,-0.0025842629838734865,-0.000002607454462122405,0,0.1560945361852646,0.95065838098526,-0.261288046836853,1],[7,0.5365033745765686,-0.0004299054853618145,0.8438981175422668,0,-0.814801812171936,0.2600596845149994,0.51813805103302,0,-0.2196866124868393,-0.9655925035476685,0.13917259871959686,0,-1.2727946043014526,2.0598793029785156,0.9937179684638977,1],[7,-0.021646739915013313,-0.3168071210384369,0.9482429027557373,0,-0.9997478127479553,0.0011721538612619042,-0.022430885583162308,0,0.005994778126478195,-0.9484893083572388,-0.316752552986145,0,-2.147172689437866,1.8236889839172363,0.7367182970046997,1],[7,-0.02177068032324314,-0.31724613904953003,0.9480932950973511,0,-0.999745786190033,0.0013363407924771309,-0.022509591653943062,0,0.00587410619482398,-0.9483422636985779,-0.3171945810317993,0,-2.1322848796844482,1.766709566116333,0.7300653457641602,1],[7,-0.6489195227622986,-0.3680840730667114,0.6658961772918701,0,-0.13385337591171265,-0.80631422996521,-0.5761430859565735,0,0.7489905953407288,-0.46300292015075684,0.4739636778831482,0,-2.192509651184082,-0.5692557692527771,-1.8947311639785767,1],[7,-8.960399213719938e-7,-0.00000214716897062317,1,0,0.903411328792572,-0.42877480387687683,-1.1115923825855134e-7,0,0.42877480387687683,0.903411328792572,0.0000023239763322635554,0,1.2565665245056152,-2.338369846343994,-0.000010862095223274082,1],[7,0.0000012052223610226065,-0.0000032313655538018793,1,0,-0.9067159295082092,0.42174211144447327,0.0000024555968138884054,0,-0.42174211144447327,-0.9067159295082092,-0.000002421637191218906,0,-1.2419465780258179,2.3341405391693115,0.0000025176511826430215,1],[7,0.9999998807907104,-0.00042166843195445836,-0.00012758553202729672,0,-0.00012787559535354376,-0.0006879446445964277,-0.9999997615814209,0,0.0004215805674903095,0.9999995827674866,-0.0006879985448904335,0,0.16088926792144775,-1.9572821855545044,-2.045490264892578,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[50,"VD289_Lion_Eye",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[180,10]],[[[62,".bin",3237067649,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":69216,"length":5202,"count":2601,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":127890,"length":3732,"count":1866,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":168582,"length":2430,"count":1215,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[3],"indexView":{"offset":217764,"length":2718,"count":1359,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[4],"indexView":{"offset":284514,"length":4962,"count":2481,"stride":2}},{"primitiveMode":7,"jointMapIndex":5,"vertexBundelIndices":[5],"indexView":{"offset":344676,"length":4020,"count":2010,"stride":2}},{"primitiveMode":7,"jointMapIndex":6,"vertexBundelIndices":[6],"indexView":{"offset":416952,"length":4446,"count":2223,"stride":2}},{"primitiveMode":7,"jointMapIndex":7,"vertexBundelIndices":[7],"indexView":{"offset":688182,"length":21576,"count":10788,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[8],"indexView":{"offset":744414,"length":2646,"count":1323,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[9],"indexView":{"offset":764532,"length":3840,"count":960,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":69216,"count":721,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":74418,"length":53472,"count":557,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":131622,"length":36960,"count":385,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":171012,"length":46752,"count":487,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":220482,"length":64032,"count":667,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":289476,"length":55200,"count":575,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":348696,"length":68256,"count":711,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":421398,"length":266784,"count":2779,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":709758,"length":34656,"count":361,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":747060,"length":17472,"count":182,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,30,36],[0,1,2,4,5,6,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,28,29,31,32,36],[0,1,2,4,5,6,7,8,9,10,11,12,14,15,16,17,18,19,21,22,24,25,26,27,33,50],[0,1,4,5,6,7,8,9,10,14,16,18,19,20,21,22,23,24,25,26,28,29,31,32,33,34,35],[0,1,2,3,4,5,6,7,8,9,10,11,12,14,15,16,17,21,23,30,37,38,39,40,41,42,43],[0,1,2,3,4,9,11,12,14,15,17,21,22,24,26,28,29,30,36,37,38,39,40,41,42,43,44,45,46],[0,1,2,3,4,7,8,9,11,12,14,17,21,24,26,29,30,35,36,37,38,39,40,41,42,43,44,45,46,47],[0,2,3,4,10,11,12,13,14,15,17,22,24,27,28,33,34,35,36,37,38,39,40,43,44,46,47,48],[0,4,10,11,12,13,14,15,22,26,28,29,33,36,38,47,49]]},"minPosition",8,[1,-0.5391759276390076,-2.413334369659424,-0.010016355663537979],"maxPosition",8,[1,0.5391759276390076,2.9394428730010986,2.5182552337646484]]],-1],0,0,[],[],[]],[[[119],[102,"VD289_Lion_Rig",[[-3,-4,[4,"Bn_FoodSpawn",-6,[1,"35i6tXF4pRNZMhldb3mDjL",-5,0],[1,-0.6544039845466614,0.0000014053456425244804,2.4855852127075195],[3,1.545431187269876e-8,-0.707106721581899,1.5454308319985022e-8,0.7071068407911907],[1,0.0000025044781562438738,-89.99999034065368,-7.67592264999771e-14]]],1,1,4],[[110,-2,[10,"bcbBLaSAhbuZMFUUZNLvRX"]]],[1,"35MaNWaVpaXITwGugCw+yp",-1,0]],[48,"Bip001 Head",[[-7,[4,"Bip001 R_Eye Ball",-8,[1,"c67HP74fZQareDO7QzeXWD",1,0],[1,0.4810067415237427,-0.13871192932128906,-0.16198280453681946],[3,0.7010897311661021,-0.09240155553280946,0.7010379347304301,0.09209210312210751],[1,165.00802974654647,-89.99911001265058,-0.02540769395075313]],[4,"Bip001 L_Eye Ball",-9,[1,"9bdMh8SI5VApTWliW7zitf",1,0],[1,0.4810067415237427,-0.13871288299560547,0.16198202967643738],[3,0.7010897551105225,-0.0923973938139687,-0.7010384951148962,-0.0920918305958545],[1,-165.00839214994963,89.99911191723139,-0.02508957840924875]],-10,-11,[4,"Bip001 R_Lip",-12,[1,"0c+/2xnDxak6fzczZpa12t",1,0],[1,0.6202429533004761,0.2222423553466797,-0.15485885739326477],[3,-0.00011103288813278455,-0.27937534352521404,0.000382185737645578,0.960181888516925],[1,0.000018506947193266856,-32.4458562590536,0.0456060329216003]],[4,"Bip001 L_Lip",-13,[1,"426MOEsD5fQ52qyRgpaw43",1,0],[1,0.6202429533004761,0.22224140167236328,0.15486010909080505],[3,0.00011102969392108471,0.2793753433583419,0.0003837463430075874,0.9601818879434041],[1,-0.00006881972605775448,32.44585627918052,0.04577764213007584]],[4,"Bip001 Upper_Teeth",-14,[1,"aaIJFC4GRcjrd2uk0jbYIV",1,0],[1,0.6855056285858154,0.140275239944458,6.420416411856422e-7],[3,1.9369720990394967e-12,-0.00000276018663500417,0.995163814734005,-0.09822923106919072],[1,179.99967904174824,179.99996831952706,-11.274421660696975]],[4,"Bip001 R_Upper_Lip",-15,[1,"8b3EQn0vVbXY+9L26wjUHK",1,0],[1,0.79768967628479,0.19597196578979492,-0.10700225830078125],[3,0.02535524931192882,0.17689026660986928,-0.006240054417799473,0.9838841428907584],[1,2.98652823969059,20.389324236101686,-0.1895799086119579]],[4,"Bip001 L_Upper_Lip",-16,[1,"78gcp2bbxVXLlxVrakCFv+",1,0],[1,0.79768967628479,0.19597125053405762,0.10700333118438721],[3,-0.02535525307963376,-0.1768902222022912,-0.006241038370526807,0.9838841445366163],[1,-2.986548629297991,-20.38932211967836,-0.1896908986222032]],[4,"Bip001 R_Upper_Eye",-17,[1,"b5e5H9odFf6al2+RZikwCR",1,0],[1,0.5582767724990845,-0.18035387992858887,-0.16731713712215424],[3,-0.1576385977327603,0.0320653176906361,-0.1303367939430467,0.9783323607296732],[1,-18.133109482336906,1.286535775580373,-15.374966949615768]],[4,"Bip001 L_Upper_Eye",-18,[1,"4fY6GcR1hSC5fYnbBbwcE3",1,0],[1,0.5582767724990845,-0.18035483360290527,0.16731615364551544],[3,0.1576385977307024,-0.032064591258594455,-0.13033697275528322,0.9783323607169017],[1,18.133121251843473,-1.2864479857142894,-15.374974130500112]],[4,"Bip001 R_Lower_Eye",-19,[1,"da5hRlZv9Yer2n/hky54Qh",1,0],[1,0.5588425397872925,-0.1220705509185791,-0.1781167834997177],[3,-0.15785925427404585,0.032146625907232565,-0.13026039580506293,0.9783042878202727],[1,-18.1579087033879,1.2938562673416478,-15.368015962628489]],[4,"Bip001 L_Lower_Eye",-20,[1,"f1rzkOtcJUoouALNH9EqMW",1,0],[1,0.5588425397872925,-0.12207150459289551,0.17811612784862518],[3,0.15785923973473004,-0.03214590327458423,-0.130260574917585,0.9783042900627464],[1,18.15791867460493,-1.29376914844599,-15.368023209192646]],[4,"Bn_Mouth",-21,[1,"74Wy3E+Ole54e8k1nw+aEG",1,0],[1,0.7551892995834351,0.18387889862060547,-0.0000018998973700945498],[3,0.6883263572440877,0.02517719747413124,0.7247287614703776,-0.018470434430343463],[1,-176.44982632392762,-92.96540327274604,0.4519622246662741]]],1,4,4,1,1,4,4,4,4,4,4,4,4,4,4],[1,"daokDkTqNZyptqI6QBb1I/",1,0],[1,0.3670990467071533,-0.09131133556365967,-4.3714862840715796e-9],[3,6.019624997662611e-7,-3.6520860217684395e-7,0.32350260898026595,0.9462272781855665],[1,0.00009967105166216462,-0.00007830430389595361,37.749761330843185]],[48,"Bip001 Neck",[[2,-22,-23,[4,"Bip001Neck Giggle",-24,[1,"42aDpB00ZY24pjtaMIy0pw",1,0],[1,0.02900838851928711,0.6082414388656616,0.0000020743948425661074],[3,3.86469865598165e-14,-9.406484298778304e-7,0.33914354814087,0.9407346351408227],[1,0.000047478123142189156,-0.00013169736139046916,39.64940598604298]]],1,1,1,4],[1,"c5EksbV85eBLHQJ5DOQ0Il",1,0],[1,0.8079414367675781,-0.3649176359176636,-7.356898095167708e-7],[3,3.231769190948456e-14,5.528266381495149e-7,-0.19931733748910155,0.9799349973217356],[1,0.000013716448421261177,0.00006743630189398614,-22.994083269461413]],[57,"Bip001 Jaw",2,[[[4,"Bip001 Lower_Teeth",-25,[1,"75WizrvY9f4bbuYTiAsdi4",1,0],[1,0.14788228273391724,-0.0014827251434326172,-3.79127413907554e-8],[3,3.780104082252863e-14,-0.00000277037657122206,0.9988377701388352,0.048198640399960066],[1,179.99968142703355,-179.99998462734527,5.525298067713643]],-26,[4,"Bip001 R_Lower_Lip",-27,[1,"09TAs1TbJfg5Fft1EAp/iz",1,0],[1,0.255571186542511,-0.025275230407714844,-0.08661354333162308],[3,0.02795634202226483,0.1496848596835241,-0.050703662830590454,0.9870369923654431],[1,4.052178660461967,17.43279123633301,-5.262766519849278]],[4,"Bip001 L_Lower_Lip",-28,[1,"9fCz99XCRUdpOH1TnEDrkD",1,0],[1,0.2555714249610901,-0.02527618408203125,0.08661340922117233],[3,-0.027956389263296563,-0.14968480369246534,-0.05070449851968066,0.9870369565891517],[1,-4.052198641800828,-17.432789752534553,-5.262860599178974]]],4,1,4,4],[1,"46yLe9/LNSU4wsF36Y4EdF",1,0],[1,0.5253777503967285,0.16764020919799805,5.410154244600562e-7],[3,-2.650718919003171e-8,-2.1287236392524712e-7,0.13813619241436384,0.9904132432198268],[1,3.7556031808144073e-7,-0.00002468187364767975,15.880020117071021]],[47,"Bip001 Spine",[-29,-30,-31],[1,"99aYTJuXxXjKlBCnMZKwSb",1,0],[1,0.2720732092857361,0.15390312671661377,0.0000011634572274488164],[3,-0.0000036112506739137594,-0.0000032734493259281867,0.0671425181802589,0.9977433949812232],[1,-0.00039122660298780275,-0.00034963070073605346,7.699758479455297]],[57,"Bip001 Spine1",5,[[3,[4,"Bip001 Chest Giggle",-32,[1,"bcLaJ+TvdQl78qlF+twDsy",1,0],[1,-0.030802786350250244,0.49484819173812866,0.0000036120202366873855],[3,3.7685426223774956e-13,-0.00000215524395919846,0.7770564103807688,0.6294309613305572],[1,179.99907571776728,-179.99925131317406,78.01630472356885]],[4,"Bip001 Xtra_Hair",-33,[1,"acBVRsOHRXTZXhAUP5FR5A",1,0],[1,0.6950159072875977,-0.6994706392288208,-0.000006818572273914469],[3,5.790522979187898e-7,-0.000003298516196602828,0.9883956670913969,0.1519013010600525],[1,179.99959776231205,-179.99987104867216,17.47425168677412]]],1,4,4],[1,"b0yaVeE+lf24sDuhbAjfnr",1,0],[1,0.7889416217803955,-0.0007495880126953125,-2.078195393551141e-9],[3,-3.5019260556543856e-13,1.5484620210818652e-7,-0.05582864471373433,0.9984403649840102],[1,9.968009184705453e-7,0.00001782752218102701,-6.400819429558583]],[157,"Bip001 Pelvis",[5,-34],[1,"05UVohVuNVcY7xAefdYL4R",1,0],[3,-0.7070778123743453,-0.006288996065458571,-0.006292967690640629,0.7070797793276539],[1,-89.99984349021217,-1.0195107027065413,-0.00032321993293957425]],[104,"Bip001 L Hand",[[4,"Bip001 L Finger0",-35,[1,"c1cWylJQtd6rol0y6sh+h7",1,0],[1,0.11026113480329514,-0.165815532207489,-0.007204532623291016],[3,-0.0002805439336568173,-0.00028253451927802003,-0.7096009373105814,0.7046036838090551],[1,-173.57108515257863,-173.5712464477026,-89.59251697193665]],[4,"Bn_Hand",-36,[1,"b4NkXDiC1Ugpi6y1EryYfH",1,0],[1,0.07876826077699661,0.0014336705207824707,0.008919715881347656],[3,-0.5285012611055592,0.45481123565417464,0.4609834753050134,0.5489329580452139],[1,-89.06222278112995,80.71567421214854,1.4532582727244376]]],[1,"b8A7ZBYvlbYJe+OTRAWqzr",1,0],[1,0.49073225259780884,0,-2.7755575615628914e-17],[3,0.006459115510774314,-0.0009703958597851153,-0.00967462636066002,0.999931867560723],[1,0.7391929267412117,-0.10405038509961596,-1.109342541708019]],[64,"VD289_Lion_Toy",1,[[66,-37,[10,"503Je38cFf+qiwMAkmKXtO"],[0,1,2,3,4,5,6,7,8,9],[29],1,10,11]],[1,"66SXxyl+ZSLIlCH9Xjfuro",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Bip001",1,[7],[1,"20FZ6FqZZT946EF29Au3vS",1,0],[1,1.1595849258583257e-7,1.5997356176376343,-0.6252281665802002],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[14,"Bip001 Tongue_01",4,[[4,"Bip001 Tongue_02",-38,[1,"3evKiZvo5TaLUHoURAeo/X",1,0],[1,0.11488211154937744,0.004982948303222656,-1.5629666449967772e-9],[3,-2.323547235219641e-13,-2.9056776282183755e-7,0.1047619535833508,0.9944973268346755],[1,0.0000035664763741375045,-0.000033856545481151455,12.026903731116498]]],[1,"55LTavoExT56Qt1yhbvz/X",1,0],[1,0.003924190998077393,0.02710580825805664,-3.941545401175972e-7],[3,8.876830915891205e-8,2.861370347925786e-7,-0.1564121826931524,0.9876918695145132],[1,0.000015956211203273638,0.00003572433450440832,-17.997414807659634]],[14,"Bip001 R_Ear",2,[[4,"Bip001 Xtra_Rear1",-39,[1,"7dpmNx611fh4xXzZzkGAmI",1,0],[1,0.16526293754577637,-0.007695436477661133,-0.00586247444152832],[3,0.0002579941082421809,0.00014602117979031542,0.00013364067216513513,0.9999999471285115],[1,0.029561711706125145,0.01672884364813452,0.015318409307953114]]],[1,"11uo16DZlTM61GJXA7u+dI",1,0],[1,0.2222374677658081,-0.27237796783447266,-0.2623478174209595],[3,0.08784863973881617,0.39916932019638285,-0.6109285268413922,0.6780212425886106],[1,68.57755439683643,95.73479365574451,-49.3156191935996]],[14,"Bip001 Bip001 L_Ear",2,[[4,"Bip001 Xtra_Lear1",-40,[1,"07XOU8MOJdXYdeZTz15z4c",1,0],[1,0.16525864601135254,-0.007697701454162598,0.005858659744262695],[3,-0.00025739037835200524,-0.00014754108367486289,0.00013392347407347846,0.9999999470231611],[1,-0.029492501292864223,-0.0169030127135326,0.015350850744476724]]],[1,"16nrjCCw1awrIbbFmrrLkt",1,0],[1,0.2222374677658081,-0.27237915992736816,0.2623463571071625],[3,-0.08784849002020216,-0.3991657109029413,-0.6109308465057375,0.6780212967365428],[1,-68.57792556304484,-95.73482604637756,-49.31596771939435]],[6,"Bip001 L Clavicle",3,[-41],[1,"24wLW8b+9UI6wK3JzbMbUF",1,0],[1,-0.14779305458068848,0.10067105293273926,0.2215055376291275],[3,0.41547124778529304,0.4998455845503116,0.7451695656451454,0.14919903587327327],[1,-126.27871613268118,-142.39487477211952,39.62053467264401]],[6,"Bip001 L UpperArm",14,[-42],[1,"a8dpwKFOlaFJYRtwefRwED",1,0],[1,0.2296522855758667,-5.960464477539063e-8,5.960464477539063e-8],[3,-0.6379365357431955,0.1235952085584575,-0.26826861637233795,0.7111913598006048],[1,-87.13188492523258,-11.401635846222337,-32.63412457981295]],[6,"Bip001 L Forearm",15,[8],[1,"25rnbqlTNR1pQdN14WG5HL",1,0],[1,0.7293049097061157,1.7881393432617188e-7,-1.4901161193847656e-8],[3,-2.9085993091906674e-18,-6.926437497026995e-18,-0.04384888403144709,0.9990381751310593],[1,-3.6920345895733417e-16,-8.106801632792376e-16,-5.026323567077576]],[6,"Bip001 R Clavicle",3,[-43],[1,"8aDq0WbNRYM4NJvJ2o74Lv",1,0],[1,-0.14779317378997803,0.10067236423492432,-0.2215055376291275],[3,-0.41547080324707847,-0.4998476439141597,0.7451681992161449,0.14920019906038545],[1,126.27838935043187,142.39508748208752,39.62072751801381]],[6,"Bip001 R UpperArm",17,[-44],[1,"07NdQ2IsRR84s8cj1lRGj3",1,0],[1,0.2296525239944458,0,0],[3,0.6379367648406821,-0.1235963988454534,-0.2682694469176002,0.7111906341534349],[1,87.13198029502165,11.401633666939945,-32.63428564318466]],[6,"Bip001 R Forearm",18,[-45],[1,"30nvpNQ2tWc6LIPcuur2vi",1,0],[1,0.7293049097061157,1.1920928955078125e-7,1.4901161193847656e-8],[3,1.1303803744703823e-18,5.973501841164178e-18,-0.04384888774957473,0.9990381749678664],[1,1.6003800920948266e-16,6.921961491095201e-16,-5.026323993553814]],[14,"Bip001 R Hand",19,[[4,"Bip001 R Finger0",-46,[1,"008tQUqzhbV6wCEbIfA14v",1,0],[1,0.11026114970445633,-0.165815532207489,0.0072045475244522095],[3,0.0002805438754491646,0.0002825344610703674,-0.7096009373106047,0.7046036838090782],[1,173.57108647059945,173.5712477657234,-89.59251697299388]]],[1,"feQFOqHlxSwbMcaPmuycQQ",1,0],[1,0.49073225259780884,-5.960464477539063e-8,0],[3,-0.006459115510844551,0.0009703939389428657,-0.009674625429442654,0.9999318675715966],[1,-0.739192928963956,0.10405016564739006,-1.109342433575704]],[6,"Bip001 L Thigh",5,[-47],[1,"e7TXJyk2pTmZxxh/3c0m7+",1,0],[1,-0.29023897647857666,-0.11606419086456299,0.26128682494163513],[3,0.6547501037544102,0.7558454217821333,0.0000013154733451603865,-0.0000016875408036243292],[1,-0.0016868458150420427,-179.9982829288019,81.80140842503103]],[6,"Bip001 L Calf",21,[-48],[1,"90JC9J3EBcF59u1d/TDnac",1,0],[1,0.8090827465057373,0,5.551115123125783e-17],[3,0,0,-0.11404207427361232,0.9934759208432642],[1,0,0,-13.09675291010064]],[6,"Bip001 L HorseLink",22,[-49],[1,"9edFaLq9JUMqw4ukRK7eJe",1,0],[1,0.25800904631614685,1.1920928955078125e-7,-2.9802322387695312e-8],[3,9.57812866348905e-14,2.2470528871822908e-14,0.245942504133208,0.9692844188682117],[1,1.1382293537766347e-11,-2.3156963582984584e-13,28.47507924983398]],[14,"Bip001 L Foot",23,[[4,"Bip001 L Toe0",-50,[1,"40GD3ZPKlVUKfO5lep3+oO",1,0],[1,0.1358935534954071,0.22066044807434082,8.940696716308594e-8],[3,9.866342672720895e-7,2.5395416366009996e-7,0.7093888948710643,0.704817278330045],[1,179.99086762866585,-179.9907671051601,89.62956826340346]]],[1,"6ax1un7LxbuodvxEmJ7fy/",1,0],[1,0.4313865005970001,0,5.960464477539063e-8],[3,-0.0000010594730005037418,-0.00000132363403322884,-0.005650970194106799,0.9999840331390251],[1,-0.00012226965720855048,-0.00015237066251723541,-0.6475569308786362]],[6,"Bip001 R Thigh",5,[-51],[1,"4dRXphVyNfYYs4uOckZrgr",1,0],[1,-0.29024165868759155,-0.11606109142303467,-0.2612874209880829],[3,0.6547501037545858,0.755845421782336,0.0000012090864537826867,-0.000001606185025239139],[1,-0.001579425924664092,-179.9983883152573,81.80140842546759]],[6,"Bip001 R Calf",25,[-52],[1,"9166HB4c9fCpJ+ndmbNclR",1,0],[1,0.8090826869010925,-1.1920928955078125e-7,-2.9802322387695312e-8],[3,-2.2245138044444033e-22,-8.103900608651333e-23,-0.11404207427361232,0.9934759208432642],[1,-2.7088384694094717e-20,-1.2456871242652872e-20,-13.09675291010064]],[6,"Bip001 R HorseLink",26,[-53],[1,"21BAg+uiNcLJ1pMuhtF2u5",1,0],[1,0.25800904631614685,2.220446049250313e-16,2.9802322387695312e-8],[3,3.303694474986318e-14,8.382667523066969e-15,0.245942504133208,0.9692844188682117],[1,3.905721507034513e-12,1.2771531827069202e-20,28.47507924983398]],[14,"Bip001 R Foot",27,[[4,"Bip001 R Toe0",-54,[1,"5cJRpZcMxdlIdscpoxZ25t",1,0],[1,0.1358935534954071,0.22066044807434082,-8.940696716308594e-8],[3,-9.86634536094653e-7,-2.539541459071018e-7,0.7093889246727637,0.7048172483350432],[1,-179.99086774519165,179.9907672216655,89.62956341814296]]],[1,"bfPdLlgZtTPLDNzkErLei1",1,0],[1,0.4313865303993225,0,0],[3,0.000001059741074068888,0.0000014110564835805256,-0.005650970194106122,0.9999840331389052],[1,0.00012235699197597083,0.00016238919088752877,-0.6475569308678233]],[6,"Bip001 Tail_01",7,[-55],[1,"04ogjBxslRvqZNn/28a2mW",1,0],[1,-0.2915322780609131,-0.22355151176452637,-9.820198556553805e-7],[3,-0.0000027950730284391583,2.102613403261408e-8,0.9999568013565235,-0.009294913287234204],[1,179.999999432131,179.9996796891088,-1.0651339420896775]],[6,"Bip001 Tail_02",29,[-56],[1,"62SLmOvJVd65B7L2G1Y1bi",1,0],[1,0.5395174622535706,0.006091594696044922,-2.1810456019011326e-7],[3,-6.981501933704374e-7,6.656289363368778e-7,-0.003450571817125076,0.9999940467588817],[1,-0.0000797403477249723,0.00007600076020202552,-0.3954071887608722]],[14,"Bip001 Tail_03",30,[[4,"Bip001 Tail_04",-57,[1,"48il1/WABdRr0dL7mUyTUY",1,0],[1,0.5596358776092529,0.004202485084533691,1.507032720837742e-9],[3,0.0000011297749087033272,1.3514002976763587e-7,-0.001367071436931353,0.9999990655567593],[1,0.0001294842014842598,0.00001566293548740287,-0.1566548960355113]]],[1,"e4/QZ1rH1f3K65N7Vtf7PY",1,0],[1,0.4064565896987915,0.007515430450439453,3.950663085561246e-8],[3,6.873440722040352e-7,6.919706716734174e-7,0.008025330355133777,0.9999677965173377],[1,0.00007813499653582644,0.00007866947233888114,0.9196449890937232]]],0,[0,4,1,0,0,1,0,-1,9,0,-2,10,0,4,1,0,1,1,0,-1,4,0,1,2,0,1,2,0,-4,12,0,-5,13,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-2,14,0,-3,17,0,1,3,0,1,4,0,-2,11,0,1,4,0,1,4,0,-1,6,0,-2,21,0,-3,25,0,1,6,0,1,6,0,-2,29,0,1,8,0,1,8,0,0,9,0,1,11,0,1,12,0,1,13,0,-1,15,0,-1,16,0,-1,18,0,-1,19,0,-1,20,0,1,20,0,-1,22,0,-1,23,0,-1,24,0,1,24,0,-1,26,0,-1,27,0,-1,28,0,1,28,0,-1,30,0,-1,31,0,1,31,0,18,1,2,1,3,3,1,6,5,1,7,7,1,10,8,1,16,57],[0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,12,20],[5,5,5,5,5,5,5,5,5,96,97,98]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0,"normalMap",6,1],{},{}],11,0,0]]],0,0,[0,0,0],[15,32,14],[88,36,29]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[89,28]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[93,28]],[[[40,"VD297_Giraffe_Rig"],[141,"VD297_Giraffe_Rig",[[-4,-5,[68,"Bn_FoodSpawn",-7,[1,"edXyveHQlamqk5Klmem7yW",-6,0],[1,2.6372758199499913e-8,0,2.4216866493225098]]],1,1,4],[[145,false,-2,[10,"a5Ur2McGJUfKEIm/lueZtm"],[15,16,17]],[80,-3,[10,"87zxcnX5pH/bS3KUEo3XGI"],18]],[1,"49pWBJK15R+45zZnNOgfJN",-1,0],[3,0,1,0,-6.123233995736766e-17],[1,0,-180,0]],[48,"Bip001 Head",[[-8,[4,"Bip001 R_UpEyelid",-9,[1,"35776kuEBeLZHUS0fLbjDm",1,0],[1,0.34337615966796875,0.2510550022125244,-0.2245255559682846],[3,0.12247283914442461,0.7241107318662566,0.05565574464344822,0.6764366117798485],[1,5.045205968772248,93.25085851212803,14.63514863313527]],[4,"Bip001 L_UpEyelid",-10,[1,"99+llp6yNf0pX1/DQ9+tgW",1,0],[1,0.34337615966796875,0.2510535717010498,0.22452694177627563],[3,-0.12247256348552801,-0.7241110299639162,0.055651747412626976,0.6764366714540253],[1,-5.045519010090419,-93.25085191470198,14.634809479074342]],[4,"Bip001 R_DownEyelid",-11,[1,"2eX9kiozNTCYTR1C6h7sEi",1,0],[1,0.2697715759277344,0.25691771507263184,-0.21696408092975616],[3,0.1223849945588972,0.7241674026347854,0.05572241887057009,0.6763863526884764],[1,5.031255141657216,93.26145031601891,14.633446357809548]],[4,"Bip001 L_DownEyelid",-12,[1,"72SZVCrg1a2LbK96LcowhX",1,0],[1,0.2697715759277344,0.25691652297973633,0.21696552634239197],[3,-0.12238473441172545,-0.7241676447406158,0.055718354862578263,0.6763864753417299],[1,-5.031576404901483,-93.26143307554283,14.633102810797125]],[4,"Bip001 UP_Lip",-13,[1,"35HbIUuotdQaMkFrCYzRIQ",1,0],[1,0.1482524871826172,0.8653846979141235,0.00001548483851365745],[3,-7.019732607805063e-7,-0.0000036544161645705422,0.8095809949645157,0.5870081878291113],[1,179.99906124463647,-179.99941869080754,71.88997265189033]],[4,"Bip001 R_Up_Lip",-14,[1,"17RB3ykLBUm6je9HRIuOn/",1,0],[1,0.1558370590209961,0.813302755355835,-0.08448056876659393],[3,0.6440443531968911,-0.40946052339214933,0.5172257532139795,0.3873325071703341],[1,111.56741681299894,-82.49034886429834,-7.281525826520712]],[4,"Bip001 L_Up_Lip",-15,[1,"df+haHFsFdPpoeUvr0OVYf",1,0],[1,0.1558370590209961,0.8133022785186768,0.08448508381843567],[3,0.6440443378808218,-0.4094576824341174,-0.5172280058902883,-0.3873325277614716],[1,-111.56768796709501,82.49035459539483,-7.281211700610275]],[4,"Bip001 R_Lip",-16,[1,"dexMSBu/Vc6oaq6wAV+avX",1,0],[1,0.1689472198486328,0.7362625598907471,-0.09580332785844803],[3,-0.5195301736970601,0.5128582682233938,0.5599839650491572,0.3917687509501342],[1,-99.65597338896119,98.85268539858689,-5.400802261110559]],[4,"Bip001 L_Lip",-17,[1,"51H6UXMFxVxreAZ4YjFABg",1,0],[1,0.1689472198486328,0.7362620830535889,0.09580741077661514],[3,0.5195300528317897,-0.5128618428673297,0.5599808042180879,0.39176874970138664],[1,99.65555102296493,-98.85270528484511,-5.4011515009998945]],[4,"Bip001 R_EyeBall",-18,[1,"2evjecQFZRbpov5tGjlFBH",1,0],[1,0.31261539459228516,0.23719239234924316,-0.1390356719493866],[3,-0.6884858534158385,-0.009179707517785443,0.7106473369420088,0.14451064013900036],[1,-169.01665158428787,90.5992931168743,12.593492657351312]],[4,"Bip001 L_EyeBall",-19,[1,"07HB7bVs5fSK0GCLwvrUvV",1,0],[1,0.31261539459228516,0.23719167709350586,0.13903698325157166],[3,0.6884858477219524,0.009175758634226603,0.7106473906694875,0.1445106538450356],[1,169.01632871573827,-90.59929283117292,12.593175480769082]],-20,[4,"Bip001 nose",-21,[1,"04PkZ8dHRVzZYNqb8TRcv7",1,0],[1,0.32142162322998047,0.7735657691955566,-0.00001353079187538242],[3,0.0000029573027132187497,1.9355367263776715e-7,0.055661912494588996,0.9984496739889605],[1,0.000339223991494756,0.000003302881515195641,6.381683568818498]],-22,[4,"Bip001 R_cheek",-23,[1,"e7FwbyyURWBqR0qzpv6MFQ",1,0],[1,0.05211019515991211,0.2889235019683838,-0.1565088927745819],[3,0.05841113290049033,0.7065731926138281,0.039178192854431165,0.7041360182787445],[1,1.555941669856946,90.09031156983801,7.915762344815528]],[4,"Bip001 L_cheek",-24,[1,"7ft6QxtctagqdyecDLAhlN",1,0],[1,0.05211019515991211,0.2889225482940674,0.15651053190231323],[3,-0.05841107281476088,-0.7065734252129403,0.039174191569980386,0.7041360124793511],[1,-1.556261645997518,-90.09031325464657,7.9154330170357]],-25,[4,"Bip001 UpTeeth",-26,[1,"bcMI6QptlSGKEmSrWoPjmO",1,0],[1,0.1596221923828125,0.847388744354248,-0.00002852861871360801],[3,2.7861110174443624e-7,-0.000004770442341778068,0.8331330139697966,0.5530726724498041],[1,179.99878138597225,-179.99915270600772,67.15613517320901]],[4,"Bn_Mouth",-27,[1,"89CoNx03Fe95p6c3PgddFh",1,0],[1,0.1322927474975586,0.8844605684280396,0.0000019073486328125],[3,-0.06744714874232752,0.6958798219497017,0.7094951918431234,-0.08842357310848374],[1,-90.93173238028068,-178.39319594896983,-12.670413083369786]]],1,4,4,4,4,4,4,4,4,4,4,4,1,4,1,4,4,1,4,4],[1,"a84YD19Gdc1L3jl37FEJEs",1,0],[1,0.5518631935119629,0.09183895587921143,2.547251369833248e-7],[3,-1.1069167078265287e-13,1.1962683563867385e-7,-0.043131225804261084,0.9990694156867217],[1,5.934478864202835e-7,0.000013746614115451107,-4.944008108247556]],[57,"Bip001 Jaw",2,[[[4,"Bip001 R_Down_Lip",-28,[1,"c6PyF6E9Fejpf+FhJZKAVH",1,0],[1,0.22414958477020264,-0.02978229522705078,-0.08345255255699158],[3,0.0379035511010869,-0.08312863876031353,-0.006381982952408379,0.9957972788300739],[1,4.269098997992235,-9.503310182423972,-1.0893766456782763]],[4,"Bip001 L_Down_Lip",-29,[1,"57n9xYdK5ZWIvmtHeYAceX",1,0],[1,0.22414958477020264,-0.029782772064208984,0.08345238864421844],[3,-0.037903543695988244,0.08312866121180473,-0.006381548032422486,0.9957972800249704],[1,-4.269102224069318,9.503314555275125,-1.0893270358589797]],[4,"Bip001 Down_Lip",-30,[1,"1cIIaKZ1pcGLS4H52SXjPZ",1,0],[1,0.2706289291381836,-0.04498434066772461,-0.0000031644667615182698],[3,1.3287119702936462e-8,5.713210890487879e-7,-0.0257779617757464,0.9996676931292525],[1,0.000003214003631930435,0.00006557321519133576,-2.954264076398538]],-31,[4,"Bip001 DownTeeth",-32,[1,"d42HOx4B5W6oKyikGCD94J",1,0],[1,0.2538257837295532,-0.03244733810424805,-0.000030705345125170425],[3,1.7297688071575725e-14,-2.3735439809270516e-8,0.008557617494658156,0.999963382921002],[1,2.3281093649878275e-8,-0.000002720179887652147,0.9806426997154128]]],4,4,4,1,4],[1,"5bcRdelBNcnqSCWgDkZn2m",1,0],[1,0.1990981101989746,0.5892319679260254,0.000001037686160998419],[3,2.504685350165249e-7,-0.000002399451695679412,0.8283695703185308,0.5601819837914038],[1,179.99934519577238,-179.99952254268467,68.1367681348831]],[48,"Bip001 Neck",[[-33,-34,-35,[4,"Bip001 Hair01",-36,[1,"05vzGOWtNStKzQvyWde+Ao",1,0],[1,-0.06071972846984863,-0.2820974588394165,8.112858722597593e-7],[3,1.6516783028762314e-14,0.0000018647883395428245,-0.6723349568022915,0.7402470573113974],[1,0.0014976386299721703,0.0016489140950808594,-84.49506936731329]]],1,1,1,4],[1,"cf54cUQTFQdaEFKgi0tXhy",1,0],[1,0.9543073177337646,-0.3201141357421875,-5.500842235051095e-7],[3,1.1810981550389486e-14,6.097828807722803e-7,-0.2198525345649096,0.9755331173491822],[1,0.000017006426557973736,0.00007546117671314657,-25.40074358145492]],[47,"Bip001 Spine",[-37,-38,-39],[1,"f2uk/fraBW44RrsLTmM1qH",1,0],[1,0.400854229927063,0.015083789825439453,4.153639565629419e-7],[3,-0.000002052787330614699,-6.669589654747255e-7,-0.037431762275221075,0.9992991860140349],[1,-0.0002385966896096073,-0.0000854188249321574,-4.290366292445109]],[57,"Bip001 Neck1",4,[[-40,[98,"Bip001 Hair02",-41,[1,"14Ad035ANcloqi0mJImlLj",1,0],[1,-0.017128705978393555,-0.21748805046081543,-5.193219294596929e-7],[3,-7.012453917385995e-13,0.0000019041008676043273,-0.6865084912899153,0.7271217857987882],[1,0.9999989867210388,0.9999989867210388,1],[1,0.002609061184881379,0.0027634112797080704,-86.70871443960806]]],1,4],[1,"56D6KHIFhfjJguAA9oJ5nd",1,0],[1,0.6923840045928955,-0.00044989585876464844,-1.2480541045079008e-9],[3,5.735766379024929e-14,8.440700028776635e-8,-0.03043228257955449,0.9995368308256535],[1,2.949038769998187e-7,0.000009685790513410704,-3.487821205901098]],[165,"Bip001 Neck2",6,[[2,[4,"Bip001 Hair03",-42,[1,"14c21KloFeW4TnZpqdpSeQ",1,0],[1,0.22313594818115234,-0.1733543872833252,-0.0000010999831374647329],[3,-5.501903323788317e-13,0.0000018955203604483748,-0.683414953116773,0.7300301376332389],[1,0.0022529890159768756,0.00240666367779299,-86.22215868172809]]],1,4],[1,"4eUfYIsfZUlrwpmZtd7TvP",1,0],[1,0.5660121440887451,-0.0004042387008666992,-1.1214069672860205e-9]],[166,"VD297_Giraffe_Toy",1,[[66,-43,[10,"a8ImwwjX5VlpOBY5oz0MC1"],[0,1,2,3,4,5,6,7,8,9,10,11,12],[29],1,13,14]],[1,"e3FAH3cZhSZLsUbfJUC80S",1,0],[1,0,-0.00011903722770512104,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Bip001",1,[-44],[1,"27goImrUhSiLj/q8l+pR3q",1,0],[1,-4.356060401278228e-9,2.378934383392334,-0.8954776525497437],[3,0,4.329780375814312e-17,-0.7071067811865476,0.7071067811865476],[1,0,0,-90]],[84,"Bip001 Pelvis",9,[5],[1,"0bz+t64LpWRoPHsBCKwTl/",1,0],[3,-0.49999999254917427,-0.49999999254917427,-0.49999930709576956,0.5000007078049009],[1,-89.99991974527727,-89.99991974527727,-0.0000017074910602964197]],[6,"Bip001 Spine1",5,[4],[1,"76JitRG4Bb6IWeWws2pnXN",1,0],[1,0.6363147497177124,-0.0006434917449951172,-1.7844286048784852e-9],[3,-5.001003109185003e-14,6.055923869577305e-7,-0.21834164731705358,0.9758723917841453],[1,0.000016748928224149575,0.00007485893130099625,-25.2232972333355]],[14,"Bip001 R_Ear",2,[[4,"Bip001 R_Ear02",-45,[1,"7c7vkHe8taurwV9/b63dyq",1,0],[1,0.24279451370239258,-0.00015926361083984375,-0.00006985664367675781],[3,0.1943117099157505,-0.021092375925360597,0.2231939752599514,0.9549777591520656],[1,24.76597094901678,-8.038122542265535,24.71428519601091]]],[1,"d2RYeAmwZVVbYhAqdc4wDo",1,0],[1,0.29334402084350586,0.004457592964172363,-0.16000939905643463],[3,0.16336328288055393,0.39462871559616325,-0.6255358051764845,0.6529054840293637],[1,76.93816074345585,97.44558932195352,-43.46377554217515]],[6,"Bip001 Tongue01",3,[-46],[1,"5fP7MY0KRScq+eqbAl68XC",1,0],[1,0.09311747550964355,-0.010273933410644531,-7.956077752169222e-8],[3,-1.3280751676258093e-7,-5.582045435328034e-7,-0.11713972903232928,0.9931154433810317],[1,-0.000023244665055349306,-0.00006715070549894516,-13.454113569998423]],[14,"Bip001 Tongue02",13,[[4,"Bip001 Tongue03",-47,[1,"14ITHPHChYjbDoBqTnlyOE",1,0],[1,0.057037353515625,0.000232696533203125,-1.6103513189591467e-7],[3,-0.0000014086552937428342,1.1217554662923372e-9,1.490116297018971e-8,0.9999999999990077],[1,-0.0001614200062424202,1.2854611307425332e-7,0.0000017075473149815245]]],[1,"d4iQC7nKxUyoITQdTj5HN0",1,0],[1,0.06330013275146484,0.0005035400390625,1.3969838619232178e-9],[3,2.34142972213993e-13,-1.4840483635151933e-7,0.05350618418461001,0.9985675181248289],[1,9.151900506504044e-7,-0.00001707937578821318,6.134286427783285]],[6,"Bip001 Tail_01",2,[-48],[1,"fd1KRbHfVdb5Q/fJ5w91SW",1,0],[1,-3.099538564682007,-1.777132272720337,-0.0000052145178415230475],[3,2.8648892559348733e-7,0.000003959627048611977,-0.7996029223990082,0.6005290721315704],[1,179.99862760717215,179.9989282292747,-73.81559809876565]],[6,"Bip001 Tail_02",15,[-49],[1,"4bY2R+ZuhfRbqPseCyF6kY",1,0],[1,0.276302695274353,0.0013399124145507812,-8.407732821069658e-8],[3,-1.6811053228192466e-7,-1.8257904405254525e-7,-0.06674220435377931,0.9977702531935582],[1,-0.000020802808719429435,-0.000022360300422630196,-7.653782761696829]],[6,"Bip001 Tail_03",16,[-50],[1,"55lY+R+5VfcL3MRr4OPaf/",1,0],[1,0.3749101161956787,0.010757684707641602,-8.89989678398706e-7],[3,-0.0000015325682318977173,0.0000016193943924228711,-0.017069453032498388,0.9998543062707688],[1,-0.00017252677321186527,0.00018265060150047768,-1.9561102335835894]],[14,"Bip001 Tail_04",17,[[4,"Bip001 Tail_05",-51,[1,"d9Du9LEYtYd6fEY+RDtLSd",1,0],[1,0.3159787654876709,-0.00016641616821289062,-8.189126674551517e-7],[3,-0.0000014061682804794182,-0.0000014202421425551375,1.0151216400779641e-7,0.9999999999979976],[1,-0.00016113499899229333,-0.0001627477449527858,0.000011632665984489571]]],[1,"37bpu2CtdYWYgYXX1+Fi7a",1,0],[1,0.3840022087097168,-0.013496160507202148,-0.0000010278017725795507],[3,-0.0000014331359352548016,0.0000014222537174612764,-7.976756251063611e-7,0.9999999999976437],[1,-0.00016422515111352108,0.00016297813981618533,-0.00009140712704794832]],[14,"Bip001 L_Ear",2,[[4,"Bip001 L_Ear02",-52,[1,"16zFfly2pUNYXtnr5x4XBX",1,0],[1,0.24279439449310303,-0.00015878677368164062,0.0000699758529663086],[3,-0.19431173719916414,0.02109113885556124,0.22319412137824649,0.9549777467724632],[1,-24.765946391686672,8.037979485146726,24.714332699889397]]],[1,"754t+mjF9VIpOTs7KdhAPA",1,0],[1,0.29334354400634766,0.0044564008712768555,0.16000941395759583],[3,-0.16336253074214327,-0.3946245857720451,-0.6255386986925687,0.6529053961270129],[1,-76.93861022551313,-97.44570159305196,-43.46421850753999]],[6,"Bip001 L Clavicle",4,[-53],[1,"e8IZExt/9Zj4U6ZKChzAp8",1,0],[1,-0.6252610683441162,-0.15536224842071533,0.3209458291530609],[3,0.6218016091848645,0.3824239934956703,0.39082494027587333,0.5606875369332697],[1,101.18437273864923,-8.096527187598403,66.04223841119425]],[6,"Bip001 L UpperArm",20,[-54],[1,"d4y+2xk59a2r6WSeI/vdA+",1,0],[1,0.4305196702480316,5.960464477539063e-8,0],[3,-0.4766226478125026,0.5748613557875564,0.4806062944999592,0.45976392083471496],[1,-85.17161138936022,97.09950957592135,-6.087838604977945]],[6,"Bip001 L Forearm",21,[-55],[1,"feam7ruXVQvZy90w4OSN1y",1,0],[1,0.5732908248901367,0,1.4901161193847656e-8],[3,1.8073457900254473e-18,-3.619298562452549e-18,-0.10238340452658577,0.9947450117882197],[1,1.6705795063605852e-16,-3.99737720120276e-16,-11.752868225791161]],[14,"Bip001 L Hand",22,[[4,"Bip001 L Finger0",-56,[1,"3byxQ4HQJX6rqKO+WPtPaP",1,0],[1,0.825505793094635,0.00021010637283325195,-0.016567260026931763],[3,-0.003084158369715048,0.013701365674395385,0.019711368282363303,0.9997070683486458],[1,-0.38456341678652844,1.5779873400313138,2.253833657637567]]],[1,"1arjDVWixWE6C/bv+TdkwO",1,0],[1,1.0205600261688232,-5.960464477539063e-8,0],[3,-0.706795399661755,-0.0019021578041327138,-0.062264722302334395,0.7046699576179485],[1,-90.39524475854142,-5.222724049499616,-4.879664052241934]],[6,"Bip001 R Clavicle",4,[-57],[1,"7c+r1SaXFbJIz1+lTaGNL8",1,0],[1,-0.6252610683441162,-0.15536046028137207,-0.3209473192691803],[3,-0.621800054529036,-0.3824250931463723,0.3908238642904015,0.5606892610178962],[1,-101.18359469678377,8.095814037152945,66.04228349204378]],[6,"Bip001 R UpperArm",24,[-58],[1,"27MQcNugdU3YnRBSyPx/OP",1,0],[1,0.4305196702480316,5.960464477539063e-8,-4.440892098500626e-16],[3,-0.4766226478125026,0.5748613557875564,-0.4806062944999592,-0.45976392083471496],[1,85.17161138936022,-97.09950957592135,-6.087838604977945]],[6,"Bip001 R Forearm",25,[-59],[1,"1aix5QZVtffaZlYVrLXuzk",1,0],[1,0.5732908248901367,1.1102230246251565e-16,-1.4901161193847656e-8],[3,1.1160960807208764e-18,4.490079861320526e-18,-0.10238340452658577,0.9947450117882197],[1,1.8375430731814063e-16,5.361561372211306e-16,-11.752868225791161]],[14,"Bip001 R Hand",26,[[4,"Bip001 R Finger0",-60,[1,"528DScHiFfopPcfjRBeca+",1,0],[1,0.825505793094635,0.00021010637283325195,0.016567260026931763],[3,0.003084158369715048,-0.013701365674395385,0.019711368282363303,0.9997070683486458],[1,0.38456341678652844,-1.5779873400313138,2.253833657637567]]],[1,"65Hr4qA4tY9J8Jvd+K0x5F",1,0],[1,1.0205599069595337,-5.960464477539063e-8,-5.551115123125783e-17],[3,0.706795399661755,0.0019021578041327138,-0.062264722302334395,0.7046699576179485],[1,90.39524475854142,5.222724049499616,-4.879664052241934]],[6,"Bip001 L Thigh",5,[-61],[1,"11BAfAQWVSDq0Huwsgvaqy",1,0],[1,-0.39860236644744873,-0.045030832290649414,0.31775563955307007],[3,0.6697904583392761,0.7425501474978701,0.0000828426578436208,-0.00011621380163828846],[1,-0.15539599845470578,-179.84189640298345,84.10176769549689]],[6,"Bip001 L Calf",28,[-62],[1,"dayS5tevFSZqR9L49DlLE1",1,0],[1,0.6152560710906982,-5.960464477539063e-8,0],[3,2.3134668868276776e-24,-5.182844774448237e-20,-0.19607236564834585,0.9805894285729687],[1,-1.2612065319290729e-18,-6.308848736250139e-18,-22.614750028058115]],[6,"Bip001 L HorseLink",29,[-63],[1,"4eZ9lbh79WQ7KnvB+7+zxC",1,0],[1,0.6745597720146179,4.440892098500626e-16,-2.9802322387695312e-8],[3,1.1641626586293666e-11,1.7558664120709856e-11,0.22098652425649812,0.9752768612537837],[1,9.4910882731769e-10,1.8480233733852806e-9,25.53396581578114]],[14,"Bip001 L Foot",30,[[4,"Bip001 L Toe0",-64,[1,"9eXV3vCA5TaIZGzjUDTB7g",1,0],[1,0.06374531984329224,-0.008129239082336426,-2.9802322387695312e-8],[3,7.147154967240356e-14,1.130674135800072e-13,-0.008726830662804639,0.9999619204882667],[1,8.304059067177777e-12,1.3029535472831268e-11,-1.0000338246402656]]],[1,"27d7tBW79d3Krcc+XS9kjS",1,0],[1,0.8986997008323669,1.1920928955078125e-7,0],[3,-0.000024228231144416933,-0.00014043359188703749,-0.0027167782979811692,0.9999962993966922],[1,-0.0028201019021005386,-0.016100225290632233,-0.31131985060473577]],[6,"Bip001 R Thigh",5,[-65],[1,"80xBgp43xZAaNnhTprLbP3",1,0],[1,-0.39860236644744873,-0.0450291633605957,-0.31775563955307007],[3,0.6697904585943798,0.7425501477806858,-0.00008071986082393435,0.00011441641456539929],[1,0.15229580824553335,179.84497019075718,84.1017685548488]],[6,"Bip001 R Calf",32,[-66],[1,"35suY1tUlZY6a8OdTLav2m",1,0],[1,0.6152560710906982,-5.960464477539063e-8,-5.551115123125783e-17],[3,-9.964784720143505e-22,-4.9835490194608505e-21,-0.19607236564834585,0.9805894285729687],[1,-2.4259603755906904e-19,-6.308848663652707e-19,-22.614750028058115]],[6,"Bip001 R HorseLink",33,[-67],[1,"a8Hm0zESxYv6gYOiTo0hxR",1,0],[1,0.6745598316192627,1.1920928955078125e-7,2.9802322387695312e-8],[3,-2.12874833573142e-11,-3.4665110129492556e-11,0.22098652425649812,0.9752768612537837],[1,-1.6637217959020381e-9,-3.6960467942528948e-9,25.53396581578114]],[14,"Bip001 R Foot",34,[[4,"Bip001 R Toe0",-68,[1,"49XHXwZQJSX7a3Ea2snvla",1,0],[1,0.06374531984329224,-0.008129239082336426,2.9802322387695312e-8],[3,-7.423691575647812e-14,6.478770305492795e-16,-0.00872682880030133,0.999961920504521],[1,-8.507247866030362e-12,-5.670285097220125e-20,-1.0000336112049801]]],[1,"c4UT6iM6ZavIrWG+TU0Tk4",1,0],[1,0.8986997008323669,1.1920928955078125e-7,5.551115123125783e-17],[3,0.000024315635403754084,0.00014043181655312579,-0.0027167782979760826,0.9999962993948199],[1,0.0028301172505327196,0.01610004906114549,-0.3113198492019426]]],0,[0,4,1,0,0,1,0,0,1,0,-1,8,0,-2,9,0,4,1,0,1,1,0,-1,12,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-13,3,0,1,2,0,-15,15,0,1,2,0,1,2,0,-18,19,0,1,2,0,1,2,0,1,3,0,1,3,0,1,3,0,-4,13,0,1,3,0,-1,6,0,-2,20,0,-3,24,0,1,4,0,-1,11,0,-2,28,0,-3,32,0,-1,7,0,1,6,0,1,7,0,0,8,0,-1,10,0,1,12,0,-1,14,0,1,14,0,-1,16,0,-1,17,0,-1,18,0,1,18,0,1,19,0,-1,21,0,-1,22,0,-1,23,0,1,23,0,-1,25,0,-1,26,0,-1,27,0,1,27,0,-1,29,0,-1,30,0,-1,31,0,1,31,0,-1,33,0,-1,34,0,-1,35,0,1,35,0,18,1,2,1,7,4,1,11,5,1,10,68],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,12,20,-1,-2,-3,22],[1,1,1,1,1,1,1,1,1,1,1,1,53,54,55,17,40,41,64]],[[[40,"PopupChangeAnimal"],[169,"PopupChangeAnimal",33554432,[-4,-5,-6],[[37,-2,[10,"56Es2g575F84qLk7MCNJ1u"],[5,900,600]],[176,0,-3,[10,"fayiM/6U1L2bf7h5LQL84U"],13]],[1,"6cZhWWAgFMj77FGB9Dj31n",-1,0],[1,4.380999999999972,30.173999999999978,0]],[170,"Yes",33554432,1,[-11],[[37,-7,[10,"1ehwqlqSVGQZ9J35Gx47gz"],[5,250,122]],[144,1,0,-8,[10,"36k+lxYoxBspsgPppu7GPt"],2],[146,1,-10,[10,"90tjOlXItBYYeTXD5zMhct"],[[111]],-9,3,4,5,6]],[1,"86xM7AC1JD4pK8JkP+CVxw",1,0],[1,180,-162,0]],[170,"No",33554432,1,[-16],[[37,-12,[10,"b1uO5E0ABDipqAFzsXDRvR"],[5,234,102]],[144,1,0,-13,[10,"a98AeAjiFJv4HlPPy08zjr"],8],[146,1,-15,[10,"dbZGYUoQNBUbudEMrUrFCD"],[[111]],-14,9,10,11,12]],[1,"60LXZn/xVEHpmWdnH2tQbx",1,0],[1,-180,-160,0]],[85,"Label",33554432,1,[[37,-17,[10,"a6GoX/EExLsJCZyV08eAPd"],[5,700,226]],[116,"你刚刚学习了这个动物的知识。\n我们再试试其他动物吧！",50,50,100,false,-18,[10,"d1DE4+SDlJB4nBBDNCRdsx"],[4,4278190080],0]],[1,"a9GWE7XPNNn59QJdHABXSq",1,0],[1,0,92,0]],[167,"Label",512,33554432,2,[[37,-19,[10,"58kIZy8sBFSrwzdGollQrZ"],[5,100,50]],[279,"是",50,50,60,1,false,false,-20,[10,"b2ixqOjUtOu68AD66dgqIo"],1]],[1,"42kGiwQXhM/rK1CXLB2Qnx",1,0]],[167,"Label",512,33554432,3,[[37,-21,[10,"02gsoKZ5dBD49GCrhDru4e"],[5,100,50]],[280,"否",50,50,60,1,false,false,-22,[10,"90O0/WnJhCqb6l2P/JDz8k"],[4,4278190080],7]],[1,"84P4hvgipMAaVmZHfRUxKz",1,0]]],0,[0,4,1,0,0,1,0,0,1,0,-1,4,0,-2,2,0,-3,3,0,0,2,0,0,2,0,11,2,0,0,2,0,-1,5,0,0,3,0,0,3,0,11,3,0,0,3,0,-1,6,0,0,4,0,0,4,0,0,5,0,0,5,0,0,6,0,0,6,0,18,1,22],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[8,8,2,6,9,10,13,8,2,6,9,10,13,2],[0,0,12,12,2,3,4,0,13,13,2,3,4,25]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0,"normalMap",6,1],{},{}],11,0,0]]],0,0,[0,0,0],[15,32,14],[181,36,29]],[[{"name":"Bg-3","rect":{"x":0,"y":0,"width":1080,"height":1920},"offset":{"x":0,"y":0},"originalSize":{"width":1080,"height":1920},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[7],0,[0],[23],[182]],[[[332,"m_applaydu_lobby_loop",".mp3",57.6],-1],0,0,[],[],[]],[[[306,"0",[{"rasterizerState":{"polygonMode":2,"shadeModel":1},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"frameTile_velLenScale",8,[2,2,1,0,0],"tintColor",8,[4,2147483647],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[183,184]],[[[333,"Sparkle",".plist"],-1],0,0,[],[],[]],[[[40,"Food_Steak"],[103,"Food_Steak",[-3],[[147,2,-2,[10,"dfbCZuS1pOLrASIyckfRGm"]]],[1,"39zeFwLgRcroMIxnUxSpHx",-1,0],[1,0.2,0.2,0.2]],[64,"Steak",1,[[114,-4,[10,"acdgmtdN9XEb4W3QOvDTxL"],[0],[29],1]],[1,"79epd6+MteDofHCEwJkR0f",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,4,1,0,0,1,0,-1,2,0,0,2,0,18,1,4],[0,0],[-1,12],[185,186]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[90,28]],[[[120,"Skin-0",374540058,["Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01/Bip001 Tail_02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Hair02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Hair03","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2","Bip001/Bip001 Pelvis","Bip001/Bip001 Pelvis/Bip001 Spine","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink/Bip001 L Foot/Bip001 L Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink/Bip001 L Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L HorseLink","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_UpEyelid","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_DownEyelid","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_cheek","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03/Bip001 Tail_04","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03/Bip001 Tail_04/Bip001 Tail_05","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Tail_01/Bip001 Tail_02/Bip001 Tail_03","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 nose","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_Up_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 L_Down_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 Down_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_Ear","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_Ear/Bip001 L_Ear02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 UP_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 UpTeeth","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 Tongue01/Bip001 Tongue02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 Tongue01/Bip001 Tongue02/Bip001 Tongue03","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 Tongue01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 DownTeeth","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Hair01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 L_EyeBall","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink/Bip001 R Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R HorseLink/Bip001 R Foot/Bip001 R Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_UpEyelid","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_DownEyelid","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_cheek","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_Ear","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_Up_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 Jaw/Bip001 R_Down_Lip","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_Ear/Bip001 R_Ear02","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Neck1/Bip001 Neck2/Bip001 Head/Bip001 R_EyeBall"],[[[7,-0.00000255021768680308,-0.000005215080363996094,1,0,0.9833522439002991,-0.18170975148677826,0.0000015601311815771624,0,0.18170975148677826,0.9833522439002991,0.000005591659828496631,0,-1.569665551185608,-2.41400408744812,-0.000016520543795195408,1],[7,-0.000001446136138838483,-0.000005819375019200379,1,0,0.9987928867340088,-0.04912137612700462,0.0000011585347010623082,0,0.04912137612700462,0.9987928867340088,0.000005883385711058509,0,-1.5078305006027222,-2.6396844387054443,-0.00001667447213549167,1],[7,5.291087177283771e-7,-0.000002661785856616916,1,0,-0.6623979210853577,0.7491523027420044,0.000002344562972211861,0,-0.7491523027420044,-0.6623979210853577,-0.0000013667780649484484,0,1.75612211227417,4.876213550567627,0.000012433055417204741,1],[7,5.010662111535481e-17,-0.0000027736000447475817,1,0,-0.5747995376586914,-0.8182942867279053,-0.0000022696210635331227,0,0.8182942867279053,-0.5747995376586914,-0.0000015942640629873495,0,-3.053658962249756,1.1519149541854858,0.0000029811449167027604,1],[7,5.215457141952585e-17,-0.0000027736004994949326,1,0,-0.523952841758728,-0.8517473340034485,-0.000002362406348765944,0,0.8517473340034485,-0.523952841758728,-0.0000014532356544805225,0,-3.8092100620269775,0.9223347902297974,0.000002344381300645182,1],[7,3.502345579276073e-17,-0.0000027736000447475817,1,0,0.8202616572380066,-0.5719896554946899,-0.0000015864683291511028,0,0.5719896554946899,0.8202616572380066,0.0000022750746211386286,0,-1.3556551933288574,-3.7203891277313232,-0.000010616566214594059,1],[7,3.5449976586372675e-17,-0.0000027736000447475817,1,0,0.8153745532035828,-0.5789345502853394,-0.0000016057314269346534,0,0.5789345502853394,0.8153745532035828,0.0000022615208763454575,0,-1.3966890573501587,-4.516148090362549,-0.000012120615792809986,1],[7,5.215457141952585e-17,-0.0000027736004994949326,1,0,-0.523952841758728,-0.8517473340034485,-0.000002362406348765944,0,0.8517473340034485,-0.523952841758728,-0.0000014532356544805225,0,-4.375222206115723,0.9227390885353088,0.000002345502707612468,1],[7,0.0000013868001360606286,0.0000013868001360606286,1,0,-1,1.923153476746098e-12,0.0000013868001360606286,0,6.123234262925839e-17,-1,0.0000013868001360606286,0,0.8954776525497437,2.3790533542633057,-0.000004536764208751265,1],[7,5.441503434922911e-17,-0.0000027736000447475817,1,0,-0.997197687625885,-0.07481105625629425,-2.0749594398239424e-7,0,0.07481105625629425,-0.997197687625885,-0.0000027658277303999057,0,0.31638628244400024,2.394348382949829,0.000006764943918824429,1],[7,0.00028080467018298805,-0.000032931722671492025,-0.9999999403953552,0,0.028058523312211037,-0.9996063113212585,0.00004079772043041885,0,-0.999606192111969,-0.02805853635072708,-0.0002797700872179121,0,2.3529014587402344,0.9618881940841675,0.31838467717170715,1],[7,0.05718785151839256,0.9961947202682495,-0.06576956808567047,0,-0.9788727164268494,0.042995937168598175,-0.19989937543869019,0,-0.1963108777999878,0.07581184059381485,0.9776065945625305,0,0.2000403255224228,-0.5133196711540222,-2.7213196754455566,1],[7,-0.047780394554138184,0.019250085577368736,0.998672366142273,0,0.31298768520355225,0.9497512578964233,-0.0033325429540127516,0,-0.948554515838623,0.31241291761398315,-0.05140453577041626,0,2.7679901123046875,-0.1258448213338852,-0.21116912364959717,1],[7,-0.05069974437355995,0.009114150889217854,0.998672366142273,0,0.11297041922807693,0.9935927391052246,-0.0033326072152704,0,-0.9923039674758911,0.11265147477388382,-0.05140452831983566,0,2.174321413040161,0.3238334059715271,-0.21116918325424194,1],[7,3.0165175901053035e-17,-0.0000027736000447475817,1,0,-0.8702383041381836,-0.49263113737106323,-0.0000013663616300618742,0,0.49263113737106323,-0.8702383041381836,-0.0000024136927549989196,0,-1.3100435733795166,2.030302047729492,0.000005755224265158176,1],[7,0.0002718777977861464,0.00007757788989692926,-0.9999999403953552,0,0.410282701253891,-0.9119583964347839,0.00004079895370523445,0,-0.9119583368301392,-0.410282701253891,-0.0002797700872179121,0,1.234162449836731,1.5561118125915527,0.31838467717170715,1],[7,0.0000020388738448673394,0.0000019824697119474877,-1,0,-6.123234262925839e-17,-1,-0.0000019824697119474877,0,-1,4.042066594628357e-12,-0.0000020388738448673394,0,0.1865268349647522,1.1759483814239502,0.3183649480342865,1],[7,-0.000001982469939321163,0.000002017392262132489,-1,0,-0.01745329424738884,-0.9998477101325989,-0.000001982484263862716,0,-0.9998477101325989,0.01745329424738884,0.000002017377937590936,0,0.2707692086696625,1.1643844842910767,0.31836414337158203,1],[7,0.03949568048119545,-0.9992038607597351,0.005626568105071783,0,0.027273131534457207,0.0067068589851260185,0.9996054172515869,0,-0.9988473653793335,-0.03932664915919304,0.027516311034560204,0,1.0981080532073975,0.3124203681945801,0.42092499136924744,1],[7,2.7372845323725414e-8,-1,8.940696005765858e-8,0,-6.123232939436859e-17,8.940696716308594e-8,0.9999998807907104,0,-0.9999998807907104,-2.7372848876439093e-8,2.38609075362418e-15,0,0.27252790331840515,0.29873359203338623,0.4468482732772827,1],[7,3.8463884854955666e-12,-0.000002773600272121257,1,0,-0.4485979974269867,-0.8937337398529053,-0.00000247885805038095,0,0.8937337398529053,-0.4485979974269867,-0.000001244234795194643,0,-4.980362415313721,0.4031815528869629,9.044772468769224e-7,1],[7,0.00027876306558027864,-0.000047192730562528595,-0.9999999403953552,0,-0.022885749116539955,-0.9997380971908569,0.00004080066719325259,0,-0.9997380375862122,0.02288573607802391,-0.0002797700872179121,0,1.1757022142410278,1.1629116535186768,0.31838467717170715,1],[7,0.9659981727600098,-0.24628859758377075,-0.07867289334535599,0,-0.2011970728635788,-0.9071778655052185,0.369524210691452,0,-0.1623798906803131,-0.34113094210624695,-0.9258847236633301,0,0.1136460080742836,-0.3415166437625885,5.318476676940918,1],[7,0.9659954905509949,-0.24626027047634125,-0.07879386097192764,0,-0.20109106600284576,-0.9071142673492432,0.3697379529476166,0,-0.16252680122852325,-0.3413205146789551,-0.9257889986038208,0,0.11636586487293243,-0.3404788672924042,5.244320869445801,1],[7,0.9904707670211792,-0.13762030005455017,-0.005315810441970825,0,-0.12237933278083801,-0.897172212600708,0.42438802123069763,0,-0.06317359954118729,-0.41969335079193115,-0.9054648280143738,0,-0.13142654299736023,-0.00309978099539876,5.034485816955566,1],[7,-0.000007277576969499933,-0.00001185160090244608,1,0,0.9998875260353088,-0.014998425729572773,0.000007099003141775029,0,0.014998425729572773,0.9998875260353088,0.000011959419680351857,0,-2.175171136856079,-2.6996700763702393,-0.000042854568164329976,1],[7,-0.000004437095412868075,-0.000014663933143310715,1,0,0.9998875260353088,-0.01499862875789404,0.000004216657544020563,0,0.01499862875789404,0.9998875260353088,0.000014728833775734529,0,-2.491150379180908,-2.699502944946289,-0.000042551488149911165,1],[7,-0.0000044326638999336865,-0.00000898532016435638,1,0,0.9998875856399536,-0.015000022947788239,0.000004297384748497279,0,0.015000022947788239,0.9998875856399536,0.000009050798325915821,0,-1.7911734580993652,-2.713163375854492,-0.00002995617251144722,1],[7,-3.6557432281369984e-7,0.0000031705701530881925,1,0,-0.5451578497886658,-0.8383334279060364,0.0000024586993276898284,0,0.8383334279060364,-0.5451578497886658,0.00000203493436856661,0,-5.3100996017456055,0.22121083736419678,0.000012819946277886629,1],[7,-0.9834277033805847,-0.07535165548324585,-0.16489998996257782,0,0.05511775240302086,0.7422297596931458,-0.6678750514984131,0,0.17271916568279266,-0.6658957004547119,-0.725776195526123,0,-0.5307903289794922,4.922797679901123,1.4283568859100342,1],[7,0.9837003350257874,-0.16731400787830353,-0.06587543338537216,0,0.152854323387146,0.5851213932037354,0.7964097261428833,0,-0.09470538049936295,-0.7934978008270264,0.601158857345581,0,0.7260411977767944,5.0750250816345215,-0.5937017798423767,1],[7,-0.16507425904273987,-0.0765521377325058,0.983305811882019,0,-0.6674317121505737,0.7426939606666565,-0.05422625690698624,0,-0.7261441349983215,-0.6652408242225647,-0.1736930012702942,0,1.431179404258728,4.907702922821045,0.5374665260314941,1],[7,-4.773568775817694e-7,-0.000002633868916745996,1,0,-0.7001278400421143,0.714017391204834,0.0000015464175930901547,0,-0.714017391204834,-0.7001278400421143,-0.0000021848863980267197,0,1.2298862934112549,4.991217136383057,0.00001701764813333284,1],[7,0.7196860313415527,0.28038498759269714,0.6351662874221802,0,0.6569914817810059,-0.5708681344985962,-0.4924141466617584,0,0.2245306372642517,0.7716824412345886,-0.5950564742088318,0,0.1065763607621193,-4.96716833114624,1.8200093507766724,1],[7,0.6838900446891785,-0.31116482615470886,0.6599020957946777,0,0.41482067108154297,-0.5782256722450256,-0.7025517225265503,0,0.6001816987991333,0.7542091012001038,-0.2663652300834656,0,-2.430375337600708,-4.696169376373291,-0.20293672382831573,1],[7,5.175351134312223e-7,-0.000005879069703951245,1,0,-0.7100159525871277,0.7041858434677124,0.000004507414359977702,0,-0.7041858434677124,-0.7100159525871277,-0.0000038097912238299614,0,1.1548869609832764,5.018223285675049,0.000015606367014697753,1],[7,0.000003184981778758811,-0.000006563875103893224,1,0,-0.6494793891906738,0.7603790760040283,0.000007059614745230647,0,-0.7603790760040283,-0.6494793891906738,-0.0000018413086309010396,0,1.5860849618911743,4.909286022186279,0.00005783742744824849,1],[7,0.00000227941018238198,-0.000002842612730091787,1,0,-0.7524473667144775,0.6586522459983826,0.000003587430228435551,0,-0.6586522459983826,-0.7524473667144775,-6.375778980327595e-7,0,0.9638833999633789,5.064806938171387,0.000012441931175999343,1],[7,0.0000022771666863263818,-0.000005659923317580251,1,0,-0.7524473071098328,0.6586522459983826,0.000005441370376502164,0,-0.6586522459983826,-0.7524473071098328,-0.000002758933760560467,0,0.9068463444709778,5.064574241638184,0.000026873483875533566,1],[7,0.0000022737335712008644,-0.000002598641913209576,1,0,-0.818522036075592,0.574475109577179,0.000003353956117280177,0,-0.574475109577179,-0.818522036075592,-8.208422173083818e-7,0,0.4804438650608063,5.139310359954834,0.00001264857201022096,1],[7,5.30944817001e-7,-0.0000026708573841460748,1,0,-0.6494793891906738,0.7603791952133179,0.000002375702024437487,0,-0.7603791952133179,-0.6494793891906738,-0.0000013309473843037267,0,1.5860859155654907,4.882230758666992,0.000043065094359917566,1],[7,0.047780394554138184,-0.019250085577368736,0.998672366142273,0,0.31298768520355225,0.9497512578964233,0.0033325429540127516,0,-0.948554515838623,0.31241291761398315,0.05140453577041626,0,2.7679901123046875,-0.1258448362350464,0.21116936206817627,1],[7,3.984083325753891e-17,-0.000002773600272121257,1,0,0.759378969669342,-0.6506486535072327,-0.00000180463905508077,0,0.6506486535072327,0.759378969669342,0.0000021062135147076333,0,-1.714515209197998,-2.841568946838379,-0.000009688893442216795,1],[7,-0.0002808095596265048,0.00003310589454486035,-0.9999999403953552,0,0.028058523312211037,-0.9996063113212585,-0.000040971961425384507,0,-0.999606192111969,-0.02805853635072708,0.0002797700872179121,0,2.3529014587402344,0.9618882536888123,-0.3183844983577728,1],[7,0.9758886694908142,0.21203115582466125,0.05180666968226433,0,-0.19028127193450928,0.9427250027656555,-0.2739751636981964,0,-0.10693071037530899,0.2575114071369171,0.9603404402732849,0,-0.045463964343070984,0.8317544460296631,-5.231501579284668,1],[7,-0.0002719495096243918,-0.00007741848821751773,-0.9999999403953552,0,0.410282701253891,-0.9119583964347839,-0.000040973740397021174,0,-0.9119583368301392,-0.410282701253891,0.0002797700872179121,0,1.234162449836731,1.5561119318008423,-0.3183844983577728,1],[7,-0.05718785151839256,-0.9961947202682495,-0.06576956808567047,0,-0.9788727164268494,0.042995937168598175,0.19989937543869019,0,-0.1963108777999878,0.07581184059381485,-0.9776065945625305,0,0.2000403106212616,-0.5133199095726013,2.7213196754455566,1],[7,0.05069974437355995,-0.009114150889217854,0.998672366142273,0,0.11297041922807693,0.9935927391052246,0.0033326072152704,0,-0.9923039674758911,0.11265147477388382,0.05140452831983566,0,2.174321413040161,0.3238334059715271,0.21116942167282104,1],[7,-0.0002787590492516756,0.00004736815390060656,-0.9999999403953552,0,-0.022885749116539955,-0.9997380971908569,-0.00004097613782505505,0,-0.9997380375862122,0.02288573607802391,0.0002797700872179121,0,1.1757022142410278,1.1629117727279663,-0.3183845281600952,1],[7,0.000001982469939321163,-0.000002017392262132489,-1,0,-0.01745329424738884,-0.9998477101325989,0.000001982484263862716,0,-0.9998477101325989,0.01745329424738884,-0.000002017377937590936,0,0.2707692086696625,1.1643844842910767,-0.3183642029762268,1],[7,0.000002039416358456947,-0.0000019824692572001368,-1,0,-6.123232277692369e-17,-0.9999997615814209,0.0000019824697119474877,0,-0.9999997615814209,-4.043019825178407e-12,-0.000002039416813204298,0,0.18652808666229248,1.1759480237960815,-0.3183642327785492,1],[7,-0.03949568048119545,0.9992038607597351,0.005626568105071783,0,0.027273131534457207,0.0067068589851260185,-0.9996054172515869,0,-0.9988473653793335,-0.03932664915919304,-0.027516311034560204,0,1.0981080532073975,0.3124206066131592,-0.42092499136924744,1],[7,2.7372845323725414e-8,1,8.940696005765858e-8,0,-6.123232939436859e-17,8.940696716308594e-8,-0.9999998807907104,0,-0.9999998807907104,2.7372848876439093e-8,2.508555412412917e-15,0,0.27252790331840515,0.29873380064964294,-0.4468482732772827,1],[7,-0.965998113155365,0.24628940224647522,-0.07867156714200974,0,-0.20119743049144745,-0.9071756601333618,-0.36952924728393555,0,-0.16238008439540863,-0.34113600850105286,0.9258828163146973,0,0.1136465072631836,-0.34148719906806946,-5.318478584289551,1],[7,-0.9659954309463501,0.2462611198425293,-0.07879266887903214,0,-0.20109142363071442,-0.9071121215820312,-0.3697430193424225,0,-0.16252711415290833,-0.3413255512714386,0.925787091255188,0,0.11636702716350555,-0.3404499888420105,-5.244322776794434,1],[7,-0.9904707670211792,0.13762052357196808,-0.005315055139362812,0,-0.12237950414419174,-0.8971698880195618,-0.424392968416214,0,-0.06317368894815445,-0.4196983575820923,0.9054625034332275,0,-0.13142608106136322,-0.003072005696594715,-5.034485816955566,1],[7,-0.719687819480896,-0.28038766980171204,0.6351631283760071,0,0.6569896936416626,-0.5708719491958618,0.49241209030151367,0,0.22453054785728455,0.7716785669326782,0.5950614809989929,0,0.10657331347465515,-4.96715784072876,-1.8200385570526123,1],[7,0.9834277033805847,0.07535257190465927,-0.1648995727300644,0,0.05511775240302086,0.7422260642051697,0.6678791642189026,0,0.17271916568279266,-0.6658997535705566,0.7257724404335022,0,-0.5307907462120056,4.9228057861328125,-1.428329348564148,1],[7,-0.9837005138397217,0.16731387376785278,-0.06587301939725876,0,0.1528528332710266,0.5851260423660278,-0.796406626701355,0,-0.09470585733652115,-0.793494462966919,-0.6011632680892944,0,0.7260398268699646,5.075022220611572,0.5937297344207764,1],[7,0.16507530212402344,0.07654688507318497,0.9833060503005981,0,-0.6674315929412842,0.7426937818527222,0.05423092097043991,0,-0.726144015789032,-0.6652417182922363,0.17369021475315094,0,1.431179404258728,4.907706260681152,-0.5374413132667542,1],[7,-0.6838915348052979,0.3111620247364044,0.6599019765853882,0,0.414818674325943,-0.5782292485237122,0.702549934387207,0,0.600181519985199,0.75420743227005,0.2663702964782715,0,-2.4303781986236572,-4.696168422698975,0.2029087245464325,1],[7,-0.9758886694908142,-0.21203139424324036,0.05180550366640091,0,-0.1902812421321869,0.9427235126495361,0.27398034930229187,0,-0.1069306954741478,0.25751668214797974,-0.9603390097618103,0,-0.045463528484106064,0.8317257761955261,5.23150634765625,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[62,".bin",3687695271,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":53152,"length":3372,"count":1686,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":79316,"length":1332,"count":666,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":126232,"length":3630,"count":1815,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[3],"indexView":{"offset":167438,"length":2268,"count":1134,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[4],"indexView":{"offset":218282,"length":3576,"count":1788,"stride":2}},{"primitiveMode":7,"jointMapIndex":5,"vertexBundelIndices":[5],"indexView":{"offset":256178,"length":1980,"count":990,"stride":2}},{"primitiveMode":7,"jointMapIndex":6,"vertexBundelIndices":[6],"indexView":{"offset":309198,"length":3102,"count":1551,"stride":2}},{"primitiveMode":7,"jointMapIndex":7,"vertexBundelIndices":[7],"indexView":{"offset":335092,"length":1332,"count":666,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[8],"indexView":{"offset":376992,"length":3216,"count":1608,"stride":2}},{"primitiveMode":7,"jointMapIndex":9,"vertexBundelIndices":[9],"indexView":{"offset":417696,"length":2244,"count":1122,"stride":2}},{"primitiveMode":7,"jointMapIndex":10,"vertexBundelIndices":[10],"indexView":{"offset":475996,"length":4038,"count":2019,"stride":2}},{"primitiveMode":7,"jointMapIndex":6,"vertexBundelIndices":[11],"indexView":{"offset":506434,"length":1686,"count":843,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[12],"indexView":{"offset":536632,"length":7680,"count":1920,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":53152,"count":604,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":56524,"length":22792,"count":259,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":80648,"length":45584,"count":518,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":129862,"length":37576,"count":427,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":169706,"length":48576,"count":552,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":221858,"length":34320,"count":390,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":258158,"length":51040,"count":580,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":312300,"length":22792,"count":259,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":336424,"length":40568,"count":461,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":380208,"length":37488,"count":426,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":419940,"length":56056,"count":637,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":480034,"length":26400,"count":300,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":508120,"length":28512,"count":324,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}],"jointMaps":[[0,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,32,33,41,42,43,44,61],[0,1,2,3,4,5,6,7,8,10,14,15,16,18,19,20,21,22,25,26,27,28,29,30,32,35],[0,2,3,4,5,6,7,8,9,10,11,12,14,15,16,17,19,20,22,23,24,28,29,30,31,32,33,34,35,42],[0,1,2,3,4,5,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,32,33,41,42,43],[0,2,7,11,12,13,15,16,17,18,19,20,21,22,23,28,29,30,31,32,33,35,36,37,38,39,40],[0,3,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,28,41,42,43,45,46,47,48,49,50,51],[0,2,3,4,5,7,8,9,10,12,14,20,28,35,41,42,43,45,46,47,48,49,50,51,52,53,54,55,56],[0,1,2,3,4,5,6,7,8,14,20,25,26,27,28,35,43,45,48,50,51,52,53,57,58],[0,2,3,4,5,7,8,9,10,14,20,28,32,35,41,42,43,45,46,49,50,52,53,54,55,56,57,58,59,60],[0,1,2,3,4,5,6,7,8,9,10,14,20,25,26,27,41,42,43,45,46,47,48,49,51,52,53,54,55,56],[0,2,7,12,14,20,28,32,35,36,37,38,39,40,41,45,46,47,48,49,50,51,52,53,54,56,57,58,59]]},"minPosition",8,[1,-0.56879723072052,-2.8188118934631348,0],"maxPosition",8,[1,0.56879723072052,2.8188118934631348,5.288472652435303]]],-1],0,0,[],[],[]],[[[50,"VD297_Giraffe_Toy",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":1,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294704123],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[187,10]],[[[50,"VD297_Giraffe_Eye",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4294967295],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[188,10]],[[[119],[102,"VD297_Giraffe_Rig",[[-3,-4,[68,"Bn_FoodSpawn",-6,[1,"edXyveHQlamqk5Klmem7yW",-5,0],[1,2.6372758199499913e-8,0,2.4216866493225098]]],1,1,4],[[255,-2,[10,"a5Ur2McGJUfKEIm/lueZtm"],[15],16]],[1,"49pWBJK15R+45zZnNOgfJN",-1,0]],[48,"Bip001 Head",[[-7,[4,"Bip001 R_UpEyelid",-8,[1,"35776kuEBeLZHUS0fLbjDm",1,0],[1,0.34337615966796875,0.2510550022125244,-0.2245255559682846],[3,0.12247283914442461,0.7241107318662566,0.05565574464344822,0.6764366117798485],[1,5.045205968772248,93.25085851212803,14.63514863313527]],[4,"Bip001 L_UpEyelid",-9,[1,"99+llp6yNf0pX1/DQ9+tgW",1,0],[1,0.34337615966796875,0.2510535717010498,0.22452694177627563],[3,-0.12247256348552801,-0.7241110299639162,0.055651747412626976,0.6764366714540253],[1,-5.045519010090419,-93.25085191470198,14.634809479074342]],[4,"Bip001 R_DownEyelid",-10,[1,"2eX9kiozNTCYTR1C6h7sEi",1,0],[1,0.2697715759277344,0.25691771507263184,-0.21696408092975616],[3,0.1223849945588972,0.7241674026347854,0.05572241887057009,0.6763863526884764],[1,5.031255141657216,93.26145031601891,14.633446357809548]],[4,"Bip001 L_DownEyelid",-11,[1,"72SZVCrg1a2LbK96LcowhX",1,0],[1,0.2697715759277344,0.25691652297973633,0.21696552634239197],[3,-0.12238473441172545,-0.7241676447406158,0.055718354862578263,0.6763864753417299],[1,-5.031576404901483,-93.26143307554283,14.633102810797125]],[4,"Bip001 UP_Lip",-12,[1,"35HbIUuotdQaMkFrCYzRIQ",1,0],[1,0.1482524871826172,0.8653846979141235,0.00001548483851365745],[3,-7.019732607805063e-7,-0.0000036544161645705422,0.8095809949645157,0.5870081878291113],[1,179.99906124463647,-179.99941869080754,71.88997265189033]],[4,"Bip001 R_Up_Lip",-13,[1,"17RB3ykLBUm6je9HRIuOn/",1,0],[1,0.1558370590209961,0.813302755355835,-0.08448056876659393],[3,0.6440443531968911,-0.40946052339214933,0.5172257532139795,0.3873325071703341],[1,111.56741681299894,-82.49034886429834,-7.281525826520712]],[4,"Bip001 L_Up_Lip",-14,[1,"df+haHFsFdPpoeUvr0OVYf",1,0],[1,0.1558370590209961,0.8133022785186768,0.08448508381843567],[3,0.6440443378808218,-0.4094576824341174,-0.5172280058902883,-0.3873325277614716],[1,-111.56768796709501,82.49035459539483,-7.281211700610275]],[4,"Bip001 R_Lip",-15,[1,"dexMSBu/Vc6oaq6wAV+avX",1,0],[1,0.1689472198486328,0.7362625598907471,-0.09580332785844803],[3,-0.5195301736970601,0.5128582682233938,0.5599839650491572,0.3917687509501342],[1,-99.65597338896119,98.85268539858689,-5.400802261110559]],[4,"Bip001 L_Lip",-16,[1,"51H6UXMFxVxreAZ4YjFABg",1,0],[1,0.1689472198486328,0.7362620830535889,0.09580741077661514],[3,0.5195300528317897,-0.5128618428673297,0.5599808042180879,0.39176874970138664],[1,99.65555102296493,-98.85270528484511,-5.4011515009998945]],[4,"Bip001 R_EyeBall",-17,[1,"2evjecQFZRbpov5tGjlFBH",1,0],[1,0.31261539459228516,0.23719239234924316,-0.1390356719493866],[3,-0.6884858534158385,-0.009179707517785443,0.7106473369420088,0.14451064013900036],[1,-169.01665158428787,90.5992931168743,12.593492657351312]],[4,"Bip001 L_EyeBall",-18,[1,"07HB7bVs5fSK0GCLwvrUvV",1,0],[1,0.31261539459228516,0.23719167709350586,0.13903698325157166],[3,0.6884858477219524,0.009175758634226603,0.7106473906694875,0.1445106538450356],[1,169.01632871573827,-90.59929283117292,12.593175480769082]],-19,[4,"Bip001 nose",-20,[1,"04PkZ8dHRVzZYNqb8TRcv7",1,0],[1,0.32142162322998047,0.7735657691955566,-0.00001353079187538242],[3,0.0000029573027132187497,1.9355367263776715e-7,0.055661912494588996,0.9984496739889605],[1,0.000339223991494756,0.000003302881515195641,6.381683568818498]],-21,[4,"Bip001 R_cheek",-22,[1,"e7FwbyyURWBqR0qzpv6MFQ",1,0],[1,0.05211019515991211,0.2889235019683838,-0.1565088927745819],[3,0.05841113290049033,0.7065731926138281,0.039178192854431165,0.7041360182787445],[1,1.555941669856946,90.09031156983801,7.915762344815528]],[4,"Bip001 L_cheek",-23,[1,"7ft6QxtctagqdyecDLAhlN",1,0],[1,0.05211019515991211,0.2889225482940674,0.15651053190231323],[3,-0.05841107281476088,-0.7065734252129403,0.039174191569980386,0.7041360124793511],[1,-1.556261645997518,-90.09031325464657,7.9154330170357]],-24,[4,"Bip001 UpTeeth",-25,[1,"bcMI6QptlSGKEmSrWoPjmO",1,0],[1,0.1596221923828125,0.847388744354248,-0.00002852861871360801],[3,2.7861110174443624e-7,-0.000004770442341778068,0.8331330139697966,0.5530726724498041],[1,179.99878138597225,-179.99915270600772,67.15613517320901]],[4,"Bn_Mouth",-26,[1,"89CoNx03Fe95p6c3PgddFh",1,0],[1,0.1322927474975586,0.8844605684280396,0.0000019073486328125],[3,-0.06744714874232752,0.6958798219497017,0.7094951918431234,-0.08842357310848374],[1,-90.93173238028068,-178.39319594896983,-12.670413083369786]]],1,4,4,4,4,4,4,4,4,4,4,4,1,4,1,4,4,1,4,4],[1,"a84YD19Gdc1L3jl37FEJEs",1,0],[1,0.5518631935119629,0.09183895587921143,2.547251369833248e-7],[3,-1.1069167078265287e-13,1.1962683563867385e-7,-0.043131225804261084,0.9990694156867217],[1,5.934478864202835e-7,0.000013746614115451107,-4.944008108247556]],[57,"Bip001 Jaw",2,[[[4,"Bip001 R_Down_Lip",-27,[1,"c6PyF6E9Fejpf+FhJZKAVH",1,0],[1,0.22414958477020264,-0.02978229522705078,-0.08345255255699158],[3,0.0379035511010869,-0.08312863876031353,-0.006381982952408379,0.9957972788300739],[1,4.269098997992235,-9.503310182423972,-1.0893766456782763]],[4,"Bip001 L_Down_Lip",-28,[1,"57n9xYdK5ZWIvmtHeYAceX",1,0],[1,0.22414958477020264,-0.029782772064208984,0.08345238864421844],[3,-0.037903543695988244,0.08312866121180473,-0.006381548032422486,0.9957972800249704],[1,-4.269102224069318,9.503314555275125,-1.0893270358589797]],[4,"Bip001 Down_Lip",-29,[1,"1cIIaKZ1pcGLS4H52SXjPZ",1,0],[1,0.2706289291381836,-0.04498434066772461,-0.0000031644667615182698],[3,1.3287119702936462e-8,5.713210890487879e-7,-0.0257779617757464,0.9996676931292525],[1,0.000003214003631930435,0.00006557321519133576,-2.954264076398538]],-30,[4,"Bip001 DownTeeth",-31,[1,"d42HOx4B5W6oKyikGCD94J",1,0],[1,0.2538257837295532,-0.03244733810424805,-0.000030705345125170425],[3,1.7297688071575725e-14,-2.3735439809270516e-8,0.008557617494658156,0.999963382921002],[1,2.3281093649878275e-8,-0.000002720179887652147,0.9806426997154128]]],4,4,4,1,4],[1,"5bcRdelBNcnqSCWgDkZn2m",1,0],[1,0.1990981101989746,0.5892319679260254,0.000001037686160998419],[3,2.504685350165249e-7,-0.000002399451695679412,0.8283695703185308,0.5601819837914038],[1,179.99934519577238,-179.99952254268467,68.1367681348831]],[48,"Bip001 Neck",[[-32,-33,-34,[4,"Bip001 Hair01",-35,[1,"05vzGOWtNStKzQvyWde+Ao",1,0],[1,-0.06071972846984863,-0.2820974588394165,8.112858722597593e-7],[3,1.6516783028762314e-14,0.0000018647883395428245,-0.6723349568022915,0.7402470573113974],[1,0.0014976386299721703,0.0016489140950808594,-84.49506936731329]]],1,1,1,4],[1,"cf54cUQTFQdaEFKgi0tXhy",1,0],[1,0.9543073177337646,-0.3201141357421875,-5.500842235051095e-7],[3,1.1810981550389486e-14,6.097828807722803e-7,-0.2198525345649096,0.9755331173491822],[1,0.000017006426557973736,0.00007546117671314657,-25.40074358145492]],[47,"Bip001 Spine",[-36,-37,-38],[1,"f2uk/fraBW44RrsLTmM1qH",1,0],[1,0.400854229927063,0.015083789825439453,4.153639565629419e-7],[3,-0.000002052787330614699,-6.669589654747255e-7,-0.037431762275221075,0.9992991860140349],[1,-0.0002385966896096073,-0.0000854188249321574,-4.290366292445109]],[57,"Bip001 Neck1",4,[[-39,[98,"Bip001 Hair02",-40,[1,"14Ad035ANcloqi0mJImlLj",1,0],[1,-0.017128705978393555,-0.21748805046081543,-5.193219294596929e-7],[3,-7.012453917385995e-13,0.0000019041008676043273,-0.6865084912899153,0.7271217857987882],[1,0.9999989867210388,0.9999989867210388,1],[1,0.002609061184881379,0.0027634112797080704,-86.70871443960806]]],1,4],[1,"56D6KHIFhfjJguAA9oJ5nd",1,0],[1,0.6923840045928955,-0.00044989585876464844,-1.2480541045079008e-9],[3,5.735766379024929e-14,8.440700028776635e-8,-0.03043228257955449,0.9995368308256535],[1,2.949038769998187e-7,0.000009685790513410704,-3.487821205901098]],[165,"Bip001 Neck2",6,[[2,[4,"Bip001 Hair03",-41,[1,"14c21KloFeW4TnZpqdpSeQ",1,0],[1,0.22313594818115234,-0.1733543872833252,-0.0000010999831374647329],[3,-5.501903323788317e-13,0.0000018955203604483748,-0.683414953116773,0.7300301376332389],[1,0.0022529890159768756,0.00240666367779299,-86.22215868172809]]],1,4],[1,"4eUfYIsfZUlrwpmZtd7TvP",1,0],[1,0.5660121440887451,-0.0004042387008666992,-1.1214069672860205e-9]],[166,"VD297_Giraffe_Toy",1,[[66,-42,[10,"a8ImwwjX5VlpOBY5oz0MC1"],[0,1,2,3,4,5,6,7,8,9,10,11,12],[29],1,13,14]],[1,"e3FAH3cZhSZLsUbfJUC80S",1,0],[1,0,-0.00011903722770512104,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Bip001",1,[-43],[1,"27goImrUhSiLj/q8l+pR3q",1,0],[1,-4.356060401278228e-9,2.378934383392334,-0.8954776525497437],[3,0,4.329780375814312e-17,-0.7071067811865476,0.7071067811865476],[1,0,0,-90]],[84,"Bip001 Pelvis",9,[5],[1,"0bz+t64LpWRoPHsBCKwTl/",1,0],[3,-0.49999999254917427,-0.49999999254917427,-0.49999930709576956,0.5000007078049009],[1,-89.99991974527727,-89.99991974527727,-0.0000017074910602964197]],[6,"Bip001 Spine1",5,[4],[1,"76JitRG4Bb6IWeWws2pnXN",1,0],[1,0.6363147497177124,-0.0006434917449951172,-1.7844286048784852e-9],[3,-5.001003109185003e-14,6.055923869577305e-7,-0.21834164731705358,0.9758723917841453],[1,0.000016748928224149575,0.00007485893130099625,-25.2232972333355]],[14,"Bip001 R_Ear",2,[[4,"Bip001 R_Ear02",-44,[1,"7c7vkHe8taurwV9/b63dyq",1,0],[1,0.24279451370239258,-0.00015926361083984375,-0.00006985664367675781],[3,0.1943117099157505,-0.021092375925360597,0.2231939752599514,0.9549777591520656],[1,24.76597094901678,-8.038122542265535,24.71428519601091]]],[1,"d2RYeAmwZVVbYhAqdc4wDo",1,0],[1,0.29334402084350586,0.004457592964172363,-0.16000939905643463],[3,0.16336328288055393,0.39462871559616325,-0.6255358051764845,0.6529054840293637],[1,76.93816074345585,97.44558932195352,-43.46377554217515]],[6,"Bip001 Tongue01",3,[-45],[1,"5fP7MY0KRScq+eqbAl68XC",1,0],[1,0.09311747550964355,-0.010273933410644531,-7.956077752169222e-8],[3,-1.3280751676258093e-7,-5.582045435328034e-7,-0.11713972903232928,0.9931154433810317],[1,-0.000023244665055349306,-0.00006715070549894516,-13.454113569998423]],[14,"Bip001 Tongue02",13,[[4,"Bip001 Tongue03",-46,[1,"14ITHPHChYjbDoBqTnlyOE",1,0],[1,0.057037353515625,0.000232696533203125,-1.6103513189591467e-7],[3,-0.0000014086552937428342,1.1217554662923372e-9,1.490116297018971e-8,0.9999999999990077],[1,-0.0001614200062424202,1.2854611307425332e-7,0.0000017075473149815245]]],[1,"d4iQC7nKxUyoITQdTj5HN0",1,0],[1,0.06330013275146484,0.0005035400390625,1.3969838619232178e-9],[3,2.34142972213993e-13,-1.4840483635151933e-7,0.05350618418461001,0.9985675181248289],[1,9.151900506504044e-7,-0.00001707937578821318,6.134286427783285]],[6,"Bip001 Tail_01",2,[-47],[1,"fd1KRbHfVdb5Q/fJ5w91SW",1,0],[1,-3.099538564682007,-1.777132272720337,-0.0000052145178415230475],[3,2.8648892559348733e-7,0.000003959627048611977,-0.7996029223990082,0.6005290721315704],[1,179.99862760717215,179.9989282292747,-73.81559809876565]],[6,"Bip001 Tail_02",15,[-48],[1,"4bY2R+ZuhfRbqPseCyF6kY",1,0],[1,0.276302695274353,0.0013399124145507812,-8.407732821069658e-8],[3,-1.6811053228192466e-7,-1.8257904405254525e-7,-0.06674220435377931,0.9977702531935582],[1,-0.000020802808719429435,-0.000022360300422630196,-7.653782761696829]],[6,"Bip001 Tail_03",16,[-49],[1,"55lY+R+5VfcL3MRr4OPaf/",1,0],[1,0.3749101161956787,0.010757684707641602,-8.89989678398706e-7],[3,-0.0000015325682318977173,0.0000016193943924228711,-0.017069453032498388,0.9998543062707688],[1,-0.00017252677321186527,0.00018265060150047768,-1.9561102335835894]],[14,"Bip001 Tail_04",17,[[4,"Bip001 Tail_05",-50,[1,"d9Du9LEYtYd6fEY+RDtLSd",1,0],[1,0.3159787654876709,-0.00016641616821289062,-8.189126674551517e-7],[3,-0.0000014061682804794182,-0.0000014202421425551375,1.0151216400779641e-7,0.9999999999979976],[1,-0.00016113499899229333,-0.0001627477449527858,0.000011632665984489571]]],[1,"37bpu2CtdYWYgYXX1+Fi7a",1,0],[1,0.3840022087097168,-0.013496160507202148,-0.0000010278017725795507],[3,-0.0000014331359352548016,0.0000014222537174612764,-7.976756251063611e-7,0.9999999999976437],[1,-0.00016422515111352108,0.00016297813981618533,-0.00009140712704794832]],[14,"Bip001 L_Ear",2,[[4,"Bip001 L_Ear02",-51,[1,"16zFfly2pUNYXtnr5x4XBX",1,0],[1,0.24279439449310303,-0.00015878677368164062,0.0000699758529663086],[3,-0.19431173719916414,0.02109113885556124,0.22319412137824649,0.9549777467724632],[1,-24.765946391686672,8.037979485146726,24.714332699889397]]],[1,"754t+mjF9VIpOTs7KdhAPA",1,0],[1,0.29334354400634766,0.0044564008712768555,0.16000941395759583],[3,-0.16336253074214327,-0.3946245857720451,-0.6255386986925687,0.6529053961270129],[1,-76.93861022551313,-97.44570159305196,-43.46421850753999]],[6,"Bip001 L Clavicle",4,[-52],[1,"e8IZExt/9Zj4U6ZKChzAp8",1,0],[1,-0.6252610683441162,-0.15536224842071533,0.3209458291530609],[3,0.6218016091848645,0.3824239934956703,0.39082494027587333,0.5606875369332697],[1,101.18437273864923,-8.096527187598403,66.04223841119425]],[6,"Bip001 L UpperArm",20,[-53],[1,"d4y+2xk59a2r6WSeI/vdA+",1,0],[1,0.4305196702480316,5.960464477539063e-8,0],[3,-0.4766226478125026,0.5748613557875564,0.4806062944999592,0.45976392083471496],[1,-85.17161138936022,97.09950957592135,-6.087838604977945]],[6,"Bip001 L Forearm",21,[-54],[1,"feam7ruXVQvZy90w4OSN1y",1,0],[1,0.5732908248901367,0,1.4901161193847656e-8],[3,1.8073457900254473e-18,-3.619298562452549e-18,-0.10238340452658577,0.9947450117882197],[1,1.6705795063605852e-16,-3.99737720120276e-16,-11.752868225791161]],[14,"Bip001 L Hand",22,[[4,"Bip001 L Finger0",-55,[1,"3byxQ4HQJX6rqKO+WPtPaP",1,0],[1,0.825505793094635,0.00021010637283325195,-0.016567260026931763],[3,-0.003084158369715048,0.013701365674395385,0.019711368282363303,0.9997070683486458],[1,-0.38456341678652844,1.5779873400313138,2.253833657637567]]],[1,"1arjDVWixWE6C/bv+TdkwO",1,0],[1,1.0205600261688232,-5.960464477539063e-8,0],[3,-0.706795399661755,-0.0019021578041327138,-0.062264722302334395,0.7046699576179485],[1,-90.39524475854142,-5.222724049499616,-4.879664052241934]],[6,"Bip001 R Clavicle",4,[-56],[1,"7c+r1SaXFbJIz1+lTaGNL8",1,0],[1,-0.6252610683441162,-0.15536046028137207,-0.3209473192691803],[3,-0.621800054529036,-0.3824250931463723,0.3908238642904015,0.5606892610178962],[1,-101.18359469678377,8.095814037152945,66.04228349204378]],[6,"Bip001 R UpperArm",24,[-57],[1,"27MQcNugdU3YnRBSyPx/OP",1,0],[1,0.4305196702480316,5.960464477539063e-8,-4.440892098500626e-16],[3,-0.4766226478125026,0.5748613557875564,-0.4806062944999592,-0.45976392083471496],[1,85.17161138936022,-97.09950957592135,-6.087838604977945]],[6,"Bip001 R Forearm",25,[-58],[1,"1aix5QZVtffaZlYVrLXuzk",1,0],[1,0.5732908248901367,1.1102230246251565e-16,-1.4901161193847656e-8],[3,1.1160960807208764e-18,4.490079861320526e-18,-0.10238340452658577,0.9947450117882197],[1,1.8375430731814063e-16,5.361561372211306e-16,-11.752868225791161]],[14,"Bip001 R Hand",26,[[4,"Bip001 R Finger0",-59,[1,"528DScHiFfopPcfjRBeca+",1,0],[1,0.825505793094635,0.00021010637283325195,0.016567260026931763],[3,0.003084158369715048,-0.013701365674395385,0.019711368282363303,0.9997070683486458],[1,0.38456341678652844,-1.5779873400313138,2.253833657637567]]],[1,"65Hr4qA4tY9J8Jvd+K0x5F",1,0],[1,1.0205599069595337,-5.960464477539063e-8,-5.551115123125783e-17],[3,0.706795399661755,0.0019021578041327138,-0.062264722302334395,0.7046699576179485],[1,90.39524475854142,5.222724049499616,-4.879664052241934]],[6,"Bip001 L Thigh",5,[-60],[1,"11BAfAQWVSDq0Huwsgvaqy",1,0],[1,-0.39860236644744873,-0.045030832290649414,0.31775563955307007],[3,0.6697904583392761,0.7425501474978701,0.0000828426578436208,-0.00011621380163828846],[1,-0.15539599845470578,-179.84189640298345,84.10176769549689]],[6,"Bip001 L Calf",28,[-61],[1,"dayS5tevFSZqR9L49DlLE1",1,0],[1,0.6152560710906982,-5.960464477539063e-8,0],[3,2.3134668868276776e-24,-5.182844774448237e-20,-0.19607236564834585,0.9805894285729687],[1,-1.2612065319290729e-18,-6.308848736250139e-18,-22.614750028058115]],[6,"Bip001 L HorseLink",29,[-62],[1,"4eZ9lbh79WQ7KnvB+7+zxC",1,0],[1,0.6745597720146179,4.440892098500626e-16,-2.9802322387695312e-8],[3,1.1641626586293666e-11,1.7558664120709856e-11,0.22098652425649812,0.9752768612537837],[1,9.4910882731769e-10,1.8480233733852806e-9,25.53396581578114]],[14,"Bip001 L Foot",30,[[4,"Bip001 L Toe0",-63,[1,"9eXV3vCA5TaIZGzjUDTB7g",1,0],[1,0.06374531984329224,-0.008129239082336426,-2.9802322387695312e-8],[3,7.147154967240356e-14,1.130674135800072e-13,-0.008726830662804639,0.9999619204882667],[1,8.304059067177777e-12,1.3029535472831268e-11,-1.0000338246402656]]],[1,"27d7tBW79d3Krcc+XS9kjS",1,0],[1,0.8986997008323669,1.1920928955078125e-7,0],[3,-0.000024228231144416933,-0.00014043359188703749,-0.0027167782979811692,0.9999962993966922],[1,-0.0028201019021005386,-0.016100225290632233,-0.31131985060473577]],[6,"Bip001 R Thigh",5,[-64],[1,"80xBgp43xZAaNnhTprLbP3",1,0],[1,-0.39860236644744873,-0.0450291633605957,-0.31775563955307007],[3,0.6697904585943798,0.7425501477806858,-0.00008071986082393435,0.00011441641456539929],[1,0.15229580824553335,179.84497019075718,84.1017685548488]],[6,"Bip001 R Calf",32,[-65],[1,"35suY1tUlZY6a8OdTLav2m",1,0],[1,0.6152560710906982,-5.960464477539063e-8,-5.551115123125783e-17],[3,-9.964784720143505e-22,-4.9835490194608505e-21,-0.19607236564834585,0.9805894285729687],[1,-2.4259603755906904e-19,-6.308848663652707e-19,-22.614750028058115]],[6,"Bip001 R HorseLink",33,[-66],[1,"a8Hm0zESxYv6gYOiTo0hxR",1,0],[1,0.6745598316192627,1.1920928955078125e-7,2.9802322387695312e-8],[3,-2.12874833573142e-11,-3.4665110129492556e-11,0.22098652425649812,0.9752768612537837],[1,-1.6637217959020381e-9,-3.6960467942528948e-9,25.53396581578114]],[14,"Bip001 R Foot",34,[[4,"Bip001 R Toe0",-67,[1,"49XHXwZQJSX7a3Ea2snvla",1,0],[1,0.06374531984329224,-0.008129239082336426,2.9802322387695312e-8],[3,-7.423691575647812e-14,6.478770305492795e-16,-0.00872682880030133,0.999961920504521],[1,-8.507247866030362e-12,-5.670285097220125e-20,-1.0000336112049801]]],[1,"c4UT6iM6ZavIrWG+TU0Tk4",1,0],[1,0.8986997008323669,1.1920928955078125e-7,5.551115123125783e-17],[3,0.000024315635403754084,0.00014043181655312579,-0.0027167782979760826,0.9999962993948199],[1,0.0028301172505327196,0.01610004906114549,-0.3113198492019426]]],0,[0,4,1,0,0,1,0,-1,8,0,-2,9,0,4,1,0,1,1,0,-1,12,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-13,3,0,1,2,0,-15,15,0,1,2,0,1,2,0,-18,19,0,1,2,0,1,2,0,1,3,0,1,3,0,1,3,0,-4,13,0,1,3,0,-1,6,0,-2,20,0,-3,24,0,1,4,0,-1,11,0,-2,28,0,-3,32,0,-1,7,0,1,6,0,1,7,0,0,8,0,-1,10,0,1,12,0,-1,14,0,1,14,0,-1,16,0,-1,17,0,-1,18,0,1,18,0,1,19,0,-1,21,0,-1,22,0,-1,23,0,1,23,0,-1,25,0,-1,26,0,-1,27,0,1,27,0,-1,29,0,-1,30,0,-1,31,0,1,31,0,-1,33,0,-1,34,0,-1,35,0,1,35,0,18,1,2,1,7,4,1,11,5,1,10,67],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,12,20,-1,31],[1,1,1,1,1,1,1,1,1,1,1,1,53,54,55,99,99]],[[[40,"Food_Twigs"],[103,"Food_Twigs",[-3],[[147,3,-2,[10,"94ZfriNQhLXaEC2D1SGaXc"]]],[1,"49wxs6a3tWJropely20Bt5",-1,0],[1,0.2,0.2,0.2]],[64,"Food_Twigs",1,[[114,-4,[10,"f6yv6mirNfcItnc7fIxuaT"],[0],[29],1]],[1,"28F/PZnHBVwL5SMk0egZYR",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,4,1,0,0,1,0,-1,2,0,0,2,0,18,1,4],[0,0],[-1,12],[189,190]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0,"normalMap",6,1],{},{}],11,0,0]]],0,0,[0,0,0],[15,32,14],[36,36,29]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[91,28]],[[[40,"VD289_Lion_Rig"],[141,"VD289_Lion_Rig",[[-4,-5,[4,"Bn_FoodSpawn",-7,[1,"35i6tXF4pRNZMhldb3mDjL",-6,0],[1,-0.6544039845466614,0.0000014053456425244804,2.4855852127075195],[3,1.545431187269876e-8,-0.707106721581899,1.5454308319985022e-8,0.7071068407911907],[1,0.0000025044781562438738,-89.99999034065368,-7.67592264999771e-14]]],1,1,4],[[256,false,-2,[10,"bcbBLaSAhbuZMFUUZNLvRX"],[12,13,14],15],[80,-3,[10,"741LdLNIRBH7skLzcTXd78"],16]],[1,"35MaNWaVpaXITwGugCw+yp",-1,0],[3,0,1,0,-6.123233995736766e-17],[1,0,-180,0]],[48,"Bip001 Head",[[-8,[4,"Bip001 R_Eye Ball",-9,[1,"c67HP74fZQareDO7QzeXWD",1,0],[1,0.4810067415237427,-0.13871192932128906,-0.16198280453681946],[3,0.7010897311661021,-0.09240155553280946,0.7010379347304301,0.09209210312210751],[1,165.00802974654647,-89.99911001265058,-0.02540769395075313]],[4,"Bip001 L_Eye Ball",-10,[1,"9bdMh8SI5VApTWliW7zitf",1,0],[1,0.4810067415237427,-0.13871288299560547,0.16198202967643738],[3,0.7010897551105225,-0.0923973938139687,-0.7010384951148962,-0.0920918305958545],[1,-165.00839214994963,89.99911191723139,-0.02508957840924875]],-11,-12,[4,"Bip001 R_Lip",-13,[1,"0c+/2xnDxak6fzczZpa12t",1,0],[1,0.6202429533004761,0.2222423553466797,-0.15485885739326477],[3,-0.00011103288813278455,-0.27937534352521404,0.000382185737645578,0.960181888516925],[1,0.000018506947193266856,-32.4458562590536,0.0456060329216003]],[4,"Bip001 L_Lip",-14,[1,"426MOEsD5fQ52qyRgpaw43",1,0],[1,0.6202429533004761,0.22224140167236328,0.15486010909080505],[3,0.00011102969392108471,0.2793753433583419,0.0003837463430075874,0.9601818879434041],[1,-0.00006881972605775448,32.44585627918052,0.04577764213007584]],[4,"Bip001 Upper_Teeth",-15,[1,"aaIJFC4GRcjrd2uk0jbYIV",1,0],[1,0.6855056285858154,0.140275239944458,6.420416411856422e-7],[3,1.9369720990394967e-12,-0.00000276018663500417,0.995163814734005,-0.09822923106919072],[1,179.99967904174824,179.99996831952706,-11.274421660696975]],[4,"Bip001 R_Upper_Lip",-16,[1,"8b3EQn0vVbXY+9L26wjUHK",1,0],[1,0.79768967628479,0.19597196578979492,-0.10700225830078125],[3,0.02535524931192882,0.17689026660986928,-0.006240054417799473,0.9838841428907584],[1,2.98652823969059,20.389324236101686,-0.1895799086119579]],[4,"Bip001 L_Upper_Lip",-17,[1,"78gcp2bbxVXLlxVrakCFv+",1,0],[1,0.79768967628479,0.19597125053405762,0.10700333118438721],[3,-0.02535525307963376,-0.1768902222022912,-0.006241038370526807,0.9838841445366163],[1,-2.986548629297991,-20.38932211967836,-0.1896908986222032]],[4,"Bip001 R_Upper_Eye",-18,[1,"b5e5H9odFf6al2+RZikwCR",1,0],[1,0.5582767724990845,-0.18035387992858887,-0.16731713712215424],[3,-0.1576385977327603,0.0320653176906361,-0.1303367939430467,0.9783323607296732],[1,-18.133109482336906,1.286535775580373,-15.374966949615768]],[4,"Bip001 L_Upper_Eye",-19,[1,"4fY6GcR1hSC5fYnbBbwcE3",1,0],[1,0.5582767724990845,-0.18035483360290527,0.16731615364551544],[3,0.1576385977307024,-0.032064591258594455,-0.13033697275528322,0.9783323607169017],[1,18.133121251843473,-1.2864479857142894,-15.374974130500112]],[4,"Bip001 R_Lower_Eye",-20,[1,"da5hRlZv9Yer2n/hky54Qh",1,0],[1,0.5588425397872925,-0.1220705509185791,-0.1781167834997177],[3,-0.15785925427404585,0.032146625907232565,-0.13026039580506293,0.9783042878202727],[1,-18.1579087033879,1.2938562673416478,-15.368015962628489]],[4,"Bip001 L_Lower_Eye",-21,[1,"f1rzkOtcJUoouALNH9EqMW",1,0],[1,0.5588425397872925,-0.12207150459289551,0.17811612784862518],[3,0.15785923973473004,-0.03214590327458423,-0.130260574917585,0.9783042900627464],[1,18.15791867460493,-1.29376914844599,-15.368023209192646]],[4,"Bn_Mouth",-22,[1,"74Wy3E+Ole54e8k1nw+aEG",1,0],[1,0.7551892995834351,0.18387889862060547,-0.0000018998973700945498],[3,0.6883263572440877,0.02517719747413124,0.7247287614703776,-0.018470434430343463],[1,-176.44982632392762,-92.96540327274604,0.4519622246662741]]],1,4,4,1,1,4,4,4,4,4,4,4,4,4,4],[1,"daokDkTqNZyptqI6QBb1I/",1,0],[1,0.3670990467071533,-0.09131133556365967,-4.3714862840715796e-9],[3,6.019624997662611e-7,-3.6520860217684395e-7,0.32350260898026595,0.9462272781855665],[1,0.00009967105166216462,-0.00007830430389595361,37.749761330843185]],[48,"Bip001 Neck",[[2,-23,-24,[4,"Bip001Neck Giggle",-25,[1,"42aDpB00ZY24pjtaMIy0pw",1,0],[1,0.02900838851928711,0.6082414388656616,0.0000020743948425661074],[3,3.86469865598165e-14,-9.406484298778304e-7,0.33914354814087,0.9407346351408227],[1,0.000047478123142189156,-0.00013169736139046916,39.64940598604298]]],1,1,1,4],[1,"c5EksbV85eBLHQJ5DOQ0Il",1,0],[1,0.8079414367675781,-0.3649176359176636,-7.356898095167708e-7],[3,3.231769190948456e-14,5.528266381495149e-7,-0.19931733748910155,0.9799349973217356],[1,0.000013716448421261177,0.00006743630189398614,-22.994083269461413]],[57,"Bip001 Jaw",2,[[[4,"Bip001 Lower_Teeth",-26,[1,"75WizrvY9f4bbuYTiAsdi4",1,0],[1,0.14788228273391724,-0.0014827251434326172,-3.79127413907554e-8],[3,3.780104082252863e-14,-0.00000277037657122206,0.9988377701388352,0.048198640399960066],[1,179.99968142703355,-179.99998462734527,5.525298067713643]],-27,[4,"Bip001 R_Lower_Lip",-28,[1,"09TAs1TbJfg5Fft1EAp/iz",1,0],[1,0.255571186542511,-0.025275230407714844,-0.08661354333162308],[3,0.02795634202226483,0.1496848596835241,-0.050703662830590454,0.9870369923654431],[1,4.052178660461967,17.43279123633301,-5.262766519849278]],[4,"Bip001 L_Lower_Lip",-29,[1,"9fCz99XCRUdpOH1TnEDrkD",1,0],[1,0.2555714249610901,-0.02527618408203125,0.08661340922117233],[3,-0.027956389263296563,-0.14968480369246534,-0.05070449851968066,0.9870369565891517],[1,-4.052198641800828,-17.432789752534553,-5.262860599178974]]],4,1,4,4],[1,"46yLe9/LNSU4wsF36Y4EdF",1,0],[1,0.5253777503967285,0.16764020919799805,5.410154244600562e-7],[3,-2.650718919003171e-8,-2.1287236392524712e-7,0.13813619241436384,0.9904132432198268],[1,3.7556031808144073e-7,-0.00002468187364767975,15.880020117071021]],[47,"Bip001 Spine",[-30,-31,-32],[1,"99aYTJuXxXjKlBCnMZKwSb",1,0],[1,0.2720732092857361,0.15390312671661377,0.0000011634572274488164],[3,-0.0000036112506739137594,-0.0000032734493259281867,0.0671425181802589,0.9977433949812232],[1,-0.00039122660298780275,-0.00034963070073605346,7.699758479455297]],[57,"Bip001 Spine1",5,[[3,[4,"Bip001 Chest Giggle",-33,[1,"bcLaJ+TvdQl78qlF+twDsy",1,0],[1,-0.030802786350250244,0.49484819173812866,0.0000036120202366873855],[3,3.7685426223774956e-13,-0.00000215524395919846,0.7770564103807688,0.6294309613305572],[1,179.99907571776728,-179.99925131317406,78.01630472356885]],[4,"Bip001 Xtra_Hair",-34,[1,"acBVRsOHRXTZXhAUP5FR5A",1,0],[1,0.6950159072875977,-0.6994706392288208,-0.000006818572273914469],[3,5.790522979187898e-7,-0.000003298516196602828,0.9883956670913969,0.1519013010600525],[1,179.99959776231205,-179.99987104867216,17.47425168677412]]],1,4,4],[1,"b0yaVeE+lf24sDuhbAjfnr",1,0],[1,0.7889416217803955,-0.0007495880126953125,-2.078195393551141e-9],[3,-3.5019260556543856e-13,1.5484620210818652e-7,-0.05582864471373433,0.9984403649840102],[1,9.968009184705453e-7,0.00001782752218102701,-6.400819429558583]],[157,"Bip001 Pelvis",[5,-35],[1,"05UVohVuNVcY7xAefdYL4R",1,0],[3,-0.7070778123743453,-0.006288996065458571,-0.006292967690640629,0.7070797793276539],[1,-89.99984349021217,-1.0195107027065413,-0.00032321993293957425]],[104,"Bip001 L Hand",[[4,"Bip001 L Finger0",-36,[1,"c1cWylJQtd6rol0y6sh+h7",1,0],[1,0.11026113480329514,-0.165815532207489,-0.007204532623291016],[3,-0.0002805439336568173,-0.00028253451927802003,-0.7096009373105814,0.7046036838090551],[1,-173.57108515257863,-173.5712464477026,-89.59251697193665]],[4,"Bn_Hand",-37,[1,"b4NkXDiC1Ugpi6y1EryYfH",1,0],[1,0.07876826077699661,0.0014336705207824707,0.008919715881347656],[3,-0.5285012611055592,0.45481123565417464,0.4609834753050134,0.5489329580452139],[1,-89.06222278112995,80.71567421214854,1.4532582727244376]]],[1,"b8A7ZBYvlbYJe+OTRAWqzr",1,0],[1,0.49073225259780884,0,-2.7755575615628914e-17],[3,0.006459115510774314,-0.0009703958597851153,-0.00967462636066002,0.999931867560723],[1,0.7391929267412117,-0.10405038509961596,-1.109342541708019]],[64,"VD289_Lion_Toy",1,[[66,-38,[10,"503Je38cFf+qiwMAkmKXtO"],[0,1,2,3,4,5,6,7,8,9],[29],1,10,11]],[1,"66SXxyl+ZSLIlCH9Xjfuro",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[6,"Bip001",1,[7],[1,"20FZ6FqZZT946EF29Au3vS",1,0],[1,1.1595849258583257e-7,1.5997356176376343,-0.6252281665802002],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[14,"Bip001 Tongue_01",4,[[4,"Bip001 Tongue_02",-39,[1,"3evKiZvo5TaLUHoURAeo/X",1,0],[1,0.11488211154937744,0.004982948303222656,-1.5629666449967772e-9],[3,-2.323547235219641e-13,-2.9056776282183755e-7,0.1047619535833508,0.9944973268346755],[1,0.0000035664763741375045,-0.000033856545481151455,12.026903731116498]]],[1,"55LTavoExT56Qt1yhbvz/X",1,0],[1,0.003924190998077393,0.02710580825805664,-3.941545401175972e-7],[3,8.876830915891205e-8,2.861370347925786e-7,-0.1564121826931524,0.9876918695145132],[1,0.000015956211203273638,0.00003572433450440832,-17.997414807659634]],[14,"Bip001 R_Ear",2,[[4,"Bip001 Xtra_Rear1",-40,[1,"7dpmNx611fh4xXzZzkGAmI",1,0],[1,0.16526293754577637,-0.007695436477661133,-0.00586247444152832],[3,0.0002579941082421809,0.00014602117979031542,0.00013364067216513513,0.9999999471285115],[1,0.029561711706125145,0.01672884364813452,0.015318409307953114]]],[1,"11uo16DZlTM61GJXA7u+dI",1,0],[1,0.2222374677658081,-0.27237796783447266,-0.2623478174209595],[3,0.08784863973881617,0.39916932019638285,-0.6109285268413922,0.6780212425886106],[1,68.57755439683643,95.73479365574451,-49.3156191935996]],[14,"Bip001 Bip001 L_Ear",2,[[4,"Bip001 Xtra_Lear1",-41,[1,"07XOU8MOJdXYdeZTz15z4c",1,0],[1,0.16525864601135254,-0.007697701454162598,0.005858659744262695],[3,-0.00025739037835200524,-0.00014754108367486289,0.00013392347407347846,0.9999999470231611],[1,-0.029492501292864223,-0.0169030127135326,0.015350850744476724]]],[1,"16nrjCCw1awrIbbFmrrLkt",1,0],[1,0.2222374677658081,-0.27237915992736816,0.2623463571071625],[3,-0.08784849002020216,-0.3991657109029413,-0.6109308465057375,0.6780212967365428],[1,-68.57792556304484,-95.73482604637756,-49.31596771939435]],[6,"Bip001 L Clavicle",3,[-42],[1,"24wLW8b+9UI6wK3JzbMbUF",1,0],[1,-0.14779305458068848,0.10067105293273926,0.2215055376291275],[3,0.41547124778529304,0.4998455845503116,0.7451695656451454,0.14919903587327327],[1,-126.27871613268118,-142.39487477211952,39.62053467264401]],[6,"Bip001 L UpperArm",14,[-43],[1,"a8dpwKFOlaFJYRtwefRwED",1,0],[1,0.2296522855758667,-5.960464477539063e-8,5.960464477539063e-8],[3,-0.6379365357431955,0.1235952085584575,-0.26826861637233795,0.7111913598006048],[1,-87.13188492523258,-11.401635846222337,-32.63412457981295]],[6,"Bip001 L Forearm",15,[8],[1,"25rnbqlTNR1pQdN14WG5HL",1,0],[1,0.7293049097061157,1.7881393432617188e-7,-1.4901161193847656e-8],[3,-2.9085993091906674e-18,-6.926437497026995e-18,-0.04384888403144709,0.9990381751310593],[1,-3.6920345895733417e-16,-8.106801632792376e-16,-5.026323567077576]],[6,"Bip001 R Clavicle",3,[-44],[1,"8aDq0WbNRYM4NJvJ2o74Lv",1,0],[1,-0.14779317378997803,0.10067236423492432,-0.2215055376291275],[3,-0.41547080324707847,-0.4998476439141597,0.7451681992161449,0.14920019906038545],[1,126.27838935043187,142.39508748208752,39.62072751801381]],[6,"Bip001 R UpperArm",17,[-45],[1,"07NdQ2IsRR84s8cj1lRGj3",1,0],[1,0.2296525239944458,0,0],[3,0.6379367648406821,-0.1235963988454534,-0.2682694469176002,0.7111906341534349],[1,87.13198029502165,11.401633666939945,-32.63428564318466]],[6,"Bip001 R Forearm",18,[-46],[1,"30nvpNQ2tWc6LIPcuur2vi",1,0],[1,0.7293049097061157,1.1920928955078125e-7,1.4901161193847656e-8],[3,1.1303803744703823e-18,5.973501841164178e-18,-0.04384888774957473,0.9990381749678664],[1,1.6003800920948266e-16,6.921961491095201e-16,-5.026323993553814]],[14,"Bip001 R Hand",19,[[4,"Bip001 R Finger0",-47,[1,"008tQUqzhbV6wCEbIfA14v",1,0],[1,0.11026114970445633,-0.165815532207489,0.0072045475244522095],[3,0.0002805438754491646,0.0002825344610703674,-0.7096009373106047,0.7046036838090782],[1,173.57108647059945,173.5712477657234,-89.59251697299388]]],[1,"feQFOqHlxSwbMcaPmuycQQ",1,0],[1,0.49073225259780884,-5.960464477539063e-8,0],[3,-0.006459115510844551,0.0009703939389428657,-0.009674625429442654,0.9999318675715966],[1,-0.739192928963956,0.10405016564739006,-1.109342433575704]],[6,"Bip001 L Thigh",5,[-48],[1,"e7TXJyk2pTmZxxh/3c0m7+",1,0],[1,-0.29023897647857666,-0.11606419086456299,0.26128682494163513],[3,0.6547501037544102,0.7558454217821333,0.0000013154733451603865,-0.0000016875408036243292],[1,-0.0016868458150420427,-179.9982829288019,81.80140842503103]],[6,"Bip001 L Calf",21,[-49],[1,"90JC9J3EBcF59u1d/TDnac",1,0],[1,0.8090827465057373,0,5.551115123125783e-17],[3,0,0,-0.11404207427361232,0.9934759208432642],[1,0,0,-13.09675291010064]],[6,"Bip001 L HorseLink",22,[-50],[1,"9edFaLq9JUMqw4ukRK7eJe",1,0],[1,0.25800904631614685,1.1920928955078125e-7,-2.9802322387695312e-8],[3,9.57812866348905e-14,2.2470528871822908e-14,0.245942504133208,0.9692844188682117],[1,1.1382293537766347e-11,-2.3156963582984584e-13,28.47507924983398]],[14,"Bip001 L Foot",23,[[4,"Bip001 L Toe0",-51,[1,"40GD3ZPKlVUKfO5lep3+oO",1,0],[1,0.1358935534954071,0.22066044807434082,8.940696716308594e-8],[3,9.866342672720895e-7,2.5395416366009996e-7,0.7093888948710643,0.704817278330045],[1,179.99086762866585,-179.9907671051601,89.62956826340346]]],[1,"6ax1un7LxbuodvxEmJ7fy/",1,0],[1,0.4313865005970001,0,5.960464477539063e-8],[3,-0.0000010594730005037418,-0.00000132363403322884,-0.005650970194106799,0.9999840331390251],[1,-0.00012226965720855048,-0.00015237066251723541,-0.6475569308786362]],[6,"Bip001 R Thigh",5,[-52],[1,"4dRXphVyNfYYs4uOckZrgr",1,0],[1,-0.29024165868759155,-0.11606109142303467,-0.2612874209880829],[3,0.6547501037545858,0.755845421782336,0.0000012090864537826867,-0.000001606185025239139],[1,-0.001579425924664092,-179.9983883152573,81.80140842546759]],[6,"Bip001 R Calf",25,[-53],[1,"9166HB4c9fCpJ+ndmbNclR",1,0],[1,0.8090826869010925,-1.1920928955078125e-7,-2.9802322387695312e-8],[3,-2.2245138044444033e-22,-8.103900608651333e-23,-0.11404207427361232,0.9934759208432642],[1,-2.7088384694094717e-20,-1.2456871242652872e-20,-13.09675291010064]],[6,"Bip001 R HorseLink",26,[-54],[1,"21BAg+uiNcLJ1pMuhtF2u5",1,0],[1,0.25800904631614685,2.220446049250313e-16,2.9802322387695312e-8],[3,3.303694474986318e-14,8.382667523066969e-15,0.245942504133208,0.9692844188682117],[1,3.905721507034513e-12,1.2771531827069202e-20,28.47507924983398]],[14,"Bip001 R Foot",27,[[4,"Bip001 R Toe0",-55,[1,"5cJRpZcMxdlIdscpoxZ25t",1,0],[1,0.1358935534954071,0.22066044807434082,-8.940696716308594e-8],[3,-9.86634536094653e-7,-2.539541459071018e-7,0.7093889246727637,0.7048172483350432],[1,-179.99086774519165,179.9907672216655,89.62956341814296]]],[1,"bfPdLlgZtTPLDNzkErLei1",1,0],[1,0.4313865303993225,0,0],[3,0.000001059741074068888,0.0000014110564835805256,-0.005650970194106122,0.9999840331389052],[1,0.00012235699197597083,0.00016238919088752877,-0.6475569308678233]],[6,"Bip001 Tail_01",7,[-56],[1,"04ogjBxslRvqZNn/28a2mW",1,0],[1,-0.2915322780609131,-0.22355151176452637,-9.820198556553805e-7],[3,-0.0000027950730284391583,2.102613403261408e-8,0.9999568013565235,-0.009294913287234204],[1,179.999999432131,179.9996796891088,-1.0651339420896775]],[6,"Bip001 Tail_02",29,[-57],[1,"62SLmOvJVd65B7L2G1Y1bi",1,0],[1,0.5395174622535706,0.006091594696044922,-2.1810456019011326e-7],[3,-6.981501933704374e-7,6.656289363368778e-7,-0.003450571817125076,0.9999940467588817],[1,-0.0000797403477249723,0.00007600076020202552,-0.3954071887608722]],[14,"Bip001 Tail_03",30,[[4,"Bip001 Tail_04",-58,[1,"48il1/WABdRr0dL7mUyTUY",1,0],[1,0.5596358776092529,0.004202485084533691,1.507032720837742e-9],[3,0.0000011297749087033272,1.3514002976763587e-7,-0.001367071436931353,0.9999990655567593],[1,0.0001294842014842598,0.00001566293548740287,-0.1566548960355113]]],[1,"e4/QZ1rH1f3K65N7Vtf7PY",1,0],[1,0.4064565896987915,0.007515430450439453,3.950663085561246e-8],[3,6.873440722040352e-7,6.919706716734174e-7,0.008025330355133777,0.9999677965173377],[1,0.00007813499653582644,0.00007866947233888114,0.9196449890937232]]],0,[0,4,1,0,0,1,0,0,1,0,-1,9,0,-2,10,0,4,1,0,1,1,0,-1,4,0,1,2,0,1,2,0,-4,12,0,-5,13,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,-2,14,0,-3,17,0,1,3,0,1,4,0,-2,11,0,1,4,0,1,4,0,-1,6,0,-2,21,0,-3,25,0,1,6,0,1,6,0,-2,29,0,1,8,0,1,8,0,0,9,0,1,11,0,1,12,0,1,13,0,-1,15,0,-1,16,0,-1,18,0,-1,19,0,-1,20,0,1,20,0,-1,22,0,-1,23,0,-1,24,0,1,24,0,-1,26,0,-1,27,0,-1,28,0,1,28,0,-1,30,0,-1,31,0,1,31,0,18,1,2,1,3,3,1,6,5,1,7,7,1,10,8,1,16,58],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,12,20,-1,-2,-3,31,22],[5,5,5,5,5,5,5,5,5,96,97,98,34,38,24,34,80]],[[{"name":"board_encyclopedia","rect":{"x":0,"y":3,"width":1424,"height":1119},"offset":{"x":0,"y":-0.5},"originalSize":{"width":1424,"height":1124},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[7],0,[0],[23],[191]],[[[118,"builtin-particle",[{"hash":585841727,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":1223598056,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":3735404623,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":2524517876,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[[307,[{}],[{}]]],0,0,[0],[14],[29]],[[[50,"Food_AssetsA",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":0.5,"metallic":0,"roughness":0.5,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[192,10]],[[[62,".bin",773436362,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6720,"length":2304,"count":576,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6720,"count":140,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.4059858322143555,-2.1569759845733643,-0.4776197671890259],"maxPosition",8,[1,2.4059858322143555,2.1569759845733643,0.4776197671890259]]],-1],0,0,[],[],[]],[[[56,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[92,28]],[[[40,"KagarooRoot"],[0,["08p3MFuydXL4oM9CbjboO3"]],[217,"KagarooRoot",[[-5,[68,"FeedPosition",-7,[1,"b1ejwKP8BBD6UH4x6Zi3XS",-6,0],[1,0,0,-2.5]]],1,4],[[334,null,null,-4,[10,"f0+X1ZhodFgJJg4GPQVMFV"],-3]],[237,"53vKouf8tIqrJE9sorGNMt",-2,0,[-1]],[1,0,0,0.696],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[20,0,null,2,[19,"8fJHyWPHhT77T0qzBIqM/Z",-19,[173,"1dRKqITCJJR6zNWur3+Cgc",2,[[25,[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[[80,-18,[10,"71SN8zFoFC/5gBHzxRLc1H"],1]]]],[[8,["_lpos"],-8,[1,0,0,0]],[9,"VD302_Kangaroo_Rig",["_name"],-9],[8,["_lrot"],-10,[3,0,1,0,6.123233995736766e-17]],[8,["_euler"],-11,[1,0,180,0]],[9,2,["_clips","length"],1],[15,["_clips","0"],1,2],[9,null,["_defaultClip"],1],[9,false,["playOnLoad"],1],[15,["_clips","1"],1,3],[9,false,["_useBakedAnimation"],1],[8,["_lrot"],-12,[3,0,0,0,1]],[8,["_euler"],-13,[1,0,0,0]],[8,["_lrot"],-14,[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001]],[8,["_euler"],-15,[1,-90,-90,0]],[8,["_lrot"],-16,[3,0,0,-6.698506168543417e-16,1]],[8,["_euler"],-17,[1,0,0,-7.67592264999771e-14]],[9,true,["_enabled"],1],[9,null,["_clips","2"],1],[9,null,["_clips","3"],1]]],0]],[0,["8fJHyWPHhT77T0qzBIqM/Z"]],[0,["5fl0cfxJ5Rs5ovU2QsXaQ9"]],[0,["61SpoqJn9XKIWNc6m3Gvr3"]],[0,["f3CmudYmJTjK7M6nViAmg5"]]],0,[0,-1,3,0,4,2,0,60,3,0,0,2,0,-1,3,0,4,2,0,1,2,0,3,4,0,3,4,0,3,4,0,3,4,0,3,5,0,3,5,0,3,6,0,3,6,0,3,7,0,3,7,0,0,3,0,4,3,0,18,2,19],[0,0,0,0],[7,22,5,5],[59,49,9,14]],[[[121,[[122,[123,[-14,-15,-16,-17,-18,-19],[[124,-5,-4],[72,0,-7,-6,[[125,1,[74,"velocity"],[75]]]],[72,0,-9,-8,[[126,[74,"velocity"],[75]]]],[73,false,-11,-10,[[127,[76,"EatFood"]]]],[73,false,-13,-12,[[128,1,[76,"EatFood"]]]]],-3,-2,-1]]],[{},"velocity",4,[129],"EatFood",4,[130,1,false]]],[51,"Idle",[52,0]],[53,"Entry"],[51,"Run",[52,1]],[51,"Eat",[52,2]],[53,"Exit"],[53,"Any"]],0,[0,28,6,0,29,5,0,30,2,0,16,1,0,17,2,0,16,3,0,17,1,0,16,1,0,17,3,0,16,4,0,17,1,0,16,1,0,17,4,0,-1,2,0,-2,5,0,-3,6,0,-4,1,0,-5,3,0,-6,4,19],[0,0,0],[19,19,19],[34,38,24]],[[[40,"VD295_Flamingo_Rig"],[218,"VD295_Flamingo_Rig",[[-4,-5,[68,"Bn_FoodSpawn",-7,[1,"c4MNbS8yRXIaS6qgPgPrqT",-6,0],[1,-0.020412404090166092,0,1.4832285642623901]]],1,1,4],[[145,false,-2,[10,"4cq3CaMM9QFplY9tFHtlLH"],[6,7,8]],[80,-3,[10,"7fNquVICVMTKR1Fa5SgPYe"],9]],[1,"5dXI/ybWZaFrEKPI46LgaD",-1,0],[3,0,1,0,-6.123233995736766e-17],[1,2,2,2],[1,0,-180,0]],[104,"Bip001 Head",[[4,"Bip001 Mouth",-8,[1,"15bHkaVhxULoQNZ95K+rGl",1,0],[1,0.1853790134191513,0.02393317222595215,2.3913526092655957e-7],[3,3.6327741156443087e-13,-3.631222933645755e-7,0.13092161595638818,0.9913927226257192],[1,0.000005641172556479641,-0.0000427169780191864,15.045704420963872]],[4,"Bip001 eye_L",-9,[1,"baXanNgPZQoZV6vIjIoTfA",1,0],[1,0.10343153774738312,-0.04911351203918457,0.05298836901783943],[3,-0.00024194813402205606,-0.6087613167009532,0.0003147253914729629,0.7933533271484717],[1,-0.00004099095042321951,-74.9999906904734,0.04549022969239943]],[4,"Bip001 eye_R",-10,[1,"1eYfzhDh5bIo6wE6rROPOs",1,0],[1,0.10257671773433685,-0.04911303520202637,-0.04994485154747963],[3,0.00024194823562694417,0.6087613160504972,0.00031810219219961393,0.7933533263007808],[1,-0.00019456181980478671,74.99999078450371,0.045797227167488165]],[4,"Bip001 eyelid_L_up",-11,[1,"30RfEJQ/xTabZjlnUgSgWc",1,0],[1,0.10343153774738312,-0.04911351203918457,0.05298838019371033],[3,0.14415553349210042,-0.5914464649160642,-0.18848307609929205,0.7706389500447322],[1,-0.04981721459010648,-75.02287479330846,-27.453291992450442]],[4,"Bip001 eyelid_L_down",-12,[1,"34Ruzm2H1XYYt2kEBRWij0",1,0],[1,0.10343150794506073,-0.04911351203918457,0.05298838019371033],[3,-0.14445081285955402,-0.5913755270136265,0.18763612123418558,0.7708447539691502],[1,-0.04978601366354341,-74.97715566447208,27.395237742743113]],[4,"Bip001 eyelid_R_down",-13,[1,"eeJG5qN81dm4bIT7UcnztQ",1,0],[1,0.10257671773433685,-0.04911303520202637,-0.049944858998060226],[3,0.14445078097891403,0.5913745052261379,0.18763941169109033,0.7708447428784502],[1,0.049556368854709015,74.97711667339797,27.39554335799152]],[4,"Bip001 eyelid_R_up",-14,[1,"81v2Uyj+Vez6nrS7hhhoNT",1,0],[1,0.10257671773433685,-0.04911303520202637,-0.04994484782218933],[3,-0.1441554573227101,0.5914475309742541,-0.1884798254710249,0.7706389411514001],[1,0.04960249879584121,75.02292260137546,-27.452982316206292]],[4,"Bip001 L_lips_point",-15,[1,"b51/1/kdFRobUfwsEeT3uH",1,0],[1,0.2125636488199234,0.0004966259002685547,0.06602133065462112],[3,-0.0002447514480468828,-0.6158146653236611,0.00031252725290150497,0.7878909444813742],[1,-0.000043382534688888074,-76.0222854335002,0.045488146695362]],[4,"Bip001 L_lips_pointOpp",-16,[1,"33lPB7VnpemLW23UhXTmaQ",1,0],[1,0.2125636488199234,0.0004971027374267578,-0.06602133065462112],[3,0.0002447515641994772,0.6158146646626275,0.0003159431690293676,0.7878909436356288],[1,-0.00019765856372147501,76.02228552971563,0.045796563154277055]],[4,"Bn_Mouth",-17,[1,"f1JuzE2exYNpMLArES2Q9R",1,0],[1,0.35302335023880005,0.03254532814025879,0.000400304765207693],[3,-0.17419363444136365,0.6794313743888158,0.17440272753386546,0.691095705271695],[1,-28.539391285878086,89.08818266132725,0.24939276046124864]]],[1,"783hrjEJBTA6iOjJ8o6PCH",1,0],[1,0.34503018856048584,0.05807298421859741,-3.204622771590948e-7],[3,0.000007283078974909878,-0.000002044906528056778,0.7926253695146028,0.6097089662655573],[1,179.99729216877995,-179.99686413223276,75.13692459404484]],[57,"Bip001",1,[[[4,"Bip001 Footsteps",-18,[1,"63UN7XUWBWyZZ/qkFfOZhT",1,0],[1,0,0,-1.2544288635253906],[3,-6.9210348904225676e-34,6.921044533149829e-34,0.7071063043492204,0.7071072580235531],[1,0,-1.1216009582263197e-31,90]],-19,-20],4,1,1],[1,"c3T8xhbBlaNp7/Bly9AFlQ",1,0],[1,0,1.2599310874938965,-0.03170289844274521],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[47,"Bip001 Spine",[-21,-22,-23],[1,"cfwWn+4r9UDZPd2/A7BPsK",1,0],[1,0.006523013114929199,0.007367122918367386,-2.466515525156865e-8],[3,-0.000003644542704351234,-0.0000032234625650382653,0.7079508448334461,0.706261708770861],[1,-179.98599514327807,179.9854386389328,89.8631318550418]],[6,"Bip001 Neck",4,[-24,-25,-26],[1,"45seyRJhVZ2YulhZHAVFr0",1,0],[1,0.31526342034339905,-0.00016570091247558594,8.220013114623725e-9],[3,-2.557486891979508e-7,0.0000019258948303804823,-0.1736482836955129,0.9848077343145861],[1,0.000010068460395121748,0.00022587115662259883,-20.000012337433215]],[64,"VD295_Flamingo_Toy",1,[[66,-27,[10,"ea68U0IKpXTa0akVc+P+6u"],[0,1,2,3],[29],1,4,5]],[1,"00epe3MM5V+6cyzbwFVcci",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[84,"Bip001 Pelvis",3,[4],[1,"28HoLqRkpcfoL7nQmIgrpu",1,0],[3,-0.49999999254917427,-0.49999999254917427,-0.49999930709576956,0.5000007078049009],[1,-89.99991974527727,-89.99991974527727,-0.0000017074910602964197]],[6,"Bip001 L Thigh",4,[-28],[1,"b5g+r/vqNfaail1orcNRvu",1,0],[1,-0.007351363077759743,0.006539463996887207,0.13554731011390686],[3,-0.025361888339490553,-0.04286933728992652,0.7657588789419875,0.6411960182827777],[1,169.22300015928454,-174.77584462709845,79.79416966078732]],[6,"Bip001 L Calf",8,[-29],[1,"91wcoKnUdZt649Xs1K9QTt",1,0],[1,0.6679134964942932,0,1.4901161193847656e-8],[3,7.532819370050671e-18,5.867785891590635e-18,-0.09536687107671847,0.9954421931488723],[1,9.404950962710234e-16,7.65580174507929e-16,-10.944871697898266]],[14,"Bip001 L Foot",9,[[4,"Bip001 L Toe0",-30,[1,"1exRZapZNcwIBXxb/0W5eY",1,0],[1,0.13152936100959778,0.11558839678764343,-1.4901161193847656e-8],[3,-0.008638708737303427,0.00863873947094798,0.7070540095677645,0.7070540095677645],[1,-89.99999875475658,90.0000012452424,88.60000000522456]]],[1,"4aHFl3fHlbuaL6RN8JRXeO",1,0],[1,0.4661397933959961,1.4901161193847656e-8,2.7755575615628914e-17],[3,0.9987407161553962,0.006006529921066466,-0.01697614202145063,-0.046826425165511394],[1,-174.64423896868865,1.9111731418192246,0.7785473263659639]],[6,"Bip001 R Thigh",4,[-31],[1,"98ubztsaReB4SM5j0C+9XQ",1,0],[1,-0.007351571694016457,0.006541728973388672,-0.13554713129997253],[3,0.02536777561468011,0.042863532364716884,0.7657592200826986,0.6411957660589462],[1,-169.22830858380843,174.78115939262284,79.79425420282486]],[6,"Bip001 R Calf",11,[-32],[1,"daFSmgldhVHZr6ed1FMbc2",1,0],[1,0.667913556098938,-2.7755575615628914e-17,2.9802322387695312e-8],[3,-2.779450550826024e-17,9.201456661039556e-19,-0.09536687845953706,0.995442192441572],[1,-3.2189959742186506e-15,-2.0246747923220863e-16,-10.944872547780557]],[14,"Bip001 R Foot",12,[[4,"Bip001 R Toe0",-33,[1,"d2NS0Sd+lc/qOaGqu0ryVu",1,0],[1,0.13152936100959778,0.11558838188648224,-1.4901161193847656e-8],[3,0.008638708737303427,-0.00863873947094798,0.7070540095677645,0.7070540095677645],[1,89.99999875475658,-90.0000012452424,88.60000000522456]]],[1,"9eM/tvRn9fvLFlTT7ESNOv",1,0],[1,0.4661397933959961,0,-2.9802322387695312e-8],[3,0.9987407144373609,0.006006534567346813,0.016976231399213774,0.04682642881025074],[1,174.64423862852755,-1.9111833471561586,0.7785483437149364]],[6,"Bip001 Neck1",5,[-34],[1,"afjViuGxNakYmIONA9A7ZA",1,0],[1,0.22764748334884644,0,1.8435457604937255e-9],[3,-0.0000026654889098749952,0.000004630969749150401,-0.7071069003857348,0.7071066619671517],[1,0,0.00043196104092464374,-90]],[6,"Bip001 Neck2",14,[-35],[1,"67sWnaBDZcZIOZiwUDQXR8",1,0],[1,0.3070821762084961,-0.00020182132720947266,-4.199591785436496e-10],[3,-4.569298452752026e-7,-0.0000010582180974791515,-0.08715570552516055,0.9961947013476246],[1,-0.00006369751454585079,-0.0001272988736324793,-9.999995718259875]],[6,"Bip001 Neck3",15,[2],[1,"46CRa2+nVSU7GAYxzrvj3h",1,0],[1,0.2573540210723877,-0.0001957416534423828,-1.0545591067057103e-9],[3,0.0000015830806458502071,-0.0000026928886834355856,0.1305262113000271,0.9914448588569629],[1,0.00022789927277829786,-0.0003412485708389339,15.000002204688592]],[6,"Bip001 L Clavicle",5,[-36],[1,"23P11ouaBeNaOziPbu7lTO",1,0],[1,-0.11201411485671997,-0.08999741077423096,0.10659269988536835],[3,0.5995536471749696,0.10547037466949456,0.7813563379675971,-0.1374543463995759],[1,-160.67440442491954,-104.13681493443396,-5.06761835750432]],[6,"Bip001 L UpperArm",17,[-37],[1,"98Sz/NQqJWj6c2DtnFVTQ6",1,0],[1,0.148685485124588,2.220446049250313e-16,2.7755575615628914e-17],[3,0.6768576592153223,-0.05294709722558723,0.07699565691071343,0.7301588750907755],[1,85.8751213326478,-10.468842676701874,2.336185274871858]],[6,"Bip001 L Forearm",18,[-38],[1,"62LM705PxVL7yWO1SbD16v",1,0],[1,0.20733222365379333,0,-1.1920928955078125e-7],[3,-3.4350338633823554e-18,9.825177174135079e-18,0.3300270242447469,0.9439714843511731],[1,-9.501113700203277e-16,1.52488165384648e-15,38.54083152151289]],[6,"Bip001 L Hand",19,[-39],[1,"cfy2dsSI5clai71SmRD+gt",1,0],[1,0.22722017765045166,1.4901161193847656e-8,1.1920928955078125e-7],[3,0.005361270470880891,-0.003487623196326396,-0.11797415870719775,0.9929960680388957],[1,0.5790368821413306,-0.3336672155888319,-13.55231738015595]],[6,"Bip001 L Finger0",20,[-40],[1,"a0kNa6alVRtb1xwMgM02q9",1,0],[1,0.34348487854003906,-1.1175870895385742e-8,0],[3,-0.0003921142787962037,-0.00006913842677759943,-0.1736481789614351,0.9848076722942647],[1,-0.048554295186474965,-0.016606331514334754,-19.999995140234756]],[14,"Bip001 L Finger01",21,[[4,"Bip001 L Finger02",-41,[1,"c5UNlN9WpelrcAagNMgB3X",1,0],[1,0.3262892961502075,-4.470348358154297e-8,2.220446049250313e-16],[3,-9.249915348858104e-10,-1.0840800562367162e-10,0.11640220969456343,0.993202157457495],[1,-1.0672169928760527e-7,-7.610714278330366e-16,13.369017926888654]]],[1,"d8KrAf/ApRq4ueboGh7Kiw",1,0],[1,0.23077142238616943,0,0],[3,3.916782039768282e-9,-1.4163511582992378e-9,0.11640220969456343,0.993202157457495],[1,4.776142253299043e-7,-2.193886077792847e-7,13.369017926888654]],[6,"Bip001 R Clavicle",5,[-42],[1,"badzM6Hqlb27spngOq5m5/",1,0],[1,-0.11201351881027222,-0.08999669551849365,-0.10659399628639221],[3,-0.5995562764385542,-0.10547293884070662,0.7813543200880798,-0.13745238097295803],[1,160.67429869662922,104.13649568648655,-5.067201018483602]],[6,"Bip001 R UpperArm",23,[-43],[1,"79MDogfrxY4pizj38cH188",1,0],[1,0.14868545532226562,2.220446049250313e-16,1.4901161193847656e-8],[3,-0.6768584984316969,0.052950271544657895,0.07699113494868529,0.7301583437744505],[1,-85.87517376343968,10.468755495047693,2.3355504078641744]],[6,"Bip001 R Forearm",24,[-44],[1,"b72NXmqyBRSqNZecSkl4t2",1,0],[1,0.20733219385147095,-2.7755575615628914e-17,1.1920928955078125e-7],[3,-7.695128976785288e-18,9.850361528872603e-19,0.3300270773573828,0.943971465782173],[1,-1.1118424875021456e-15,5.082939182817443e-16,38.54083796901678]],[6,"Bip001 R Hand",25,[-45],[1,"8df/WULSJXH4ndqHq46j6Q",1,0],[1,0.22722017765045166,2.7755575615628914e-17,-1.1920928955078125e-7],[3,-0.00536126909286529,0.00348761901771416,-0.1179741293222698,0.9929960715521252],[1,-0.5790367849833785,0.33366676089575653,-13.55231398635651]],[6,"Bip001 R Finger0",26,[-46],[1,"33XcvF5phc+IlA2P543Z0E",1,0],[1,0.3434847593307495,3.725290298461914e-9,1.1920928955078125e-7],[3,0.0003921099734592463,0.000069135407613098,-0.17364815005809198,0.9848076773926302],[1,0.04855371317484482,0.01660587607116881,-19.999991777283306]],[14,"Bip001 R Finger01",27,[[4,"Bip001 R Finger02",-47,[1,"ec0i50qEBURauM08B13c/7",1,0],[1,0.32628965377807617,7.450580596923828e-8,-1.1920928955078125e-7],[3,3.243936652636153e-18,2.126782492110894e-18,0.11640221704419262,0.9932021565961265],[1,3.503257335078032e-16,2.0432157548678967e-16,13.369018774858489]]],[1,"d0xrCNmzhYj5mJfGfYioBX",1,0],[1,0.23077142238616943,-2.9802322387695312e-8,1.1920928955078125e-7],[3,-3.6999665836324554e-9,-4.336320502502623e-10,0.11640220969456343,0.993202157457495],[1,-4.268868487206369e-7,-2.0263625574909182e-16,13.369017926888654]],[6,"Bip001 Tail",3,[-48],[1,"74qcjuzehSf5BUatpViYMH",1,0],[1,-0.13302025198936462,1.881728195485266e-7,0.055188775062561035],[3,0.00028152588657601635,0.7071057416663604,0.7071077086195986,-0.00028152510077260974],[1,-90.00015937922115,-179.9543768396282,2.176542928445588e-10]],[171,"Bip001 Tail02",29,[[68,"Bip001 Tail03",-49,[1,"e1NdgXAPpT3pWeZaVw/WW/",1,0],[1,0.19411420822143555,-0.00015807151794433594,-4.388311936054379e-10]]],[1,"11e4xaYaxdEodwfLk3pWmV",1,0],[1,0.16504977643489838,-0.00015473365783691406,-4.2882675188593566e-10]]],0,[0,4,1,0,0,1,0,0,1,0,-1,6,0,-2,3,0,4,1,0,1,1,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,3,0,-2,7,0,-3,29,0,-1,8,0,-2,11,0,-3,5,0,-1,14,0,-2,17,0,-3,23,0,0,6,0,-1,9,0,-1,10,0,1,10,0,-1,12,0,-1,13,0,1,13,0,-1,15,0,-1,16,0,-1,18,0,-1,19,0,-1,20,0,-1,21,0,-1,22,0,1,22,0,-1,24,0,-1,25,0,-1,26,0,-1,27,0,-1,28,0,1,28,0,-1,30,0,1,30,0,18,1,2,1,16,4,1,7,49],[0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,12,20,-1,-2,-3,22],[27,27,27,84,85,86,32,57,58,193]],[[{"name":"title_green","rect":{"x":0,"y":1,"width":1022,"height":252},"offset":{"x":-1,"y":1},"originalSize":{"width":1024,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[7],0,[0],[23],[194]],[[[62,".bin",3715973771,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":10704,"length":3096,"count":774,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":10704,"count":223,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.483253240585327,-3.0616281032562256,-0.5437402129173279],"maxPosition",8,[1,2.483253240585327,3.0616281032562256,0.5437402129173279]]],-1],0,0,[],[],[]],[[[50,"Food_AssetsB",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"albedoScale":1,"metallic":0,"roughness":0,"emissiveScale":1,"alphaSource":1},"mainColor",8,[4,4286545791],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[15,14],[195,10]]]]
