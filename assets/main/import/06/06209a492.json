[1,["bfxBG9OL9Np52lYacNvCAc","98D0/v3axCerHzlUHUv4Pq","cf0/Gi70NPuaqUAUg6oYEg@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","10l4NTI2lLA47BeXmb/u8U@f9941","1ba7066b6@6c48a","a64HywX55HJoGL15BTRFB9@f9941","14b7fcddf@6c48a","12ce832a6@6c48a","1cfca5a3e@6c48a","bft5T1anhNwIzSqTh/MkAL@f9941","20g1ukYUVPvKWKBRznAKo+@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","19ab3d4f1@6c48a","a6nmE67kFOhpxbgYoiu+uO@f9941","153628710@6c48a","35hdgKDPFDZa9gA8R2Dje6@f9941","1aPNAndo5Gnp+j99+grE+j@f9941","bajd9p2cBExb+R78U1mrzD@f9941","1fEy/5vmBMb52ejbf4uc6o@f9941","3bBwaLCghMbaluu6BFkRf6@f9941","d4jscpU/pLX4n6YnZiahKE@1874f","c2moVwJJNKRJa5hFTmXzzE@f9941","42rTwAnU5Lcq6pOeysY7j9","3fEtkiUJ5PabvyZmJwH1Fc","eav+7EobVP1bkweAxy4MhQ@f9941","2cZKsa/zJBa7I2s4/pcrs0@f9941","d58hQlh+1IQa4SpynmVF9J@f9941","152DGZXu1NIqjZH7BRIyJS@60ade","0c3A3ckBhMyZlyDcLBp5/A@cf5ee","166nQ4Wh9AvYooDccrRgZe@8ffd2","dfSCAY8fVDGaZGtar3Kqy/@e0be2","3ajataGt9HU4+8qvIWfOIL@f9941","4bxb6j4kBMX5xmBYBkhhbB@f9941","f9aYxh2/9J9bPatzOWB08X@f9941","1brw/JvvpFnIvdrxpFCgMZ","8dUIo5lfpGd5kESjVWd4Do@6c48a","a0/rvkbaBB5aG0xZ2ck4QO@f9941","a5Dcb0zrpLko3+/na9JHbK@f9941","025zwmhr1K54eIZPcfKOmg@f9941","720TuXLxhAQKH3ouEYRM9D@f9941","88m4pKEG9J6oBlT3eOaVxi@f9941","6c64i3xu5BC59wzpvPbjtk@f9941","7dmY2/D6BK3ZI39lFJrZkL@f9941","bbm+SFmL9Nja5qNjEGkPJT","d7Z/Cuhx5PJKWI6VL3aGTp","c2YeXcg/VFMp7jOOTGbxht","fdoJXLgx1GAa2UhGATlj3o","9df91urcBOD6UF68DhybTa@f9941","d6k7Rs0v1Ie7/zp61+OEb3@f9941","04ErYLCQVLhJdB7QlJwRMZ","12Y9dMgWdJKJGmTiZyQR9H@2e76e","7fZAUHKFNFmL2hciKq/4km@f9941","3eEgTMVIZD3Ks9zUZoI+Is@f9941","09SwKyZmZPUJGuDpy0m9vW","dfSCAY8fVDGaZGtar3Kqy/@c2696","5bObxToHtF7bcH7jxjVlgY@f9941","68k3u9kyVAr5bzo2hcbUYW","edKKPeQRdDoa+8J2A3hK4c@f9941","3fOXOLWJNLV5gLBkkjr6FG@f9941","94Pf0bfP1EdJi8USpJmEEM@f9941","0diFBFvAJJuLs641xRnDnR@f9941","dfSCAY8fVDGaZGtar3Kqy/@b9e10","dfSCAY8fVDGaZGtar3Kqy/@438fe","5eyn5QrZlJJLe9DSw0dvOx","62oIahHLtBoa9I49HG4gJO@f9941","8b59xIEyVOuZhw/3DOJlPU@f9941","b1WUZ+WSBBDqgjjN11mH7n","bft5T1anhNwIzSqTh/MkAL@6c48a","29m1rBqZxJI6y3ML5RzdEN","2e6xTGgtpCdaSnbC0qSojp","85ehYVvllDM52NahgjI90E@f9941","b90l3PZEFIRL3qD62BWqKx@f9941","8bbooN4URDiZyxXoyvqy2f","68CF4/fItB3buM6sz1hRfp@f9941","cexQB/H3lCkJlj/sK+9jc6@f9941","856Of8DAVD9p2IrRoj/AAg","72J47Fp3FP4rP3IM7FuLh0","1cvPlWYOtPM5DLO6E9zanh@f9941","d1NGQ2rJZCcbhjH0/erZWw","d3x4IMKphEKYvHuEU7yaxB","12Y9dMgWdJKJGmTiZyQR9H@17020","bduZwr5WNF1bqP+JLmbi0o@f9941","f0F1ESotFOxaHT5o9JxW4v","61g3fKsOZO4IYmZrzSbg9l@f9941","2bZvO++c1AGqkIe2020/BT@f9941","679M9t9hNAxquCjL5YK3cn@f9941","adlUzyNmBDcZVsGx3qymBt@f9941","04YHq5wn9NOpeM+zMI/bd6@f9941","e82JUPXvRNWLWjjc118IIc@f9941","ed7xsECYxD2K0JXdF8btKQ","20g1ukYUVPvKWKBRznAKo+@6c48a","fchudeAcpLGbXeo0PZcTMU@f9941","3a9/qT2f1P+bzyCiQbDXdz@6c48a","81oDWS0lxNRpXAM5vXfiFK@f9941","54TknWPwVPqJqeCR+Y/Czo@6c48a","633vHesjtFdZKvx/54Cuk5@f9941","58xh3Ml11LO6N5+l2Db8tW@6c48a","ee/CP4/nlLm7oSIy/E2WVA@f9941","58upKzVEVN47uoAlnH8O+D@f9941","7dj5uJT9FMn6OrOOx83tfK@6c48a","d7rYf2XolEXrFST8vb/BhQ@f9941","941AtPZnVL9ICyDmJKIntW@f9941","77E9S3lBJMAa0ZqslZ7Umr","bft5T1anhNwIzSqTh/MkAL","d3CxWMbLJP2YKcuFGYhUlS","94ZtsbVoNEwpc5VuIy6F7f@6c48a","95EkngnxZFbYuFpsqVTaFr@6c48a","a0gA92YvpPZqOiYpNcFSjM@6c48a","51yWNd8nZESbM2qSxlXBLQ","08Oxs6E0FAbLSqLTw+FbsZ","eb5a1j6c9CeJqJMi0erpod","c6gVSmH1BMPLHnvKJ6qxWQ","31Ke35+c9AQ6gAooZ3JiCN","04CGa1ayNEVJxwU8p/i+BX","d8Fnb9nxVGPoKS2QchucpG","40XVZv3uxLyYRfx7WDd8uu","f11buewLVKiammyGXz+RFG","e46MUaDyFEbKVuiiPLn5AG","fdanoRt6FEHpzi+xnSzdMj","68FGwMNH1N4agj9pU6NCmX","6cFHAvZblBsrrkSSWR1i32@f9941","77oA70nmJKuJpN6ojys4IZ","b46jpd3CZIK7OV+1TIkuHN@f9941","ad/rPB5+JOrpAhS7LQN7Pf","bd/0cHBatDR4WHTyWUqBrw","e2Mwr6OVlIYbM70G9dChIe","269ff/6tJN/4I7A6J0HnXa","feEvf5j8RI7ZEsks3A1mk4@f9941","6dhOWIWspJgpXuzB3LOBOU","a8Rs1YskZPXpMwpvBxEYU4","14xZCD8kxLV7CquGG1uUXn","55B8V4N3VPWY1SuCAY3iNn","b1V/4UZsdHwoahD1WbX0Z1","17TDZ6g/JIR6BMVHyhWsbr","b8vntGxXRCbYocYdrSEeT7","2aldXE41xJwKws3ZxxRLFu","0cqj5owF5C4p35+BVgUI9J@f9941","d2nEdyVJVD94XdhKTzZIWH@6c48a","adHL+HHQ9EH4Aw6cqZJmRT@f9941","47CAgLiaJAHqVaqjZnmuSn@f9941","7dj5uJT9FMn6OrOOx83tfK@f9941","7aOHEmcndArL70e5zPlVTR@f9941","91SQc6GsNKB4UjoSkJLmiR@f9941","3a9/qT2f1P+bzyCiQbDXdz@f9941","3f2YST+cVMU5Jirlw6VpxZ@f9941","9fHyUgOR9Iz7uBd/NMDMph@f9941","5b8M7gmGBIRJPJMgzuD9ds@f9941","85n9snLtNNPL5u4IsxIyK4@f9941","12j+ZpZ/ZN37RWKF5Z6rRR@f9941","fbA97RIt9HI4eRrVs4oelZ@f9941","cbXImkXsNIBL5kXVKUtk9/@f9941","3chN4+9eZBmIZEcIJ6RwH9@f9941","81loSInLBAlLp4c2kXebP+@f9941","cat6sMZhdE4Zjrs55JV7p6@f9941","8dAJGy7XFCk5B8hxA53PJI@f9941","c6Nt3x+TZJl4GLwsKIb2nq@f9941","50Vc8euipCorAmXL5NZWlO@f9941","a8t9Jrw1dDr6XkQQVtXcw6@f9941","d6800I+39BfI9tHiQwuEh5@f9941","9af0/OM7NJ1ZRrm9xb3wrT@f9941","aeI0hmpmhFiq/VVKmpFUwq","dfzbQr1u5OqYM3FVMKtfsM@f9941","5e2CSzJI5MCq9plS/sBgO5@f9941","a4ZFfS0VRAjqO09ZNzy7h5","58xh3Ml11LO6N5+l2Db8tW@f9941","57mebtXppAI7sF4A85hCn6@f9941","4fzidgMkxMlLYy6q+WxIMV@f9941"],["node","_spriteFrame","targetInfo","_textureSource","_parent","asset","_normalSprite","root","_target","_font","data","_disabledSprite","target","to","from","clip","_pressedSprite","source","_hoverSprite","planet","btnInfor","_cameraComponent","graph","scene","_mesh","_defaultClip","_effectAsset","_anyState","_exitState","_entryState","mainTexture","active","deactive","hand","_customMaterial","_targetTexture","_particleSystem","_mainTexture","_skeleton","chest","player","mainMenu","UIPhoto","backGroundNode","renderTexture","material","gameData","Popup_ParentControl","soundBtn","bgImage","uiSoundSF","uiSoundMuteSF","_clip","BodyAnim","levelText","model","tileMap","loseBanner","winBanner","resetButton","retryButton","playButton","stepPlaceholder","stepMap","camera","value","confetti","buttonBack","transition","left","right","forward","movePlaceholder","astronaut","spritePlanet","titleOfPopup","descriptionOfPopup","popupInfor","animationTakeOff","SpaceRoot","dot","greenMark","_file"],["cc.SpriteFrame",["cc.Node",["_name","_layer","_id","_active","_objFlags","__editorExtras__","_components","_parent","_lpos","_children","_prefab","_lscale","_lrot","_euler"],-3,9,1,5,2,4,5,5,5],["cc.Widget",["_alignFlags","_bottom","_left","_top","_right","_originalWidth","_originalHeight","_enabled","node","__prefab","_target"],-5,1,4,1],"cc.ImageAsset","cc.Texture2D",["cc.Sprite",["_sizeMode","_type","_useGrayscale","_enabled","node","_spriteFrame","__prefab","_color","_customMaterial"],-1,1,6,4,5,6],["cc.Button",["_transition","node","_normalSprite","clickEvents","_target","_normalColor","_pressedColor","_pressedSprite","_disabledSprite","__prefab","_hoverSprite","_hoverColor"],2,1,6,9,1,5,5,6,6,4,6,5],["cc.Label",["_string","_actualFontSize","_isSystemFontUsed","_fontSize","_lineHeight","_enableWrapText","node","_font","_color","__prefab"],-3,1,6,5,4],["cc.Node",["_name","_layer","_objFlags","_active","_components","_parent","_lpos","_lscale","_lrot","_euler","_children","_prefab"],-1,12,1,5,5,5,5,2,4],["cc.UITransform",["_enabled","node","_contentSize","__prefab","_anchorPoint"],2,1,5,4,5],["cc.Node",["_name","_id","_layer","_lpos","_components","_parent","_children","_prefab","_lrot","_euler"],0,5,2,1,9,4,5,5],["cc.Camera",["_visibility","_clearFlags","_projection","_priority","_orthoHeight","_far","_fov","_name","_near","node","_color","_targetTexture"],-6,1,5,6],["cc.CurveRange",["mode","constantMax","constantMin","constant","spline"],-1,4],["cc.Animation",["playOnLoad","_enabled","node","_clips","__prefab","_defaultClip"],1,1,3,4,6],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedComponents","removedComponents","mountedChildren"],1,9,9,9,9],["cc.animation.AnimationTransition",["exitConditionEnabled","_exitCondition","from","to","conditions"],1,1,1,9],["cc.PrefabInfo",["fileId","targetOverrides","nestedPrefabInstanceRoots","root","asset"],1,2,1,1],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_skyColorLDR","_groundAlbedoHDR","_groundAlbedoLDR"],2,5,5,5,5],["cc.ClickEvent",["_componentId","handler","customEventData","target"],0,1],["cc.animation.AnimationController",["node","graph","__prefab"],3,1,6,4],["cc.PrefabInfo",["fileId","root","instance","asset","targetOverrides","nestedPrefabInstanceRoots"],2,1,4,6,9,2],["cc.PrefabInfo",["root","fileId","asset","instance"],1,6,4],["cc.Material",["_states","_defines","_techIdx","_props"],0,12],["cc.Canvas",["node","_cameraComponent","__prefab"],3,1,1,4],["cc.Scene",["_name","_children","_globals","_prefab"],2,2,4,4],["cc.ShadowsInfo",["_shadowColor","_size"],3,5,5],["cc.FogInfo",["_fogColor"],3,5],["CCPropertyOverrideInfo",["propertyPath","value","targetInfo"],1,4],["cc.DirectionalLight",["_shadowBias","_shadowNear","_shadowFar","_illuminanceHDR","node","_staticSettings"],-1,1,4],["cc.UIMeshRenderer",["node","__prefab"],3,1,4],["cc.ParticleSystem",["simulationSpeed","loop","node","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer","__prefab"],1,1,3,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4,4],["cc.RealKeyframeValue",["interpolationMode","value"],1],["cc.animation.Transition",["from","to","conditions"],3,1,1,9],["cc.animation.UnaryCondition",["operator","operand"],2,4],["cc.animation.ClipMotion",["clip"],3,6],["f0e95o3W7dJ96S58AIkkvr7",["node","hand","level1","forward","right","left","reset","play"],3,1,1,1,1,1,1,1,1],["e5f97gJCotIg5KKROnbV8Hv",["node","__prefab","BodyAnim"],3,1,4,1],["cc.SkeletalAnimation",["playOnLoad","_useBakedAnimation","node","__prefab","_clips","_defaultClip"],1,1,4,3,6],["cc.Layout",["_layoutType","_affectedByScale","_resizeMode","_spacingY","_constraint","_constraintNum","_spacingX","node","_cellSize"],-4,1,5],["cc.TargetOverrideInfo",["propertyPath","source","target","targetInfo","sourceInfo"],2,1,1,4,4],["cc.UIOpacity",["_opacity","node"],2,1],["RenderQueueDesc",["stages","isTransparent","sortMode"],0],"cc.RenderTexture",["cc.Prefab",["_name"],2],["cc.Node",["_name","_layer","_children","_prefab","_lpos"],1,12,4,5],["cc.Node",["_name","_parent","_children","_components","_lpos"],2,1,2,2,5],["cc.CompPrefabInfo",["fileId"],2],["cc.PrefabInfo",["root","fileId","asset"],1,1],["cc.Material",["_props","_defines"],1],["cc.SceneAsset",["_name"],2],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.SkyboxInfo",[],3],["cc.OctreeInfo",[],3],["9ab36EAispEAJ8YfKUC6onu",["node","backGroundNode","UIPhoto","mainMenu","renderTexture","material"],3,1,1,1,1,6,6],["cc.TargetInfo",["localID"],2],["cc.MeshRenderer",["_name","node","_materials","lightmapSettings","_mesh"],2,1,3,4,6],["cc.ModelLightmapSettings",[],3],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,4],["cc.StaticLightSettings",[],3],["9644eYkFL5FuILU9eVct36a",["velocity","node","mainCamera","sphere"],2,1,1,1],["81c1e0ogW9L6oGUwxVTpLNz",["node","BG","PopupRedirectCRM","PopupTutorial","PopupGotoCharacterSelection","UIButtonSwitchRocket","UIButtonSwitchAstronaut","UIButtonPlayCodeSpark","UIButtonPlaySpaceMission","TitleAstronaut","TitleRocketShip"],3,1,1,1,1,1,1,1,1,1,1,1],["cc.Mesh",["_native","_hash","_struct"],1,11],["b8f7aTWp5JPYru7bMkahJvM",["node","__prefab","active","deactive"],3,1,4,6,6],["cc.GradientRange",[],3],["cc.Burst",["_time","count"],2,4],["cc.ColorOvertimeModule",["color"],3,4],["cc.ShapeModule",["_enable","emitFrom","arcSpeed"],1,4],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.RealCurve",["_times","_values"],2,9],["cc.VelocityOvertimeModule",["_enable","x","y","z","speedModifier"],2,4,4,4,4],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.LimitVelocityOvertimeModule",["_enable","dampen","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.RotationOvertimeModule",["_enable","x","y","z"],2,4,4,4],["cc.TextureAnimationModule",["_enable","_numTilesX","_numTilesY","animation","cycleCount","randomRow","frameOverTime","startFrame"],-3,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.ParticleSystemRenderer",["_mainTexture"],3,6],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.animation.AnimationGraph",["_layers","_variables"],3,9,11],["cc.animation.Layer",["_stateMachine"],3,4],["cc.animation.StateMachine",["_states","_transitions","_entryState","_exitState","_anyState"],3,2,9,1,1,1],["cc.animation.BindableBoolean",["variable"],2],["cc.animation.PlainVariable",["_type","_value"],1],["cc.animation.State",["name"],2],["cc.animation.Motion",["name","motion"],2,4],["120b93sNg9C/ZO+YLW7bf23",["node","__prefab","rewardStar"],3,1,4,2],["55f924/599MK53Jc8cLiohB",["node","gameData"],3,1,1],["50d96NEdrdEGKO6GX3+Z0tk",["node"],3,1],["a378d5ME8BDQrgkyMJ6UCRj",["node","Popup_ParentControl"],3,1,1],["3f65eZnitpAD6auNMmWOlil",["node","soundBtn","uiSoundSF","uiSoundMuteSF"],3,1,1,6,6],["cc.AudioSource",["_loop","node","_clip"],2,1,6],["8c650vjfuRG0baJ8qlxoKw3",["node"],3,1],["75348tPWIlDzr3PoY+ONjZ9",["node","bgImage"],3,1,6],["d685ehurTFOH7JaMmy1FBTq",["node","betaInfo","versionLabel","uuidLabel"],3,1,1,1,1],["cc.TTFFont",["_name","_native"],1],["cc.Asset",["_name","_native"],1],["cc.SkinnedMeshRenderer",["node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],3,1,4,3,4,1,6,6],["2aba7MT17hBdIg/s6Nuvdoa",["moveSpeed","rotateSpeed","node","blocks","decors","tileMap","player","model","chest","levelText"],1,1,3,3,1,1,1,1,1],["5c3c5daSIVPLp7akyPQKmsk",["node","moveBlocks","stepMap","stepPlaceholder","playButton","retryButton","resetButton","winBanner","loseBanner","movePlaceholder"],3,1,3,1,1,1,1,1,1,1,6],["fa005GpvrNMuodvXTLCT6Hj",["node","player","chest","camera"],3,1,1,1,1],["f10f825x4RA447/cnjy5wGi",["node"],3,1],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,12],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,2],["03c54TEqAZNPo0U+wokUZO4",["node","transition","buttonBack","confetti","astronaut"],3,1,1,1,1,6],["cc.MountedChildrenInfo",["targetInfo","nodes"],3,4,2],["cc.Mask",["node"],3,1],["d5743jjF2lOrqeY0Z99ae2H",["node"],3,1],["cc.AudioClip",["_name","_native","_duration"],0],["4d25fRGQGBOiqPthThp6p10",["node","popupInfor","descriptionOfPopup","titleOfPopup","spritePlanet"],3,1,1,1,1,1],["cc.RigidBody2D",["enabledContactListener","_group","_gravityScale","_linearDamping","node"],-1,1],["cc.CircleCollider2D",["_group","_radius","node","_offset"],1,1,5],["0c2a2LXMMBA27nFfDY/LbVq",["plantID","speedRotate","radius","title","content","isRotate","node","btnInfor","planet"],-3,1,1,1],["1f176LxgRlMaJFkrj/SjnRc",["velocity","node","SpaceRoot","animationTakeOff","hand"],2,1,1,1,1],["96402PzfWNHRrA3Hd+ylco2",["rotateAroundSpeed","angleStart","node","planet"],1,1,1],["c38e2JYkGtP1qDJ7x5FRRvC",["radius","node","dot","ring"],2,1,1,1],["4feca++bj9EwrSxPqP0tqNM",["node","muteIcon"],3,1,1],["76c5cYEZsNOAqzu89WSDmJ3",["radian","speedRotate","node","spaceShip","arrow"],1,1,1,1],["cc.LabelOutline",["_enabled","_width","node"],1,1],["8b3d77xXOlI7rsKN7tWv2Ti",["node","tutorialPopup"],3,1,1],["881b86lxyRDDpfGQFnXZ5CX",["node"],3,1],["380f6dyS2xPnLp0wkyD9V9T",["useRigibody","fastSpeed","rotationSpeed","speedCamera","rotationAccelerationSpeed","animationFireEngine","node","camera","effectHited"],-3,1,1,1],["bfb9b+8QUNDK7Lzg3h7/VkO",["node","IntroNode","TransitionNode","animationTransitionScene"],3,1,1,1,1],["b491d52j71MA4AoD1SgwEOn",["currentPlanet","node","planets","spaceShip","greenMark"],2,1,2,1,6],["ff0a5TF8CFGpqYRNw8wxYXA",["timeShowTutorial","node","handTutorial"],2,1,1],["cc.ParticleSystem2D",["_name","emissionRate","life","lifeVar","angle","angleVar","startSizeVar","endSize","startSpin","endSpin","endSpinVar","speed","speedVar","tangentialAccel","autoRemoveOnFinish","_custom","_totalParticles","node","__prefab","posVar","gravity","_startColor","_startColorVar","_endColor","_endColorVar","_file","_spriteFrame"],-14,1,4,5,5,5,5,5,5,6,6],["ForwardPipeline",["_flows"],3,9],["ShadowFlow",["_name","_stages"],2,9],["ShadowStage",["_name"],2],["ForwardFlow",["_name","_priority","_stages"],1,9],["ForwardStage",["_name","renderQueues"],2,9]],[[46,0,2],[9,1,2,1],[54,0,2],[16,0,3,4,2],[58,0,1,2,2],[9,1,3,2,1],[57,0,1,2,3],[9,1,1],[1,0,1,7,6,8,3],[18,0,1,3,3],[5,0,4,5,2],[12,1],[5,4,5,1],[59,0,1,2,2],[1,0,1,7,6,10,8,11,3],[21,0,1,2,3],[5,1,0,4,5,3],[5,0,2,4,6,5,3],[43,0,2],[1,0,1,7,10,8,12,13,3],[1,0,1,7,9,10,8,12,13,3],[14,0,2,2],[12,3,2],[1,0,1,7,9,6,8,3],[1,0,1,7,6,8,11,3],[27,1,0,2,3],[20,0,1,2,3,2],[1,4,5,7,10,3],[10,0,2,5,6,7,3,8,9,3],[5,0,4,6,5,2],[87,0,1,2],[1,0,3,1,7,6,8,11,4],[5,4,6,5,1],[34,0,1],[1,0,1,7,9,6,3],[1,0,1,7,6,3],[84,0,2],[86,0,2],[1,0,1,6,10,8,11,3],[6,0,1,3,5,4,2,8,2],[39,0,1,4,2,3,2],[1,0,1,7,6,11,3],[18,1],[7,0,1,3,4,2,6,7,6],[33,1,1],[114,0,1,2,3,4,5,6,7,8,7],[9,1,3,2,4,1],[6,0,1,9,3,6,2,2],[7,0,1,6,9,3],[88,0,1,2,1],[1,0,1,7,9,6,8,11,3],[1,0,1,6,10,11,3],[1,0,1,7,9,6,10,8,11,3],[21,0,1,3,2,3],[6,0,1,3,5,4,2,10,7,8,2],[67,1],[1,0,1,9,6,8,3],[1,0,2,7,6,3],[6,0,1,3,5,4,2,2],[85,0,1,3],[1,0,1,7,6,8,12,11,13,3],[1,0,1,9,10,8,12,13,3],[7,0,1,3,4,2,6,8,7,6],[15,0,2,3,4,2],[1,0,1,2,9,6,8,4],[10,0,5,4,3,2],[47,0,1,2,3],[49,0,2],[50,0,1,2,3,4,1],[51,1],[52,1],[6,0,1,3,6,2,2],[56,1],[1,0,3,1,7,9,6,4],[1,0,4,1,7,6,4],[1,0,1,9,6,8,11,3],[23,0,1,1],[2,0,3,1,8,4],[24,0,1,3,2,2],[26,1],[6,1,3,2,1],[7,0,1,3,4,6,5],[61,0,1,2,2],[11,2,3,4,5,1,0,9,10,7],[31,0,2],[31,0,1,3],[81,0,1,1],[82,0,1],[83,0,1,2,3,4,1],[15,2,3,4,1],[1,0,3,1,9,6,4],[1,0,3,1,7,6,8,4],[1,0,2,7,6,8,3],[1,0,1,7,9,6,8,12,13,3],[1,0,1,7,9,6,11,3],[9,1,3,1],[5,4,7,5,1],[2,0,2,3,1,6,8,6],[2,7,0,2,8,10,4],[25,0,1],[6,1,9,2,1],[55,0,1,2,3,4,2],[7,0,1,3,4,5,2,6,8,7,7],[7,0,1,3,4,5,2,6,7,7],[66,0,1,2,3,1],[29,0,1,1],[32,0,1,1],[15,2,3,1],[19,0,2,1,1],[13,0,2,3,5,2],[116,0,1,2,3,3],[1,0,1,9,6,3],[1,0,4,1,7,6,8,12,13,4],[1,0,1,7,6,10,8,12,13,3],[1,0,1,7,9,10,12,13,3],[10,0,2,6,7,3,8,9,3],[8,0,2,1,5,4,6,4],[44,0,1,2,3,4,3],[9,0,1,3,2],[9,1,2,4,1],[20,0,4,5,2],[22,0,1,3,3],[23,0,2,1,1],[2,0,2,4,3,1,5,8,9,7],[2,0,4,1,8,4],[2,0,2,4,3,1,5,6,8,8],[2,0,1,8,3],[17,0,1,3,2,4,2],[17,1,3,1],[25,0,1,1],[6,0,1,3,2,2],[6,0,1,3,6,4,2,10,7,8,2],[7,0,1,2,6,8,7,4],[7,0,1,3,4,2,6,8,6],[14,0,1,3,2,4,3],[60,0,1,2,2],[62,1],[11,2,3,4,8,5,0,9,10,7],[12,0,2,1,4],[12,0,4,2],[12,0,1,3],[68,0,1,2],[69,0,1],[70,0,1,2,3],[71,0,1,2,3,4,2],[72,0,1,2],[73,0,1,2,3,4,2],[74,0,1,2,1],[75,0,1,2,3,4,5,3],[76,0,1,2,3,2],[77,0,1,2,3,4,5,6,7,7],[78,0,1,2,3,4,1],[79,0,1],[33,0,1,2],[34,1],[19,0,1],[99,0,1,2,3,4,5,6,1],[38,0,6,1,7,4],[39,0,1,2,3,2],[13,2,1],[40,0,1,2],[1,0,1,6,8,3],[1,0,7,9,6,8,2],[1,0,3,1,7,9,4],[1,0,3,1,7,6,4],[1,0,3,2,7,6,8,11,4],[1,0,3,1,2,7,6,8,12,11,13,5],[1,0,1,2,7,9,8,4],[1,0,2,7,6,12,13,3],[1,0,9,10,2],[1,0,1,6,10,8,3],[1,0,1,2,6,8,4],[1,0,1,2,7,6,4],[1,0,4,3,1,7,9,6,5],[1,0,2,7,9,6,3],[1,0,1,7,6,8,12,13,3],[1,0,1,6,3],[1,0,1,9,6,11,3],[1,4,5,10,3],[1,0,1,9,6,12,13,3],[1,0,1,7,9,6,8,12,11,13,3],[1,0,1,7,6,12,11,13,3],[1,0,1,9,6,10,3],[1,0,1,7,6,10,8,12,11,13,3],[1,0,1,9,6,10,11,3],[1,0,1,9,6,10,8,11,3],[1,0,2,6,3],[1,0,1,6,8,12,3],[1,0,1,2,7,6,8,4],[1,0,1,9,6,10,8,3],[1,0,1,7,6,10,8,3],[10,0,1,4,3],[10,0,1,5,4,3,3],[8,0,5,4,11,8,7,9,2],[8,0,1,5,4,6,8,9,3],[8,0,1,10,4,11,6,8,7,9,3],[8,0,1,5,4,6,8,7,9,3],[8,0,1,5,10,4,7,3],[8,0,3,1,5,10,4,4],[8,0,1,5,4,6,3],[8,0,1,5,4,6,7,3],[8,0,1,5,4,3],[45,0,1,2,3,4,2],[9,0,1,2,2],[5,0,4,6,7,5,2],[5,3,4,5,2],[5,0,4,8,5,2],[5,0,4,7,8,5,2],[5,4,8,5,1],[5,0,4,2],[16,0,2,2],[16,0,1,2,3],[22,2,0,1,3,4],[48,0,1,3],[2,0,2,3,1,6,8,9,6],[2,0,5,6,8,4],[2,7,0,1,8,4],[2,0,2,4,3,1,6,8,7],[2,0,2,4,3,5,8,6],[2,0,3,8,3],[2,0,2,4,1,5,8,6],[2,0,2,8,3],[2,0,4,8,3],[24,0,1,2,2],[17,0,1,2,2],[26,0,1],[6,1,9,3,2,1],[6,0,1,3,11,6,4,2],[6,0,1,3,5,4,2,7,2],[6,0,1,5,4,2,2],[18,0,1,2,3,4],[53,0,1,2,3,4,5,1],[7,0,1,4,2,6,8,7,5],[7,0,1,3,2,6,7,5],[7,0,1,3,4,6,8,5],[14,0,5,2,2],[14,0,1,2,3],[27,0,2,2],[28,0,1,2,4,5,4],[28,3,4,5,2],[11,6,1,0,9,4],[11,2,3,4,5,1,0,9,10,11,7],[11,7,0,9,10,11,3],[63,0,1,2,3,2],[64,0,1,2,3,4,5,6,7,8,9,10,1],[65,0,1,2,3],[29,0,1],[30,0,2,28,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2],[30,1,0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,3],[80,0,1,2,4],[32,0,1,2,1],[15,1,2,3,4,2],[89,0,1,1],[35,0,1,2,1],[35,0,3,4,5,6,7,1,1],[90,0,1],[91,0,1,1],[92,0,1,2,3,1],[93,0,1,2,2],[94,0,1],[95,0,1,1],[96,0,1,2,3,1],[97,0,1,3],[98,0,1,3],[19,0,1,1],[36,0,1,2,1],[36,0,1],[37,0,1,2,3,4,3],[37,0,2,3,4,5,2],[100,0,1,2,3,4,5,6,7,8,9,3],[101,0,1,2,3,4,5,6,7,8,9,1],[102,0,1,2,3,1],[103,0,1],[104,0,1,1],[105,0,1,1],[106,0,1,2,3,4,1],[107,0,1,1],[108,0,1],[38,2,0,3,4,5,1,7,8,7],[109,0,1],[13,2,4,3,1],[13,2,3,1],[13,1,0,2,4,3,5,3],[110,0,1,2,4],[111,0,1,2,3,4,1],[112,0,1,2,3,4,5],[113,0,1,2,3,3],[115,0,1,2,3,4,2],[117,0,1,2,3,2],[40,1,1],[118,0,1,1],[119,0,1,2,3,4,3],[120,0,1,2,3],[121,0,1,1],[122,0,1],[123,0,1,2,3,4,5,6,7,8,7],[124,0,1,2,3,1],[125,0,1,2,3,4,2],[126,0,1,2,2],[127,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,18],[128,0,1],[129,0,1,2],[130,0,2],[131,0,1,2,3],[132,0,1,2],[41,0,2],[41,1,2,0,4]],[[[{"name":"UI_Tutorial_Hands","rect":{"x":767,"y":1441,"width":110,"height":131},"offset":{"x":-2.5,"y":0},"originalSize":{"width":131,"height":131},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[[18,"HighBlock2"],[38,"HighBlock2",33554432,[[46,-2,[0,"49bYA2/55Dq5ZdUbVcinDu"],[5,194,223],[0,0.5,0.63]],[29,0,-3,[0,"7cnsn83uRBjZ+XkZ20FGoj"],0]],[3,"05z8C0jgpGp7qfE+HlFbUV",-1,0],[1,46.029999999999966,22.771699999999996,0],[1,0.38,0.38,0.402]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[78]],[[[121,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[30,26],[24,35]],[[{"name":"Switch_astronaut","rect":{"x":571,"y":1067,"width":172,"height":156},"offset":{"x":25.5,"y":-4},"originalSize":{"width":285,"height":218},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[[212,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[30,26],[36,79]],[[{"name":"Block-1","rect":{"x":216,"y":83,"width":73,"height":84},"offset":{"x":0,"y":0},"originalSize":{"width":73,"height":84},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[[67,"mainMenu"],[64,"Canvas",33554432,"a21pQl119Bb7AG+mipSq+H",[-5,-6,-7,-8,-9,-10,-11,-12],[[5,-1,[0,"0dngp/9gNO34wUQjZfN/CX"],[5,1080,1920]],[122,-3,[0,"3f2oTdCepERZdpmIfLsrhd"],-2],[123,45,-5.684341886080802e-14,-5.684341886080802e-14,1.1368683772161603e-13,1.1368683772161603e-13,960,-4,[0,"e8a+bU/8dPDbbJguUzLdoF"]]],[1,540,960.0000000000001,0]],[191,"MainMenu","6dw0ZL2mhECrg9lgRoEzDc",[-13]],[78,"mainMenu",[-15,-16,-17,-18,1,2,-19,-20,-21],[210,"0d539084-2feb-4111-a9cd-f5b28423e501",[-14]],[68,[224,0.78125,[2,0.2,0.5019607843137255,0.8,0.520833125],[2,0.2,0.5019607843137255,0.8,0.520833125]],[99,[4,4283190348]],[69],[225,[4,4292993505]],[70]]],[90,"PopupRedirectCRM",false,33554432,[-24,-25,-26,-27,-28,-29],[[1,-22,[5,950,600]],[10,0,-23,52]]],[90,"PopupGoToCharacterSelection",false,33554432,[-32,-33,-34],[[1,-30,[5,950,600]],[10,0,-31,31]]],[56,"UI_Btn_ChangeCharacter",33554432,[-39,-40],[[1,-35,[5,130,130]],[58,3,-37,[[9,"81c1e0ogW9L6oGUwxVTpLNz","switchCharacter",2]],[4,4292269782],-36,59],[10,0,-38,60]],[1,79.895,0.025,0]],[56,"UI_Btn_PlayMiniGame",33554432,[-45,-46],[[1,-41,[5,130,130]],[58,3,-43,[[9,"81c1e0ogW9L6oGUwxVTpLNz","playMiniGame",2]],[4,4292269782],-42,55],[10,0,-44,56]],[1,-73.614,0,0]],[23,"Cancel",33554432,5,[-51],[[1,-47,[5,150,100]],[16,1,0,-48,23],[58,3,-50,[[9,"81c1e0ogW9L6oGUwxVTpLNz","hidePopupGotoCharacterSelection",2]],[4,4292269782],-49,24]],[1,-200,-150,0]],[23,"OK",33554432,5,[-56],[[1,-52,[5,150,100]],[16,1,0,-53,26],[54,3,-55,[[9,"81c1e0ogW9L6oGUwxVTpLNz","gotoCharacterSelection",2]],[4,4292269782],-54,27,28,29,30]],[1,200,-150,0]],[23,"CRM",33554432,4,[-61],[[1,-57,[5,540,183]],[16,1,0,-58,41],[54,3,-60,[[9,"81c1e0ogW9L6oGUwxVTpLNz","popupRedirectCRMOnBtnCRMClick",2]],[4,4292269782],-59,42,43,44,45]],[1,0,-294.192,0]],[23,"Guilde",33554432,4,[-66],[[1,-62,[5,540,183]],[16,1,0,-63,47],[54,3,-65,[[9,"81c1e0ogW9L6oGUwxVTpLNz","popupRedirectCRMOnBtnGuideClick",2]],[4,4292269782],-64,48,49,50,51]],[1,0,-487.18,0]],[50,"UI_Btn_Icon_Gift",33554432,1,[-71],[[1,-67,[5,322,389]],[12,-68,69],[124,36,47.529000000000025,152.221,-69],[130,3,-70,[[9,"81c1e0ogW9L6oGUwxVTpLNz","showPopupRedirectCRM",2]],70]],[1,419.055,-719.087,0],[1,0.456,0.456,0.089]],[56,"Astronaut",33554432,[-74],[[1,-72,[5,450,120]],[10,0,-73,3]],[1,0,75,0]],[56,"RocketShip",33554432,[-77],[[1,-75,[5,450,120]],[10,0,-76,5]],[1,0,75,0]],[161,"UI_Btn_TakePhoto",33554432,[[1,-78,[5,177,177]],[16,1,0,-79,6],[54,3,-82,[[9,"9ab36EAispEAJ8YfKUC6onu","CaptureScreenShot",-81]],[4,4292269782],-80,62,63,64,65]],[1,0,-717.913,0]],[34,"Popup",33554432,1,[4,-84,5],[[7,-83]]],[73,"PopupTutorial",false,33554432,16,[-87],[[1,-85,[5,900,1800]],[10,0,-86,20]]],[8,"UI_Btn_Check",33554432,17,[[7,-88],[16,1,0,-89,15],[54,3,-91,[[9,"81c1e0ogW9L6oGUwxVTpLNz","hidePopupTutorial",2]],[4,4292269782],-90,16,17,18,19]],[1,0,-818.755,0]],[8,"Close",33554432,4,[[1,-92,[5,150,150]],[16,1,0,-93,35],[54,3,-95,[[9,"81c1e0ogW9L6oGUwxVTpLNz","hidePopupRedirectCRM",2]],[4,4292269782],-94,36,37,38,39]],[1,455.165,280.315,0]],[56,"UI_Btn_Redirect",33554432,[6,7],[[1,-96,[5,360,170]],[10,0,-97,57]],[1,0,-483.528,0]],[8,"UI_Btn_Back",33554432,1,[[1,-98,[5,150,150]],[10,0,-99,66],[97,9,69.92000000000002,100.08499999999998,416.80100000000004,278,-100],[130,3,-101,[[9,"81c1e0ogW9L6oGUwxVTpLNz","gotoCharacterSelection",2]],67]],[1,-395.08,784.915,0]],[23,"CharacterTitle",33554432,1,[13,14],[[7,-102]],[1,0,709.09,0]],[34,"MainGame",33554432,1,[15,20],[[7,-103]]],[162,"CapturenScreen",1,[-108],[[231,-107,-106,-105,-104,9,10]],[1,-540,-959.9999999999999,0]],[163,"GamePhoto",false,131072,24,[-109,-110]],[91,"Switch_rocket",false,33554432,6,[[1,-111,[5,110,130]],[10,0,-112,61]],[1,0,0.717,0]],[35,"Codespark",33554432,7,[[1,-113,[5,120,120]],[10,0,-114,53]]],[164,"SpaceMission",false,33554432,7,[[1,-115,[5,120,120]],[10,0,-116,54]]],[8,"Switch_astronaut",33554432,6,[[1,-117,[5,120,120]],[10,0,-118,58]],[1,0,-7.887,0]],[2,["60whtUc01AqKpk/+jyFPeB"]],[165,"Sphere",false,"05XKYMiUpFYoYCmvxroYbI",3,[[101,"Sphere<ModelComponent>",-119,[0],[72],1]],[1,0,0,1.189],[1,0.3,0.3,0.3]],[35,"Label",33554432,13,[[1,-120,[5,230.88,90.4]],[132,"宇航员\nAstronaut",40,false,-121,[4,4290867458],2]]],[35,"Label",33554432,14,[[1,-122,[5,265.44,90.4]],[132,"火箭飞船\nRocket Ship",40,false,-123,[4,4290867458],4]]],[8,"GameName",131072,25,[[1,-124,[5,244,174]],[12,-125,7]],[1,171.259,1793.031,0]],[8,"QRGame",131072,25,[[1,-126,[5,285,284]],[12,-127,8]],[1,906.009,199.196,0]],[166,"ImagBackGroundSceneCapture",false,262144,"e9iUBiiFtOHofoj6DL+89g",3,[[101,"Plane<ModelComponent>",-128,[11],[72],12]],[1,0,2.5,-25],[3,0.7071067811865475,0,0,0.7071067811865476],[1,3.42,1,6],[1,90,0,0]],[167,"PlaneBG",262144,"dc1iHEb3BFspVdZlmHFC87",3,[-129],[1,535.945,919.318,0]],[8,"Label-001",33554432,5,[[1,-130,[5,619.98,100.8]],[62,"我们再试试其他角色吧!",60,60,80,false,-131,[4,4290867458],21]],[1,0,66.61,0]],[74,"Label",512,33554432,8,[[1,-132,[5,50,75.6]],[102,"否",50,50,60,false,false,-133,[4,4290867458],22]]],[74,"Label",512,33554432,9,[[1,-134,[5,50,75.6]],[103,"是",50,50,60,false,false,-135,25]]],[91,"Label",false,33554432,4,[[1,-136,[5,900,126]],[62,"恭喜你和孩子解锁了动物新知识！",60,60,100,false,-137,[4,4290867458],32]],[1,0,188.727,0]],[8,"Label-001",33554432,4,[[1,-138,[5,630,180.8]],[62,"加入健达会员\n获取入会积分享好礼",70,70,80,false,-139,[4,4290867458],33]],[1,0,110.698,0]],[8,"Label-002",33554432,4,[[1,-140,[5,720,101.7]],[232,"会员积分及礼品兑换规则详见\n“健达福利社”微信小程序“会员规则”",40,45,false,-141,[4,4290867458],34]],[1,0,-127.668,0]],[74,"Label",512,33554432,10,[[1,-142,[5,300,75.6]],[103,"成为健达会员",50,50,60,false,false,-143,40]]],[74,"Label",512,33554432,11,[[1,-144,[5,400,75.6]],[103,"学习更多太空知识",50,50,60,false,false,-145,46]]],[27,0,{},12,[26,"60whtUc01AqKpk/+jyFPeB",-146,[21,"bbhlFTUIBE1IuppNEHt2ws",[[6,"Text_effect",["_name"],30],[4,["_lpos"],30,[1,0,0,0]],[4,["_lrot"],30,[3,0,0,0,1]],[4,["_euler"],30,[1,0,0,0]]]],68]],[92,"Main Light","c0y6F5f+pAvI805TdmxIjx",3,[[238,0.1,1,30,-147,[136]]],[1,0,0,220.15]],[192,"Main Camera","c9DMICJLFO5IeO07EPon7U",3,[-148],[1,0,2.911,12.371]],[240,65.985,6,1083441152,48],[168,"CharacterController","4cMZ2Lvr5FLL+9iP3vhLA0",3,[[243,5,-149,49,31]],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[65,"Camera",1,[-150],[1,0,0,1000]],[83,0,1073741824,960,2000,6,42598400,51,[4,4278190080]],[244,2,37,4,17,5,26,29,27,28,13,14],[60,"Plane",262144,37,[[101,"Plane<ModelComponent>",-151,[13],[72],14]],[1,-535.945,-909.318,-975.151],[3,0.7071067811865475,0,0,0.7071067811865476],[1,98,1,140],[1,90,0,0]],[8,"CaptureSceneCameraUI",33554432,1,[[241,0,1073741824,960,2000,6,131072,-152,[4,4278190080],71]],[1,0,0,1000]],[92,"CaptrueSceneCamera","f2TjsIy/ZMoqbIamMz5ZaQ",3,[[242,"Camera<CameraComponent>",1074003968,-153,[4,4286073907],72]],[1,0,2.911,12.371]]],0,[0,0,1,0,21,52,0,0,1,0,0,1,0,-1,22,0,-2,51,0,-3,23,0,-4,21,0,-5,12,0,-6,24,0,-7,16,0,-8,55,0,-1,53,0,-1,46,0,-1,47,0,-2,48,0,-3,31,0,-4,50,0,-7,36,0,-8,56,0,-9,37,0,0,4,0,0,4,0,-1,41,0,-2,42,0,-3,43,0,-4,19,0,-5,10,0,-6,11,0,0,5,0,0,5,0,-1,38,0,-2,8,0,-3,9,0,0,6,0,8,6,0,0,6,0,0,6,0,-1,29,0,-2,26,0,0,7,0,8,7,0,0,7,0,0,7,0,-1,27,0,-2,28,0,0,8,0,0,8,0,8,8,0,0,8,0,-1,39,0,0,9,0,0,9,0,8,9,0,0,9,0,-1,40,0,0,10,0,0,10,0,8,10,0,0,10,0,-1,44,0,0,11,0,0,11,0,8,11,0,0,11,0,-1,45,0,0,12,0,0,12,0,0,12,0,0,12,0,-1,46,0,0,13,0,0,13,0,-1,32,0,0,14,0,0,14,0,-1,33,0,0,15,0,0,15,0,8,15,0,12,24,0,0,15,0,0,16,0,-2,17,0,0,17,0,0,17,0,-1,18,0,0,18,0,0,18,0,8,18,0,0,18,0,0,19,0,0,19,0,8,19,0,0,19,0,0,20,0,0,20,0,0,21,0,0,21,0,0,21,0,0,21,0,0,22,0,0,23,0,41,53,0,42,25,0,43,36,0,0,24,0,-1,25,0,-1,34,0,-2,35,0,0,26,0,0,26,0,0,27,0,0,27,0,0,28,0,0,28,0,0,29,0,0,29,0,0,31,0,0,32,0,0,32,0,0,33,0,0,33,0,0,34,0,0,34,0,0,35,0,0,35,0,0,36,0,-1,54,0,0,38,0,0,38,0,0,39,0,0,39,0,0,40,0,0,40,0,0,41,0,0,41,0,0,42,0,0,42,0,0,43,0,0,43,0,0,44,0,0,44,0,0,45,0,0,45,0,7,46,0,0,47,0,-1,49,0,0,50,0,-1,52,0,0,54,0,0,55,0,0,56,0,23,3,1,4,3,2,4,3,4,4,16,5,4,16,6,4,20,7,4,20,13,4,22,14,4,22,15,4,23,20,4,23,153],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,24,9,1,9,1,1,1,1,44,45,-1,24,-1,24,1,6,18,16,11,1,9,9,1,6,9,1,6,18,16,11,1,9,9,9,1,6,18,16,11,9,1,6,18,16,11,9,1,6,18,16,11,1,1,1,6,1,1,1,6,1,1,6,18,16,11,1,6,5,1,6,35,35],[80,81,1,18,1,18,48,49,82,24,50,50,51,83,51,19,19,11,12,3,84,1,1,52,52,1,20,20,11,12,3,25,1,1,1,16,16,11,12,3,1,20,20,11,12,3,1,20,20,11,12,3,25,85,86,26,26,87,88,26,26,89,48,11,12,3,17,17,90,27,27,24,24]],[[{"name":"Codespark_UI_Counterclockwise_disabled","rect":{"x":87,"y":803,"width":78,"height":70},"offset":{"x":0,"y":-2},"originalSize":{"width":82,"height":82},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"name":"UI_icon_zoom","rect":{"x":761,"y":1849,"width":163,"height":170},"offset":{"x":0,"y":-0.5},"originalSize":{"width":167,"height":173},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[[245,".bin",3219909449,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[{"name":"Moon","rect":{"x":502,"y":680,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"fmt":"4_0","w":1018,"h":1226},-1],[3],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["14b7fcddf"]}],[4],0,[],[],[]],[[[18,"Codespark_UI_Clockwise_disabled"],[38,"Codespark_UI_Clockwise_disabled",33554432,[[5,-2,[0,"81o04iDt9G47qJhO5stujH"],[5,204,184]],[32,-3,[0,"0ef5Lh96pMfY4jmR2S3A9T"],0],[104,-4,[0,"91bmGdt7ZJWpDMZnx1F61V"],1,2]],[3,"9aK05CWJ9HA4ZP6sVT2w6u",-1,0],[1,-260.9663109871368,0,0],[1,0.4,0.4,0.414]]],0,[0,7,1,0,0,1,0,0,1,0,0,1,0,10,1,4],[0,0,0],[1,31,32],[53,37,53]],[[{"fmt":"4_0","w":748,"h":1017},-1],[3],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["153628710"]}],[4],0,[],[],[]],[[[18,"Particle_Confetti"],[169,"Particle_Confetti",[-2],[3,"02i9O3FHBBNq4cBFjrUBnI",-1,0]],[193,"Confetti",1,[[-3,[105,-4,[0,"7a+yucyQhA0rCCokiCBevt"]],[95,-5,[0,"5c+BoCJ29MO5Ub8AEbQVUr"]]],1,4,4],[3,"95i89SZW5PjYtr0wXfh3J8",1,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,100,100,100],[1,90,0,0]],[247,1.2,2,[0,"18NLOBC89MdYgPs3XeW7RQ"],[0],[55],[138,3,0.5,1.2],[11],[11],[22,6],[11],[11],[11],[11],[22,5],[22,0.2],[22,10],[11],[[141,1,[22,1]]],[142,[55]],[143,true,0,[22,1]],[144,true,[139,1,[145,[0.023076923076923078,0.1358974358974359,0.7256410256410256,0.9974358974358974],[[84,2],[85,2,1],[85,2,0.9962962962962963],[84,2]]]],[11],[11],[11]],[146,true,[22,1],[22,1],[11],[22,1.2]],[147,[11],[11],[11]],[148,true,0.2,[11],[11],[11],[11]],[149,true,[11],[11],[22,3.141592653589793]],[150,true,5,1,1,1,true,[11],[140,3,5]],[151,[22,1],[11],[55],[55],-6],[152,1]]],0,[0,7,1,0,-1,2,0,-1,3,0,0,2,0,0,2,0,36,3,0,10,1,6],[0,0],[-1,37],[54,36]],[[{"name":"UI_Btn_Back","rect":{"x":293,"y":874,"width":278,"height":272},"offset":{"x":-0.5,"y":0},"originalSize":{"width":283,"height":278},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"fmt":"4_0","w":314,"h":1020},-1],[3],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["1ba7066b6"]}],[4],0,[],[],[]],[[[249,"builtin-standard",[{"hash":4079105024,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":["HAS_SECOND_UV"]},{"name":"v_shadowBias","type":14,"count":1,"stageFlags":17,"location":7,"defines":["CC_RECEIVE_SHADOW"]},{"name":"v_tangent","type":16,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out lowp vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out mediump vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) in mediump vec2 v_uv1;\n#endif\nlayout(location = 4) in mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 2) in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) in mediump vec4 v_tangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nout vec3 v_position;\nout mediump vec3 v_normal;\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":223,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":3928335406,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":["HAS_SECOND_UV"]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) out vec2 v_uv1;\n#endif\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) in vec2 v_uv1;\n#endif\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out vec2 v_uv1;\n#endif\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in vec2 v_uv1;\n#endif\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":184,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[{"name":"Block-4","rect":{"x":216,"y":3,"width":74,"height":84},"offset":{"x":0,"y":0},"originalSize":{"width":74,"height":84},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"fmt":"4_0","w":935,"h":2047},-1],[3],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["1cfca5a3e"]}],[4],0,[],[],[]],[[{"name":"UI_btn_check_mark","rect":{"x":572,"y":3,"width":177,"height":173},"offset":{"x":0,"y":0},"originalSize":{"width":179,"height":175},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[15]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["20g1ukYUVPvKWKBRznAKo+"]}],[4],0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[0],0,[0],[3],[91]],[[[18,"Codespark_UI_forward_active 02"],[51,"Codespark_UI_forward_active 02",33554432,[[5,-2,[0,"46xKwuoh5Di5pfqmTV2jKh"],[5,204,187]],[32,-3,[0,"56PHbyUaZF8Yh8reHeZ0hH"],0],[100,-4,[0,"997y3IwBhGJ72D11OkCwwK"],1]],[3,"e9Yu+ETB5G7IfsauYyit8Q",-1,0],[1,1.763285024154589,1.763285024154589,0.5147826086956522]]],0,[0,7,1,0,0,1,0,0,1,0,0,1,0,10,1,4],[0,0],[1,6],[38,38]],[[[86,[[87,[88,[-12,-13,-14,-15,-16,-17,-18],[[106,-5,-4],[107,-7,-6],[89,-9,-8,[[44,[36,"onStop"]]]],[107,-11,-10]],-3,-2,-1]]],[{},"onStop",4,[59,1,false]]],[37,"Entry"],[30,"runStart",[33,0]],[30,"run",[33,1]],[30,"runEnd",[33,2]],[37,"Exit"],[37,"Any"],[30,"reward",[33,3]]],0,[0,27,6,0,28,5,0,29,1,0,13,2,0,14,1,0,13,3,0,14,2,0,13,4,0,14,3,0,13,7,0,14,4,0,-1,1,0,-2,5,0,-3,6,0,-4,2,0,-5,3,0,-6,4,0,-7,7,18],[0,0,0,0],[15,15,15,15],[28,29,30,21]],[[{"name":"Codespark_UI_forward_active 02","rect":{"x":790,"y":705,"width":203,"height":186},"offset":{"x":-0.5,"y":-3},"originalSize":{"width":216,"height":216},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"name":"UI_button_brown","rect":{"x":515,"y":479,"width":269,"height":269},"offset":{"x":0,"y":0},"originalSize":{"width":269,"height":269},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[[18,"HighBlock1"],[38,"HighBlock1",33554432,[[46,-2,[0,"63a5RCHrJEpqJxcxxcUw8e"],[5,194,223],[0,0.5,0.63]],[29,0,-3,[0,"ccJaQTmvtBprx07jW7JBLt"],0]],[3,"08sp1pWs5PH4V3K34CpewL",-1,0],[1,-17.99000000000003,22.771699999999996,0],[1,0.38,0.38,0.402]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[92]],[[{"name":"UI_btn_close","rect":{"x":571,"y":870,"width":191,"height":196},"offset":{"x":0,"y":0},"originalSize":{"width":197,"height":202},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"name":"Codespark_UI_Retry","rect":{"x":552,"y":1493,"width":150,"height":155},"offset":{"x":-1,"y":0.5},"originalSize":{"width":216,"height":216},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["3a9/qT2f1P+bzyCiQbDXdz"]}],[4],0,[],[],[]],[[{"name":"spaceship_hit_01","rect":{"x":0,"y":0,"width":287,"height":402},"offset":{"x":0,"y":0},"originalSize":{"width":287,"height":402},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[93]],[[{"name":"UI_Button_Blue","rect":{"x":331,"y":479,"width":370,"height":178},"offset":{"x":-0.5,"y":-0.5},"originalSize":{"width":375,"height":183},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"name":"Saturn","rect":{"x":502,"y":986,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"name":"Codespark_UI_Clockwise_disabled","rect":{"x":3,"y":871,"width":78,"height":70},"offset":{"x":0,"y":-2},"originalSize":{"width":82,"height":82},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"base":"2,2,0,0,0,0","w":1440,"h":2048,"n":""}],[42],0,[],[],[]],[[{"name":"Astronaut","rect":{"x":274,"y":3,"width":292,"height":501},"offset":{"x":1,"y":-1},"originalSize":{"width":300,"height":507},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[15]],[[{"name":"UI_Book_Cover_Merge","rect":{"x":3,"y":1289,"width":650,"height":480},"offset":{"x":0,"y":0},"originalSize":{"width":650,"height":480},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[[18,"Decor-1"],[51,"Decor-1",33554432,[[5,-2,[0,"c5JBKj1BlNhJEnYpQ/FR1H"],[5,130,142]],[32,-3,[0,"85EiHME+xNGLRYR5yWU8XA"],0]],[3,"71bKPEB5tNarHqByop/5le",-1,0],[1,1,1.01,0.3376799999999999]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[94]],[[{"name":"Sun","rect":{"x":3,"y":3,"width":600,"height":600},"offset":{"x":0,"y":0},"originalSize":{"width":600,"height":600},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"name":"UI_MM_Arrow 1","rect":{"x":1305,"y":1047,"width":292,"height":423},"offset":{"x":0,"y":0},"originalSize":{"width":512,"height":431},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[{"name":"Decor-4","rect":{"x":3,"y":473,"width":162,"height":156},"offset":{"x":-0.5,"y":-1},"originalSize":{"width":165,"height":158},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"name":"Ground","rect":{"x":409,"y":3,"width":1091,"height":514},"offset":{"x":0,"y":-135.5},"originalSize":{"width":1091,"height":785},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["54TknWPwVPqJqeCR+Y/Czo"]}],[4],0,[],[],[]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[0],0,[0],[3],[95]],[[[18,"Codespark_UI_active (2)"],[38,"Codespark_UI_active (2)",33554432,[[5,-2,[0,"0bI/ksMuVJgL6c9nuhWdyb"],[5,204,184]],[204,0,-3,[0,"2amfSkRNREfafUbixN7KTQ"],[4,2231369727],0]],[3,"26ZufsGQBIPorRRH/5QSLT",-1,0],[1,-260.9663109871368,0,0],[1,0.4,0.4,1]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[96]],[[{"name":"Decor-2","rect":{"x":3,"y":350,"width":117,"height":172},"offset":{"x":0,"y":-1},"originalSize":{"width":121,"height":174},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"name":"Chest","rect":{"x":3,"y":3,"width":171,"height":207},"offset":{"x":-0.5,"y":0},"originalSize":{"width":174,"height":209},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["58xh3Ml11LO6N5+l2Db8tW"]}],[4],0,[],[],[]],[[{"name":"Sparkle","rect":{"x":0,"y":0,"width":128,"height":128},"offset":{"x":0,"y":0},"originalSize":{"width":128,"height":128},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[97]],[[{"name":"Codespark_UI_forward_disabled 02","rect":{"x":87,"y":879,"width":77,"height":70},"offset":{"x":-0.5,"y":-2},"originalSize":{"width":82,"height":82},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"name":"Mercury","rect":{"x":3,"y":1091,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[[86,[[87,[88,[-16,-17,-18,-19,-20,-21,-22,-23],[[250,-5,-4,[[44,[36,"onStart"]]]],[63,false,-7,-6,[[44,[36,"isMoving"]]]],[107,-9,-8],[63,false,-11,-10,[[153,1,[36,"isMoving"]]]],[89,-13,-12,[[153,1,[36,"win"]]]],[89,-15,-14,[[44,[36,"win"]]]]],-3,-2,-1]]],[{},"isMoving",4,[59,1,false],"onStart",4,[59,1,true],"win",4,[59,1,false]]],[30,"Idle",[33,0]],[30,"runEnd",[33,3]],[37,"Entry"],[30,"runStart",[33,1]],[30,"run",[33,2]],[37,"Exit"],[37,"Any"],[30,"reward",[33,4]]],0,[0,27,7,0,28,6,0,29,3,0,13,1,0,14,3,0,13,4,0,14,1,0,13,5,0,14,4,0,13,2,0,14,5,0,13,1,0,14,2,0,13,8,0,14,2,0,-1,3,0,-2,6,0,-3,7,0,-4,1,0,-5,4,0,-6,5,0,-7,2,0,-8,8,23],[0,0,0,0,0],[15,15,15,15,15],[55,28,29,30,21]],[[{"name":"Block-2","rect":{"x":216,"y":162,"width":73,"height":84},"offset":{"x":0,"y":0},"originalSize":{"width":73,"height":84},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"name":"Tutotial_download_space","rect":{"x":3,"y":3,"width":470,"height":931},"offset":{"x":0.5,"y":-1},"originalSize":{"width":473,"height":933},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"name":"Codespark_UI_Stop","rect":{"x":1636,"y":1451,"width":192,"height":199},"offset":{"x":0,"y":0.5},"originalSize":{"width":216,"height":216},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[{"name":"Codespark_UI_active (2)","rect":{"x":3,"y":947,"width":77,"height":70},"offset":{"x":0.5,"y":0},"originalSize":{"width":82,"height":82},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"name":"UI_MM_Icon_Space_Mission","rect":{"x":790,"y":479,"width":225,"height":220},"offset":{"x":-0.5,"y":0},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"name":"Earth","rect":{"x":309,"y":1292,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[[18,"Decor-5"],[51,"Decor-5",33554432,[[5,-2,[0,"53v1BNDbFGMJe/S+6XCmbq"],[5,164,177]],[32,-3,[0,"ebC6L2ttVMJ6HPDlvo/FlJ"],0]],[3,"e76wNHAzJETLVFYXuNh4+N",-1,0],[1,1,1.01,0.3376799999999999]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[98]],[[[18,"UI_Tutorial_Hands"],[38,"UI_Tutorial_Hands",33554432,[[46,-2,[0,"8dhrEPngBGRKH8Sy7sQm7y"],[5,110,131],[0,0,1]],[32,-3,[0,"66yU0ZiXtK8qYTRtuMQaNL"],0]],[3,"d8U4lD0QtChYN/bnd/uMHI",-1,0],[1,-288.89,-433.013,0],[1,1,1,0.5169999999999998]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[39]],[[{"name":"UI_Natoons_Book_Light Yellow Bar","rect":{"x":1636,"y":729,"width":716,"height":258},"offset":{"x":0.5,"y":0},"originalSize":{"width":721,"height":262},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[{"name":"UI_Toy_Collection_leftside_bar_slot","rect":{"x":1257,"y":1493,"width":383,"height":373},"offset":{"x":-8.5,"y":0.5},"originalSize":{"width":408,"height":382},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[[18,"Codespark_UI_forward_disabled 02"],[38,"Codespark_UI_forward_disabled 02",33554432,[[5,-2,[0,"c5r0oTeQ9HaJoZzU5RyBwH"],[5,204,184]],[32,-3,[0,"f4bLJtmk9Mr5TaSV3hGZm3"],0],[104,-4,[0,"06D3aONHVAP41LpTHPIgZM"],1,2]],[3,"a7zCgp615IKIJ+zPjtN26X",-1,0],[1,-129.76631098713676,0,0],[1,0.4,0.4,0.414]]],0,[0,7,1,0,0,1,0,0,1,0,0,1,0,10,1,4],[0,0,0],[1,31,32],[56,38,56]],[[{"name":"Mute","rect":{"x":572,"y":341,"width":141,"height":148},"offset":{"x":0,"y":0},"originalSize":{"width":145,"height":150},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[15]],[[[18,"UI_Btn_Home"],[170,"UI_Btn_Home",33554432,[[5,-2,[0,"68pBYAfRRCALiNAjlsy+KZ"],[5,283,278]],[32,-3,[0,"687+aE6URPRK/l0Ma9PO8C"],0],[214,9,48.66949999999994,31.0030000000001,416.80100000000004,278,-4,[0,"cdcV4xTs5Ed4CiARrPYjrs"]],[226,-5,[0,"af0rxx/jFNdImRVBbg4mBs"],[[42]],1]],[3,"5btj7rBsVNc6CFukgbbz0m",-1,0],[1,-807.9820711645101,1604.48868207024,0]]],0,[0,7,1,0,0,1,0,0,1,0,0,1,0,0,1,0,10,1,5],[0,0],[1,6],[17,17]],[[[18,"Treasure"],[38,"Treasure",33554432,[[46,-2,[0,"c0VSg60wxHZKXaeskLcEZH"],[5,172,207],[0,0.5,0.35]],[32,-3,[0,"19GLDOwkdHrJQdmTDl0/jm"],0]],[3,"106eX7MB9HSaqL11I0Gh9T",-1,0],[1,-227.484,266.279,0],[1,0.35,0.35,0.323]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[99]],[[{"name":"UI_Virtual_Joystick_Background","rect":{"x":282,"y":1775,"width":249,"height":249},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["7dj5uJT9FMn6OrOOx83tfK"]}],[4],0,[],[],[]],[[{"name":"default_sprite_splash","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[100]],[[{"name":"Codespark_UI_Panel_02","rect":{"x":227,"y":1670,"width":1024,"height":228},"offset":{"x":0,"y":0},"originalSize":{"width":1024,"height":228},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[{"name":"BTN-white","rect":{"x":773,"y":897,"width":241,"height":144},"offset":{"x":0,"y":0},"originalSize":{"width":241,"height":144},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"name":"Uranus","rect":{"x":3,"y":1397,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"name":"Decor-1","rect":{"x":181,"y":420,"width":130,"height":142},"offset":{"x":-0.5,"y":-1},"originalSize":{"width":133,"height":144},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[[67,"planetExplore"],[111,"Path",33554432,[-3,-4,-5,-6,-7,-8,-9,-10],[[1,-1,[5,547,1665]],[10,0,-2,81]]],[52,"Codespark_UI_Level_Select_Button_Blank",33554432,1,[-22,-23,-24,-25],[[5,-15,[0,"37vZ4V7xZLxqy7bSRex6IP"],[5,221,231]],[29,0,-16,[0,"10v/Rih7dBUqyK0wIwuZ/D"],8],[47,1,-17,[0,"82FgLQ8UVIYLrUE170sm0V"],[[42]],[4,4288059030],9],[49,-21,[0,"2e163afOxKpokONOeI0W7q"],[-18,-19,-20]]],[53,null,"66KViboYhNvZM50LXbDcUO",[21,"92ni0QH69Bapx17tenqmJ+",[[6,"Codespark_UI_Level_Select_Button_Blank",["_name"],-11],[4,["_lpos"],-12,[1,78.669,-790.341,0]],[4,["_lrot"],-13,[3,0,0,0,1]],[4,["_euler"],-14,[1,0,0,0]]]],10],[1,78.669,-790.341,0],[1,0.647,0.647,0.277]],[52,"Codespark_UI_Level_Select_Button_Blank-001",33554432,1,[-37,-38,-39,-40],[[5,-30,[0,"37vZ4V7xZLxqy7bSRex6IP"],[5,221,231]],[29,0,-31,[0,"10v/Rih7dBUqyK0wIwuZ/D"],18],[47,1,-32,[0,"82FgLQ8UVIYLrUE170sm0V"],[[42]],[4,4288059030],19],[49,-36,[0,"2e163afOxKpokONOeI0W7q"],[-33,-34,-35]]],[53,null,"66KViboYhNvZM50LXbDcUO",[21,"c22QDPu0lEqbLay3uc+HqI",[[6,"Codespark_UI_Level_Select_Button_Blank-001",["_name"],-26],[4,["_lpos"],-27,[1,-227.158,-523.438,0]],[4,["_lrot"],-28,[3,0,0,0,1]],[4,["_euler"],-29,[1,0,0,0]]]],20],[1,-227.158,-523.438,0],[1,0.647,0.647,0.277]],[52,"Codespark_UI_Level_Select_Button_Blank-002",33554432,1,[-56,-57,-58,-59],[[5,-49,[0,"37vZ4V7xZLxqy7bSRex6IP"],[5,221,231]],[29,0,-50,[0,"10v/Rih7dBUqyK0wIwuZ/D"],28],[47,1,-51,[0,"82FgLQ8UVIYLrUE170sm0V"],[[42]],[4,4288059030],29],[49,-55,[0,"2e163afOxKpokONOeI0W7q"],[-52,-53,-54]]],[53,null,"66KViboYhNvZM50LXbDcUO",[21,"0aV2NxmxhBNrokvWfvEY+S",[[6,"Codespark_UI_Level_Select_Button_Blank-002",["_name"],-41],[4,["_lpos"],-42,[1,39.228,-336.67,0]],[4,["_lrot"],-43,[3,0,0,0,1]],[4,["_euler"],-44,[1,0,0,0]],[6,33554432,["_layer"],-45],[6,"levelNumber",["_name"],-46],[4,["_lpos"],-47,[1,-5.683,2.525,0]],[4,["_lscale"],-48,[1,2.279,2.279,2.279]]]],30],[1,39.228,-336.67,0],[1,0.647,0.647,0.277]],[52,"Codespark_UI_Level_Select_Button_Blank-003",33554432,1,[-75,-76,-77,-78],[[5,-68,[0,"37vZ4V7xZLxqy7bSRex6IP"],[5,221,231]],[29,0,-69,[0,"10v/Rih7dBUqyK0wIwuZ/D"],38],[47,1,-70,[0,"82FgLQ8UVIYLrUE170sm0V"],[[42]],[4,4288059030],39],[49,-74,[0,"2e163afOxKpokONOeI0W7q"],[-71,-72,-73]]],[53,null,"66KViboYhNvZM50LXbDcUO",[21,"efN5FfsgRDt5fZjVBTPQRx",[[6,"Codespark_UI_Level_Select_Button_Blank-003",["_name"],-60],[4,["_lpos"],-61,[1,-66.805,-69.544,0]],[4,["_lrot"],-62,[3,0,0,0,1]],[4,["_euler"],-63,[1,0,0,0]],[6,33554432,["_layer"],-64],[6,"levelNumber",["_name"],-65],[4,["_lpos"],-66,[1,-5.683,2.525,0]],[4,["_lscale"],-67,[1,2.279,2.279,2.279]]]],40],[1,-66.805,-69.544,0],[1,0.647,0.647,0.277]],[52,"Codespark_UI_Level_Select_Button_Blank-004",33554432,1,[-86,-87,-88,-89],[[5,-79,[0,"37vZ4V7xZLxqy7bSRex6IP"],[5,221,231]],[29,0,-80,[0,"10v/Rih7dBUqyK0wIwuZ/D"],48],[47,1,-81,[0,"82FgLQ8UVIYLrUE170sm0V"],[[42]],[4,4288059030],49],[49,-85,[0,"2e163afOxKpokONOeI0W7q"],[-82,-83,-84]]],[53,null,"66KViboYhNvZM50LXbDcUO",[21,"45KrfFRnlGpbhL1dGZh47G",[[25,"Codespark_UI_Level_Select_Button_Blank-004",["_name"],[2,["66KViboYhNvZM50LXbDcUO"]]],[13,["_lpos"],[2,["66KViboYhNvZM50LXbDcUO"]],[1,-110.206,204.611,0]],[13,["_lrot"],[2,["66KViboYhNvZM50LXbDcUO"]],[3,0,0,0,1]],[13,["_euler"],[2,["66KViboYhNvZM50LXbDcUO"]],[1,0,0,0]],[25,33554432,["_layer"],[2,["66KViboYhNvZM50LXbDcUO"]]],[25,"levelNumber",["_name"],[2,["baNUBJVU5BkIFeNBFNd2Se"]]],[13,["_lpos"],[2,["baNUBJVU5BkIFeNBFNd2Se"]],[1,-5.683,2.525,0]],[13,["_lscale"],[2,["baNUBJVU5BkIFeNBFNd2Se"]],[1,2.279,2.279,2.279]]]],50],[1,-110.206,204.611,0],[1,0.647,0.647,0.277]],[52,"Codespark_UI_Level_Select_Button_Blank-005",33554432,1,[-105,-106,-107,-108],[[5,-98,[0,"37vZ4V7xZLxqy7bSRex6IP"],[5,221,231]],[29,0,-99,[0,"10v/Rih7dBUqyK0wIwuZ/D"],58],[47,1,-100,[0,"82FgLQ8UVIYLrUE170sm0V"],[[42]],[4,4288059030],59],[49,-104,[0,"2e163afOxKpokONOeI0W7q"],[-101,-102,-103]]],[53,null,"66KViboYhNvZM50LXbDcUO",[21,"cdSgZ9e2tMtrMkw47QZq4k",[[6,"Codespark_UI_Level_Select_Button_Blank-005",["_name"],-90],[4,["_lpos"],-91,[1,205.977,357.266,0]],[4,["_lrot"],-92,[3,0,0,0,1]],[4,["_euler"],-93,[1,0,0,0]],[6,33554432,["_layer"],-94],[6,"levelNumber",["_name"],-95],[4,["_lpos"],-96,[1,-5.683,2.525,0]],[4,["_lscale"],-97,[1,2.279,2.279,2.279]]]],60],[1,205.977,357.266,0],[1,0.647,0.647,0.277]],[52,"Codespark_UI_Level_Select_Button_Blank-006",33554432,1,[-124,-125,-126,-127],[[5,-117,[0,"37vZ4V7xZLxqy7bSRex6IP"],[5,221,231]],[29,0,-118,[0,"10v/Rih7dBUqyK0wIwuZ/D"],68],[47,1,-119,[0,"82FgLQ8UVIYLrUE170sm0V"],[[42]],[4,4288059030],69],[49,-123,[0,"2e163afOxKpokONOeI0W7q"],[-120,-121,-122]]],[53,null,"66KViboYhNvZM50LXbDcUO",[21,"74I2IwABlJ2rkSJEWnTwkk",[[6,"Codespark_UI_Level_Select_Button_Blank-006",["_name"],-109],[4,["_lpos"],-110,[1,157.846,695.02,0]],[4,["_lrot"],-111,[3,0,0,0,1]],[4,["_euler"],-112,[1,0,0,0]],[6,33554432,["_layer"],-113],[6,"levelNumber",["_name"],-114],[4,["_lpos"],-115,[1,-5.683,2.525,0]],[4,["_lscale"],-116,[1,2.279,2.279,2.279]]]],70],[1,157.846,695.02,0],[1,0.647,0.647,0.277]],[52,"Codespark_UI_Level_Select_Button_Blank-007",33554432,1,[-143,-144,-145,-146],[[5,-136,[0,"37vZ4V7xZLxqy7bSRex6IP"],[5,221,231]],[29,0,-137,[0,"10v/Rih7dBUqyK0wIwuZ/D"],78],[47,1,-138,[0,"82FgLQ8UVIYLrUE170sm0V"],[[42]],[4,4288059030],79],[49,-142,[0,"2e163afOxKpokONOeI0W7q"],[-139,-140,-141]]],[53,null,"66KViboYhNvZM50LXbDcUO",[21,"2ajydCZSlKH4Uy+IT8z/3B",[[6,"Codespark_UI_Level_Select_Button_Blank-007",["_name"],-128],[4,["_lpos"],-129,[1,-168.143,789.589,0]],[4,["_lrot"],-130,[3,0,0,0,1]],[4,["_euler"],-131,[1,0,0,0]],[6,33554432,["_layer"],-132],[6,"levelNumber",["_name"],-133],[4,["_lpos"],-134,[1,-5.683,2.525,0]],[4,["_lscale"],-135,[1,2.279,2.279,2.279]]]],80],[1,-168.143,789.589,0],[1,0.647,0.647,0.277]],[64,"Canvas",33554432,"27/XVgq4NNM4V2Yq0DH+IA",[-151,-152,-153,-154],[[1,-147,[5,1080,1920]],[76,-149,-148],[77,45,-1.1368683772161603e-13,-1.1368683772161603e-13,-150]],[1,540,959.9999999999999,0]],[34,"LevelSelect",33554432,10,[1,-159],[[252,-156,-155],[253,-158,-157,2]]],[2,["66KViboYhNvZM50LXbDcUO"]],[2,["66KViboYhNvZM50LXbDcUO"]],[2,["66KViboYhNvZM50LXbDcUO"]],[2,["66KViboYhNvZM50LXbDcUO"]],[2,["66KViboYhNvZM50LXbDcUO"]],[171,"GameData",33554432,"27IoU3t0RGlq9gg4x3fDfb",[[7,-160],[255,-161]],[1,540,960,0]],[2,["5btj7rBsVNc6CFukgbbz0m"]],[2,["af0rxx/jFNdImRVBbg4mBs"]],[35,"BG-Select-Level",33554432,10,[[1,-162,[5,1480,2320]],[10,0,-163,0],[125,45,-200,-200,-200,-200,1080,1920,-164]]],[14,"Reward_star",33554432,2,[[5,-165,[0,"89ROzgf8pB9ZxebackmmE4"],[5,240,215]],[17,0,true,-166,[0,"06ZLbFSElLfbNaJ+7HF6FF"],2]],[15,null,"549ZAEI3dCj7jnSIbx+N3l",3],[1,92.59,67.584,0],[1,0.372,0.372,0.372]],[14,"Reward_star-001",33554432,2,[[5,-167,[0,"baGwbpwEdNsKkKMe1pvtSq"],[5,240,215]],[17,0,true,-168,[0,"d7vJkJPrtAMooU4vSfGQ44"],4]],[15,null,"d6l2vTfRRHYI703T6FdsBR",5],[1,-93.425,67.442,0],[1,0.372,0.372,0.372]],[14,"Reward_star-002",33554432,2,[[5,-169,[0,"1d7fFdQ6ZJCLntXjwMnFkW"],[5,240,215]],[17,0,true,-170,[0,"62DADpX01MebwyIb4IADv6"],6]],[15,null,"19Ud4sUg9G/5tX74YauyMW",7],[1,-1.022,119.028,0],[1,0.372,0.372,0.372]],[2,["66KViboYhNvZM50LXbDcUO"]],[14,"Reward_star",33554432,3,[[5,-171,[0,"89ROzgf8pB9ZxebackmmE4"],[5,240,215]],[17,0,true,-172,[0,"06ZLbFSElLfbNaJ+7HF6FF"],12]],[15,null,"549ZAEI3dCj7jnSIbx+N3l",13],[1,92.59,67.584,0],[1,0.372,0.372,0.372]],[14,"Reward_star-001",33554432,3,[[5,-173,[0,"baGwbpwEdNsKkKMe1pvtSq"],[5,240,215]],[17,0,true,-174,[0,"d7vJkJPrtAMooU4vSfGQ44"],14]],[15,null,"d6l2vTfRRHYI703T6FdsBR",15],[1,-93.425,67.442,0],[1,0.372,0.372,0.372]],[14,"Reward_star-002",33554432,3,[[5,-175,[0,"1d7fFdQ6ZJCLntXjwMnFkW"],[5,240,215]],[17,0,true,-176,[0,"62DADpX01MebwyIb4IADv6"],16]],[15,null,"19Ud4sUg9G/5tX74YauyMW",17],[1,-1.022,119.028,0],[1,0.372,0.372,0.372]],[2,["66KViboYhNvZM50LXbDcUO"]],[14,"Reward_star",33554432,4,[[5,-177,[0,"89ROzgf8pB9ZxebackmmE4"],[5,240,215]],[17,0,true,-178,[0,"06ZLbFSElLfbNaJ+7HF6FF"],22]],[15,null,"549ZAEI3dCj7jnSIbx+N3l",23],[1,92.59,67.584,0],[1,0.372,0.372,0.372]],[14,"Reward_star-001",33554432,4,[[5,-179,[0,"baGwbpwEdNsKkKMe1pvtSq"],[5,240,215]],[17,0,true,-180,[0,"d7vJkJPrtAMooU4vSfGQ44"],24]],[15,null,"d6l2vTfRRHYI703T6FdsBR",25],[1,-93.425,67.442,0],[1,0.372,0.372,0.372]],[14,"Reward_star-002",33554432,4,[[5,-181,[0,"1d7fFdQ6ZJCLntXjwMnFkW"],[5,240,215]],[17,0,true,-182,[0,"62DADpX01MebwyIb4IADv6"],26]],[15,null,"19Ud4sUg9G/5tX74YauyMW",27],[1,-1.022,119.028,0],[1,0.372,0.372,0.372]],[14,"Reward_star",33554432,5,[[5,-183,[0,"89ROzgf8pB9ZxebackmmE4"],[5,240,215]],[17,0,true,-184,[0,"06ZLbFSElLfbNaJ+7HF6FF"],32]],[15,null,"549ZAEI3dCj7jnSIbx+N3l",33],[1,92.59,67.584,0],[1,0.372,0.372,0.372]],[14,"Reward_star-001",33554432,5,[[5,-185,[0,"baGwbpwEdNsKkKMe1pvtSq"],[5,240,215]],[17,0,true,-186,[0,"d7vJkJPrtAMooU4vSfGQ44"],34]],[15,null,"d6l2vTfRRHYI703T6FdsBR",35],[1,-93.425,67.442,0],[1,0.372,0.372,0.372]],[14,"Reward_star-002",33554432,5,[[5,-187,[0,"1d7fFdQ6ZJCLntXjwMnFkW"],[5,240,215]],[17,0,true,-188,[0,"62DADpX01MebwyIb4IADv6"],36]],[15,null,"19Ud4sUg9G/5tX74YauyMW",37],[1,-1.022,119.028,0],[1,0.372,0.372,0.372]],[14,"Reward_star",33554432,6,[[5,-189,[0,"89ROzgf8pB9ZxebackmmE4"],[5,240,215]],[17,0,true,-190,[0,"06ZLbFSElLfbNaJ+7HF6FF"],42]],[15,null,"549ZAEI3dCj7jnSIbx+N3l",43],[1,92.59,67.584,0],[1,0.372,0.372,0.372]],[14,"Reward_star-001",33554432,6,[[5,-191,[0,"baGwbpwEdNsKkKMe1pvtSq"],[5,240,215]],[17,0,true,-192,[0,"d7vJkJPrtAMooU4vSfGQ44"],44]],[15,null,"d6l2vTfRRHYI703T6FdsBR",45],[1,-93.425,67.442,0],[1,0.372,0.372,0.372]],[14,"Reward_star-002",33554432,6,[[5,-193,[0,"1d7fFdQ6ZJCLntXjwMnFkW"],[5,240,215]],[17,0,true,-194,[0,"62DADpX01MebwyIb4IADv6"],46]],[15,null,"19Ud4sUg9G/5tX74YauyMW",47],[1,-1.022,119.028,0],[1,0.372,0.372,0.372]],[14,"Reward_star",33554432,7,[[5,-195,[0,"89ROzgf8pB9ZxebackmmE4"],[5,240,215]],[17,0,true,-196,[0,"06ZLbFSElLfbNaJ+7HF6FF"],52]],[15,null,"549ZAEI3dCj7jnSIbx+N3l",53],[1,92.59,67.584,0],[1,0.372,0.372,0.372]],[14,"Reward_star-001",33554432,7,[[5,-197,[0,"baGwbpwEdNsKkKMe1pvtSq"],[5,240,215]],[17,0,true,-198,[0,"d7vJkJPrtAMooU4vSfGQ44"],54]],[15,null,"d6l2vTfRRHYI703T6FdsBR",55],[1,-93.425,67.442,0],[1,0.372,0.372,0.372]],[14,"Reward_star-002",33554432,7,[[5,-199,[0,"1d7fFdQ6ZJCLntXjwMnFkW"],[5,240,215]],[17,0,true,-200,[0,"62DADpX01MebwyIb4IADv6"],56]],[15,null,"19Ud4sUg9G/5tX74YauyMW",57],[1,-1.022,119.028,0],[1,0.372,0.372,0.372]],[14,"Reward_star",33554432,8,[[5,-201,[0,"89ROzgf8pB9ZxebackmmE4"],[5,240,215]],[17,0,true,-202,[0,"06ZLbFSElLfbNaJ+7HF6FF"],62]],[15,null,"549ZAEI3dCj7jnSIbx+N3l",63],[1,92.59,67.584,0],[1,0.372,0.372,0.372]],[14,"Reward_star-001",33554432,8,[[5,-203,[0,"baGwbpwEdNsKkKMe1pvtSq"],[5,240,215]],[17,0,true,-204,[0,"d7vJkJPrtAMooU4vSfGQ44"],64]],[15,null,"d6l2vTfRRHYI703T6FdsBR",65],[1,-93.425,67.442,0],[1,0.372,0.372,0.372]],[14,"Reward_star-002",33554432,8,[[5,-205,[0,"1d7fFdQ6ZJCLntXjwMnFkW"],[5,240,215]],[17,0,true,-206,[0,"62DADpX01MebwyIb4IADv6"],66]],[15,null,"19Ud4sUg9G/5tX74YauyMW",67],[1,-1.022,119.028,0],[1,0.372,0.372,0.372]],[14,"Reward_star",33554432,9,[[5,-207,[0,"89ROzgf8pB9ZxebackmmE4"],[5,240,215]],[17,0,true,-208,[0,"06ZLbFSElLfbNaJ+7HF6FF"],72]],[15,null,"549ZAEI3dCj7jnSIbx+N3l",73],[1,92.59,67.584,0],[1,0.372,0.372,0.372]],[14,"Reward_star-001",33554432,9,[[5,-209,[0,"baGwbpwEdNsKkKMe1pvtSq"],[5,240,215]],[17,0,true,-210,[0,"d7vJkJPrtAMooU4vSfGQ44"],74]],[15,null,"d6l2vTfRRHYI703T6FdsBR",75],[1,-93.425,67.442,0],[1,0.372,0.372,0.372]],[14,"Reward_star-002",33554432,9,[[5,-211,[0,"1d7fFdQ6ZJCLntXjwMnFkW"],[5,240,215]],[17,0,true,-212,[0,"62DADpX01MebwyIb4IADv6"],76]],[15,null,"19Ud4sUg9G/5tX74YauyMW",77],[1,-1.022,119.028,0],[1,0.372,0.372,0.372]],[27,0,{},11,[26,"d8U4lD0QtChYN/bnd/uMHI",-217,[21,"178LMB0jJECqnByoeLfuEa",[[6,"UI_Tutorial_Hands",["_name"],-213],[4,["_lpos"],-214,[1,74.438,-793.209,0]],[4,["_lrot"],-215,[3,0,0,0,1]],[4,["_euler"],-216,[1,0,0,0]]]],82]],[2,["d8U4lD0QtChYN/bnd/uMHI"]],[78,"planetExplore",[10,17],[211,"8473dbf1-264f-43a4-b207-12d087269b16",[],[2,3,4,5,6,7,8,9,47,-218]],[68,[127,0.5208,[2,0.242613,0.362617,0.798746,0.520833125],[2,0.241814,0.361945,0.798799,0],[2,0.519964,0.630786,0.905039,0.5208],[2,0.519544,0.630484,0.905069,0]],[129,[4,4283190348],[0,1024,1024]],[69],[79],[70]]],[14,"levelNumber",33554432,2,[[5,-219,[0,"99rznLuktLOqSmFsj3GI+U"],[5,22.25,50.4]],[48,"2",40,-220,[0,"d0kghXV/VCOq9Tri/a9nW4"]]],[15,null,"baNUBJVU5BkIFeNBFNd2Se",1],[1,-5.683,2.525,0],[1,2.279,2.279,2.279]],[14,"levelNumber",33554432,3,[[5,-221,[0,"99rznLuktLOqSmFsj3GI+U"],[5,22.25,50.4]],[48,"2",40,-222,[0,"d0kghXV/VCOq9Tri/a9nW4"]]],[15,null,"baNUBJVU5BkIFeNBFNd2Se",11],[1,-5.683,2.525,0],[1,2.279,2.279,2.279]],[14,"levelNumber",33554432,4,[[5,-223,[0,"99rznLuktLOqSmFsj3GI+U"],[5,22.25,50.4]],[48,"2",40,-224,[0,"d0kghXV/VCOq9Tri/a9nW4"]]],[15,null,"baNUBJVU5BkIFeNBFNd2Se",21],[1,-5.683,2.525,0],[1,2.279,2.279,2.279]],[2,["baNUBJVU5BkIFeNBFNd2Se"]],[14,"levelNumber",33554432,5,[[5,-225,[0,"99rznLuktLOqSmFsj3GI+U"],[5,22.25,50.4]],[48,"2",40,-226,[0,"d0kghXV/VCOq9Tri/a9nW4"]]],[15,null,"baNUBJVU5BkIFeNBFNd2Se",31],[1,-5.683,2.525,0],[1,2.279,2.279,2.279]],[2,["baNUBJVU5BkIFeNBFNd2Se"]],[14,"levelNumber",33554432,6,[[5,-227,[0,"99rznLuktLOqSmFsj3GI+U"],[5,22.25,50.4]],[48,"2",40,-228,[0,"d0kghXV/VCOq9Tri/a9nW4"]]],[15,null,"baNUBJVU5BkIFeNBFNd2Se",41],[1,-5.683,2.525,0],[1,2.279,2.279,2.279]],[14,"levelNumber",33554432,7,[[5,-229,[0,"99rznLuktLOqSmFsj3GI+U"],[5,22.25,50.4]],[48,"2",40,-230,[0,"d0kghXV/VCOq9Tri/a9nW4"]]],[15,null,"baNUBJVU5BkIFeNBFNd2Se",51],[1,-5.683,2.525,0],[1,2.279,2.279,2.279]],[2,["baNUBJVU5BkIFeNBFNd2Se"]],[14,"levelNumber",33554432,8,[[5,-231,[0,"99rznLuktLOqSmFsj3GI+U"],[5,22.25,50.4]],[48,"2",40,-232,[0,"d0kghXV/VCOq9Tri/a9nW4"]]],[15,null,"baNUBJVU5BkIFeNBFNd2Se",61],[1,-5.683,2.525,0],[1,2.279,2.279,2.279]],[2,["baNUBJVU5BkIFeNBFNd2Se"]],[14,"levelNumber",33554432,9,[[5,-233,[0,"99rznLuktLOqSmFsj3GI+U"],[5,22.25,50.4]],[48,"2",40,-234,[0,"d0kghXV/VCOq9Tri/a9nW4"]]],[15,null,"baNUBJVU5BkIFeNBFNd2Se",71],[1,-5.683,2.525,0],[1,2.279,2.279,2.279]],[2,["baNUBJVU5BkIFeNBFNd2Se"]],[27,0,{},10,[26,"5btj7rBsVNc6CFukgbbz0m",-237,[21,"9fYi+nkPpIdq/LBr16D6Y0",[[6,"UI_Btn_Home",["_name"],18],[4,["_lpos"],18,[1,-419.25,790.5,0]],[4,["_lrot"],18,[3,0,0,0,1]],[4,["_euler"],18,[1,0,0,0]],[4,["_lscale"],18,[1,0.5,0.5,0.441]],[6,50,["_left"],-235],[6,100,["_top"],-236],[135,["clickEvents","0","target"],19,11],[6,"55f924/599MK53Jc8cLiohB",["clickEvents","0","_componentId"],19],[6,"goHome",["clickEvents","0","handler"],19],[6,2,["clickEvents","length"],19],[82,["clickEvents","1"],19,[9,"50d96NEdrdEGKO6GX3+Z0tk","RemoveRootNode",17]]]],83]],[65,"Camera",10,[-238],[1,0,0,1000]],[83,0,1073741824,960,2000,6,41943040,64,[4,4278190080]],[2,["cdcV4xTs5Ed4CiARrPYjrs"]]],0,[0,0,1,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,-5,6,0,-6,7,0,-7,8,0,-8,9,0,2,24,0,2,24,0,2,24,0,2,24,0,0,2,0,0,2,0,0,2,0,-1,21,0,-2,22,0,-3,23,0,0,2,0,-1,50,0,-2,21,0,-3,22,0,-4,23,0,2,28,0,2,28,0,2,28,0,2,28,0,0,3,0,0,3,0,0,3,0,-1,25,0,-2,26,0,-3,27,0,0,3,0,-1,51,0,-2,25,0,-3,26,0,-4,27,0,2,12,0,2,12,0,2,12,0,2,12,0,2,12,0,2,53,0,2,53,0,2,53,0,0,4,0,0,4,0,0,4,0,-1,29,0,-2,30,0,-3,31,0,0,4,0,-1,52,0,-2,29,0,-3,30,0,-4,31,0,2,13,0,2,13,0,2,13,0,2,13,0,2,13,0,2,55,0,2,55,0,2,55,0,0,5,0,0,5,0,0,5,0,-1,32,0,-2,33,0,-3,34,0,0,5,0,-1,54,0,-2,32,0,-3,33,0,-4,34,0,0,6,0,0,6,0,0,6,0,-1,35,0,-2,36,0,-3,37,0,0,6,0,-1,56,0,-2,35,0,-3,36,0,-4,37,0,2,14,0,2,14,0,2,14,0,2,14,0,2,14,0,2,58,0,2,58,0,2,58,0,0,7,0,0,7,0,0,7,0,-1,38,0,-2,39,0,-3,40,0,0,7,0,-1,57,0,-2,38,0,-3,39,0,-4,40,0,2,15,0,2,15,0,2,15,0,2,15,0,2,15,0,2,60,0,2,60,0,2,60,0,0,8,0,0,8,0,0,8,0,-1,41,0,-2,42,0,-3,43,0,0,8,0,-1,59,0,-2,41,0,-3,42,0,-4,43,0,2,16,0,2,16,0,2,16,0,2,16,0,2,16,0,2,62,0,2,62,0,2,62,0,0,9,0,0,9,0,0,9,0,-1,44,0,-2,45,0,-3,46,0,0,9,0,-1,61,0,-2,44,0,-3,45,0,-4,46,0,0,10,0,21,65,0,0,10,0,0,10,0,-1,64,0,-2,20,0,-3,11,0,-4,63,0,46,17,0,0,11,0,33,47,0,0,11,0,-2,47,0,0,17,0,0,17,0,0,20,0,0,20,0,0,20,0,0,21,0,0,21,0,0,22,0,0,22,0,0,23,0,0,23,0,0,25,0,0,25,0,0,26,0,0,26,0,0,27,0,0,27,0,0,29,0,0,29,0,0,30,0,0,30,0,0,31,0,0,31,0,0,32,0,0,32,0,0,33,0,0,33,0,0,34,0,0,34,0,0,35,0,0,35,0,0,36,0,0,36,0,0,37,0,0,37,0,0,38,0,0,38,0,0,39,0,0,39,0,0,40,0,0,40,0,0,41,0,0,41,0,0,42,0,0,42,0,0,43,0,0,43,0,0,44,0,0,44,0,0,45,0,0,45,0,0,46,0,0,46,0,2,48,0,2,48,0,2,48,0,2,48,0,7,47,0,-10,63,0,0,50,0,0,50,0,0,51,0,0,51,0,0,52,0,0,52,0,0,54,0,0,54,0,0,56,0,0,56,0,0,57,0,0,57,0,0,59,0,0,59,0,0,61,0,0,61,0,2,66,0,2,66,0,7,63,0,-1,65,0,23,49,1,4,11,10,4,49,17,4,49,238],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,5,1,5,1,5,1,5,1,6,5,5,1,5,1,5,1,5,1,6,5,5,1,5,1,5,1,5,1,6,5,5,1,5,1,5,1,5,1,6,5,5,1,5,1,5,1,5,1,6,5,5,1,5,1,5,1,5,1,6,5,5,1,5,1,5,1,5,1,6,5,5,1,5,1,5,1,5,1,6,5,1,5,5],[101,0,2,0,2,0,2,0,6,6,0,0,2,0,2,0,2,0,6,6,0,0,2,0,2,0,2,0,6,6,0,0,2,0,2,0,2,0,6,6,0,0,2,0,2,0,2,0,6,6,0,0,2,0,2,0,2,0,6,6,0,0,2,0,2,0,2,0,6,6,0,0,2,0,2,0,2,0,6,6,0,102,57,103]],[[{"name":"spaceship","rect":{"x":609,"y":3,"width":348,"height":671},"offset":{"x":0,"y":0},"originalSize":{"width":348,"height":671},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"name":"Venus","rect":{"x":615,"y":1388,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"name":"Codespark_UI_Counterclockwise_active","rect":{"x":93,"y":635,"width":78,"height":72},"offset":{"x":0,"y":-1},"originalSize":{"width":82,"height":82},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"name":"UI_Natoons_Book_Play Button","rect":{"x":1305,"y":729,"width":312,"height":325},"offset":{"x":-0.5,"y":-0.5},"originalSize":{"width":317,"height":330},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[{"name":"satellite-1","rect":{"x":808,"y":680,"width":180,"height":213},"offset":{"x":0,"y":0},"originalSize":{"width":180,"height":213},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["8dUIo5lfpGd5kESjVWd4Do"]}],[4],0,[],[],[]],[[{"name":"UI_Virtual_Joystick_Button","rect":{"x":3,"y":1956,"width":80,"height":80},"offset":{"x":0,"y":0},"originalSize":{"width":128,"height":128},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[[67,"characterSelection"],[64,"Canvas",33554432,"7aTVDcLnFNLaoZoyLAfzIa",[-5,-6,-7,-8,-9,-10],[[5,-1,[0,"0dngp/9gNO34wUQjZfN/CX"],[5,1080,1920]],[122,-3,[0,"3f2oTdCepERZdpmIfLsrhd"],-2],[123,45,-5.684341886080802e-14,-5.684341886080802e-14,-1.1368683772161603e-13,-1.1368683772161603e-13,960,-4,[0,"e8a+bU/8dPDbbJguUzLdoF"]]],[1,540,959.9999999999999,0]],[23,"CharacterSelection",1,1,[-12,-13,-14,-15,-16],[[7,-11]],[1,0,3.871,0]],[223,"characterSelection",[1,-17,-18,-19,-20],[68,[127,0.5208,[2,0.242613,0.362617,0.798746,0.520833125],[2,0.241814,0.361945,0.798799,0],[2,0.519964,0.630786,0.905039,0.5208],[2,0.519544,0.630484,0.905069,0]],[129,[4,4283190348],[0,1024,1024]],[69],[79],[70]]],[93,"Button_RocketShip",1,2,[-26],[[1,-21,[5,750,240]],[16,1,0,-22,3],[58,3,-25,[[9,"a378d5ME8BDQrgkyMJ6UCRj","onRocketShipSelected",-24]],[4,4292269782],-23,8]],[1,-31.937,366.989,0],[3,0,0,0.03489949670250097,0.9993908270190958],[1,0,0,4]],[172,"CharacterSelection",33554432,"f7QtP67gJIP6vHTwsq9LLP",3,[[256,-28,-27]]],[73,"Popup_ParentControl",false,33554432,1,[-31,-32],[[1,-29,[5,900,600]],[10,0,-30,7]]],[93,"Button_Astronaut",1,2,[-37],[[1,-33,[5,750,240]],[16,1,0,-34,10],[58,3,-36,[[9,"a378d5ME8BDQrgkyMJ6UCRj","onAstronautSelected",5]],[4,4292269782],-35,11]],[1,73.968,-395.957,0],[3,0,0,0.03489949670250097,0.9993908270190958],[1,0,0,4]],[56,"Canvas",33554432,[-42,-43],[[1,-38,[5,1080,1920]],[76,-40,-39],[77,45,1.1368683772161603e-13,-1.1368683772161603e-13,-41]],[1,540,959.9999999999999,0]],[8,"Button",33554432,6,[[7,-44],[16,1,0,-45,5],[58,3,-47,[[9,"a378d5ME8BDQrgkyMJ6UCRj","hidePopupControl",5]],[4,4292269782],-46,6]],[1,0,-175.999,0]],[8,"Button",1,2,[[1,-48,[5,150,150]],[16,1,0,-49,13],[54,3,-51,[[9,"a378d5ME8BDQrgkyMJ6UCRj","gotoLandingPage",5]],[4,4292269782],-50,14,15,16,17]],[1,-395.08,800,0]],[173,"BetaBuildInfo",512,false,33554432,1,[-53,-54],[[7,-52]]],[174,"SoundManager","da+//Lf5hFC5FKFsIjxp2F",3,[8],[[257,-56,-55,22,23],[258,true,-57,24]]],[194,"SoundBtn",33554432,8,[[[1,-58,[5,145,150]],[10,2,-59,21],-60],4,4,1],[1,448.356,800,0],[3,0,0,0.026176948307873153,0.9996573249755573],[1,0,0,3]],[34,"Bg",1,2,[-63],[[1,-61,[5,1080,1920]],[10,0,-62,1]]],[8,"Master_Litho_KJ_Logo_CN_roundbar_18logo",1,14,[[1,-64,[5,244,174]],[12,-65,0]],[1,0,771.376,0]],[112,"Label",512,33554432,4,[[1,-66,[5,464.52,158.2]],[102,"火箭飞船\nRocket Ship",70,70,70,false,false,-67,[4,4290867458],2]],[1,-34.596,2.778,0],[3,0,0,-0.01745240643728351,0.9998476951563913],[1,0,0,-2]],[8,"Label",33554432,6,[[1,-68,[5,840,126]],[62,"建议家长陪同孩子共同体验",70,70,100,false,-69,[4,4290867458],4]],[1,0,69.089,0]],[112,"Label",512,33554432,7,[[1,-70,[5,404.04,158.2]],[102,"宇航员\nAstronaut",70,70,70,false,false,-71,[4,4290867458],9]],[1,97.364,12.491,0],[3,0,0,-0.03489949670250097,0.9993908270190958],[1,0,0,-4]],[8,"BottomText",1,2,[[1,-72,[5,770,100.8]],[43,"选择你和孩子喜欢的角色",70,70,80,false,-73,12]],[1,0,-826.279,0]],[175,"Astronaut",1,1,[[1,-74,[5,350,600]],[10,0,-75,18]],[1,-244.355,-350.309,0],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[8,"Spaceship",1,1,[[1,-76,[5,280,629]],[10,2,-77,19]],[1,317.591,282.016,0]],[116,"Version",512,33554432,11,[[[1,-78,[5,196.82,100.8]],-79],4,1],[1,410.034,-907.932,0]],[116,"UUID",512,33554432,11,[[[1,-80,[5,939.72,63]],-81],4,1],[1,0,920.949,0]],[57,"GameManager","60E/taU91IXY0gtClG0fL1",3,[[259,-82],[260,-83,20]]],[65,"Camera",1,[-84],[1,0,0,1000]],[83,0,1073741824,960,2000,6,42467329,25,[4,4278190080]],[81,"1.3.0dx",60,60,80,22],[81,"032649a0-e748-4baf-aabc-942ea2de8693",50,50,50,23],[65,"Camera",8,[-85],[1,0,0,1000]],[83,0,1073741824,960,2000,6,41943040,29,[4,4278190080]],[227,1,13,[[9,"3f65eZnitpAD6auNMmWOlil","switchVolume",12]],[4,4290690750],[4,4288124823],13],[57,"TrackingManager","67jYaQPqJOYrdIcEaogir0",3,[[261,-86,11,27,28]]]],0,[0,0,1,0,21,26,0,0,1,0,0,1,0,-1,25,0,-2,2,0,-3,20,0,-4,21,0,-5,6,0,-6,11,0,0,2,0,-1,14,0,-2,4,0,-3,7,0,-4,19,0,-5,10,0,-2,5,0,-3,24,0,-4,12,0,-5,32,0,0,4,0,0,4,0,8,4,0,12,5,0,0,4,0,-1,16,0,47,6,0,0,5,0,0,6,0,0,6,0,-1,17,0,-2,9,0,0,7,0,0,7,0,8,7,0,0,7,0,-1,18,0,0,8,0,21,30,0,0,8,0,0,8,0,-1,29,0,-2,13,0,0,9,0,0,9,0,8,9,0,0,9,0,0,10,0,0,10,0,8,10,0,0,10,0,0,11,0,-1,22,0,-2,23,0,48,31,0,0,12,0,0,12,0,0,13,0,0,13,0,-3,31,0,0,14,0,0,14,0,-1,15,0,0,15,0,0,15,0,0,16,0,0,16,0,0,17,0,0,17,0,0,18,0,0,18,0,0,19,0,0,19,0,0,20,0,0,20,0,0,21,0,0,21,0,0,22,0,-2,27,0,0,23,0,-2,28,0,0,24,0,0,24,0,-1,26,0,-1,30,0,0,32,0,23,3,1,4,3,8,4,12,86],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31,31,31,31],[1,1,9,1,9,1,6,1,6,9,1,6,9,1,6,18,16,11,1,1,49,1,50,51,52,6,18,16,11],[49,10,1,18,1,19,19,25,18,1,18,18,1,58,58,11,12,3,59,60,104,22,22,40,105,22,11,12,3]],[[{"name":"spaceship2","rect":{"x":3,"y":3,"width":265,"height":629},"offset":{"x":-7.5,"y":0},"originalSize":{"width":280,"height":629},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[15]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["94ZtsbVoNEwpc5VuIy6F7f"]}],[4],0,[],[],[]],[[{"name":"spaceship_hit_02","rect":{"x":0,"y":0,"width":287,"height":402},"offset":{"x":0,"y":0},"originalSize":{"width":287,"height":402},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[106]],[[{"name":"Path","rect":{"x":3,"y":3,"width":543,"height":1661},"offset":{"x":-0.5,"y":1},"originalSize":{"width":550,"height":1669},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["95EkngnxZFbYuFpsqVTaFr"]}],[4],0,[],[],[]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[0],0,[0],[3],[107]],[[[262,"china","china.ttf"],-1],0,0,[],[],[]],[[{"name":"UI_icon_greenmark_zoom","rect":{"x":767,"y":1264,"width":165,"height":171},"offset":{"x":1,"y":-1},"originalSize":{"width":167,"height":173},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[{"name":"UI_Camera_take_photo","rect":{"x":773,"y":1047,"width":168,"height":175},"offset":{"x":0.5,"y":0},"originalSize":{"width":173,"height":181},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"name":"UI_ToyName_Tag_Shadow","rect":{"x":659,"y":1264,"width":300,"height":102},"offset":{"x":0,"y":-0.5},"originalSize":{"width":300,"height":103},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["a0gA92YvpPZqOiYpNcFSjM"]}],[4],0,[],[],[]],[[{"name":"spaceship_hit_04","rect":{"x":0,"y":0,"width":287,"height":402},"offset":{"x":0,"y":0},"originalSize":{"width":287,"height":402},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[108]],[[{"name":"Codespark_UI_Clockwise_active","rect":{"x":93,"y":719,"width":78,"height":72},"offset":{"x":0,"y":-1},"originalSize":{"width":82,"height":82},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[[263,"Sparkle",".plist"],-1],0,0,[],[],[]],[[{"name":"Codespark_UI_forward_active 02","rect":{"x":3,"y":793,"width":78,"height":72},"offset":{"x":0,"y":-1},"originalSize":{"width":82,"height":82},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"name":"Star 4","rect":{"x":808,"y":1276,"width":106,"height":109},"offset":{"x":1,"y":-1.5},"originalSize":{"width":128,"height":128},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"name":"Codespark_UI_Level_Select_Button_Blank","rect":{"x":3,"y":1670,"width":218,"height":231},"offset":{"x":0,"y":-5.5},"originalSize":{"width":250,"height":250},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[[18,"Codespark_UI_Counterclockwise_disabled"],[38,"Codespark_UI_Counterclockwise_disabled",33554432,[[5,-2,[0,"6bmcho7XNAs7Oq/ee1s2o3"],[5,204,184]],[32,-3,[0,"e4WNjv/mVNOb3+CeFjjpNy"],0],[104,-4,[0,"ca4qRMTjRDIYsXdZdhXBk3"],1,2]],[3,"87yQP6BktJsago/P3b42Hl",-1,0],[1,-195.36631098713679,0,0],[1,0.4,0.4,0.414]]],0,[0,7,1,0,0,1,0,0,1,0,0,1,0,10,1,4],[0,0,0],[1,31,32],[61,41,61]],[[{"name":"Concept_Control_Panel_off","rect":{"x":659,"y":1570,"width":273,"height":175},"offset":{"x":0,"y":0},"originalSize":{"width":273,"height":175},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[{"name":"Block-5","rect":{"x":3,"y":635,"width":73,"height":84},"offset":{"x":0,"y":0},"originalSize":{"width":73,"height":84},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[{"name":"UI box","rect":{"x":940,"y":3,"width":141,"height":66},"offset":{"x":-1,"y":0},"originalSize":{"width":145,"height":70},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[[18,"Model"],[195,"Model",33554432,[-7,-8],[[-2,[118,false,-3,[0,"5dlhlTxN5AO7v7WP3WJ17d"]],[108,-4,[0,"2acbd5zSlJXI/1f7Hyiz7e"],9],[265,-6,[0,"06VV8yqfBIta9yWMCv0Odp"],-5]],1,4,4,4],[3,"38glPkc3pPr6SuGI6AFaSv",-1,0],[1,3.181,16.205,0],[3,0,0.7071067811865475,0,0.7071067811865476],[1,30.425000000000004,30.457157957607187,30.45919252243646],[1,0,90,0]],[115,"Bip001 Xtra01",33554432,[[19,"R hand handle1",33554432,-9,[3,"795e70w5ZMnJBfX7C3/laV",1,0],[1,0.5100117921829224,-0.03201562166213989,-0.45077818632125854],[3,-0.005188420423502014,-0.7068445694211046,-0.09790486113521249,0.7005415570396214],[1,-8.448483427837095,-91.06499193160911,-7.460233031588316]],[19,"R hand handle2",33554432,-10,[3,"c5Aeg/hJpGjISxlpKm7RTb",1,0],[1,0.2482302188873291,-0.8186889886856079,-0.5586746335029602],[3,-0.025460728985730388,-0.697277535255075,-0.11748181848691609,0.706649709851444],[1,-11.627194806311339,-89.99976177097336,-7.500254563933692]],[19,"L hand handle2",33554432,-11,[3,"2bmy4bU1pIxJPQMDC4Vo+T",1,0],[1,0.2816418409347534,-0.8178844451904297,0.6075959205627441],[3,0.05604491530924374,-0.6981601303515795,0.14023021234062308,0.6998334711932184],[1,16.032384555808207,-90.81843994511613,6.77778383509979]],[19,"L hand handle1",33554432,-12,[3,"30VKnvzZJHqKLJvnCwk/EC",1,0],[1,0.5100117325782776,-0.03201943635940552,0.45100128650665283],[3,-0.10807455599566979,-0.7104745087690618,0.032465518327416114,0.6946163350047502],[1,-6.0919464591023464,-90.68144331892557,11.45922968505323]]],[3,"d30nRlPRNHpKV7dFSuQjWH",1,0],[1,0.24099814891815186,-0.5346709489822388,-0.0000022221356630325317],[3,5.66752508525438e-11,-0.000002784897083942903,0.9999964754732449,0.0026550015691793652],[1,179.99968087090986,-179.99999914621426,0.3042411264629999]],[61,"Bip001 Spine",33554432,[-13,-14,-15],[3,"83GunGLOxCsb/Ka0LI3Mf4",1,0],[1,0.06027185916900635,0.032107848674058914,0.0017063021659851074],[3,0.01831307293887407,0.02004462701512546,0.051330083007181865,0.9983126097900575],[1,1.9880965062524896,2.1976265180429233,5.924685929600534]],[117,"Bip001 Neck",33554432,[[-16,-17,[19,"Bip001 Head",33554432,-18,[3,"7a3gOW/dpA3JJ86jkPgA5p",1,0],[1,0.06547927856445312,-0.000014360994100570679,1.862645149230957e-9],[3,0.03445632421258817,0.011725077534988505,-0.04653003863194179,0.9982535949263923],[1,4.024421030307099,1.5316579143910214,-5.2838288446271795]]],1,1,4],[3,"43EyYYbF5DJ45Tx/wlIPEc",1,0],[1,0.3603935241699219,-0.06606259942054749,-1.862645149230957e-9]],[61,"Bip001 L Hand",33554432,[-19,-20,-21],[3,"8d4OewxuVPZYIkcZIWK/RK",1,0],[1,0.27253085374832153,-5.960464477539063e-8,0],[3,-0.7419664123320368,-0.09395094038083236,-0.025406443964477346,0.6633351915719257],[1,-95.90594946615346,-9.396061037980928,6.068126523038534]],[61,"Bip001 R Hand",33554432,[-22,-23,-24],[3,"787evIrapNKpyeQMxtw2Dd",1,0],[1,0.27253082394599915,5.960464477539063e-8,-5.960464477539063e-8],[3,0.7424006876752727,-0.16733713039192535,0.0373819833801062,0.6476434907030624],[1,96.15859035195534,-16.1331769299178,-11.539415377468101]],[113,"VD043_Jetpack_Flyer_Toy",33554432,1,[[156,-25,[0,"83CtKnZl9MBayHV0ubsRL3"],[0,1],[72],1,2,3],[105,-26,[0,"bfPmKE0GNL/b8oklBl2SGU"]],[46,-27,[0,"77QYx/oo5IsIZCvzao30pE"],[5,1.8033320407970963,3.0591937802105322],[0,0.5,0.7]]],[3,"daLFWDeYZPLLzHu/qWw01s",1,0],[1,0.000004234213572207324,0.34442489582445646,-0.5965614189595705],[3,-0.7071067811865476,0,0,0.7071067811865475],[1,-90.00000000000001,0,0]],[20,"Bip001 Spine1",33554432,3,[4,2],[3,"7dY4T6t01Ceopmze+/f1FW",1,0],[1,0.30468177795410156,-0.00024194270372390747,-0.000008396804332733154],[3,0.01652411234166925,-0.023288617600632614,-0.03368326748875341,0.999024539985306],[1,1.8062750228980584,-2.6092475452322503,-3.9031688345757445]],[20,"Bip001",33554432,1,[-28],[3,"73kWn/QChIVKoBe+01enDy",1,0],[1,0.025053977966308594,0.7133909463882446,0.03748690336942673],[3,-0.4592295592545704,-0.5376878387195055,-0.5376878387195054,0.45922955925457043],[1,-90,-98.99990617392913,0]],[114,"Bip001 Pelvis",33554432,9,[3],[3,"365xpqyytH5a4/bI+0KF6Z",1,0],[3,0.5203319787540229,0.4855473935194539,0.518123626665281,-0.47439041729740306],[1,-94.4967349616145,-90.48229397300277,0.7853151089261627]],[20,"Bip001 L Clavicle",33554432,4,[-29],[3,"94/43hjm9FJaKdN4UGNrfv",1,0],[1,-0.15008139610290527,-0.029379824176430702,0.16028693318367004],[3,0.7379414630554331,-0.0002946540265846981,0.6748646076676733,0.00026758207934930825],[1,179.95458604417567,-84.88728416552377,-0.0042233576805496]],[20,"Bip001 L UpperArm",33554432,11,[-30],[3,"1d05oQrLdP47BXHZsUzoqu",1,0],[1,0.1752856969833374,1.30385160446167e-8,0],[3,-0.1909291589128922,0.5413013679400174,0.055306404652568766,0.8169945452372911],[1,-21.986797837186934,65.75393827764961,-6.680364579993282]],[20,"Bip001 L Forearm",33554432,12,[5],[3,"94jHZsdiVJWJ75Qlq7bz4p",1,0],[1,0.30327725410461426,5.551115123125783e-17,5.960464477539063e-8],[3,1.4625413342768572e-17,-3.263487547518527e-17,-0.6823387669725535,0.7310361188658021],[1,-1.9273518689805456e-14,-2.31052198399669e-14,-86.05334796136489]],[28,"Bip001 L Finger0",33554432,5,[[19,"Bip001 L Finger01",33554432,-31,[3,"15tq1gJfFH5ZZPI4L3Nv/F",1,0],[1,0.12686099112033844,-5.960464477539063e-8,2.220446049250313e-16],[3,6.7717409268558375e-9,3.1071960473302073e-9,0.4170408535278855,0.9088877414118494],[1,8.537736078717935e-7,-3.8379800353244007e-14,49.29580931519125]]],[3,"b3sYhm1a5Ptp2mVc9LXUFL",1,0],[1,0.05214601755142212,0.010561108589172363,-0.07510733604431152],[3,0.6746811945821796,0.29407200561851043,0.24056166692344885,0.6328167393453507],[1,92.10049931983626,3.827088343668838,44.52919453220961]],[28,"Bip001 L Finger1",33554432,5,[[19,"Bip001 L Finger11",33554432,-32,[3,"95/WSv3H1EBaSujPVf9zzo",1,0],[1,0.11407226324081421,5.960464477539063e-8,5.960464477539063e-8],[3,-4.066922923868787e-9,1.4455938225677603e-8,0.7127351384477825,0.7014332629850256],[1,-179.99990567592812,179.999906517761,89.08421659248222]]],[3,"c6otiHVmNLGpImPIvMIPnd",1,0],[1,0.13685476779937744,-0.06003260612487793,-0.017368435859680176],[3,-0.1673444815267504,0.08695138286027557,0.2768333269045508,0.9422306461987887],[1,-24.688426747642307,17.142431839455604,29.510300381098883]],[28,"Bip001 L Finger2",33554432,5,[[19,"Bip001 L Finger21",33554432,-33,[3,"bbqNYxk/JErLh9QWiNfTRr",1,0],[1,0.11604306101799011,1.1102230246251565e-16,1.1102230246251565e-16],[3,0.005586658533918401,0.02709030512049791,0.581860832975312,0.8128178613097644],[1,-3.9771057377360717,6.661465414910693,71.11965907439375]]],[3,"18L9tq7epAs6CXJBA1UJWy",1,0],[1,0.13624519109725952,-0.048795878887176514,0.09180718660354614],[3,-0.13856673351836557,0.07784738454096357,0.36049381187707236,0.9191209151578041],[1,-23.893264133111604,18.45982424655009,39.87394415309718]],[20,"Bip001 R Clavicle",33554432,4,[-34],[3,"99Tn4cGgND2a9lpCxjyuPw",1,0],[1,-0.15008139610290527,-0.02937893196940422,-0.16028745472431183],[3,0.7480214735998131,-0.0002969640733798371,-0.6636744054438308,-0.0002653388038828932],[1,-179.95467140421664,83.16142932137103,-0.005275443688355604]],[20,"Bip001 R UpperArm",33554432,17,[-35],[3,"d9hYyJ8DlFX6QOKVplt0zd",1,0],[1,0.17528563737869263,-5.587935447692871e-9,2.220446049250313e-16],[3,0.20653430849426985,-0.547382049607393,0.06835500062185525,0.8081114187241694],[1,24.292656874925044,-66.79363258623155,-6.639931109062676]],[20,"Bip001 R Forearm",33554432,18,[6],[3,"aa8+TEd7BPp4fwbYZ+YCRP",1,0],[1,0.30327725410461426,-5.960464477539063e-8,0],[3,0,0,-0.6512993580123281,0.7588208920771287],[1,0,0,-81.27927936718207]],[28,"Bip001 R Finger0",33554432,6,[[19,"Bip001 R Finger01",33554432,-36,[3,"76RvuiGkJJpYCi9Uy8TeQS",1,0],[1,0.12686097621917725,-5.551115123125783e-17,0],[3,4.6844838988063015e-8,5.099695762537187e-9,0.417040853527885,0.9088877414118484],[1,0.000007107554750065308,-0.0000026183196263363308,49.29580931519113]]],[3,"0b09nm0tRLkqAS34TTVICK",1,0],[1,0.052145957946777344,0.010561227798461914,0.07510733604431152],[3,-0.7992934893017968,-0.2846068551680877,0.14495339058835943,0.5090357261607757],[1,-113.61955784540162,-4.169697231212765,37.05215275548036]],[28,"Bip001 R Finger1",33554432,6,[[19,"Bip001 R Finger11",33554432,-37,[3,"ab33rwKQ1Jnr0L+DHBGs1R",1,0],[1,0.11407217383384705,-1.1920928955078125e-7,-5.960464477539063e-8],[3,-1.6841125531131413e-10,2.1072748647615377e-8,0.7127351086492664,0.7014332932636701],[1,-179.99989146868464,179.99989316258515,89.08422146059704]]],[3,"4a+EsGp+BAXIyMOaY6cxjo",1,0],[1,0.1368546485900879,-0.06003260612487793,0.01736849546432495],[3,0.16734449633585335,-0.08695136046070064,0.2768333267522613,0.9422306456804558],[1,24.688427931148876,-17.1424295363662,29.510300667330508]],[28,"Bip001 R Finger2",33554432,6,[[19,"Bip001 R Finger21",33554432,-38,[3,"665bE4CohD1oPOjmL34Sxl",1,0],[1,0.1160430908203125,5.960464477539063e-8,0],[3,-0.0055866544205679615,-0.027090301771503896,0.5818609006622605,0.8128178129955181],[1,3.977108907119225,-6.661467934225278,71.11966855597838]]],[3,"d647+CYstFQa2Pdi9LJyYD",1,0],[1,0.13624513149261475,-0.04879593849182129,-0.09180724620819092],[3,0.1385667058573379,-0.07784737829337175,0.3604937876455218,0.9191209293611369],[1,23.893258845831284,-18.459820830051857,39.87394204293123]],[20,"Bip001 L Thigh",33554432,3,[-39],[3,"ec42pkUhdM5LR5bbZCo0UH",1,0],[1,-0.06955111026763916,-0.019373338669538498,0.16432179510593414],[3,0.1365471175158444,0.9795017773234587,0.11902838866105335,-0.08811013341865497],[1,-15.392582147897418,-167.78117226829093,14.271742314915677]],[20,"Bip001 L Calf",33554432,23,[-40],[3,"e2yy4+RxlCKLEQbGd6MqQt",1,0],[1,0.2833104133605957,2.7755575615628914e-17,0],[3,-7.94353597486993e-18,9.663437981896868e-18,-0.2905194084380881,0.9568690993656257],[1,-6.60848836659558e-16,9.566188430703192e-16,-33.77810960344908]],[28,"Bip001 L Foot",33554432,24,[[19,"Bip001 L Toe0",33554432,-41,[3,"6eZj5IlQNDI5Y20ISn671i",1,0],[1,0.12055830657482147,0.1753564178943634,2.9802322387695312e-8],[3,-4.913837954028883e-7,0.0000010259031062596675,0.7071069003953715,0.7071066619767884],[1,0,-0.00007963216615437602,90]]],[3,"d4yWIkRZNOp6/acY8CPCO/",1,0],[1,0.32318341732025146,-5.204170427930421e-18,2.9802322387695312e-8],[3,-0.14829636816999522,-0.12443219624282932,0.16820883418307833,0.9665560531229138],[1,-15.22628584512692,-11.801937960540801,21.227512760199243]],[20,"Bip001 R Thigh",33554432,3,[-42],[3,"b3JJCJi7hLE4xmh0Prvuea",1,0],[1,-0.056758761405944824,-0.03232694789767265,-0.1705644577741623],[3,0.28349079891924855,0.9339861013533769,-0.19430671090902984,0.0977130058004596],[1,28.712520919353565,160.36008287869288,29.444506192928287]],[20,"Bip001 R Calf",33554432,26,[-43],[3,"b3ikEihEFEypg1bfCeUz6E",1,0],[1,0.2833103537559509,0,0],[3,7.552592260718814e-17,-3.7706441708005647e-17,-0.293513440263538,0.9559549468383238],[1,8.46347372924871e-15,-1.9213213508359334e-15,-34.136836267456545]],[28,"Bip001 R Foot",33554432,27,[[19,"Bip001 R Toe0",33554432,-44,[3,"59XAxbiKJGsrSJYsI488eA",1,0],[1,0.12055831402540207,0.1753564327955246,2.9802322387695312e-8],[3,-1.7085779829572256e-7,2.716841368257836e-7,0.7071070494073549,0.7071065129655654],[1,0,-0.00002768870194162374,90]]],[3,"2eGxq8nzBJa7+vn3AQMrbe",1,0],[1,0.32318347692489624,-1.4901161193847656e-8,2.7755575615628914e-17],[3,0.11063275000585403,0.04712268448101054,0.03850727618625852,0.9919964903739128],[1,12.514328107823792,4.8928647296201335,4.9809656483770155]],[267,true,false,1,[0,"ccSFVpwiROFJQG1ycigKnl"],[4,5,6,7,8]]],0,[0,7,1,0,-1,29,0,0,1,0,0,1,0,53,29,0,0,1,0,-1,9,0,-2,7,0,4,2,0,4,2,0,4,2,0,4,2,0,-1,8,0,-2,23,0,-3,26,0,-1,11,0,-2,17,0,4,4,0,-1,14,0,-2,15,0,-3,16,0,-1,20,0,-2,21,0,-3,22,0,0,7,0,0,7,0,0,7,0,-1,10,0,-1,12,0,-1,13,0,4,14,0,4,15,0,4,16,0,-1,18,0,-1,19,0,4,20,0,4,21,0,4,22,0,-1,24,0,-1,25,0,4,25,0,-1,27,0,-1,28,0,4,28,0,10,1,2,4,8,3,4,10,4,4,8,5,4,13,6,4,19,44],[0,0,0,0,0,0,0,0,0,0],[-1,-2,24,38,-1,-2,-3,-4,-5,22],[31,31,62,63,55,21,28,29,30,64]],[[[86,[[87,[88,[-10,-11,-12,-13,-14,-15],[[106,-5,-4],[63,false,-7,-6,[[44,[36,"Start"]]]],[63,false,-9,-8,[[44,[36,"Start"]]]]],-3,-2,-1]]],[{},"Start",4,[59,1,false]]],[37,"Entry"],[30,"Fire_Engine_Start",[33,0]],[30,"Null",[154]],[37,"Exit"],[37,"Any"],[30,"Fire_Engien_Loop",[33,1]]],0,[0,27,5,0,28,4,0,29,1,0,13,3,0,14,1,0,13,2,0,14,3,0,13,6,0,14,2,0,-1,1,0,-2,4,0,-3,5,0,-4,2,0,-5,6,0,-6,3,15],[0,0],[15,15],[109,110]],[[[67,"mainGame"],[176,"GameManager",33554432,[[7,-1],[269,100,150,-7,[1,2,3,4,5],[6,7,8,9,10],-6,-5,-4,-3,-2],[270,-15,[25,26,27],-14,-13,-12,-11,-10,-9,-8,28],[271,-19,-18,-17,-16]]],[177,"Buttons",33554432,[-23,-24,-25,-26,-27,-28],[[1,-20,[5,1996.3031423290201,3548.9833641404803]],[215,45,1996.3031423290204,3548.9833641404807,-21],[272,-22]],[1,0.541,0.541,0.128]],[64,"Canvas",33554432,"beI88Z2HpFELqR4T5EMHpg",[-33,-34,1,-35,2,-36,-37,-38],[[1,-29,[5,1080,1920]],[76,-31,-30],[77,45,-5.684341886080802e-14,-5.684341886080802e-14,-32]],[1,540,960,0]],[178,0,{},[26,"38glPkc3pPr6SuGI6AFaSv",-44,[134,"e6+IQ/5SNExL4lJyLqJGEc",null,[[273,[2,["38glPkc3pPr6SuGI6AFaSv"]],[[[264,-42,16],-43],4,1]]],[[25,"Model",["_name"],[2,["38glPkc3pPr6SuGI6AFaSv"]]],[13,["_lpos"],[2,["38glPkc3pPr6SuGI6AFaSv"]],[1,3.181,16.205,0]],[13,["_lrot"],[2,["38glPkc3pPr6SuGI6AFaSv"]],[3,0,0.7071067811865475,0,0.7071067811865476]],[13,["_euler"],[2,["38glPkc3pPr6SuGI6AFaSv"]],[1,0,90,0]],[237,["_defaultClip"],[2,["ccSFVpwiROFJQG1ycigKnl"]]],[25,true,["_enabled"],[2,["ccSFVpwiROFJQG1ycigKnl"]]],[25,false,["_enabled"],[2,["5dlhlTxN5AO7v7WP3WJ17d"]]],[25,false,["_useBakedAnimation"],[2,["ccSFVpwiROFJQG1ycigKnl"]]],[6,1,["_materials","length"],-39],[135,["_skinningRoot"],-41,-40]],[[2,["2acbd5zSlJXI/1f7Hyiz7e"]],[2,["06VV8yqfBIta9yWMCv0Odp"]]]],15]],[50,"WinBanner",33554432,3,[-51,-52,-53],[[203,false,-45,[5,1150,256]],[205,false,-46,48],[275,-50,-49,-48,-47,49]],[1,0,-522.072,0],[1,1.315,1.315,1.315]],[94,"MainGame",33554432,3,[-55,-56,-57,-58,-59],[[7,-54]],[1,2.189,2.189,2.189]],[75,"Codespark_UI_Panel_02",33554432,[-63,-64,-65],[[1,-60,[5,1018.6589747051316,181.09393090360928]],[10,0,-61,23],[216,false,4,146.60950000000003,-62]],[1,-4.157,158.547,0],[1,0.566,0.566,1.132]],[75,"Codespark_UI_Setup_Panel",33554432,[-68],[[1,-66,[5,1139.240763222156,217.80323052811318]],[10,0,-67,24]],[1,0.000011060085113978602,57.353,0],[1,0.553,0.553,0.535]],[24,"UI_Natoons_Book_Play Button",33554432,2,[[1,-69,[5,312,325]],[12,-70,39],[71,1,-72,[[9,"5c3c5daSIVPLp7akyPQKmsk","PlayMove",1],[9,"f0e95o3W7dJ96S58AIkkvr7","HideHand",-71]],[4,4288059030],41],[126,4,120,-73]],[1,0,-1504.5795748613677,0],[1,0.922536044362292,0.922536044362292,8.500160625]],[27,0,{},5,[26,"02i9O3FHBBNq4cBFjrUBnI",-88,[235,"31ZRFDA1NEzZn9jEGliM5G",[[276,[2,["02i9O3FHBBNq4cBFjrUBnI"]],[-87]]],[[6,"Particle_Confetti",["_name"],-74],[4,["_lpos"],-75,[1,-443.897,-342.52,0]],[4,["_lrot"],-76,[3,0,0,0,1]],[4,["_euler"],-77,[1,0,0,0]],[6,33554432,["_layer"],-78],[6,33554432,["_layer"],-79],[6,1.5,["startSizeX","constantMax"],-80],[6,0.8,["startSizeX","constantMin"],-81],[6,7,["startSpeed","constant"],-82],[6,1.4,["_velocityOvertimeModule","speedModifier","constant"],-83],[6,false,["loop"],-84],[4,["_lrot"],-85,[3,0.7044160264027586,-0.061628416716219346,-0.06162841671621935,0.7044160264027587]],[4,["_euler"],-86,[1,90,0,-10]]]],45]],[93,"Player",33554432,6,[-90,4],[[7,-89]],[1,-150.105,268.099,0],[3,0.49999999999999994,0,0,0.8660254037844387],[1,60,0,0]],[50,"Mask",33554432,8,[-94,-95],[[1,-91,[5,580.9182564422267,71.7265183226849]],[98,false,8,33.294397236961046,-92,8],[277,-93]],[1,-5.250583884928157,0,0],[1,1.7800000000000002,1.7800000000000002,1.7799999999999998]],[31,"Codespark_UI_Stop",false,33554432,2,[[1,-96,[5,192,199]],[12,-97,31],[71,1,-98,[[9,"5c3c5daSIVPLp7akyPQKmsk","ResetMove",1]],[4,4288059030],32],[126,4,120,-99]],[1,0,-1506.183,0],[1,1.5068088724584103,1.5068088724584103,21.237404374999997]],[24,"Codespark_UI_Retry",33554432,2,[[1,-100,[5,150,155]],[12,-101,33],[71,1,-102,[[9,"5c3c5daSIVPLp7akyPQKmsk","ResetMove",1]],[4,4288059030],34]],[1,-271.8252454713494,-1529.0926496857671,0],[1,1.211597338262477,1.211597338262477,17.078304375000002]],[2,["7dpTyH9uRFJawmY5ekg9n+"]],[24,"UI_Btn_Back",33554432,5,[[1,-103,[5,177,173]],[12,-104,43],[217,36,820.7650000000001,269.957,710.9839999999999,-115.29100000000003,278,-105],[80,-106,[[9,"f10f825x4RA447/cnjy5wGi","BackToLevelSelection",2],[9,"2aba7MT17hBdIg/s6Nuvdoa","DestroyMap",1],[9,"5c3c5daSIVPLp7akyPQKmsk","HideWinBanner",1]],44]],[1,235.39350000000002,-175.21550000000002,0],[1,0.787,0.787,0.077]],[179,"Banner",33554432,[-109,-110,-111],[[1,-107,[5,1150,256]],[12,-108,56]],[3,0,0,0.043619387365336,0.9990482215818578],[1,0,0,5]],[24,"TileMap",33554432,6,[[1,-112,[5,516.8521909137918,84.74]],[278,1,3,-15,2,7,true,-113,[5,73.72,84.74]],[218,17,-131.2804933759707,131.28049337597068,-79.9928,100,-114]],[1,0,94.40199999999999,0],[1,0.84,0.84,0.84]],[180,"LevelText",33554432,6,[-118],[[1,-115,[5,716,258]],[12,-116,12],[219,1,-365.331,-117]],[1,43.388,388.112,0],[3,0,0,1,0],[1,-0.211,0.211,0.211],[1,-180,-180,0]],[27,0,{},6,[26,"106eX7MB9HSaqL11I0Gh9T",-121,[21,"c8dtXl61hJ3aB202/iTjBh",[[25,"Treasure",["_name"],[2,["106eX7MB9HSaqL11I0Gh9T"]]],[13,["_lpos"],[2,["106eX7MB9HSaqL11I0Gh9T"]],[1,-227.484,266.279,0]],[13,["_lscale"],[2,["106eX7MB9HSaqL11I0Gh9T"]],[1,0.33,0.33,0.323]],[13,["_lrot"],[2,["106eX7MB9HSaqL11I0Gh9T"]],[3,0,0,0,1]],[13,["_euler"],[2,["106eX7MB9HSaqL11I0Gh9T"]],[1,0,0,0]],[25,true,["_active"],[2,["106eX7MB9HSaqL11I0Gh9T"]]],[4,["_anchorPoint"],-119,[0,0.5,0.2]],[4,["_contentSize"],-120,[5,171,207]]]],13]],[50,"Moveset",33554432,6,[7,8],[[7,-122],[220,44,12,12,-303.449,100,-123]],[1,0,-315.449,0],[1,0.76,0.76,0.76]],[2,["85GZNBcDBFHoQLqtWRJROe"]],[2,["e7XxNEodhFPrGARFU3Hnd8"]],[35,"StepPlaceholder",33554432,12,[[1,-124,[5,581.9020207300815,71.7265183226849]],[157,1,-16,true,-125],[98,false,8,33.294397236961046,-126,8]]],[35,"Steps",33554432,12,[[1,-127,[5,581.9020207300815,71.7265183226849]],[157,1,-16,true,-128],[98,false,8,33.294397236961046,-129,8]]],[8,"UI_Btn_Back",33554432,2,[[1,-130,[5,278,272]],[12,-131,29],[97,9,75.95157116451,155.5806820702402,416.80100000000004,278,-132],[80,-133,[[9,"f10f825x4RA447/cnjy5wGi","BackToLevelSelection",2],[9,"2aba7MT17hBdIg/s6Nuvdoa","DestroyMap",1],[9,"5c3c5daSIVPLp7akyPQKmsk","HideWinBanner",1]],30]],[1,-783.2,1482.911,0]],[24,"ArrowLeft",33554432,2,[[1,-134,[5,292,423]],[12,-135,35],[221,8,50,-136],[71,1,-137,[[9,"5c3c5daSIVPLp7akyPQKmsk","MoveStepRight",1]],[4,4288059030],36]],[1,-883.9492127171903,-1374.985,0],[1,0.4397421811460258,0.4397421811460258,1.8585978124999996]],[60,"ArrowRight",33554432,2,[[1,-138,[5,292,423]],[12,-139,37],[222,32,50,-140],[71,1,-141,[[9,"5c3c5daSIVPLp7akyPQKmsk","MoveStepLeft",1]],[4,4288059030],38]],[1,883.9492127171903,-1374.9860785951942,0],[3,0,1,0,1.366449077874006e-16],[1,0.4397421811460258,0.4397421811460258,1.8585978124999996],[1,0,180,0]],[94,"Guide",33554432,3,[-148],[[7,-142],[254,-147,-146,-145,-144,14,9,-143]],[1,1,1,2.189]],[2,["02i9O3FHBBNq4cBFjrUBnI"]],[2,["18NLOBC89MdYgPs3XeW7RQ"]],[94,"LoseBanner",33554432,3,[-150,17],[[1,-149,[5,1080,1920]]],[1,1.315,1.315,1.315]],[24,"UI_Btn_Back",33554432,17,[[1,-151,[5,191,196]],[12,-152,54],[97,9,851.0079999999999,-41.70399999999999,416.80100000000004,278,-153],[80,-154,[[9,"f10f825x4RA447/cnjy5wGi","BackToLevelSelection",2],[9,"2aba7MT17hBdIg/s6Nuvdoa","DestroyMap",1],[9,"5c3c5daSIVPLp7akyPQKmsk","HideWinBanner",1]],55]],[1,331.3979999999999,112.864,0],[1,0.58,0.58,0.057]],[78,"mainGame",[3,-161,-162],[120,"a0756c18-11fb-46cf-9374-c68a11921468",[[158,["BodyAnim"],-160,4,[2,["ccSFVpwiROFJQG1ycigKnl"]]],[40,["_trailModule","_particleSystem"],10,[2,["18NLOBC89MdYgPs3XeW7RQ"]],10,[2,["18NLOBC89MdYgPs3XeW7RQ"]]]],[20,4,-155,-156,-157,-158,-159,10]],[68,[128,[2,0,0,0,0.520833125],[2,0,0,0,0]],[99,[4,4283190348]],[69],[79],[70]]],[35,"Bg",33554432,3,[[1,-163,[5,1480,2320]],[10,0,-164,0],[125,45,-200,-200,-200,-200,1080,1920,-165]]],[181,"LevelNumber",33554432,19,[[1,-166,[5,100,63]],[62,"难度",50,50,50,false,-167,[4,4286316599],11]],[3,0,0,-0.020907520941156242,0.9997814138941047],[1,2.014,-2.014,2.014],[1,0,0,-2.396]],[50,"UI_Toy_Collection_leftside_bar_slot",33554432,7,[-170],[[1,-168,[5,383,373]],[12,-169,18]],[1,310.707,6.733,0],[1,0.394,0.394,0.547]],[27,0,{},37,[26,"85GZNBcDBFHoQLqtWRJROe",-175,[21,"2dVML4LPtMh6hvqP9MAzdI",[[6,"Codespark_UI_Counterclockwise_active",["_name"],22],[4,["_lpos"],22,[1,0,0,0]],[4,["_lscale"],22,[1,1.763285024154589,1.763285024154589,0.5147826086956522]],[4,["_lrot"],22,[3,0,0,0,1]],[4,["_euler"],22,[1,0,0,0]],[6,1,["clickEvents","length"],-171],[82,["clickEvents","0"],-172,[230,"5c3c5daSIVPLp7akyPQKmsk","TurnLeft","0",1]],[13,["_contentSize"],[2,["f1aAtYg5JBd4/RIL9j2O0y"]],[5,203,187]],[6,1,["_transition"],-173],[4,["_pressedColor"],-174,[4,4288059030]]]],17]],[2,["ccksu5MMdCj4GGlaNEeWxz"]],[50,"UI_Toy_Collection_leftside_bar_slot-001",33554432,7,[-178],[[1,-176,[5,383,373]],[12,-177,20]],[1,2.087,6.733,0],[1,0.394,0.394,0.547]],[27,0,{},40,[26,"e7XxNEodhFPrGARFU3Hnd8",-183,[21,"c1a8LxkyRIOJjvRvmQmjnF",[[6,"Codespark_UI_Clockwise_active",["_name"],23],[4,["_lpos"],23,[1,-2.2737367544323206e-13,0,0]],[4,["_lscale"],23,[1,1.763285024154589,1.763285024154589,0.5147826086956522]],[4,["_lrot"],23,[3,0,0,0,1]],[4,["_euler"],23,[1,0,0,0]],[6,1,["clickEvents","length"],-179],[82,["clickEvents","0"],-180,[9,"5c3c5daSIVPLp7akyPQKmsk","TurnRight",1]],[13,["_contentSize"],[2,["e514XZZXpIk7eGgjZDBhe6"]],[5,203,187]],[6,1,["_transition"],-181],[4,["_pressedColor"],-182,[4,4288059030]]]],19]],[2,["d34K/FBW5ENZTwQV7Fkx6Q"]],[50,"UI_Toy_Collection_leftside_bar_slot-002",33554432,7,[-186],[[1,-184,[5,383,373]],[12,-185,22]],[1,-306.534,6.733,0],[1,0.394,0.394,0.547]],[27,0,{},43,[26,"e9Yu+ETB5G7IfsauYyit8Q",-190,[236,"27hPKNkUhNMa5wHrUYttcL",null,[[25,"Codespark_UI_forward_active 02",["_name"],[2,["e9Yu+ETB5G7IfsauYyit8Q"]]],[13,["_lpos"],[2,["e9Yu+ETB5G7IfsauYyit8Q"]],[1,0,0,0]],[13,["_lscale"],[2,["e9Yu+ETB5G7IfsauYyit8Q"]],[1,1.763285024154589,1.763285024154589,0.5147826086956522]],[13,["_lrot"],[2,["e9Yu+ETB5G7IfsauYyit8Q"]],[3,0,0,0,1]],[13,["_euler"],[2,["e9Yu+ETB5G7IfsauYyit8Q"]],[1,0,0,0]],[25,1,["clickEvents","length"],[2,["997y3IwBhGJ72D11OkCwwK"]]],[82,["clickEvents","0"],-187,[9,"5c3c5daSIVPLp7akyPQKmsk","MoveForward",1]],[13,["_contentSize"],[2,["46xKwuoh5Di5pfqmTV2jKh"]],[5,203,186]],[6,1,["_transition"],-188],[4,["_pressedColor"],-189,[4,4288059030]]]],21]],[27,0,{},29,[26,"d8U4lD0QtChYN/bnd/uMHI",-195,[21,"2bPOcsbilIxI8enfWvOIk+",[[6,"UI_Tutorial_Hands",["_name"],-191],[4,["_lpos"],-192,[1,-288.89,-433.013,0]],[4,["_lrot"],-193,[3,0,0,0,1]],[4,["_euler"],-194,[1,0,0,0]]]],40]],[2,["d8U4lD0QtChYN/bnd/uMHI"]],[27,0,{},5,[26,"7dpTyH9uRFJawmY5ekg9n+",-196,[21,"97X6wPY+9EM6k6Bb0aO14a",[[6,"transition",["_name"],15],[4,["_lpos"],15,[1,0,385.162,0]],[4,["_lrot"],15,[3,0,0,0,1]],[4,["_euler"],15,[1,0,0,0]],[6,true,["_active"],15],[4,["_lscale"],15,[1,0.734,0.734,0.734]]]],42]],[196,"Confetti-001",33554432,10,[[-197,[246,-198],[7,-199]],1,4,4],[1,869.695,10.906,0],[3,0.7044160264027586,0.061628416716219346,0.06162841671621935,0.7044160264027587],[1,100,100,100],[1,90,0,10]],[60,"UI_btn_check_mark",33554432,17,[[1,-200,[5,150,155]],[12,-201,52],[80,-202,[[9,"5c3c5daSIVPLp7akyPQKmsk","HideWinBanner",1],[9,"5c3c5daSIVPLp7akyPQKmsk","ResetMove",1]],53]],[1,8.305,-126.274,0],[3,0,0,0.03721055383141619,0.9993074475273159],[1,1.005,1.005,1.005],[1,0,0,4.265]],[65,"Camera",3,[-203],[1,0,0,1000]],[41,"Shadow",33554432,11,[[1,-204,[5,46,45]],[96,-205,[4,2365587455],14]],[1,1,1,0.046]],[2,["997y3IwBhGJ72D11OkCwwK"]],[2,["95i89SZW5PjYtr0wXfh3J8"]],[35,"Blur",33554432,32,[[1,-206,[5,1080,1920]],[96,-207,[4,3053453311],50]]],[24,"Lose",33554432,17,[[1,-208,[5,324.45,88.2]],[62,"再试一次?",70,70,70,false,-209,[4,4278190080],51]],[1,0,17.494,0],[1,1.396,1.396,1.396]],[137,0,1073741824,960,0,2000,41943040,50,[4,4278190080]],[2,["c0VSg60wxHZKXaeskLcEZH"]],[266,4],[2,["83CtKnZl9MBayHV0ubsRL3"]],[248,false,1.2,48,[46],[55],[138,3,0.8,1.5],[11],[11],[22,7],[11],[11],[11],[11],[22,5],[22,0.2],[22,10],[11],[[141,1,[22,1]]],[142,[55]],[143,true,0,[22,1]],[144,true,[139,1,[145,[0.023076923076923078,0.1358974358974359,0.7256410256410256,0.9974358974358974],[[84,2],[85,2,1],[85,2,0.9962962962962963],[84,2]]]],[11],[11],[11]],[146,true,[22,1],[22,1],[11],[22,1.4]],[147,[11],[11],[11]],[148,true,0.2,[11],[11],[11],[11]],[149,true,[11],[11],[22,3.141592653589793]],[150,true,5,1,1,1,true,[11],[140,3,5]],[151,[22,1],[11],[55],[55],-210],[152,47]],[57,"PlanetExplore","60bsjPx2hJSZH2u9Or4K73",34,[[279,-211]]],[92,"Directional Light","a7o+uBPlFEhISEvEbIPzTV",34,[[239,85000,-212,[136]]],[1,910.95,0,1206.987]]],0,[0,0,1,0,54,36,0,39,20,0,55,4,0,40,11,0,56,18,0,0,1,0,57,32,0,58,5,0,59,14,0,60,13,0,61,9,0,62,24,0,63,25,0,0,1,0,64,50,0,39,20,0,40,11,0,0,1,0,0,2,0,0,2,0,0,2,0,-1,26,0,-2,9,0,-3,13,0,-4,14,0,-5,27,0,-6,28,0,0,3,0,21,56,0,0,3,0,0,3,0,-1,50,0,-2,35,0,-4,6,0,-6,29,0,-7,32,0,-8,5,0,2,59,0,65,4,0,2,59,0,0,4,0,-2,58,0,7,4,0,0,5,0,0,5,0,66,10,0,67,16,0,68,47,0,0,5,0,-1,47,0,-2,16,0,-3,10,0,0,6,0,-1,18,0,-2,19,0,-3,20,0,-4,11,0,-5,21,0,0,7,0,0,7,0,0,7,0,-1,37,0,-2,40,0,-3,43,0,0,8,0,0,8,0,-1,12,0,0,9,0,0,9,0,12,29,0,0,9,0,0,9,0,2,30,0,2,30,0,2,30,0,2,30,0,2,30,0,2,53,0,2,31,0,2,31,0,2,31,0,2,31,0,2,31,0,2,53,0,2,53,0,-1,48,0,7,10,0,0,11,0,-1,51,0,0,12,0,0,12,0,0,12,0,-1,24,0,-2,25,0,0,13,0,0,13,0,0,13,0,0,13,0,0,14,0,0,14,0,0,14,0,0,16,0,0,16,0,0,16,0,0,16,0,0,17,0,0,17,0,-1,55,0,-2,49,0,-3,33,0,0,18,0,0,18,0,0,18,0,0,19,0,0,19,0,0,19,0,-1,36,0,2,57,0,2,57,0,7,20,0,0,21,0,0,21,0,0,24,0,0,24,0,0,24,0,0,25,0,0,25,0,0,25,0,0,26,0,0,26,0,0,26,0,0,26,0,0,27,0,0,27,0,0,27,0,0,27,0,0,28,0,0,28,0,0,28,0,0,28,0,0,29,0,33,45,0,69,38,0,70,41,0,71,44,0,0,29,0,-1,45,0,0,32,0,-1,54,0,0,33,0,0,33,0,0,33,0,0,33,0,-3,38,0,-4,41,0,-5,44,0,-6,45,0,-7,47,0,17,58,0,-2,61,0,-3,62,0,0,35,0,0,35,0,0,35,0,0,36,0,0,36,0,0,37,0,0,37,0,-1,38,0,2,39,0,2,39,0,2,39,0,2,39,0,7,38,0,0,40,0,0,40,0,-1,41,0,2,42,0,2,42,0,2,42,0,2,42,0,7,41,0,0,43,0,0,43,0,-1,44,0,2,52,0,2,52,0,2,52,0,7,44,0,2,46,0,2,46,0,2,46,0,2,46,0,7,45,0,7,47,0,-1,60,0,0,48,0,0,48,0,0,49,0,0,49,0,0,49,0,-1,56,0,0,51,0,0,51,0,0,54,0,0,54,0,0,55,0,0,55,0,36,60,0,0,61,0,0,62,0,23,34,1,4,3,2,4,3,3,4,34,4,4,11,7,4,21,8,4,21,17,4,32,212],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,-1,-2,-3,-4,-5,-1,-2,-3,-4,-5,9,1,5,1,5,22,5,1,5,1,5,1,1,1,-1,-2,-3,72,1,6,1,6,1,6,1,6,1,6,1,5,6,5,1,6,5,-1,37,1,73,1,9,1,6,1,6,1],[10,111,112,113,114,115,116,117,118,119,120,1,121,122,123,124,64,125,42,126,42,127,42,43,128,129,130,131,132,17,17,65,65,32,32,33,33,33,33,66,57,66,133,19,19,134,54,36,43,135,10,1,32,32,16,16,43]],[[[18,"transition"],[182,"transition",33554432,[-5,-6],[[95,-2,[0,"80QeH1j2JG2bew7XoAAOA6"]],[108,-3,[0,"0ehuvVehxGILxkt3d9qTkd"],2],[280,-4,[0,"624xmpxpVCsLRUmPqbAnDI"],[3,4,5]]],[3,"7dpTyH9uRFJawmY5ekg9n+",-1,0]],[14,"Fragments+right",33554432,1,[[5,-7,[0,"56NEGZrvFBZKcbv3w317oZ"],[5,400,1280]],[29,2,-8,[0,"56hUraoWdM0rzuz0aPKxax"],0]],[3,"90DIz0IRJIopiwASMMPpdu",1,0],[1,1155.322,58.68,0],[1,2,2,1]],[183,"Fragments_left",33554432,1,[[5,-9,[0,"a64HDp6u5EwZ8PPBYG7pHT"],[5,400,1280]],[29,2,-10,[0,"1flgRXsr1Ne6WvlHhfbT0k"],1]],[3,"2bh6lF639OzpkrTcfK7vpm",1,0],[1,-1158.328,-39.97,0],[3,6.123233995736766e-17,6.123233995736766e-17,-1,-6.123233995736766e-17],[1,2,2,1],[1,180,180,7.016709298534876e-15]]],0,[0,7,1,0,0,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,0,2,0,0,2,0,0,3,0,0,3,0,10,1,10],[0,0,0,0,0,0],[1,1,22,-1,-2,-3],[34,34,67,44,45,46]],[[[86,[[87,[88,[-14,-15,-16,-17,-18,-19,-20],[[89,-5,-4,[[44,[36,"Open"]]]],[251,2.5,-7,-6,[[44,[36,"Open"]]]],[106,-9,-8],[63,false,-11,-10,[[44,[36,"Open"]]]],[63,false,-13,-12,[[44,[36,"Close"]]]]],-3,-2,-1]]],[{},"Close",4,[59,1,false],"Open",4,[59,1,false]]],[30,"Empty",[154]],[37,"Entry"],[30,"DeactiveSprite",[33,0]],[30,"Close",[33,1]],[30,"Open",[33,2]],[37,"Exit"],[37,"Any"]],0,[0,27,7,0,28,6,0,29,2,0,13,3,0,14,5,0,13,5,0,14,4,0,13,1,0,14,2,0,13,1,0,14,3,0,13,4,0,14,1,0,-1,2,0,-2,6,0,-3,7,0,-4,3,0,-5,4,0,-6,5,0,-7,1,20],[0,0,0],[15,15,15],[46,45,44]],[[{"name":"black-circle-fade-transparent","rect":{"x":1838,"y":3,"width":46,"height":45},"offset":{"x":0,"y":-0.5},"originalSize":{"width":50,"height":50},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[[18,"Model_WinScreen"],[184,"Model_WinScreen",33554432,[-5,-6],[[268,true,-2,[0,"a85ZQlxx9GOIiJsK5nZhcF"],[4,5,6,7],8],[118,false,-3,[0,"56pQzN0x1Lf5MU5NpK4+A0"]],[108,-4,[0,"5a/gPGsFZB2phdW8WsGxH7"],9]],[3,"57+Sx0ZJNCe5iZkbGFTgn3",-1,0],[1,175.617,175.617,175.617]],[115,"Bip001 Xtra01",33554432,[[19,"R hand handle1",33554432,-7,[3,"5dzGkW4BRDvaqolgV4QXnl",1,0],[1,0.5100117921829224,-0.03201562166213989,-0.45077818632125854],[3,-0.005188420423502014,-0.7068445694211046,-0.09790486113521249,0.7005415570396214],[1,-8.448483427837095,-91.06499193160911,-7.460233031588316]],[19,"R hand handle2",33554432,-8,[3,"7cFmwjz45GV6w6+LzB7ULc",1,0],[1,0.2482302188873291,-0.8186889886856079,-0.5586746335029602],[3,-0.025460728985730388,-0.697277535255075,-0.11748181848691609,0.706649709851444],[1,-11.627194806311339,-89.99976177097336,-7.500254563933692]],[19,"L hand handle2",33554432,-9,[3,"4fJvuLChtIKrbNUOY93GVI",1,0],[1,0.2816418409347534,-0.8178844451904297,0.6075959205627441],[3,0.05604491530924374,-0.6981601303515795,0.14023021234062308,0.6998334711932184],[1,16.032384555808207,-90.81843994511613,6.77778383509979]],[19,"L hand handle1",33554432,-10,[3,"47JPqnn8FLAY+C//wN92JS",1,0],[1,0.5100117325782776,-0.03201943635940552,0.45100128650665283],[3,-0.10807455599566979,-0.7104745087690618,0.032465518327416114,0.6946163350047502],[1,-6.0919464591023464,-90.68144331892557,11.45922968505323]]],[3,"03/WEsTm9Nv7zDaLqVJpqs",1,0],[1,0.24099814891815186,-0.5346709489822388,-0.0000022221356630325317],[3,5.66752508525438e-11,-0.000002784897083942903,0.9999964754732449,0.0026550015691793652],[1,179.99968087090986,-179.99999914621426,0.3042411264629999]],[61,"Bip001 Spine",33554432,[-11,-12,-13],[3,"e2eNPDbERJK4q5olPgiBG2",1,0],[1,0.06027185916900635,0.032107848674058914,0.0017063021659851074],[3,0.01831307293887407,0.02004462701512546,0.051330083007181865,0.9983126097900575],[1,1.9880965062524896,2.1976265180429233,5.924685929600534]],[117,"Bip001 Neck",33554432,[[-14,-15,[19,"Bip001 Head",33554432,-16,[3,"baUbi45ApM46rWBu4TGwW6",1,0],[1,0.06547927856445312,-0.000014360994100570679,1.862645149230957e-9],[3,0.03445632421258817,0.011725077534988505,-0.04653003863194179,0.9982535949263923],[1,4.024421030307099,1.5316579143910214,-5.2838288446271795]]],1,1,4],[3,"6ffoeV5iFIiItbgbHAgFBQ",1,0],[1,0.3603935241699219,-0.06606259942054749,-1.862645149230957e-9]],[61,"Bip001 L Hand",33554432,[-17,-18,-19],[3,"57QYhFVfVDUZLDBnA3cFqy",1,0],[1,0.27253085374832153,-5.960464477539063e-8,0],[3,-0.7419664123320368,-0.09395094038083236,-0.025406443964477346,0.6633351915719257],[1,-95.90594946615346,-9.396061037980928,6.068126523038534]],[61,"Bip001 R Hand",33554432,[-20,-21,-22],[3,"19jfUBtwJFOaj9L1oGg/ik",1,0],[1,0.27253082394599915,5.960464477539063e-8,-5.960464477539063e-8],[3,0.7424006876752727,-0.16733713039192535,0.0373819833801062,0.6476434907030624],[1,96.15859035195534,-16.1331769299178,-11.539415377468101]],[113,"VD043_Jetpack_Flyer_Toy",33554432,1,[[156,-23,[0,"deK4S5J/BDppsnGkcHx01X"],[0,1],[72],1,2,3],[105,-24,[0,"9fD/cLYBVLPKZ6pOqG8AYh"]],[46,-25,[0,"eaTTAHt6VCd52VzN+/f5/s"],[5,1.8033320407970963,3.0591937802105322],[0,0.5,0.7]]],[3,"f05jiQfy5CYIB/ZpHzs1dj",1,0],[1,0.000004234213572207324,0.34442489582445646,-0.5965614189595705],[3,-0.7071067811865476,0,0,0.7071067811865475],[1,-90.00000000000001,0,0]],[20,"Bip001 Spine1",33554432,3,[4,2],[3,"d2z3rWXulHMq7Lp5JK+8p9",1,0],[1,0.30468177795410156,-0.00024194270372390747,-0.000008396804332733154],[3,0.01652411234166925,-0.023288617600632614,-0.03368326748875341,0.999024539985306],[1,1.8062750228980584,-2.6092475452322503,-3.9031688345757445]],[20,"Bip001",33554432,1,[-26],[3,"04xeQunGZMTburBNNTqJP1",1,0],[1,0.025053977966308594,0.7133909463882446,0.03748690336942673],[3,-0.4592295592545704,-0.5376878387195055,-0.5376878387195054,0.45922955925457043],[1,-90,-98.99990617392913,0]],[114,"Bip001 Pelvis",33554432,9,[3],[3,"d0yJnIF3ZPU59lH7XrcPCu",1,0],[3,0.5203319787540229,0.4855473935194539,0.518123626665281,-0.47439041729740306],[1,-94.4967349616145,-90.48229397300277,0.7853151089261627]],[20,"Bip001 L Clavicle",33554432,4,[-27],[3,"e5vJUewNdBe7rlP/pJSPGV",1,0],[1,-0.15008139610290527,-0.029379824176430702,0.16028693318367004],[3,0.7379414630554331,-0.0002946540265846981,0.6748646076676733,0.00026758207934930825],[1,179.95458604417567,-84.88728416552377,-0.0042233576805496]],[20,"Bip001 L UpperArm",33554432,11,[-28],[3,"295FoiHIxEiIoaDzA3FAn7",1,0],[1,0.1752856969833374,1.30385160446167e-8,0],[3,-0.1909291589128922,0.5413013679400174,0.055306404652568766,0.8169945452372911],[1,-21.986797837186934,65.75393827764961,-6.680364579993282]],[20,"Bip001 L Forearm",33554432,12,[5],[3,"52fiMr335JZLE9vYJJpLYw",1,0],[1,0.30327725410461426,5.551115123125783e-17,5.960464477539063e-8],[3,1.4625413342768572e-17,-3.263487547518527e-17,-0.6823387669725535,0.7310361188658021],[1,-1.9273518689805456e-14,-2.31052198399669e-14,-86.05334796136489]],[28,"Bip001 L Finger0",33554432,5,[[19,"Bip001 L Finger01",33554432,-29,[3,"d1ZSYfmkRMHLZHRZUqGe1X",1,0],[1,0.12686099112033844,-5.960464477539063e-8,2.220446049250313e-16],[3,6.7717409268558375e-9,3.1071960473302073e-9,0.4170408535278855,0.9088877414118494],[1,8.537736078717935e-7,-3.8379800353244007e-14,49.29580931519125]]],[3,"2fTGeQUb5Ge4UQNX/Z8OkZ",1,0],[1,0.05214601755142212,0.010561108589172363,-0.07510733604431152],[3,0.6746811945821796,0.29407200561851043,0.24056166692344885,0.6328167393453507],[1,92.10049931983626,3.827088343668838,44.52919453220961]],[28,"Bip001 L Finger1",33554432,5,[[19,"Bip001 L Finger11",33554432,-30,[3,"41A/xoIwlPZKobYdGdYUEj",1,0],[1,0.11407226324081421,5.960464477539063e-8,5.960464477539063e-8],[3,-4.066922923868787e-9,1.4455938225677603e-8,0.7127351384477825,0.7014332629850256],[1,-179.99990567592812,179.999906517761,89.08421659248222]]],[3,"3cX1kdYeBFc4F3cOKSqdZC",1,0],[1,0.13685476779937744,-0.06003260612487793,-0.017368435859680176],[3,-0.1673444815267504,0.08695138286027557,0.2768333269045508,0.9422306461987887],[1,-24.688426747642307,17.142431839455604,29.510300381098883]],[28,"Bip001 L Finger2",33554432,5,[[19,"Bip001 L Finger21",33554432,-31,[3,"3cTu60ZelEK5oqhxbKtgx6",1,0],[1,0.11604306101799011,1.1102230246251565e-16,1.1102230246251565e-16],[3,0.005586658533918401,0.02709030512049791,0.581860832975312,0.8128178613097644],[1,-3.9771057377360717,6.661465414910693,71.11965907439375]]],[3,"5c5CQp14ROopqgwAE9emDu",1,0],[1,0.13624519109725952,-0.048795878887176514,0.09180718660354614],[3,-0.13856673351836557,0.07784738454096357,0.36049381187707236,0.9191209151578041],[1,-23.893264133111604,18.45982424655009,39.87394415309718]],[20,"Bip001 R Clavicle",33554432,4,[-32],[3,"09iuC+z89PYZG6EKSWk1I3",1,0],[1,-0.15008139610290527,-0.02937893196940422,-0.16028745472431183],[3,0.7480214735998131,-0.0002969640733798371,-0.6636744054438308,-0.0002653388038828932],[1,-179.95467140421664,83.16142932137103,-0.005275443688355604]],[20,"Bip001 R UpperArm",33554432,17,[-33],[3,"51WRLpmDBG/6/1kHEOPeZo",1,0],[1,0.17528563737869263,-5.587935447692871e-9,2.220446049250313e-16],[3,0.20653430849426985,-0.547382049607393,0.06835500062185525,0.8081114187241694],[1,24.292656874925044,-66.79363258623155,-6.639931109062676]],[20,"Bip001 R Forearm",33554432,18,[6],[3,"0f9U8rOUhGYpX8uGzOJbkz",1,0],[1,0.30327725410461426,-5.960464477539063e-8,0],[3,0,0,-0.6512993580123281,0.7588208920771287],[1,0,0,-81.27927936718207]],[28,"Bip001 R Finger0",33554432,6,[[19,"Bip001 R Finger01",33554432,-34,[3,"89Q5QXG0lApqar9KvUoqYK",1,0],[1,0.12686097621917725,-5.551115123125783e-17,0],[3,4.6844838988063015e-8,5.099695762537187e-9,0.417040853527885,0.9088877414118484],[1,0.000007107554750065308,-0.0000026183196263363308,49.29580931519113]]],[3,"a9lrzvvgpCsJ6N1czd/KaS",1,0],[1,0.052145957946777344,0.010561227798461914,0.07510733604431152],[3,-0.7992934893017968,-0.2846068551680877,0.14495339058835943,0.5090357261607757],[1,-113.61955784540162,-4.169697231212765,37.05215275548036]],[28,"Bip001 R Finger1",33554432,6,[[19,"Bip001 R Finger11",33554432,-35,[3,"9a85AsXXxBsKVZ9ZyRE7sx",1,0],[1,0.11407217383384705,-1.1920928955078125e-7,-5.960464477539063e-8],[3,-1.6841125531131413e-10,2.1072748647615377e-8,0.7127351086492664,0.7014332932636701],[1,-179.99989146868464,179.99989316258515,89.08422146059704]]],[3,"f6aNrfsT9GRbt0mNU3Ie+T",1,0],[1,0.1368546485900879,-0.06003260612487793,0.01736849546432495],[3,0.16734449633585335,-0.08695136046070064,0.2768333267522613,0.9422306456804558],[1,24.688427931148876,-17.1424295363662,29.510300667330508]],[28,"Bip001 R Finger2",33554432,6,[[19,"Bip001 R Finger21",33554432,-36,[3,"fdUItpNQdDS5HC67i8+Dwe",1,0],[1,0.1160430908203125,5.960464477539063e-8,0],[3,-0.0055866544205679615,-0.027090301771503896,0.5818609006622605,0.8128178129955181],[1,3.977108907119225,-6.661467934225278,71.11966855597838]]],[3,"976N/H9sJAmr/osVgE2xgW",1,0],[1,0.13624513149261475,-0.04879593849182129,-0.09180724620819092],[3,0.1385667058573379,-0.07784737829337175,0.3604937876455218,0.9191209293611369],[1,23.893258845831284,-18.459820830051857,39.87394204293123]],[20,"Bip001 L Thigh",33554432,3,[-37],[3,"0a7nAplvhDvrnfWCE/ywr0",1,0],[1,-0.06955111026763916,-0.019373338669538498,0.16432179510593414],[3,0.1365471175158444,0.9795017773234587,0.11902838866105335,-0.08811013341865497],[1,-15.392582147897418,-167.78117226829093,14.271742314915677]],[20,"Bip001 L Calf",33554432,23,[-38],[3,"16AsR+vFdPo5TBnt401ogX",1,0],[1,0.2833104133605957,2.7755575615628914e-17,0],[3,-7.94353597486993e-18,9.663437981896868e-18,-0.2905194084380881,0.9568690993656257],[1,-6.60848836659558e-16,9.566188430703192e-16,-33.77810960344908]],[28,"Bip001 L Foot",33554432,24,[[19,"Bip001 L Toe0",33554432,-39,[3,"a4Po7DD9VG27HRx/Ocz1Az",1,0],[1,0.12055830657482147,0.1753564178943634,2.9802322387695312e-8],[3,-4.913837954028883e-7,0.0000010259031062596675,0.7071069003953715,0.7071066619767884],[1,0,-0.00007963216615437602,90]]],[3,"53zvi657RI4Zc/UmRnDjPF",1,0],[1,0.32318341732025146,-5.204170427930421e-18,2.9802322387695312e-8],[3,-0.14829636816999522,-0.12443219624282932,0.16820883418307833,0.9665560531229138],[1,-15.22628584512692,-11.801937960540801,21.227512760199243]],[20,"Bip001 R Thigh",33554432,3,[-40],[3,"b1uggZz9VNZ7N6ufXN7OzN",1,0],[1,-0.056758761405944824,-0.03232694789767265,-0.1705644577741623],[3,0.28349079891924855,0.9339861013533769,-0.19430671090902984,0.0977130058004596],[1,28.712520919353565,160.36008287869288,29.444506192928287]],[20,"Bip001 R Calf",33554432,26,[-41],[3,"f6SWBV5t1AV4zqbTsZlcxo",1,0],[1,0.2833103537559509,0,0],[3,7.552592260718814e-17,-3.7706441708005647e-17,-0.293513440263538,0.9559549468383238],[1,8.46347372924871e-15,-1.9213213508359334e-15,-34.136836267456545]],[28,"Bip001 R Foot",33554432,27,[[19,"Bip001 R Toe0",33554432,-42,[3,"39oKOBrOxMab82Ga/V2huF",1,0],[1,0.12055831402540207,0.1753564327955246,2.9802322387695312e-8],[3,-1.7085779829572256e-7,2.716841368257836e-7,0.7071070494073549,0.7071065129655654],[1,0,-0.00002768870194162374,90]]],[3,"0brOumJUxIMbsCwEbD/Otx",1,0],[1,0.32318347692489624,-1.4901161193847656e-8,2.7755575615628914e-17],[3,0.11063275000585403,0.04712268448101054,0.03850727618625852,0.9919964903739128],[1,12.514328107823792,4.8928647296201335,4.9809656483770155]]],0,[0,7,1,0,0,1,0,0,1,0,0,1,0,-1,9,0,-2,7,0,4,2,0,4,2,0,4,2,0,4,2,0,-1,8,0,-2,23,0,-3,26,0,-1,11,0,-2,17,0,4,4,0,-1,14,0,-2,15,0,-3,16,0,-1,20,0,-2,21,0,-3,22,0,0,7,0,0,7,0,0,7,0,-1,10,0,-1,12,0,-1,13,0,4,14,0,4,15,0,4,16,0,-1,18,0,-1,19,0,4,20,0,4,21,0,4,22,0,-1,24,0,-1,25,0,4,25,0,-1,27,0,-1,28,0,4,28,0,10,1,2,4,8,3,4,10,4,4,8,5,4,13,6,4,19,42],[0,0,0,0,0,0,0,0,0,0],[-1,-2,24,38,-1,-2,-3,-4,25,22],[31,31,62,63,21,29,30,28,21,136]],[[{"name":"UI_triangle_white","rect":{"x":537,"y":1849,"width":218,"height":195},"offset":{"x":0,"y":0.5},"originalSize":{"width":256,"height":256},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[{"name":"UI_Name_tag","rect":{"x":274,"y":510,"width":450,"height":120},"offset":{"x":0,"y":0},"originalSize":{"width":450,"height":120},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[15]],[[{"name":"WeChat_Kinder_CRM_MP","rect":{"x":3,"y":874,"width":285,"height":284},"offset":{"x":0,"y":0},"originalSize":{"width":285,"height":284},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[[18,"Codespark_UI_Counterclockwise_active"],[51,"Codespark_UI_Counterclockwise_active",33554432,[[5,-2,[0,"f1aAtYg5JBd4/RIL9j2O0y"],[5,204,187]],[32,-3,[0,"89MGKhQIxIUalSvzu7ww06"],0],[100,-4,[0,"ccksu5MMdCj4GGlaNEeWxz"],1]],[3,"85GZNBcDBFHoQLqtWRJROe",-1,0],[1,1.763285024154589,1.763285024154589,0.5147826086956522]]],0,[0,7,1,0,0,1,0,0,1,0,0,1,0,10,1,4],[0,0],[1,6],[41,41]],[[{"fmt":"4_0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["bft5T1anhNwIzSqTh/MkAL"]}],[4],0,[],[],[]],[[{"name":"BG","rect":{"x":0,"y":0,"width":1080,"height":1920},"offset":{"x":0,"y":0},"originalSize":{"width":1080,"height":1920},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[68]],[[[18,"Codespark_UI_Level_Select_Button_Blank"],[185,"Codespark_UI_Level_Select_Button_Blank",33554432,[-8,-9,-10,-11],[[5,-1,[0,"37vZ4V7xZLxqy7bSRex6IP"],[5,221,231]],[29,0,-2,[0,"10v/Rih7dBUqyK0wIwuZ/D"],3],[47,1,-3,[0,"82FgLQ8UVIYLrUE170sm0V"],[[42]],[4,4288059030],4],[49,-7,[0,"2e163afOxKpokONOeI0W7q"],[-4,-5,-6]]],[66,null,"66KViboYhNvZM50LXbDcUO",0],[1,78.669,-790.341,0],[1,0.647,0.647,0.277]],[14,"Reward_star",33554432,1,[[5,-12,[0,"89ROzgf8pB9ZxebackmmE4"],[5,240,215]],[17,0,true,-13,[0,"06ZLbFSElLfbNaJ+7HF6FF"],0]],[66,null,"549ZAEI3dCj7jnSIbx+N3l",0],[1,92.59,67.584,0],[1,0.372,0.372,0.372]],[14,"Reward_star-001",33554432,1,[[5,-14,[0,"baGwbpwEdNsKkKMe1pvtSq"],[5,240,215]],[17,0,true,-15,[0,"d7vJkJPrtAMooU4vSfGQ44"],1]],[66,null,"d6l2vTfRRHYI703T6FdsBR",0],[1,-93.425,67.442,0],[1,0.372,0.372,0.372]],[14,"Reward_star-002",33554432,1,[[5,-16,[0,"1d7fFdQ6ZJCLntXjwMnFkW"],[5,240,215]],[17,0,true,-17,[0,"62DADpX01MebwyIb4IADv6"],2]],[66,null,"19Ud4sUg9G/5tX74YauyMW",0],[1,-1.022,119.028,0],[1,0.372,0.372,0.372]],[14,"levelNumber",33554432,1,[[5,-18,[0,"99rznLuktLOqSmFsj3GI+U"],[5,22.25,50.4]],[48,"2",40,-19,[0,"d0kghXV/VCOq9Tri/a9nW4"]]],[66,null,"baNUBJVU5BkIFeNBFNd2Se",0],[1,-5.683,2.525,0],[1,2.279,2.279,2.279]]],0,[0,0,1,0,0,1,0,0,1,0,-1,2,0,-2,3,0,-3,4,0,0,1,0,-1,5,0,-2,2,0,-3,3,0,-4,4,0,0,2,0,0,2,0,0,3,0,0,3,0,0,4,0,0,4,0,0,5,0,0,5,0,10,1,19],[0,0,0,0,0],[1,1,1,1,6],[2,2,2,6,6]],[[{"name":"UI_Sound Button","rect":{"x":572,"y":186,"width":141,"height":149},"offset":{"x":0,"y":-0.5},"originalSize":{"width":145,"height":150},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[15]],[[{"name":"satellite-2","rect":{"x":808,"y":1139,"width":137,"height":131},"offset":{"x":0,"y":0},"originalSize":{"width":137,"height":131},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[[18,"PathBlock"],[38,"PathBlock",33554432,[[46,-2,[0,"1aYjCXOtZJv7hl/nomQeRV"],[5,194,223],[0,0.5,0.37]],[29,0,-3,[0,"b6l2KzGNNHSbRTA2veiJf3"],0]],[3,"83ogn0V29AVJK7gdxZjOxw",-1,0],[1,174.06999999999994,3.638299999999994,0],[1,0.38,0.38,0.402]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[137]],[[{"name":"Neptune","rect":{"x":309,"y":1598,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"name":"Jupiter","rect":{"x":3,"y":1703,"width":300,"height":300},"offset":{"x":0,"y":0},"originalSize":{"width":300,"height":300},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"name":"Concept_Control_Panel_on","rect":{"x":3,"y":1775,"width":273,"height":175},"offset":{"x":0,"y":0},"originalSize":{"width":273,"height":175},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[{"name":"Space_Mission_Transition_Screen_Star","rect":{"x":552,"y":729,"width":758,"height":747},"offset":{"x":-1,"y":0.5},"originalSize":{"width":1024,"height":1024},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[13]],[[{"fmt":"0","w":0,"h":0},-1],[3],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["d2nEdyVJVD94XdhKTzZIWH"]}],[4],0,[],[],[]],[[{"name":"spaceship_hit_03","rect":{"x":0,"y":0,"width":287,"height":402},"offset":{"x":0,"y":0},"originalSize":{"width":287,"height":402},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[138]],[[[283,"m_lic_upm_space_solar_system",".m4a",41.193],-1],0,0,[],[],[]],[[[213,[{}],[{}]]],0,0,[0],[26],[35]],[[{"name":"UI_Button_Icon_Gift","rect":{"x":3,"y":479,"width":322,"height":389},"offset":{"x":-2,"y":-2.5},"originalSize":{"width":400,"height":400},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"name":"Master_Litho_KJ_Logo_CN_roundbar_18logo","rect":{"x":513,"y":636,"width":244,"height":174},"offset":{"x":0,"y":0},"originalSize":{"width":244,"height":174},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[15]],[[{"name":"Concept_Control_Panel","rect":{"x":409,"y":1100,"width":485,"height":158},"offset":{"x":0.5,"y":-4},"originalSize":{"width":512,"height":166},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[[18,"HighBlock3"],[38,"HighBlock3",33554432,[[46,-2,[0,"00cKxQTn1MAopVmZhfqvqi"],[5,194,223],[0,0.5,0.63]],[29,0,-3,[0,"a8t6YkFSJIP7L2coigyGir"],0]],[3,"77rtfdXLNEaK1LsKj6WLBZ",-1,0],[1,110.04999999999995,22.771699999999996,0],[1,0.38,0.38,0.402]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[139]],[[[67,"spaceExplore"],[64,"Canvas",33554432,"beI88Z2HpFELqR4T5EMHpg",[-5,-6,-7,-8,-9,-10,-11,-12,-13,-14],[[1,-1,[5,1080,1920]],[76,-3,-2],[77,45,-5.684341886080802e-14,-5.684341886080802e-14,-4]],[1,540,960,0]],[186,"PlanetInforPopupMM","9b6YkGOr5KMbuRyDSXxBo1",[[284,-19,-18,-17,-16,-15]]],[34,"Stars",33554432,1,[-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31],[[7,-20]]],[34,"Planets",33554432,1,[-33,-34,-35,-36,-37,-38,-39,-40,-41,-42],[[7,-32]]],[197,"SpaceShip",33554432,1,[-47,-48,-49,-50,-51],[[[1,-43,[5,348,671]],[285,true,2,0,1,-44],[286,2,364.2,-45,[0,0,-250]],-46],4,4,4,1],[1,0.35,0.35,1]],[202,"Camera",1,[-53,-54,-55,-56,-57,-58,-59],[-52],[1,0,0,1000]],[34,"EarthRoot",33554432,4,[-64,-65,-66],[[7,-60],[45,0,4,220,"地球\nTHE EARTH","地球是我们的家园，也是\n目前所知唯一有生命\n和表面有水的星球。",true,-63,-62,-61]]],[73,"GameIntro",false,33554432,1,[-72,-73,-74,-75,-76],[[7,-67],[287,500,-71,-70,-69,-68]]],[34,"PopupTutorial",33554432,1,[-78,-79,-80,-81,-82,-83],[[7,-77]]],[78,"spaceExplore",[1,-113,-114,2,-115,-116,-117],[120,"d89cb5df-a9d6-482f-922a-b1981fbf8c06",[[40,["startPos"],-92,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-91,[2,["27x+uvi5BMYYAGq5JEEecx"]]],[40,["endPos"],-94,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-93,[2,["77qhsoIsNDc7HJlAGV4x26"]]],[40,["startPos"],-96,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-95,[2,["27x+uvi5BMYYAGq5JEEecx"]]],[40,["endPos"],-98,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-97,[2,["77qhsoIsNDc7HJlAGV4x26"]]],[40,["startPos"],-100,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-99,[2,["27x+uvi5BMYYAGq5JEEecx"]]],[40,["endPos"],-102,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-101,[2,["77qhsoIsNDc7HJlAGV4x26"]]],[158,["animationFireEngine"],-104,-103,[2,["8fNPQvpVBBjrWQ7m8vs8Io"]]],[40,["startPos"],-106,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-105,[2,["27x+uvi5BMYYAGq5JEEecx"]]],[40,["endPos"],-108,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-107,[2,["77qhsoIsNDc7HJlAGV4x26"]]],[40,["startPos"],-110,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-109,[2,["27x+uvi5BMYYAGq5JEEecx"]]],[40,["endPos"],-112,[2,["9cCRIPV0NLxZ9VFAKlXck0"]],-111,[2,["77qhsoIsNDc7HJlAGV4x26"]]]],[-84,-85,-86,-87,-88,-89,-90]],[68,[128,[2,0,0,0,0.520833125],[2,0,0,0,0]],[99,[4,4283190348]],[69],[79],[70]]],[23,"MoonRoot",33554432,4,[-123,-124,-125],[[7,-118],[45,1,5,200,"月球\nTHE MOON","月球绕地球公转，也是\n人类在地球之外唯一到\n过的星球。",true,-121,-120,-119],[110,0.5,10,-122,7]],[1,276.84,-869.047,0]],[23,"SunRoot",33554432,4,[-130,-131,-132],[[1,-126,[5,1000,1000]],[45,4,4,1500,"太阳\nTHE SUN","太阳是太阳系中心的一\n颗炽热的红色星球，所\n有的行星都围绕它转。\n太阳的直径约为地球的\n一百倍。没有太阳的温\n暖，人们就无法生存。",false,-129,-128,-127]],[1,0,-6709.87,0]],[73,"PopupInfor",false,33554432,6,[-134,-135,-136,-137],[[7,-133]]],[23,"MercuryRoot",33554432,4,[-142,-143,-144],[[7,-138],[45,3,3,200,"水星\nMECURY","水星是太阳系中\n最小的行星，\n也是离太阳最近的行星。",true,-141,-140,-139]],[1,1528.135,-4246.834,0]],[23,"VenusRoot",33554432,4,[-149,-150,-151],[[7,-145],[45,2,5,270,"金星\nVENUS","金星是离太阳\n第二远的行星，也是\n太阳系中最热的行星。",true,-148,-147,-146]],[1,-1165.671,-3102.814,0]],[23,"MarsRoot",33554432,4,[-156,-157,-158],[[7,-152],[45,5,4,210,"火星\nMARS","火星是一个尘土飞扬\n的寒冷星球，\n表面布满了红色沙漠。",true,-155,-154,-153]],[1,1251.584,1251.912,0]],[23,"JupiterRoot",33554432,4,[-163,-164,-165],[[7,-159],[45,6,3,400,"木星\nJUPITER","木星是一颗巨大的行星，\n体积约为太阳系中所有\n其他行星总和的两倍。",true,-162,-161,-160]],[1,-1130.35,2170.372,0]],[23,"SaturnRoot",33554432,4,[-170,-171,-172],[[7,-166],[45,7,0,300,"土星\nSATURN","土星是离太阳第六远\n的行星，围绕着独特\n的冰环。",false,-169,-168,-167]],[1,892.357,3458.279,0]],[23,"UranusRoot",33554432,4,[-177,-178,-179],[[7,-173],[45,8,0,220,"天王星\nURANUS","天王星是距太阳第七远\n的行星，也是唯一一颗\n躺着自转的行星。",false,-176,-175,-174]],[1,-1006.539,4009.785,0]],[23,"NeptuneRoot",33554432,4,[-184,-185,-186],[[7,-180],[45,9,0,220,"海王星\nNEPTUNE","海王星是太阳系中\n离太阳最远的行星，\n不仅黑暗寒冷，\n还刮着大风。",false,-183,-182,-181]],[1,753.6,5228.764,0]],[34,"MeteoriteMM",33554432,1,[-188,-189,-190,-191,-192],[[7,-187]]],[27,0,{},21,[26,"ae624fktNKxpIfBpP6HqMD",-201,[21,"b6LRPxZVNJNIy02RuyzgsF",[[6,"MeteoriteRoot",["_name"],-193],[4,["_lpos"],-194,[1,0,0,0]],[4,["_lrot"],-195,[3,0,0,0,1]],[4,["_euler"],-196,[1,0,0,0]],[13,["_contentSize"],[2,["eaShLzs1dHVKFM/c/WKIqN"]],[5,234,172]],[25,0.04,["speed"],[2,["9cCRIPV0NLxZ9VFAKlXck0"]]],[6,100,["_radius"],-197],[13,["_lpos"],[2,["27x+uvi5BMYYAGq5JEEecx"]],[1,-5068.477,43.895,0]],[13,["_lpos"],[2,["77qhsoIsNDc7HJlAGV4x26"]],[1,3666.21,671.052,0]],[4,["_lscale"],-198,[1,0.7,0.7,1]],[4,["_lpos"],-199,[1,0,601.384,0]],[25,4,["_group"],[2,["abvokjWpdGc5Rau0u40Gfo"]]],[6,4,["_group"],-200]]],105]],[27,0,{},21,[26,"ae624fktNKxpIfBpP6HqMD",-208,[21,"505H9VjTBMXI9Dsvdy9m4Y",[[6,"MeteoriteRoot-001",["_name"],-202],[4,["_lpos"],-203,[1,0,2165.132,0]],[4,["_lrot"],-204,[3,0,0,0,1]],[4,["_euler"],-205,[1,0,0,0]],[4,["_lpos"],-206,[1,0,0,0]],[13,["_contentSize"],[2,["eaShLzs1dHVKFM/c/WKIqN"]],[5,234,172]],[25,100,["_radius"],[2,["0dYPiGR/RDPZ9ZVNa+NCoX"]]],[25,0.04,["speed"],[2,["9cCRIPV0NLxZ9VFAKlXck0"]]],[13,["_lpos"],[2,["27x+uvi5BMYYAGq5JEEecx"]],[1,-5139.346,-228.742,0]],[13,["_lpos"],[2,["77qhsoIsNDc7HJlAGV4x26"]],[1,3832.558,671.052,0]],[4,["_lscale"],-207,[1,0.7,0.7,1]]]],106]],[27,0,{},21,[26,"ae624fktNKxpIfBpP6HqMD",-213,[21,"37hW01+UlLN6Z5EuHiI9Q5",[[6,"MeteoriteRoot-002",["_name"],-209],[4,["_lpos"],-210,[1,0,3312.188,0]],[4,["_lrot"],-211,[3,0,0,0,1]],[4,["_euler"],-212,[1,0,0,0]],[13,["_contentSize"],[2,["eaShLzs1dHVKFM/c/WKIqN"]],[5,234,172]],[25,0.04,["speed"],[2,["9cCRIPV0NLxZ9VFAKlXck0"]]],[13,["_lpos"],[2,["27x+uvi5BMYYAGq5JEEecx"]],[1,4852.404,-374.39,0]],[13,["_lpos"],[2,["77qhsoIsNDc7HJlAGV4x26"]],[1,-4021.077,974.657,0]],[13,["_lscale"],[2,["70ARbEzmxNAp7R6xF/h6SX"]],[1,0.7,0.7,1]]]],107]],[27,0,{},21,[26,"ae624fktNKxpIfBpP6HqMD",-220,[21,"5abxWuKwtAga7p7JjnZiPN",[[6,"MeteoriteRoot-003",["_name"],-214],[4,["_lpos"],-215,[1,0,-1855.68,0]],[4,["_lrot"],-216,[3,0,0,0,1]],[4,["_euler"],-217,[1,0,0,0]],[4,["_lpos"],-218,[1,0,0,0]],[13,["_contentSize"],[2,["eaShLzs1dHVKFM/c/WKIqN"]],[5,234,172]],[13,["_lpos"],[2,["27x+uvi5BMYYAGq5JEEecx"]],[1,5284.552,-472.848,0]],[13,["_lpos"],[2,["77qhsoIsNDc7HJlAGV4x26"]],[1,-3860.961,671.052,0]],[4,["_lscale"],-219,[1,0.7,0.7,1]],[25,0.04,["speed"],[2,["9cCRIPV0NLxZ9VFAKlXck0"]]]]],108]],[27,0,{},21,[26,"ae624fktNKxpIfBpP6HqMD",-225,[21,"b1dhQ+Q25PF7yTOOg4CVHv",[[6,"MeteoriteRoot-004",["_name"],-221],[4,["_lpos"],-222,[1,0,-3336.589,0]],[4,["_lrot"],-223,[3,0,0,0,1]],[4,["_euler"],-224,[1,0,0,0]],[13,["_lpos"],[2,["27x+uvi5BMYYAGq5JEEecx"]],[1,-5581.187,43.895,0]],[13,["_lpos"],[2,["77qhsoIsNDc7HJlAGV4x26"]],[1,3842.6,43.895,0]],[13,["_lscale"],[2,["70ARbEzmxNAp7R6xF/h6SX"]],[1,0.7,0.7,1]],[25,0.04,["speed"],[2,["9cCRIPV0NLxZ9VFAKlXck0"]]]]],109]],[198,"transition",false,33554432,1,[-229,-230],[[[7,-226],-227,[281,-228,[132,133,134]]],4,1,4]],[31,"btnInfor",false,33554432,12,[[7,-231],[16,1,0,-232,8],[39,3,-234,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-233,45,46]],[1,286.464,1079.321,0],[1,2,2,1]],[56,"ring",33554432,[-237,-238],[[7,-235],[124,36,193.49,191.882,-236]],[1,836.51,241.882,0]],[91,"muteBtn",false,33554432,6,[[1,-239,[5,145,150]],[16,1,2,-240,30],[131,1,-243,[[9,"4feca++bj9EwrSxPqP0tqNM","switchVolume",-242]],[4,4289703855],-241,31,32,33,34]],[1,450,850,0]],[31,"btnInfor",false,33554432,14,[[7,-244],[16,1,0,-245,49],[39,3,-247,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-246,50,51]],[1,261.799,236.866,0],[1,2,2,1]],[31,"btnInfor",false,33554432,15,[[7,-248],[16,1,0,-249,54],[39,3,-251,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-250,55,56]],[1,274.266,292.966,0],[1,2,2,1]],[31,"btnInfor",false,33554432,11,[[7,-252],[16,1,0,-253,59],[39,3,-255,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-254,60,61]],[1,218.166,143.366,0],[1,2,2,1]],[31,"btnInfor",false,33554432,7,[[7,-256],[16,1,0,-257,64],[39,3,-259,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-258,65,66]],[1,280.499,317.899,0],[1,2,2,1]],[31,"btnInfor",false,33554432,16,[[7,-260],[16,1,0,-261,69],[39,3,-263,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-262,70,71]],[1,231,258,0],[1,2,2,1]],[31,"btnInfor",false,33554432,17,[[7,-264],[16,1,0,-265,74],[39,3,-267,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-266,75,76]],[1,305.432,430.098,0],[1,2,2,1]],[31,"btnInfor",false,33554432,18,[[7,-268],[16,1,0,-269,79],[39,3,-271,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-270,80,81]],[1,261.799,330.366,0],[1,2,2,1]],[31,"btnInfor",false,33554432,19,[[7,-272],[16,1,0,-273,84],[39,3,-275,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-274,85,86]],[1,242.014,493.613,0],[1,2,2,1]],[31,"btnInfor",false,33554432,20,[[7,-276],[16,1,0,-277,89],[39,3,-279,[[9,"4d25fRGQGBOiqPthThp6p10","showPopupPlanetInfor",2]],[4,4292269782],-278,90,91]],[1,261.799,274.266,0],[1,2,2,1]],[187,"btnStartGame",33554432,[[1,-280,[5,220,140]],[16,1,0,-281,121],[228,2,-283,[[9,"1f176LxgRlMaJFkrj/SjnRc","SpaceshipTakeOff",8]],[4,4292269782],-282,122,123],[159,-284]],[1,1.878500000000031,13.289000000000101,0],[3,null,null,null,null]],[34,"BG",33554432,1,[-286,-287,-288],[[7,-285]]],[24,"homeBtn",33554432,6,[[7,-289],[16,1,0,-290,9],[58,3,-293,[[9,"881b86lxyRDDpfGQFnXZ5CX","goHome",-292]],[4,4292269782],-291,10]],[1,-422.973,844.27,-1000],[1,1.5,1.5,1]],[23,"Joystick",33554432,6,[-297,29],[[119,-294,[5,1080,600],[0,0,0]],[288,130,-296,-295,29]],[1,-540,-960,0]],[35,"dot",33554432,29,[[1,-298,[5,120,120]],[206,0,-299,14,15],[289,-300]]],[24,"crmRedirect",33554432,6,[[1,-301,[5,322,389]],[16,1,0,-302,16],[229,3,-304,[4,4292269782],-303,17]],[1,-400,-800,-1000],[1,0.5,0.5,1]],[8,"Hand",33554432,6,[[1,-305,[5,110,131]],[12,-306,18],[109,true,-307,[19],20]],[1,355.791,-751.113,0]],[8,"soundBtn",33554432,6,[[1,-308,[5,145,150]],[16,1,2,-309,21],[131,1,-312,[[9,"4feca++bj9EwrSxPqP0tqNM","switchVolume",-311]],[4,4289703855],-310,35,36,37,38]],[1,450,850,0]],[90,"ArrowRoot",false,33554432,[-314,-315],[[7,-313]]],[31,"EffectHit",false,33554432,5,[[1,-316,[5,287,402]],[96,-317,[4,4294638072],27],[109,true,-318,[28],29]],[1,-25.926,-342.234,0],[1,2,2,1]],[23,"Book",33554432,13,[-320,-321,-322],[[1,-319,[5,650,480]]],[1,-256.792,-333.941,0]],[8,"btnClose",33554432,13,[[1,-323,[5,150,150]],[16,1,0,-324,42],[39,3,-326,[[9,"4d25fRGQGBOiqPthThp6p10","hidePopupPlanetInfor",2]],[4,4292269782],-325,43,44]],[1,463.611,137.346,0]],[75,"ISS",33554432,[-330],[[1,-327,[5,180,213]],[10,0,-328,92],[110,2,60,-329,7]],[1,-343.356,-461.756,0],[1,0.9,0.9,1]],[75,"Telescope",33554432,[-334],[[1,-331,[5,137,131]],[12,-332,93],[110,1,80,-333,7]],[1,354.903,-151.381,0],[1,1.4,1.4,1]],[24,"btnClosePP",33554432,9,[[7,-335],[16,1,0,-336,112],[54,3,-339,[[9,"8b3d77xXOlI7rsKN7tWv2Ti","CloseTutorialPopup",-338]],[4,4292269782],-337,113,114,115,116]],[1,475.023,339.858,0],[1,1.5,1.5,1]],[23,"SpaceshipRoot",33554432,8,[-341,-342],[[7,-340]],[1,0,-109.32299999999998,0]],[8,"Tutorial_Hand",33554432,8,[[1,-343,[5,110,131]],[10,0,-344,127],[109,true,-345,[128],129]],[1,37.450000000000045,-863.49,0]],[23,"BGroot-001",33554432,41,[-347,-348],[[7,-346]],[1,0,5760,0]],[23,"BGroot-002",33554432,41,[-350,-351],[[7,-349]],[1,0,-5760,0]],[34,"BGroot",33554432,41,[-353,-354],[[7,-352]]],[24,"Sun",33554432,12,[[1,-355,[5,1000,1000]],[10,0,-356,6]],[1,0,22.854,0],[1,2,2,2]],[24,"area",33554432,43,[[119,-357,[5,1080,600],[0,0,0]],[207,0,-358,[4,4278190080],11,12],[160,10,-359]],[1,-428.683,-390.989,0],[1,2,1.5,1]],[35,"background",33554432,29,[[1,-360,[5,240,240]],[10,0,-361,13],[160,200,-362]]],[35,"Audio",33554432,5,[[290,-363,30]]],[27,0,null,5,[26,"92LPJS5HBKHKvaYrzmqfLt",-368,[21,"a07ezRXDlAU6sP7JPzllop",[[6,"Effect_Fire",["_name"],-364],[4,["_lpos"],-365,[1,-22.277000000000044,-357.7970000000002,0]],[4,["_lrot"],-366,[3,0,0,0,1]],[4,["_euler"],-367,[1,0,0,0]]]],22]],[2,["92LPJS5HBKHKvaYrzmqfLt"]],[8,"Sprite",33554432,5,[[1,-369,[5,348,671]],[208,-370,23,24],[159,-371]],[1,0,-320,0]],[34,"Navigation",33554432,5,[48],[[7,-372],[291,400,1,-373,5,48]]],[199,"Content",33554432,50,[[[1,-374,[5,500,469.5]],-375,[292,false,0.5,-376]],4,1,4],[1,312.099,-80,0]],[50,"Title",33554432,50,[-379],[[1,-377,[5,791.1238095238095,280.97121212121215]],[10,0,-378,41]],[1,307.433,315.935,0],[1,0.7,0.7,1]],[24,"Mercury",33554432,14,[[1,-380,[5,300,300]],[12,-381,47]],[1,0,-27.876,0],[1,2,2,1]],[41,"Venus",33554432,15,[[1,-382,[5,300,300]],[12,-383,52]],[1,2,2,1]],[41,"Moon",33554432,11,[[1,-384,[5,300,300]],[12,-385,57]],[1,1.2,1.2,1]],[41,"Earth",33554432,7,[[1,-386,[5,300,300]],[10,0,-387,62]],[1,2.2,2.2,1]],[24,"Mars",33554432,16,[[1,-388,[5,1000,1000]],[10,0,-389,67]],[1,0,-38.691,0],[1,0.7,0.7,1]],[41,"Jupiter",33554432,17,[[1,-390,[5,1000,1000]],[10,0,-391,72]],[1,1.2,1.2,1]],[35,"Saturn",33554432,18,[[1,-392,[5,1000,1000]],[10,0,-393,77]]],[41,"Uranus",33554432,19,[[1,-394,[5,1000,1000]],[10,0,-395,82]],[1,0.85,0.85,1]],[24,"Neptune",33554432,20,[[1,-396,[5,1000,1000]],[10,0,-397,87]],[1,0,-22.989,0],[1,0.7,0.7,1]],[111,"Earth",33554432,[52,53],[[7,-398]]],[2,["ae624fktNKxpIfBpP6HqMD"]],[2,["ae624fktNKxpIfBpP6HqMD"]],[2,["ae624fktNKxpIfBpP6HqMD"]],[2,["ae624fktNKxpIfBpP6HqMD"]],[2,["ae624fktNKxpIfBpP6HqMD"]],[188,"TutorialPopup",33554432,"9eYBUuqwNBWpSzkkfMrmSa",10,[[7,-399],[293,-400,9]],[1,540,960,0]],[23,"TableControl",33554432,8,[40],[[1,-401,[5,1080,350]],[10,0,-402,124]],[1,0,-841.428,0]],[27,0,{},55,[26,"92LPJS5HBKHKvaYrzmqfLt",-406,[134,"33/Fdq8VJOUqneUY2rrpjK",null,[[274,[2,["92LPJS5HBKHKvaYrzmqfLt"]],[-405]]],[[13,["_lpos"],[2,["92LPJS5HBKHKvaYrzmqfLt"]],[1,-8.161,-405.35,0]],[25,"Effect_Fire",["_name"],[2,["92LPJS5HBKHKvaYrzmqfLt"]]],[13,["_lrot"],[2,["92LPJS5HBKHKvaYrzmqfLt"]],[3,0,0,0,1]],[13,["_euler"],[2,["92LPJS5HBKHKvaYrzmqfLt"]],[1,0,0,0]],[13,["_lscale"],[2,["92LPJS5HBKHKvaYrzmqfLt"]],[1,0.5500000000000002,1.0000000000000002,1]],[6,null,["_defaultClip"],-403],[6,false,["playOnLoad"],-404],[13,["_contentSize"],[2,["9ciPH6lGxMMLin2RFrsoBD"]],[5,300,300]]],[[2,["8fNPQvpVBBjrWQ7m8vs8Io"]]]],125]],[8,"background-002",33554432,57,[[1,-407,[5,3240,5760]],[10,0,-408,0]],[1,1620,0,0]],[8,"background-001",33554432,57,[[1,-409,[5,3240,5760]],[10,0,-410,1]],[1,-1620,0,0]],[8,"background-002",33554432,58,[[1,-411,[5,3240,5760]],[10,0,-412,2]],[1,1620,0,0]],[8,"background-001",33554432,58,[[1,-413,[5,3240,5760]],[10,0,-414,3]],[1,-1620,0,0]],[8,"background-002",33554432,59,[[1,-415,[5,3240,5760]],[10,0,-416,4]],[1,1620,0,0]],[8,"background-001",33554432,59,[[1,-417,[5,3240,5760]],[10,0,-418,5]],[1,-1620,0,0]],[8,"name",33554432,12,[[1,-419,[5,180,113.4]],[43,"太阳",90,90,90,false,-420,7]],[1,0,1084.023,0]],[57,"SpaceExplore","c0y3nsbelCe5p84moIGgDA",10,[[294,-421]]],[8,"arrow-001",33554432,48,[[1,-422,[5,218,195]],[12,-423,25]],[1,0,649.177,0]],[8,"arrow-002",33554432,48,[[1,-424,[5,218,195]],[12,-425,26]],[1,0,1094.283,0]],[41,"BG",33554432,13,[[1,-426,[5,1080,1920]],[10,0,-427,39]],[1,1.8,1.8,1]],[200,"Planet",33554432,13,[[[1,-428,[5,300,300]],-429],4,1],[1,0,540.816,0],[1,2.6,2.6,1]],[24,"bookSprte",33554432,50,[[1,-430,[5,650,480]],[12,-431,40]],[1,-16.064,0,0],[1,2.3,2.3,1]],[201,"titleString",33554432,69,[[[1,-432,[5,338.73,158.2]],-433],4,1]],[8,"name",33554432,14,[[1,-434,[5,140,88.2]],[43,"水星",70,70,70,false,-435,48]],[1,0,269.146,0]],[8,"name",33554432,15,[[1,-436,[5,140,88.2]],[43,"金星",70,70,70,false,-437,53]],[1,0,325.976,0]],[8,"name",33554432,11,[[1,-438,[5,140,88.2]],[43,"月球",70,70,70,false,-439,58]],[1,0,184.475,0]],[8,"name",33554432,7,[[1,-440,[5,140,50.4]],[233,"地球",70,70,false,-441,63]],[1,0,325.976,0]],[8,"name",33554432,16,[[1,-442,[5,140,88.2]],[43,"火星",70,70,70,false,-443,68]],[1,0,298.34,0]],[8,"name",33554432,17,[[1,-444,[5,140,88.2]],[43,"木星",70,70,70,false,-445,73]],[1,0,460.862,0]],[8,"name",33554432,18,[[1,-446,[5,140,88.2]],[43,"土星",70,70,70,false,-447,78]],[1,0,330.125,0]],[8,"name",33554432,19,[[1,-448,[5,210,88.2]],[43,"天王星",70,70,70,false,-449,83]],[1,0,508.166,0]],[8,"name",33554432,20,[[1,-450,[5,210,88.2]],[43,"海王星",70,70,70,false,-451,88]],[1,0,297.065,0]],[34,"Satelites",33554432,1,[79],[[7,-452]]],[31,"name",false,33554432,52,[[1,-453,[5,112.83,63]],[81,"ISS",70,70,50,-454]],[1,19.346,123.464,0],[1,0.8,0.8,1]],[31,"name",false,33554432,53,[[1,-455,[5,315.21,88.2]],[81,"Telescope",70,70,70,-456]],[1,12.591,96.775,0],[1,0.6,0.6,1]],[8,"Star",33554432,3,[[1,-457,[5,106,109]],[12,-458,94]],[1,-1454.071,-939.957,0]],[8,"Star-001",33554432,3,[[1,-459,[5,106,109]],[12,-460,95]],[1,-462.659,-173.265,0]],[8,"Star-002",33554432,3,[[1,-461,[5,106,109]],[12,-462,96]],[1,-918.709,2001.232,0]],[8,"Star-003",33554432,3,[[1,-463,[5,106,109]],[12,-464,97]],[1,-1652.354,1221.321,0]],[8,"Star-004",33554432,3,[[1,-465,[5,106,109]],[12,-466,98]],[1,2025.039,910.678,0]],[8,"Star-005",33554432,3,[[1,-467,[5,106,109]],[12,-468,99]],[1,85.922,2748.096,0]],[8,"Star-006",33554432,3,[[1,-469,[5,106,109]],[12,-470,100]],[1,1510.115,4378.036,0]],[8,"Star-007",33554432,3,[[1,-471,[5,106,109]],[12,-472,101]],[1,-1619.551,3330.027,0]],[8,"Star-008",33554432,3,[[1,-473,[5,106,109]],[12,-474,102]],[1,-1833.965,-3136.621,0]],[8,"Star-009",33554432,3,[[1,-475,[5,106,109]],[12,-476,103]],[1,329.175,-4035.477,0]],[8,"Star-010",33554432,3,[[1,-477,[5,106,109]],[12,-478,104]],[1,579.569,-1871.631,0]],[41,"BG",33554432,9,[[1,-479,[5,1080,1920]],[12,-480,110]],[1,2,1.5,1]],[41,"Images",33554432,9,[[1,-481,[5,504,284]],[12,-482,111]],[1,1.9,2.5,1]],[60,"Deco",33554432,9,[[1,-483,[5,265,629]],[12,-484,117]],[1,-386.115,-255.312,0],[3,0,0,-0.17364817766693033,0.984807753012208],[1,0.3,0.3,1],[1,0,0,-20]],[8,"Label",33554432,9,[[1,-485,[5,230.82,75.6]],[234,"Tutorial",70,70,60,-486,[4,4278650631]]],[1,0,236.984,0]],[60,"Deco-001",33554432,9,[[1,-487,[5,292,501]],[12,-488,118]],[1,385.868,29.54,0],[3,0,0,0.08715574274765817,0.9961946980917455],[1,0.3,0.3,1],[1,0,0,10]],[41,"BackGround",33554432,8,[[1,-489,[5,1080,1920]],[10,0,-490,119]],[1,1.5,1.5,1]],[24,"Ground",33554432,8,[[1,-491,[5,1091,514]],[12,-492,120]],[1,4.732999999999947,-679.778,0],[1,1.4,1.4,1]],[24,"SpaceShip",33554432,55,[[1,-493,[5,348,671]],[12,-494,126]],[1,-10,-375.235,0],[1,0.6,0.6,1]],[24,"Fragments+right",33554432,27,[[1,-495,[5,400,1280]],[10,2,-496,130]],[1,1155.322,58.68,0],[1,2,2,1]],[60,"Fragments_left",33554432,27,[[1,-497,[5,400,1280]],[10,2,-498,131]],[1,-1158.328,-39.97,0],[3,6.123233995736766e-17,6.123233995736766e-17,-1,-6.123233995736766e-17],[1,2,2,1],[1,180,180,7.016709298534876e-15]],[295,false,300,1,0.01,0.05,null,5,6,49],[137,0,1073741824,960,0,2000,41943040,6,[4,4278190080]],[209,0,99],[133,"太阳是太阳系中心的一\n颗炽热的红色星球，所\n有的行星都围绕它转。\n太阳的直径约为地球的\n一百倍。没有太阳的温\n暖，人们就无法生存。",50,50,75,false,68,[4,4286141962]],[133,"太阳 \nTHE SUN",70,70,70,false,101,[4,4294741506]],[2,["0dYPiGR/RDPZ9ZVNa+NCoX"]],[2,["70ARbEzmxNAp7R6xF/h6SX"]],[2,["70ARbEzmxNAp7R6xF/h6SX"]],[2,["70ARbEzmxNAp7R6xF/h6SX"]],[155,87],[2,["acwN18iadP+JiZ1hDI2n9D"]],[155,27],[57,"GameMM","32alB+mVZJUrWeCWStIAJD",10,[[296,-499,8,27,146]]],[57,"PlanetMM","03hTiwM89LF6bgTLDi9+N1",10,[[297,1,-500,[7,11,15,14,12,16,17,18,19,20],5,135]]],[57,"GameTutorial","d0WS3cfRdN0pzcaEBehVKJ",10,[[298,15,-501,46]]]],0,[0,0,1,0,21,136,0,0,1,0,0,1,0,-1,41,0,-2,4,0,-3,111,0,-4,3,0,-5,21,0,-6,5,0,-7,6,0,-8,9,0,-9,8,0,-10,27,0,74,137,0,75,139,0,76,138,0,77,13,0,0,2,0,0,3,0,-1,114,0,-2,115,0,-3,116,0,-4,117,0,-5,118,0,-6,119,0,-7,120,0,-8,121,0,-9,122,0,-10,123,0,-11,124,0,0,4,0,-1,12,0,-2,14,0,-3,15,0,-4,11,0,-5,7,0,-6,16,0,-7,17,0,-8,18,0,-9,19,0,-10,20,0,0,5,0,0,5,0,0,5,0,-4,135,0,-1,64,0,-2,66,0,-3,67,0,-4,63,0,-5,49,0,-1,136,0,-1,42,0,-2,43,0,-3,45,0,-4,46,0,-5,47,0,-6,30,0,-7,13,0,0,7,0,19,73,0,20,34,0,0,7,0,-1,73,0,-2,105,0,-3,34,0,0,8,0,33,56,0,78,144,0,79,55,0,0,8,0,-1,130,0,-2,131,0,-3,86,0,-4,55,0,-5,56,0,0,9,0,-1,125,0,-2,126,0,-3,54,0,-4,127,0,-5,128,0,-6,129,0,-1,22,0,-2,23,0,-3,24,0,-4,25,0,-5,26,0,-6,64,0,-7,87,0,12,22,0,17,22,0,12,22,0,17,22,0,12,23,0,17,23,0,12,23,0,17,23,0,12,24,0,17,24,0,12,24,0,17,24,0,12,64,0,17,135,0,12,25,0,17,25,0,12,25,0,17,25,0,12,26,0,17,26,0,12,26,0,17,26,0,-2,147,0,-3,95,0,-5,148,0,-6,149,0,-7,85,0,0,11,0,19,72,0,20,33,0,0,11,0,0,11,0,-1,72,0,-2,104,0,-3,33,0,0,12,0,19,60,0,20,28,0,0,12,0,-1,60,0,-2,94,0,-3,28,0,0,13,0,-1,98,0,-2,99,0,-3,50,0,-4,51,0,0,14,0,19,70,0,20,31,0,0,14,0,-1,70,0,-2,102,0,-3,31,0,0,15,0,19,71,0,20,32,0,0,15,0,-1,71,0,-2,103,0,-3,32,0,0,16,0,19,74,0,20,35,0,0,16,0,-1,74,0,-2,106,0,-3,35,0,0,17,0,19,75,0,20,36,0,0,17,0,-1,75,0,-2,107,0,-3,36,0,0,18,0,19,76,0,20,37,0,0,18,0,-1,76,0,-2,108,0,-3,37,0,0,19,0,19,77,0,20,38,0,0,19,0,-1,77,0,-2,109,0,-3,38,0,0,20,0,19,78,0,20,39,0,0,20,0,-1,78,0,-2,110,0,-3,39,0,0,21,0,-1,22,0,-2,23,0,-3,24,0,-4,25,0,-5,26,0,2,80,0,2,80,0,2,80,0,2,80,0,2,140,0,2,141,0,2,141,0,2,140,0,7,22,0,2,81,0,2,81,0,2,81,0,2,81,0,2,142,0,2,142,0,7,23,0,2,82,0,2,82,0,2,82,0,2,82,0,7,24,0,2,83,0,2,83,0,2,83,0,2,83,0,2,143,0,2,143,0,7,25,0,2,84,0,2,84,0,2,84,0,2,84,0,7,26,0,0,27,0,-2,146,0,0,27,0,-1,133,0,-2,134,0,0,28,0,0,28,0,8,28,0,0,28,0,0,29,0,0,29,0,-1,62,0,-2,44,0,0,30,0,0,30,0,8,30,0,12,63,0,0,30,0,0,31,0,0,31,0,8,31,0,0,31,0,0,32,0,0,32,0,8,32,0,0,32,0,0,33,0,0,33,0,8,33,0,0,33,0,0,34,0,0,34,0,8,34,0,0,34,0,0,35,0,0,35,0,8,35,0,0,35,0,0,36,0,0,36,0,8,36,0,0,36,0,0,37,0,0,37,0,8,37,0,0,37,0,0,38,0,0,38,0,8,38,0,0,38,0,0,39,0,0,39,0,8,39,0,0,39,0,0,40,0,0,40,0,8,40,0,0,40,0,0,40,0,0,41,0,-1,57,0,-2,58,0,-3,59,0,0,42,0,0,42,0,8,42,0,12,95,0,0,42,0,0,43,0,80,44,0,0,43,0,-1,61,0,0,44,0,0,44,0,0,44,0,0,45,0,0,45,0,8,45,0,0,45,0,0,46,0,0,46,0,0,46,0,0,47,0,0,47,0,8,47,0,12,63,0,0,47,0,0,48,0,-1,96,0,-2,97,0,0,49,0,0,49,0,0,49,0,0,50,0,-1,100,0,-2,68,0,-3,69,0,0,51,0,0,51,0,8,51,0,0,51,0,0,52,0,0,52,0,0,52,0,-1,112,0,0,53,0,0,53,0,0,53,0,-1,113,0,0,54,0,0,54,0,8,54,0,12,85,0,0,54,0,0,55,0,-1,87,0,-2,132,0,0,56,0,0,56,0,0,56,0,0,57,0,-1,88,0,-2,89,0,0,58,0,-1,90,0,-2,91,0,0,59,0,-1,92,0,-2,93,0,0,60,0,0,60,0,0,61,0,0,61,0,0,61,0,0,62,0,0,62,0,0,62,0,0,63,0,2,65,0,2,65,0,2,65,0,2,65,0,7,64,0,0,66,0,0,66,0,0,66,0,0,67,0,0,67,0,0,68,0,-2,138,0,0,68,0,0,69,0,0,69,0,-1,101,0,0,70,0,0,70,0,0,71,0,0,71,0,0,72,0,0,72,0,0,73,0,0,73,0,0,74,0,0,74,0,0,75,0,0,75,0,0,76,0,0,76,0,0,77,0,0,77,0,0,78,0,0,78,0,0,79,0,0,85,0,0,85,0,0,86,0,0,86,0,2,145,0,2,145,0,-1,144,0,7,87,0,0,88,0,0,88,0,0,89,0,0,89,0,0,90,0,0,90,0,0,91,0,0,91,0,0,92,0,0,92,0,0,93,0,0,93,0,0,94,0,0,94,0,0,95,0,0,96,0,0,96,0,0,97,0,0,97,0,0,98,0,0,98,0,0,99,0,-2,137,0,0,100,0,0,100,0,0,101,0,-2,139,0,0,102,0,0,102,0,0,103,0,0,103,0,0,104,0,0,104,0,0,105,0,0,105,0,0,106,0,0,106,0,0,107,0,0,107,0,0,108,0,0,108,0,0,109,0,0,109,0,0,110,0,0,110,0,0,111,0,0,112,0,0,112,0,0,113,0,0,113,0,0,114,0,0,114,0,0,115,0,0,115,0,0,116,0,0,116,0,0,117,0,0,117,0,0,118,0,0,118,0,0,119,0,0,119,0,0,120,0,0,120,0,0,121,0,0,121,0,0,122,0,0,122,0,0,123,0,0,123,0,0,124,0,0,124,0,0,125,0,0,125,0,0,126,0,0,126,0,0,127,0,0,127,0,0,128,0,0,128,0,0,129,0,0,129,0,0,130,0,0,130,0,0,131,0,0,131,0,0,132,0,0,132,0,0,133,0,0,133,0,0,134,0,0,134,0,0,147,0,0,148,0,0,149,0,23,10,1,4,10,2,4,10,29,4,43,40,4,86,48,4,67,52,4,79,53,4,79,79,4,111,501],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,138,139,144,146],[1,1,1,1,1,1,1,9,1,1,6,34,1,1,34,1,1,6,1,-1,25,1,5,34,1,1,1,1,-1,25,1,6,18,16,11,6,18,16,11,1,1,1,1,6,11,6,11,1,9,1,6,11,1,9,1,6,11,1,9,1,6,11,1,9,1,6,11,1,9,1,6,11,1,9,1,6,11,1,9,1,6,11,1,9,1,6,11,1,9,1,6,11,1,1,1,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,1,1,1,6,18,16,11,1,1,1,1,1,6,16,1,5,1,1,-1,25,1,1,-1,-2,-3,81,1,9,9,22,22],[10,10,10,10,10,10,140,1,4,17,17,47,141,142,47,143,27,27,39,69,69,22,70,47,71,72,72,144,73,73,40,40,11,12,3,22,11,12,3,10,145,146,16,16,3,4,3,147,1,4,4,3,148,1,4,4,3,149,1,4,4,3,74,1,4,4,3,150,1,4,4,3,151,1,4,4,3,152,1,4,4,3,153,1,4,4,3,154,1,4,4,3,155,156,14,14,14,14,14,14,14,14,14,14,14,23,23,23,23,23,10,25,16,16,11,12,3,60,59,10,157,75,75,158,159,70,71,39,76,76,34,34,44,45,46,160,74,1,1,161,67]],[[{"name":"Decor-3","rect":{"x":186,"y":241,"width":122,"height":173},"offset":{"x":0,"y":-0.5},"originalSize":{"width":126,"height":176},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[[18,"Codespark_UI_Clockwise_active"],[51,"Codespark_UI_Clockwise_active",33554432,[[5,-2,[0,"e514XZZXpIk7eGgjZDBhe6"],[5,204,187]],[32,-3,[0,"dcV8y5nR5Iha16wxxqXqYm"],0],[100,-4,[0,"d34K/FBW5ENZTwQV7Fkx6Q"],1]],[3,"e7XxNEodhFPrGARFU3Hnd8",-1,0],[1,1.763285024154589,1.763285024154589,0.5147826086956522]]],0,[0,7,1,0,0,1,0,0,1,0,0,1,0,10,1,4],[0,0],[1,6],[37,37]],[[[18,"Decor-3"],[51,"Decor-3",33554432,[[5,-2,[0,"e3KOecfNxEFLI8TDiXcIPC"],[5,122,173]],[32,-3,[0,"b5ByxZXmpNDIji/V9045fp"],0]],[3,"cdShLv+HpB8rZgm4rxrkXN",-1,0],[1,1,1.01,0.3376799999999999]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[162]],[[{"name":"Switch_rocket","rect":{"x":515,"y":754,"width":110,"height":132},"offset":{"x":0,"y":0},"originalSize":{"width":110,"height":132},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[7]],[[{"name":"ingamepopup_bg","rect":{"x":3,"y":638,"width":504,"height":284},"offset":{"x":0,"y":-1},"originalSize":{"width":506,"height":286},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[15]],[[[18,"StartBlock"],[38,"StartBlock",33554432,[[46,-2,[0,"51ipTHXh1Fgpb95fbgNjwA"],[5,194,223],[0,0.5,0.37]],[29,0,-3,[0,"8e4dGFuDRJcY+n4nZbHl1A"],0]],[3,"630/DlyGJIrIf/okUZ8b1N",-1,0],[1,238.08999999999992,3.638299999999994,0],[1,0.38,0.38,0.402]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[163]],[[{"name":"UI_btn_Home","rect":{"x":513,"y":886,"width":130,"height":128},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":149,"height":149},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[15]],[[[18,"Text_effect"],[189,"Text_effect",33554432,[-3],[[95,-2,[0,"412NYONbhPIJ71nH1n06JO"]]],[3,"60whtUc01AqKpk/+jyFPeB",-1,0],[1,0,730.572,0]],[190,"Particle2D",33554432,1,[[5,-4,[0,"89hbBDCQVH4LrOphozzWmZ"],[5,500,100]],[299,"Node<ParticleSystem2D>",999.999985098839,0.5,0.8,10,10,60,30.31999969482422,30,-47.369998931884766,-142.11000061035156,10,90,0,true,true,5,-5,[0,"89UC8wTZJKBIPn2IyJPyqJ"],[0,150,80],[0,10,10],[4,4292410111],[4,4278190080],[4,4294967295],[4,4278190080],0,1],[282,false,true,-6,[0,"c7n4vGx69N5q/pdVVfvFxt"],[2],3]],[3,"feWWPHO4RLA6LnERZbRi0y",1,0],[1,17.035,-7.797,-1]]],0,[0,7,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,0,2,0,10,1,6],[0,0,0,0],[82,1,-1,25],[164,165,77,77]],[[{"name":"Decor-5","rect":{"x":3,"y":180,"width":164,"height":177},"offset":{"x":-1,"y":-0.5},"originalSize":{"width":166,"height":180},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[[121,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[30,26],[68,35]],[[[18,"Decor-2"],[51,"Decor-2",33554432,[[5,-2,[0,"3fQHp6XWpNhLFEI/e8Mv/j"],[5,117,172]],[32,-3,[0,"5eKMBfm1xDG5SuaQthwiTP"],0]],[3,"a5aGD7gf1Hr7SP8GHDvFbC",-1,0],[1,1,1.01,0.3376799999999999]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[166]],[[{"name":"Cloud","rect":{"x":3,"y":3,"width":400,"height":1280},"offset":{"x":0,"y":0},"originalSize":{"width":400,"height":1280},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[9]],[[{"name":"Mars","rect":{"x":615,"y":1694,"width":299,"height":299},"offset":{"x":0,"y":0},"originalSize":{"width":299,"height":299},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[8]],[[{"name":"Block-3","rect":{"x":3,"y":714,"width":73,"height":84},"offset":{"x":0,"y":0},"originalSize":{"width":73,"height":84},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]],[[[18,"Decor-4"],[51,"Decor-4",33554432,[[5,-2,[0,"00eAv0wCpMpZbeZSGF+dCg"],[5,163,156]],[32,-3,[0,"c7PCMLmfdLfL+tivjuEfiZ"],0]],[3,"63VqYL5wpE27nl7ykNJ2ua",-1,0],[1,1,1.01,0.3376799999999999]]],0,[0,7,1,0,0,1,0,0,1,0,10,1,3],[0],[1],[167]],[[[300,[[301,"ShadowFlow",[[302,"ShadowStage"]]],[303,"ForwardFlow",1,[[304,"ForwardStage",[[305,["default"]],[306,true,1,["default"]]]]]]]]],0,0,[],[],[]],[[{"name":"Codespark_UI_Setup_Panel_ngan","rect":{"x":171,"y":568,"width":441,"height":120},"offset":{"x":0,"y":0},"originalSize":{"width":441,"height":120},"rotated":true,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[3],[5]]]]
