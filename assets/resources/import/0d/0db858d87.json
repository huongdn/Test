[1,["dfSCAY8fVDGaZGtar3Kqy/@e0be2","dfSCAY8fVDGaZGtar3Kqy/@c2696","152DGZXu1NIqjZH7BRIyJS@60ade","0c3A3ckBhMyZlyDcLBp5/A@cf5ee","166nQ4Wh9AvYooDccrRgZe@8ffd2","55wOMz9XxL6o48+9wZJY3H@73b7f","dfSCAY8fVDGaZGtar3Kqy/@b9e10","dfSCAY8fVDGaZGtar3Kqy/@438fe","57eymTXHdBMZT+qBmvlyg9","61zm1m1NtLB7wuJv6DfC4z@6c48a","ff906PqfxFmbht+XNWKvcz@6c48a","f6SJZOjTJB/JrJeh5xTdF7"],["_parent","to","from","clip","node","_anyState","_exitState","_entryState","root","data","_mesh","_skeleton","graph","mainTexture","normalMap","_effectAsset"],[["cc.Node",["_name","_layer","_prefab","_lrot","_euler","_children","_parent","_lpos","_components"],1,4,5,5,2,1,5,9],["cc.animation.Motion",["name","speed","motion","_components"],1,4,9],["cc.animation.AnimationTransition",["exitConditionEnabled","from","to","conditions"],2,1,1,9],["cc.animation.UnaryCondition",["operator","operand"],2,4],["cc.Node",["_name","_layer","_children","_prefab","_lpos","_lrot","_euler","_parent"],1,9,4,5,5,5,1],["cc.animation.AnimationGraph",["_layers","_variables"],3,9,11],["cc.animation.Layer",["_stateMachine"],3,4],["cc.animation.StateMachine",["_states","_transitions","_entryState","_exitState","_anyState"],3,2,9,1,1,1],["cc.animation.BindableBoolean",["variable"],2],["cc.animation.Transition",["from","to"],3,1,1],["cc.animation.PlainVariable",["_type","_value"],1],["cc.animation.ClipMotion",["clip"],3,6],["cc.animation.State",["name"],2],["AnimationGraphComponentRun",[],3],["AnimationGraphComponentSummoned",[],3],["cc.Prefab",["_name"],2],["cc.Node",["_name","_layer","_children","_prefab","_lpos"],1,12,4,5],["cc.animation.AnimationController",["node","__prefab","graph"],3,1,4,6],["cc.CompPrefabInfo",["fileId"],2],["cc.PrefabInfo",["fileId","root","asset"],2,1,1],["cc.SkinnedMeshRenderer",["node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],3,1,4,3,4,1,6,6],["cc.ModelLightmapSettings",[],3],["cc.UIMeshRenderer",["node","__prefab"],3,1,4],["cc.UITransform",["node","__prefab","_contentSize","_anchorPoint"],3,1,4,5,5],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Material",["_techIdx","_states","_defines","_props"],0,12],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[19,0,1,2,2],[0,0,1,6,2,7,3,4,3],[0,0,1,6,5,2,7,3,4,3],[4,0,1,7,2,3,4,5,6,3],[11,0,1],[18,0,2],[2,1,2,1],[10,0,1,3],[12,0,2],[0,0,1,5,2,7,3,4,3],[2,0,1,2,3,2],[8,0,2],[1,0,1,2,3],[1,0,3,2,2],[5,0,1,1],[6,0,1],[7,0,1,2,3,4,1],[3,1,1],[3,0,1,2],[9,0,1,1],[1,0,2,2],[13,1],[14,1],[15,0,2],[0,0,1,5,8,2,3,4,3],[0,0,1,6,8,2,7,3,4,3],[0,0,1,6,5,2,3,4,3],[4,0,1,2,3,4,5,6,3],[16,0,1,2,3,4,3],[17,0,1,2,1],[20,0,1,2,3,4,5,6,1],[21,1],[22,0,1,1],[23,0,1,2,3,1],[24,0,1,2,3,4],[25,0,1,2,3],[26,0,1,2,3,4],[27,0,1,2,4]],[[[[14,[[15,[16,[-16,-17,-18,-19,-20,-21,-22,-23],[[10,false,-5,-4,[[17,[11,"isMoving"]]]],[6,-7,-6],[10,false,-9,-8,[[18,1,[11,"isMoving"]]]],[6,-11,-10],[19,-13,-12],[6,-15,-14]],-3,-2,-1]]],[{},"isMoving",4,[7,1,false],"onStart",4,[7,1,true],"win",4,[7,1,false]]],[20,"Idle",[4,0]],[8,"Entry"],[12,"runStart",3,[4,1]],[13,"run",[[21]],[4,2]],[12,"runEnd",3,[4,3]],[13,"Take 001",[[22]],[4,4]],[8,"Exit"],[8,"Any"]],0,[0,5,8,0,6,7,0,7,2,0,1,3,0,2,1,0,1,4,0,2,3,0,1,5,0,2,4,0,1,1,0,2,5,0,1,6,0,2,2,0,1,1,0,2,6,0,-1,2,0,-2,7,0,-3,8,0,-4,1,0,-5,3,0,-6,4,0,-7,5,0,-8,6,23],[0,0,0,0,0],[3,3,3,3,3],[1,2,3,4,5]],[[[23,"Astronaut"],[24,"Astronaut",262144,[-3,-4],[[29,-2,[5,"821rZ+UTdGfK89ia2Jbjiu"],4]],[0,"38glPkc3pPr6SuGI6AFaSv",-1,0],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[27,"Bip001 Xtra01",262144,[[1,"R hand handle1",262144,-5,[0,"795e70w5ZMnJBfX7C3/laV",1,0],[1,0.5100117921829224,-0.03201562166213989,-0.45077818632125854],[3,-0.005188420423502014,-0.7068445694211046,-0.09790486113521249,0.7005415570396214],[1,-8.448483427837095,-91.06499193160911,-7.460233031588316]],[1,"R hand handle2",262144,-6,[0,"c5Aeg/hJpGjISxlpKm7RTb",1,0],[1,0.2482302188873291,-0.8186889886856079,-0.5586746335029602],[3,-0.025460728985730388,-0.697277535255075,-0.11748181848691609,0.706649709851444],[1,-11.627194806311339,-89.99976177097336,-7.500254563933692]],[1,"L hand handle2",262144,-7,[0,"2bmy4bU1pIxJPQMDC4Vo+T",1,0],[1,0.2816418409347534,-0.8178844451904297,0.6075959205627441],[3,0.05604491530924374,-0.6981601303515795,0.14023021234062308,0.6998334711932184],[1,16.032384555808207,-90.81843994511613,6.77778383509979]],[1,"L hand handle1",262144,-8,[0,"30VKnvzZJHqKLJvnCwk/EC",1,0],[1,0.5100117325782776,-0.03201943635940552,0.45100128650665283],[3,-0.10807455599566979,-0.7104745087690618,0.032465518327416114,0.6946163350047502],[1,-6.0919464591023464,-90.68144331892557,11.45922968505323]]],[0,"d30nRlPRNHpKV7dFSuQjWH",1,0],[1,0.24099814891815186,-0.5346709489822388,-0.0000022221356630325317],[3,5.66752508525438e-11,-0.000002784897083942903,0.9999964754732449,0.0026550015691793652],[1,179.99968087090986,-179.99999914621426,0.3042411264629999]],[9,"Bip001 Spine",262144,[-9,-10,-11],[0,"83GunGLOxCsb/Ka0LI3Mf4",1,0],[1,0.06027185916900635,0.032107848674058914,0.0017063021659851074],[3,0.01831307293887407,0.02004462701512546,0.051330083007181865,0.9983126097900575],[1,1.9880965062524896,2.1976265180429233,5.924685929600534]],[28,"Bip001 Neck",262144,[[-12,-13,[1,"Bip001 Head",262144,-14,[0,"7a3gOW/dpA3JJ86jkPgA5p",1,0],[1,0.06547927856445312,-0.000014360994100570679,1.862645149230957e-9],[3,0.03445632421258817,0.011725077534988505,-0.04653003863194179,0.9982535949263923],[1,4.024421030307099,1.5316579143910214,-5.2838288446271795]]],1,1,4],[0,"43EyYYbF5DJ45Tx/wlIPEc",1,0],[1,0.3603935241699219,-0.06606259942054749,-1.862645149230957e-9]],[9,"Bip001 L Hand",262144,[-15,-16,-17],[0,"8d4OewxuVPZYIkcZIWK/RK",1,0],[1,0.27253085374832153,-5.960464477539063e-8,0],[3,-0.7419664123320368,-0.09395094038083236,-0.025406443964477346,0.6633351915719257],[1,-95.90594946615346,-9.396061037980928,6.068126523038534]],[9,"Bip001 R Hand",262144,[-18,-19,-20],[0,"787evIrapNKpyeQMxtw2Dd",1,0],[1,0.27253082394599915,5.960464477539063e-8,-5.960464477539063e-8],[3,0.7424006876752727,-0.16733713039192535,0.0373819833801062,0.6476434907030624],[1,96.15859035195534,-16.1331769299178,-11.539415377468101]],[25,"VD043_Jetpack_Flyer_Toy",262144,1,[[30,-21,[5,"83CtKnZl9MBayHV0ubsRL3"],[0,1],[31],1,2,3],[32,-22,[5,"bfPmKE0GNL/b8oklBl2SGU"]],[33,-23,[5,"77QYx/oo5IsIZCvzao30pE"],[5,1.8033320407970963,3.0591937802105322],[0,0.5,0.7]]],[0,"daLFWDeYZPLLzHu/qWw01s",1,0],[1,0.000004234213572207324,0.34442489582445646,-0.5965614189595705],[3,-0.7071067811865476,0,0,0.7071067811865475],[1,-90.00000000000001,0,0]],[2,"Bip001 Spine1",262144,3,[4,2],[0,"7dY4T6t01Ceopmze+/f1FW",1,0],[1,0.30468177795410156,-0.00024194270372390747,-0.000008396804332733154],[3,0.01652411234166925,-0.023288617600632614,-0.03368326748875341,0.999024539985306],[1,1.8062750228980584,-2.6092475452322503,-3.9031688345757445]],[2,"Bip001",262144,1,[-24],[0,"73kWn/QChIVKoBe+01enDy",1,0],[1,0.025053977966308594,0.7133909463882446,0.03748690336942673],[3,-0.4592295592545704,-0.5376878387195055,-0.5376878387195054,0.45922955925457043],[1,-90,-98.99990617392913,0]],[26,"Bip001 Pelvis",262144,9,[3],[0,"365xpqyytH5a4/bI+0KF6Z",1,0],[3,0.5203319787540229,0.4855473935194539,0.518123626665281,-0.47439041729740306],[1,-94.4967349616145,-90.48229397300277,0.7853151089261627]],[2,"Bip001 L Clavicle",262144,4,[-25],[0,"94/43hjm9FJaKdN4UGNrfv",1,0],[1,-0.15008139610290527,-0.029379824176430702,0.16028693318367004],[3,0.7379414630554331,-0.0002946540265846981,0.6748646076676733,0.00026758207934930825],[1,179.95458604417567,-84.88728416552377,-0.0042233576805496]],[2,"Bip001 L UpperArm",262144,11,[-26],[0,"1d05oQrLdP47BXHZsUzoqu",1,0],[1,0.1752856969833374,1.30385160446167e-8,0],[3,-0.1909291589128922,0.5413013679400174,0.055306404652568766,0.8169945452372911],[1,-21.986797837186934,65.75393827764961,-6.680364579993282]],[2,"Bip001 L Forearm",262144,12,[5],[0,"94jHZsdiVJWJ75Qlq7bz4p",1,0],[1,0.30327725410461426,5.551115123125783e-17,5.960464477539063e-8],[3,1.4625413342768572e-17,-3.263487547518527e-17,-0.6823387669725535,0.7310361188658021],[1,-1.9273518689805456e-14,-2.31052198399669e-14,-86.05334796136489]],[3,"Bip001 L Finger0",262144,5,[[1,"Bip001 L Finger01",262144,-27,[0,"15tq1gJfFH5ZZPI4L3Nv/F",1,0],[1,0.12686099112033844,-5.960464477539063e-8,2.220446049250313e-16],[3,6.7717409268558375e-9,3.1071960473302073e-9,0.4170408535278855,0.9088877414118494],[1,8.537736078717935e-7,-3.8379800353244007e-14,49.29580931519125]]],[0,"b3sYhm1a5Ptp2mVc9LXUFL",1,0],[1,0.05214601755142212,0.010561108589172363,-0.07510733604431152],[3,0.6746811945821796,0.29407200561851043,0.24056166692344885,0.6328167393453507],[1,92.10049931983626,3.827088343668838,44.52919453220961]],[3,"Bip001 L Finger1",262144,5,[[1,"Bip001 L Finger11",262144,-28,[0,"95/WSv3H1EBaSujPVf9zzo",1,0],[1,0.11407226324081421,5.960464477539063e-8,5.960464477539063e-8],[3,-4.066922923868787e-9,1.4455938225677603e-8,0.7127351384477825,0.7014332629850256],[1,-179.99990567592812,179.999906517761,89.08421659248222]]],[0,"c6otiHVmNLGpImPIvMIPnd",1,0],[1,0.13685476779937744,-0.06003260612487793,-0.017368435859680176],[3,-0.1673444815267504,0.08695138286027557,0.2768333269045508,0.9422306461987887],[1,-24.688426747642307,17.142431839455604,29.510300381098883]],[3,"Bip001 L Finger2",262144,5,[[1,"Bip001 L Finger21",262144,-29,[0,"bbqNYxk/JErLh9QWiNfTRr",1,0],[1,0.11604306101799011,1.1102230246251565e-16,1.1102230246251565e-16],[3,0.005586658533918401,0.02709030512049791,0.581860832975312,0.8128178613097644],[1,-3.9771057377360717,6.661465414910693,71.11965907439375]]],[0,"18L9tq7epAs6CXJBA1UJWy",1,0],[1,0.13624519109725952,-0.048795878887176514,0.09180718660354614],[3,-0.13856673351836557,0.07784738454096357,0.36049381187707236,0.9191209151578041],[1,-23.893264133111604,18.45982424655009,39.87394415309718]],[2,"Bip001 R Clavicle",262144,4,[-30],[0,"99Tn4cGgND2a9lpCxjyuPw",1,0],[1,-0.15008139610290527,-0.02937893196940422,-0.16028745472431183],[3,0.7480214735998131,-0.0002969640733798371,-0.6636744054438308,-0.0002653388038828932],[1,-179.95467140421664,83.16142932137103,-0.005275443688355604]],[2,"Bip001 R UpperArm",262144,17,[-31],[0,"d9hYyJ8DlFX6QOKVplt0zd",1,0],[1,0.17528563737869263,-5.587935447692871e-9,2.220446049250313e-16],[3,0.20653430849426985,-0.547382049607393,0.06835500062185525,0.8081114187241694],[1,24.292656874925044,-66.79363258623155,-6.639931109062676]],[2,"Bip001 R Forearm",262144,18,[6],[0,"aa8+TEd7BPp4fwbYZ+YCRP",1,0],[1,0.30327725410461426,-5.960464477539063e-8,0],[3,0,0,-0.6512993580123281,0.7588208920771287],[1,0,0,-81.27927936718207]],[3,"Bip001 R Finger0",262144,6,[[1,"Bip001 R Finger01",262144,-32,[0,"76RvuiGkJJpYCi9Uy8TeQS",1,0],[1,0.12686097621917725,-5.551115123125783e-17,0],[3,4.6844838988063015e-8,5.099695762537187e-9,0.417040853527885,0.9088877414118484],[1,0.000007107554750065308,-0.0000026183196263363308,49.29580931519113]]],[0,"0b09nm0tRLkqAS34TTVICK",1,0],[1,0.052145957946777344,0.010561227798461914,0.07510733604431152],[3,-0.7992934893017968,-0.2846068551680877,0.14495339058835943,0.5090357261607757],[1,-113.61955784540162,-4.169697231212765,37.05215275548036]],[3,"Bip001 R Finger1",262144,6,[[1,"Bip001 R Finger11",262144,-33,[0,"ab33rwKQ1Jnr0L+DHBGs1R",1,0],[1,0.11407217383384705,-1.1920928955078125e-7,-5.960464477539063e-8],[3,-1.6841125531131413e-10,2.1072748647615377e-8,0.7127351086492664,0.7014332932636701],[1,-179.99989146868464,179.99989316258515,89.08422146059704]]],[0,"4a+EsGp+BAXIyMOaY6cxjo",1,0],[1,0.1368546485900879,-0.06003260612487793,0.01736849546432495],[3,0.16734449633585335,-0.08695136046070064,0.2768333267522613,0.9422306456804558],[1,24.688427931148876,-17.1424295363662,29.510300667330508]],[3,"Bip001 R Finger2",262144,6,[[1,"Bip001 R Finger21",262144,-34,[0,"665bE4CohD1oPOjmL34Sxl",1,0],[1,0.1160430908203125,5.960464477539063e-8,0],[3,-0.0055866544205679615,-0.027090301771503896,0.5818609006622605,0.8128178129955181],[1,3.977108907119225,-6.661467934225278,71.11966855597838]]],[0,"d647+CYstFQa2Pdi9LJyYD",1,0],[1,0.13624513149261475,-0.04879593849182129,-0.09180724620819092],[3,0.1385667058573379,-0.07784737829337175,0.3604937876455218,0.9191209293611369],[1,23.893258845831284,-18.459820830051857,39.87394204293123]],[2,"Bip001 L Thigh",262144,3,[-35],[0,"ec42pkUhdM5LR5bbZCo0UH",1,0],[1,-0.06955111026763916,-0.019373338669538498,0.16432179510593414],[3,0.1365471175158444,0.9795017773234587,0.11902838866105335,-0.08811013341865497],[1,-15.392582147897418,-167.78117226829093,14.271742314915677]],[2,"Bip001 L Calf",262144,23,[-36],[0,"e2yy4+RxlCKLEQbGd6MqQt",1,0],[1,0.2833104133605957,2.7755575615628914e-17,0],[3,-7.94353597486993e-18,9.663437981896868e-18,-0.2905194084380881,0.9568690993656257],[1,-6.60848836659558e-16,9.566188430703192e-16,-33.77810960344908]],[3,"Bip001 L Foot",262144,24,[[1,"Bip001 L Toe0",262144,-37,[0,"6eZj5IlQNDI5Y20ISn671i",1,0],[1,0.12055830657482147,0.1753564178943634,2.9802322387695312e-8],[3,-4.913837954028883e-7,0.0000010259031062596675,0.7071069003953715,0.7071066619767884],[1,0,-0.00007963216615437602,90]]],[0,"d4yWIkRZNOp6/acY8CPCO/",1,0],[1,0.32318341732025146,-5.204170427930421e-18,2.9802322387695312e-8],[3,-0.14829636816999522,-0.12443219624282932,0.16820883418307833,0.9665560531229138],[1,-15.22628584512692,-11.801937960540801,21.227512760199243]],[2,"Bip001 R Thigh",262144,3,[-38],[0,"b3JJCJi7hLE4xmh0Prvuea",1,0],[1,-0.056758761405944824,-0.03232694789767265,-0.1705644577741623],[3,0.28349079891924855,0.9339861013533769,-0.19430671090902984,0.0977130058004596],[1,28.712520919353565,160.36008287869288,29.444506192928287]],[2,"Bip001 R Calf",262144,26,[-39],[0,"b3ikEihEFEypg1bfCeUz6E",1,0],[1,0.2833103537559509,0,0],[3,7.552592260718814e-17,-3.7706441708005647e-17,-0.293513440263538,0.9559549468383238],[1,8.46347372924871e-15,-1.9213213508359334e-15,-34.136836267456545]],[3,"Bip001 R Foot",262144,27,[[1,"Bip001 R Toe0",262144,-40,[0,"59XAxbiKJGsrSJYsI488eA",1,0],[1,0.12055831402540207,0.1753564327955246,2.9802322387695312e-8],[3,-1.7085779829572256e-7,2.716841368257836e-7,0.7071070494073549,0.7071065129655654],[1,0,-0.00002768870194162374,90]]],[0,"2eGxq8nzBJa7+vn3AQMrbe",1,0],[1,0.32318347692489624,-1.4901161193847656e-8,2.7755575615628914e-17],[3,0.11063275000585403,0.04712268448101054,0.03850727618625852,0.9919964903739128],[1,12.514328107823792,4.8928647296201335,4.9809656483770155]]],0,[0,8,1,0,4,1,0,-1,9,0,-2,7,0,0,2,0,0,2,0,0,2,0,0,2,0,-1,8,0,-2,23,0,-3,26,0,-1,11,0,-2,17,0,0,4,0,-1,14,0,-2,15,0,-3,16,0,-1,20,0,-2,21,0,-3,22,0,4,7,0,4,7,0,4,7,0,-1,10,0,-1,12,0,-1,13,0,0,14,0,0,15,0,0,16,0,-1,18,0,-1,19,0,0,20,0,0,21,0,0,22,0,-1,24,0,-1,25,0,0,25,0,-1,27,0,-1,28,0,0,28,0,9,1,2,0,8,3,0,10,4,0,8,5,0,13,6,0,19,40],[0,0,0,0,0],[-1,-2,10,11,12],[0,0,6,7,8]],[[[34,"Skin-0",743951864,["Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Xtra01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine","Bip001/Bip001 Pelvis","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","Bip001","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Xtra01/L hand handle1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Xtra01/R hand handle1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger0/Bip001 L Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot/Bip001 R Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot/Bip001 L Toe0","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger0/Bip001 R Finger01","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Xtra01/L hand handle2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Xtra01/R hand handle2","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger2/Bip001 L Finger21","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/Bip001 L Finger1/Bip001 L Finger11","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger2/Bip001 R Finger21","Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1/Bip001 R Finger11"],[[[7,6.187233392296321e-9,-0.0000041444932321610395,1,0,-0.004513197112828493,0.9999898076057434,0.000004144479134993162,0,-0.9999897480010986,-0.00451319757848978,-1.2517745950901826e-8,0,1.3908617496490479,-0.4347469210624695,-3.492707207897183e-7,1],[7,1.0916177961561857e-9,-0.0000014026936696609482,1,0,-0.000796317879576236,-0.9999997019767761,-0.0000014026923054188956,0,0.9999996423721313,-0.0007963179377838969,-2.208607741138735e-9,0,-1.4671730995178223,-0.026515182107686996,-1.3442367219340667e-7,1],[7,0.9999980330467224,-0.0000013709940276385169,0.0019909716211259365,0,0.0000013709912991544115,1,2.729528603140352e-9,0,-0.00199097185395658,8.15931591497017e-14,0.9999979734420776,0,-0.1576644480228424,-0.0018153621349483728,-1.3174101114273071,1],[7,1.0916177961561857e-9,-0.0000014026936696609482,1,0,-0.000796317879576236,-0.9999997019767761,-0.0000014026923054188956,0,0.9999996423721313,-0.0007963179377838969,-2.208607741138735e-9,0,-1.1067795753479004,-0.09257777780294418,-1.3447971980440343e-7,1],[7,0.6554455757141113,0.06636323779821396,0.7523211240768433,0,-0.06185077130794525,0.9975025653839111,-0.03410470485687256,0,-0.7527055740356445,-0.02417786419391632,0.6579132080078125,0,0.7712838649749756,0.007755107246339321,-1.1186999082565308,1],[7,1.0916177961561857e-9,-0.0000014026936696609482,1,0,-0.000796317879576236,-0.9999997019767761,-0.0000014026923054188956,0,0.9999996423721313,-0.0007963179377838969,-2.208607741138735e-9,0,-0.802081823348999,-0.09282040596008301,-1.351526606185871e-7,1],[7,0.0000013868000223737909,0.0000027577070795814507,1,0,6.123234262925839e-17,-1,0.0000027577070795814507,0,1,-3.8243271396898315e-12,-0.0000013868001360606286,0,-0.7414840459823608,-0.06182606890797615,0.0000011987883681285894,1],[7,0.0000013430886838250444,-0.000001402693328600435,1,0,6.123234262925839e-17,-1,-0.000001402693328600435,0,1,1.8840029362976463e-12,-0.0000013430887975118821,0,-1.5326309204101562,-0.02772129327058792,0.000001920690465340158,1],[7,0.13688209652900696,0.1590796560049057,-0.9777305722236633,0,-0.09744144976139069,-0.9800717830657959,-0.17310237884521484,0,-0.9857831597328186,0.11896609514951706,-0.11865334212779999,0,0.701964259147644,-0.175481379032135,0.24123336374759674,1],[7,-0.9999980330467224,-0.0000013708198594031273,0.0019909716211259365,0,-0.000001370817130919022,1,2.729345194296684e-9,0,-0.00199097185395658,8.186228523396691e-14,-0.9999979734420776,0,-0.1576647162437439,-0.001815369469113648,1.3174101114273071,1],[7,0.000001370906943520822,1,-6.123234262925839e-17,0,-1,0.000001370906943520822,6.123225660247469e-17,0,6.123234262925839e-17,6.123225660247469e-17,1,0,-0.06182606890797615,8.47577865670246e-8,-0.7414840459823608,1],[7,0.6495519280433655,0.10997873544692993,0.7523210644721985,0,-0.12831522524356842,0.9911468625068665,-0.03410467877984047,0,-0.7494114637374878,-0.07438148558139801,0.657913327217102,0,0.466444194316864,0.03898624703288078,-1.1187000274658203,1],[7,-0.655445396900177,-0.06636596471071243,0.7523210048675537,0,-0.06185256317257881,0.9975024461746216,0.03410675749182701,0,-0.7527055144309998,-0.02417786605656147,-0.6579132676124573,0,0.7712836265563965,0.0077551016584038734,1.1187001466751099,1],[7,-0.1368820071220398,-0.1590770035982132,-0.9777309894561768,0,-0.09744182229042053,-0.9800722002983093,0.17309975624084473,0,-0.9857831001281738,0.11896612495183945,0.11865350604057312,0,0.7019641995429993,-0.1754814237356186,-0.24123363196849823,1],[7,0.10254950821399689,0.18310290575027466,-0.9777305722236633,0,0.09920996427536011,-0.9798943996429443,-0.173102468252182,0,-0.9897680878639221,-0.07924904674291611,-0.1186533272266388,0,0.4451713562011719,-0.0888102725148201,0.24123336374759674,1],[7,-0.6495516300201416,-0.109981469810009,0.7523209452629089,0,-0.12831701338291168,0.9911466240882874,0.034106750041246414,0,-0.7494114637374878,-0.07438149303197861,-0.657913327217102,0,0.4664440453052521,0.03898622468113899,1.1187001466751099,1],[7,-0.1025499552488327,-0.1831001490354538,-0.9777309894561768,0,0.09920968115329742,-0.9798949360847473,0.17309969663619995,0,-0.9897680282592773,-0.07924902439117432,0.11865349113941193,0,0.4451712965965271,-0.08881032466888428,-0.24123364686965942,1],[7,0.6570939421653748,-0.7182113528251648,0.2289104163646698,0,-0.09769375622272491,0.21997271478176117,0.9706018567085266,0,-0.7474513053894043,-0.6601397395133972,0.07437796890735626,0,0.18840467929840088,1.1060526371002197,-0.1782228797674179,1],[7,0.25852638483047485,-0.09052107483148575,0.9617536664009094,0,-0.36935535073280334,0.9106875658035278,0.18500006198883057,0,-0.8926034569740295,-0.40305623412132263,0.20200228691101074,0,0.509779691696167,0.5170634984970093,-0.8378967642784119,1],[7,0.7021540403366089,-0.6582005023956299,0.2715728282928467,0,-0.17534476518630981,0.2098202407360077,0.9618886113166809,0,-0.6900969743728638,-0.7230129241943359,0.031914111226797104,0,-0.04077046364545822,1.1662547588348389,-0.1627086102962494,1],[7,4.371138828673793e-8,0.2901841998100281,-0.9569708704948425,0,-6.123234262925839e-17,-0.9569709300994873,-0.2901841700077057,0,-1,1.2684354011582855e-8,-4.183052482176208e-8,0,0.1423247903585434,-0.12443234026432037,0.21265490353107452,1],[7,0.7002003788948059,-0.7129670977592468,0.037384044378995895,0,-0.016252584755420685,0.036431171000003815,0.9992039799690247,0,-0.7137615084648132,-0.7002505660057068,0.013921558856964111,0,-0.013526206836104393,1.1857166290283203,-0.05661425366997719,1],[7,1,-0.0000041442608562647365,0.00000464297636426636,0,0.000004123264261579607,0.9999896883964539,0.004513242281973362,0,-0.00000466163373857853,-0.004513242747634649,0.9999896287918091,0,-0.45099756121635437,-0.4027273952960968,-0.8808521628379822,1],[7,-0.6570937037467957,0.718210756778717,0.22891314327716827,0,-0.09769558161497116,0.21997471153736115,-0.9706012606620789,0,-0.7474513649940491,-0.6601397395133972,-0.07437797635793686,0,0.18840453028678894,1.1060527563095093,0.17822299897670746,1],[7,1,-0.00000426350197813008,0.0000046498885239998344,0,0.000004242472641635686,0.9999896883964539,0.004513264633715153,0,-0.000004669084319175454,-0.00451326509937644,0.9999896287918091,0,0.45078185200691223,-0.4027312397956848,-0.8808478713035583,1],[7,4.371138828673793e-8,-0.29018154740333557,-0.9569716453552246,0,-6.123234262925839e-17,-0.9569717049598694,0.29018154740333557,0,-1,-1.2684238548388294e-8,-4.183056034889887e-8,0,0.14232482016086578,-0.12443240731954575,-0.21265514194965363,1],[7,-0.2585253417491913,0.09051850438117981,0.9617542624473572,0,-0.36935609579086304,0.9106878638267517,-0.1849973499774933,0,-0.8926034569740295,-0.403056263923645,-0.20200228691101074,0,0.509779691696167,0.5170634388923645,0.837897002696991,1],[7,0.2512088119983673,-0.1091977059841156,0.9617536664009094,0,-0.3017197251319885,0.9352754950523376,0.18500015139579773,0,-0.9197062849998474,-0.3366536796092987,0.20200230181217194,0,0.4197312593460083,0.48765459656715393,-0.8378967046737671,1],[7,-0.29018157720565796,4.183056034889887e-8,-0.9569716453552246,0,-0.9569717049598694,-5.639562772330464e-8,0.29018154740333557,0,-4.183056034889887e-8,1,5.639563127601832e-8,0,-0.29978886246681213,-0.02176648937165737,-0.212655171751976,1],[7,0.29018422961235046,-4.183052837447576e-8,-0.9569708704948425,0,-0.9569709300994873,-5.6395741410142364e-8,-0.2901841998100281,0,-4.183052837447576e-8,1,-5.639574851556972e-8,0,-0.2997887432575226,-0.02176648937165737,0.21265490353107452,1],[7,-0.7021535634994507,0.6581999659538269,0.27157554030418396,0,-0.1753467172384262,0.20982207357883453,-0.9618878960609436,0,-0.6900970935821533,-0.7230128645896912,-0.0319141149520874,0,-0.04077055677771568,1.1662548780441284,0.16270872950553894,1],[7,-0.7002003192901611,0.7129669785499573,0.03738683834671974,0,-0.016254538670182228,0.03643316403031349,-0.9992039799690247,0,-0.713761568069458,-0.700250506401062,-0.01392156071960926,0,-0.013526327908039093,1.1857167482376099,0.05661429837346077,1],[7,-0.2512079179286957,0.10919494926929474,0.9617542624473572,0,-0.3017204701900482,0.9352759122848511,-0.1849973201751709,0,-0.9197062849998474,-0.3366537094116211,-0.20200230181217194,0,0.4197312295436859,0.48765450716018677,0.8378970623016357,1],[7,1,-0.0000041442608562647365,0.0000046429750000243075,0,0.000004123264261579607,0.9999896883964539,0.004513197112828493,0,-0.000004661632374336477,-0.00451319757848978,0.9999896287918091,0,-0.45099323987960815,0.4837659001350403,-1.0320807695388794,1],[7,1,-0.000004144259946770035,0.000004642974545276957,0,0.000004123264261579607,0.9999895691871643,0.004513194784522057,0,-0.000004661632374336477,-0.004513195250183344,0.9999895095825195,0,0.4507819712162018,0.4830706715583801,-1.0360755920410156,1],[7,0.7548536062240601,-0.6545447111129761,0.0420394130051136,0,-0.02552242949604988,0.03473353013396263,0.9990707039833069,0,-0.6553965210914612,-0.7552251219749451,0.009513161145150661,0,-0.22385025024414062,1.17152738571167,-0.05772443488240242,1],[7,0.6074097156524658,-0.7465264201164246,0.27157285809516907,0,-0.1455814689397812,0.23146571218967438,0.9618885517120361,0,-0.7809349298477173,-0.6237965822219849,0.031914107501506805,0,0.003167590359225869,1.1764847040176392,-0.16270864009857178,1],[7,-0.7548535466194153,0.6545445919036865,0.042042188346385956,0,-0.025524524971842766,0.03473534807562828,-0.9990706443786621,0,-0.655396580696106,-0.7552250623703003,-0.00951316300779581,0,-0.22385036945343018,1.1715275049209595,0.05772446468472481,1],[7,-0.6074093580245972,0.7465257048606873,0.27157554030418396,0,-0.1455831527709961,0.23146775364875793,-0.9618878960609436,0,-0.7809349298477173,-0.6237965226173401,-0.0319141149520874,0,0.0031674474012106657,1.1764848232269287,0.16270872950553894,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[35,".bin",963410638,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":715088,"length":56568,"count":28284,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":815656,"length":4200,"count":2100,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":715088,"count":8126,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]},{"view":{"offset":771656,"length":44000,"count":500,"stride":88},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}],"jointMaps":[[0,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,22,23,24,25,27,28,29,36],[0,11,15,17,18,19,21,23,26,27,30,31,32,35,36,37,38]]},"minPosition",8,[1,-1.0414035320281982,-0.6798864006996155,0],"maxPosition",8,[1,1.0414035320281982,0.6798864006996155,2.797865629196167]]],-1],0,0,[],[],[]],[[[36,"0",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_NORMAL_MAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":0.206},"mainTexture",6,0,"normalMap",6,1],{},{}],11,0,0]]],0,0,[0,0,0],[13,14,15],[9,10,11]],[[[37,"dcc/imported-specular-glossiness",[{"hash":221290481,"name":"dcc/imported-specular-glossiness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_NORMAL_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":10,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n  precision highp float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(set = 1, binding = 0) uniform Constants {\n    vec4 tilingOffset;\n    vec4 albedo;\n    vec4 albedoScaleAndCutoff;\n    vec4  diffuseColor;\n    vec4  specularColor;\n    vec4  emissive;\n    float alphaThreshold;\n    float shininessExponent;\n    float glossiness;\n    float metallic;\n    float normalScale;\n    float transparencyFactor;\n    float diffuseFactor;\n    float specularFactor;\n  };\n  float LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n  }\n  float ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n  }\n  float LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n      if (wPos.y < _FogTop) {\n        fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n        fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n      } else {\n        fDeltaY = 0.;\n        fDensityIntegral = 0.;\n      }\n    } else {\n      if (wPos.y < _FogTop) {\n        float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n        fDeltaY = abs(fDeltaA - fDeltaB);\n        fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n      } else {\n        fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n      }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n      fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n      fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n  }\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n    #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      factor = LayeredFog(pos);\n    #else\n      factor = 1.0;\n    #endif\n  }\n  void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n    color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n  }\n  #if !CC_USE_ACCURATE_FOG\n  layout(location = 0) in float v_fog_factor;\n  #endif\n    void CC_APPLY_FOG(inout vec4 color) {\n  #if !CC_USE_ACCURATE_FOG\n      CC_APPLY_FOG_BASE(color, v_fog_factor);\n  #endif\n  }\n  void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n  #if CC_USE_ACCURATE_FOG\n      float factor;\n      CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n  #else\n      float factor = v_fog_factor;\n  #endif\n      CC_APPLY_FOG_BASE(color, factor);\n  }\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n  vec3 SRGBToLinear (vec3 gamma) {\n    return gamma * gamma;\n  }\n  layout(set = 0, binding = 2) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    mediump vec4 cc_shadowNFLSInfo;\n    mediump vec4 cc_shadowWHPBInfo;\n    mediump vec4 cc_shadowLPNNInfo;\n    lowp vec4 cc_shadowColor;\n    mediump vec4 cc_planarNDInfo;\n  };\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n    layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(normalBias > EPSILON_LOWP)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n    }else {\n      return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    float realtimeShadow = 1.0;\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n    }else {\n      realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n    }\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #endif\n  #if CC_USE_IBL\n    layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n    vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n        return textureLod(tex, coord, lod);\n    }\n    vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n        return textureLod(tex, coord, lod);\n    }\n    vec3 unpackRGBE (vec4 rgbe) {\n      return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n    }\n    #if CC_USE_DIFFUSEMAP\n      layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n    vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n      #if CC_USE_IBL\n      \tfloat mip = roughness * mipCount;\n      \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n      \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n       \tvec4 filtered = texture(cc_environment, R);\n        #if CC_USE_IBL == 2\n        \tbiased.rgb = unpackRGBE(biased);\n        \tfiltered.rgb = unpackRGBE(filtered);\n        #else\n        \tbiased.rgb = SRGBToLinear(biased.rgb);\n        \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n        #endif\n        return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n      #else\n        return vec3(0.0, 0.0, 0.0);\n      #endif\n    }\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      vec3 position, position_fract_part;\n      #else\n      vec3 position;\n      #endif\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n    float specularIntensity;\n    #if CC_RECEIVE_SHADOW\n      vec2 shadowBias;\n    #endif\n  };\n  vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW\n      if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      }\n    #endif\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      if (s.lightmap_test > EPSILON_LOWP) {\n        finalColor = diffuse * s.lightmap.rgb * shadow;\n      }\n    #endif\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n    #if CC_USE_IBL\n      #if CC_USE_DIFFUSEMAP\n        vec4 diffuseMap = texture(cc_diffuseMap, N);\n        #if CC_USE_DIFFUSEMAP == 2\n          ambDiff = unpackRGBE(diffuseMap);\n        #else\n          ambDiff = SRGBToLinear(diffuseMap.rgb);\n        #endif\n      #endif\n      vec3 R = normalize(reflect(-V, N));\n      #if USE_REFLECTION_DENOISE\n        vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n        #if CC_USE_IBL == 2\n          vec3 env = unpackRGBE(envmap);\n        #else\n          vec3 env = SRGBToLinear(envmap.rgb);\n        #endif\n      #endif\n      finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n    #endif\n    finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.albedo.a);\n  }\n  vec3 ACESToneMap (vec3 color) {\n    color = min(color, vec3(8.0));\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n  }\n  vec4 CCFragOutput (vec4 color) {\n    #if CC_USE_HDR\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = sqrt(color.rgb);\n    return color;\n  }\n  layout(location = 1) in highp vec4 v_shadowPos;\n    #if CC_RECEIVE_SHADOW\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    layout(location = 9) in vec3 v_luv;\n    layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n  #endif\n  layout(location = 3) in vec3 v_position;\n  layout(location = 5) in vec2 v_uv;\n  layout(location = 6) in vec2 v_uv1;\n  layout(location = 4) in vec3 v_normal;\n  #define DCC_APP_AUTODESK 0\n  #define DCC_APP_BLENDER 1\n  #define DCC_APP_CINEMA4D 2\n  #if USE_SHININESS_MAP\n    layout(set = 1, binding = 1) uniform sampler2D shininessExponentMap;\n  #endif\n  #if USE_SPECULAR_MAP\n    layout(set = 1, binding = 2) uniform sampler2D specularMap;\n  #endif\n   #if USE_METALLIC_MAP\n    layout(set = 1, binding = 3) uniform sampler2D metallicMap;\n  #endif\n  #if USE_VERTEX_COLOR\n    layout(location = 2) in vec4 v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    layout(set = 1, binding = 4) uniform sampler2D albedoMap;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    layout(set = 1, binding = 5) uniform sampler2D transparencyMap;\n  #endif\n  #if USE_NORMAL_MAP\n    layout(location = 7) in vec3 v_tangent;\n    layout(location = 8) in vec3 v_bitangent;\n    layout(set = 1, binding = 6) uniform sampler2D normalMap;\n  #endif\n  #if USE_EMISSIVE_MAP\n    layout(set = 1, binding = 7) uniform sampler2D emissiveMap;\n  #endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n  float d = max(max(diffuse.x, diffuse.y), diffuse.z);\n  vec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n  normalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n  float s = max(max(specular.x, specular.y), specular.z);\n  float delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n  float deltaSqrt = sqrt(max(0.0, delta));\n  float solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n  vec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n  bool isValidSolver = delta >= 0.0;\n  metallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n  albedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n  return isValidSolver;\n}\n  float discolor(vec3 srcColor) {\n    return dot(GRAY_VECTOR, srcColor);\n  }\n  float convertShininessExponent(float shininessExp)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    #else\n      float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n      float glossiness = pow(l2, 0.5);\n    #endif\n      return glossiness;\n  }\n  float getSpecularIntensityFromRoughness(float roughness)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n    #else\n      float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n    #endif\n      return specularIntensityMultiplier;\n  }\n  vec4 getSpecularColorAndFactor()\n  {\n    vec3 inSpecular = specularColor.rgb;\n    #if USE_SPECULAR_MAP\n        vec4 specularTex = texture(specularMap, TEXTURE_UV);\n        specularTex.rgb = SRGBToLinear(specularTex.rgb);\n        inSpecular = specularTex.rgb;\n    #endif\n    return vec4(inSpecular, specularFactor);\n  }\n  void surf (out StandardSurface s) {\n    vec4 baseColor = diffuseColor;\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(v_color.rgb);\n      baseColor.a *= v_color.a;\n    #endif\n    float diffuseScale = diffuseFactor;\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      baseColor = texColor;\n      diffuseScale = 1.0;\n    #endif\n    baseColor.rgb *= diffuseScale;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < albedoScaleAndCutoff.w) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = specularColorAndFactor.w;\n    #if HAS_EXPORTED_GLOSSINESS\n      inGlossiness = glossiness;\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec4 albedo = baseColor;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    s.normal = v_normal;\n    #if USE_NORMAL_MAP\n      vec3 nmmp = texture(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n      s.normal =\n        (nmmp.x * normalScale) * normalize(v_tangent) +\n        (nmmp.y * normalScale) * normalize(v_bitangent) +\n        nmmp.z * normalize(s.normal);\n    #endif\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      packHighpData(s.position, s.position_fract_part, v_position);\n      #else\n      s.position = v_position;\n      #endif\n    s.albedo = albedo;\n    s.occlusion = 1.0;\n    s.roughness = 1.0 - inGlossiness;\n    s.metallic = inMetallic;\n    s.specularIntensity = inSpecularIntensity * 0.5;\n    s.emissive = vec3(0.0);\n  #if USE_EMISSIVE_MAP\n    s.emissive = texture(emissiveMap, TEXTURE_UV).xyz;\n  #endif\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n      s.lightmap = lightColor.xyz * v_luv.z;\n      s.lightmap_test = v_luv.z;\n    #endif\n  }\n    #if CC_FORWARD_ADD\n      #if CC_PIPELINE_TYPE == 0\n        #define LIGHTS_PER_PASS 1\n      #else\n        #define LIGHTS_PER_PASS 10\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      layout(set = 2, binding = 1) uniform CCForwardLight {\n        highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n        vec4 cc_lightColor[LIGHTS_PER_PASS];\n        vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n        vec4 cc_lightDir[LIGHTS_PER_PASS];\n      };\n      #endif\n      float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n        float factor = distSqr * invSqrAttRadius;\n        float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n        return smoothFactor * smoothFactor;\n      }\n      float GetDistAtt (float distSqr, float invSqrAttRadius) {\n        float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n        attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n        return attenuation;\n      }\n      float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n        float cd = dot(litDir, L);\n        float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n        return (attenuation * attenuation);\n      }\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.0);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n        for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n          if (i >= numLights) break;\n          vec3 SLU = cc_lightPos[i].xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.0);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = cc_lightSizeRangeAngle[i].x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n          float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (cc_lightPos[i].w > 0.0) {\n            float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n            float cosOuter = cc_lightSizeRangeAngle[i].z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = cc_lightColor[i].rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n      layout(set = 1, binding = 8) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n      layout(set = 1, binding = 9) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n      layout(set = 1, binding = 10) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n      struct CCLight\n      {\n        vec4 cc_lightPos;\n        vec4 cc_lightColor;\n        vec4 cc_lightSizeRangeAngle;\n        vec4 cc_lightDir;\n      };\n      struct Cluster\n      {\n        vec3 minBounds;\n        vec3 maxBounds;\n      };\n      struct LightGrid\n      {\n        uint offset;\n        uint ccLights;\n      };\n      CCLight getCCLight(uint i)\n      {\n        CCLight light;\n        light.cc_lightPos = b_ccLights[4u * i + 0u];\n        light.cc_lightColor = b_ccLights[4u * i + 1u];\n        light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n        light.cc_lightDir = b_ccLights[4u * i + 3u];\n        return light;\n      }\n      LightGrid getLightGrid(uint cluster)\n      {\n        uvec4 gridvec = b_clusterLightGrid[cluster];\n        LightGrid grid;\n        grid.offset = gridvec.x;\n        grid.ccLights = gridvec.y;\n        return grid;\n      }\n      uint getGridLightIndex(uint start, uint offset)\n      {\n        return b_clusterLightIndices[start + offset];\n      }\n      uint getClusterZIndex(vec4 worldPos)\n      {\n        float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n        float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n        float eyeDepth = -(cc_matView * worldPos).z;\n        uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n        return zIndex;\n      }\n      uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n      {\n        uint zIndex = getClusterZIndex(worldPos);\n        float clusterSizeX = ceil(cc_viewPort.z / float(16));\n        float clusterSizeY = ceil(cc_viewPort.w / float(8));\n        uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n        uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n        return cluster;\n      }\n      vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.001);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n        LightGrid grid = getLightGrid(cluster);\n        uint numLights = grid.ccLights;\n        for (uint i = 0u; i < 100u; i++) {\n          if (i >= numLights) break;\n          uint lightIndex = getGridLightIndex(grid.offset, i);\n          CCLight light = getCCLight(lightIndex);\n          vec3 SLU = light.cc_lightPos.xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.001);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = light.cc_lightSizeRangeAngle.x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n          float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (light.cc_lightPos.w > 0.0) {\n            float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n            float cosOuter = light.cc_lightSizeRangeAngle.z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = light.cc_lightColor.rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (light.cc_lightPos.w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      layout(location = 0) out vec4 fragColorX;\n      void main () {\n        StandardSurface s; surf(s);\n        #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n        vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n        #else\n        vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n        #endif\n        fragColorX = CCFragOutput(color);\n      }\n    #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n      layout(location = 0) out vec4 fragColorX;\n      void main () {\n        StandardSurface s; surf(s);\n        vec4 color = CCStandardShadingBase(s, v_shadowPos);\n        CC_APPLY_FOG(color, s.position.xyz);\n        fragColorX = CCFragOutput(color);\n      }\n    #elif CC_PIPELINE_TYPE == 1\n      vec2 signNotZero(vec2 v) {\n        return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n      }\n      vec2 float32x3_to_oct(in vec3 v) {\n        vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n        return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n      }\n      layout(location = 0) out vec4 fragColor0;\n      layout(location = 1) out vec4 fragColor1;\n      layout(location = 2) out vec4 fragColor2;\n      void main () {\n        StandardSurface s; surf(s);\n        fragColor0 = s.albedo;\n        fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n        fragColor2 = vec4(s.emissive, s.occlusion);\n      }\n    #endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n  precision highp float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(std140) uniform Constants {\n    vec4 tilingOffset;\n    vec4 albedo;\n    vec4 albedoScaleAndCutoff;\n    vec4  diffuseColor;\n    vec4  specularColor;\n    vec4  emissive;\n    float alphaThreshold;\n    float shininessExponent;\n    float glossiness;\n    float metallic;\n    float normalScale;\n    float transparencyFactor;\n    float diffuseFactor;\n    float specularFactor;\n  };\n  float LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n  }\n  float ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n  }\n  float LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n      if (wPos.y < _FogTop) {\n        fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n        fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n      } else {\n        fDeltaY = 0.;\n        fDensityIntegral = 0.;\n      }\n    } else {\n      if (wPos.y < _FogTop) {\n        float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n        fDeltaY = abs(fDeltaA - fDeltaB);\n        fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n      } else {\n        fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n      }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n      fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n      fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n  }\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n    #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      factor = LayeredFog(pos);\n    #else\n      factor = 1.0;\n    #endif\n  }\n  void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n    color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n  }\n  #if !CC_USE_ACCURATE_FOG\n  in float v_fog_factor;\n  #endif\n    void CC_APPLY_FOG(inout vec4 color) {\n  #if !CC_USE_ACCURATE_FOG\n      CC_APPLY_FOG_BASE(color, v_fog_factor);\n  #endif\n  }\n  void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n  #if CC_USE_ACCURATE_FOG\n      float factor;\n      CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n  #else\n      float factor = v_fog_factor;\n  #endif\n      CC_APPLY_FOG_BASE(color, factor);\n  }\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n  vec3 SRGBToLinear (vec3 gamma) {\n    return gamma * gamma;\n  }\n  layout(std140) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    mediump vec4 cc_shadowNFLSInfo;\n    mediump vec4 cc_shadowWHPBInfo;\n    mediump vec4 cc_shadowLPNNInfo;\n    lowp vec4 cc_shadowColor;\n    mediump vec4 cc_planarNDInfo;\n  };\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(normalBias > EPSILON_LOWP)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n    }else {\n      return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    float realtimeShadow = 1.0;\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n    }else {\n      realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n    }\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #endif\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n        return textureLod(tex, coord, lod);\n    }\n    vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n        return textureLod(tex, coord, lod);\n    }\n    vec3 unpackRGBE (vec4 rgbe) {\n      return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n    }\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n    vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n      #if CC_USE_IBL\n      \tfloat mip = roughness * mipCount;\n      \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n      \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n       \tvec4 filtered = texture(cc_environment, R);\n        #if CC_USE_IBL == 2\n        \tbiased.rgb = unpackRGBE(biased);\n        \tfiltered.rgb = unpackRGBE(filtered);\n        #else\n        \tbiased.rgb = SRGBToLinear(biased.rgb);\n        \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n        #endif\n        return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n      #else\n        return vec3(0.0, 0.0, 0.0);\n      #endif\n    }\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      vec3 position, position_fract_part;\n      #else\n      vec3 position;\n      #endif\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n    float specularIntensity;\n    #if CC_RECEIVE_SHADOW\n      vec2 shadowBias;\n    #endif\n  };\n  vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW\n      if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      }\n    #endif\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      if (s.lightmap_test > EPSILON_LOWP) {\n        finalColor = diffuse * s.lightmap.rgb * shadow;\n      }\n    #endif\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n    #if CC_USE_IBL\n      #if CC_USE_DIFFUSEMAP\n        vec4 diffuseMap = texture(cc_diffuseMap, N);\n        #if CC_USE_DIFFUSEMAP == 2\n          ambDiff = unpackRGBE(diffuseMap);\n        #else\n          ambDiff = SRGBToLinear(diffuseMap.rgb);\n        #endif\n      #endif\n      vec3 R = normalize(reflect(-V, N));\n      #if USE_REFLECTION_DENOISE\n        vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n        #if CC_USE_IBL == 2\n          vec3 env = unpackRGBE(envmap);\n        #else\n          vec3 env = SRGBToLinear(envmap.rgb);\n        #endif\n      #endif\n      finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n    #endif\n    finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.albedo.a);\n  }\n  vec3 ACESToneMap (vec3 color) {\n    color = min(color, vec3(8.0));\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n  }\n  vec4 CCFragOutput (vec4 color) {\n    #if CC_USE_HDR\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = sqrt(color.rgb);\n    return color;\n  }\n  in highp vec4 v_shadowPos;\n    #if CC_RECEIVE_SHADOW\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    in vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n  #endif\n  in vec3 v_position;\n  in vec2 v_uv;\n  in vec2 v_uv1;\n  in vec3 v_normal;\n  #define DCC_APP_AUTODESK 0\n  #define DCC_APP_BLENDER 1\n  #define DCC_APP_CINEMA4D 2\n  #if USE_SHININESS_MAP\n    uniform sampler2D shininessExponentMap;\n  #endif\n  #if USE_SPECULAR_MAP\n    uniform sampler2D specularMap;\n  #endif\n   #if USE_METALLIC_MAP\n    uniform sampler2D metallicMap;\n  #endif\n  #if USE_VERTEX_COLOR\n    in vec4 v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    uniform sampler2D albedoMap;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    uniform sampler2D transparencyMap;\n  #endif\n  #if USE_NORMAL_MAP\n    in vec3 v_tangent;\n    in vec3 v_bitangent;\n    uniform sampler2D normalMap;\n  #endif\n  #if USE_EMISSIVE_MAP\n    uniform sampler2D emissiveMap;\n  #endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n  float d = max(max(diffuse.x, diffuse.y), diffuse.z);\n  vec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n  normalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n  float s = max(max(specular.x, specular.y), specular.z);\n  float delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n  float deltaSqrt = sqrt(max(0.0, delta));\n  float solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n  vec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n  bool isValidSolver = delta >= 0.0;\n  metallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n  albedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n  return isValidSolver;\n}\n  float discolor(vec3 srcColor) {\n    return dot(GRAY_VECTOR, srcColor);\n  }\n  float convertShininessExponent(float shininessExp)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    #else\n      float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n      float glossiness = pow(l2, 0.5);\n    #endif\n      return glossiness;\n  }\n  float getSpecularIntensityFromRoughness(float roughness)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n    #else\n      float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n    #endif\n      return specularIntensityMultiplier;\n  }\n  vec4 getSpecularColorAndFactor()\n  {\n    vec3 inSpecular = specularColor.rgb;\n    #if USE_SPECULAR_MAP\n        vec4 specularTex = texture(specularMap, TEXTURE_UV);\n        specularTex.rgb = SRGBToLinear(specularTex.rgb);\n        inSpecular = specularTex.rgb;\n    #endif\n    return vec4(inSpecular, specularFactor);\n  }\n  void surf (out StandardSurface s) {\n    vec4 baseColor = diffuseColor;\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(v_color.rgb);\n      baseColor.a *= v_color.a;\n    #endif\n    float diffuseScale = diffuseFactor;\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      baseColor = texColor;\n      diffuseScale = 1.0;\n    #endif\n    baseColor.rgb *= diffuseScale;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < albedoScaleAndCutoff.w) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = specularColorAndFactor.w;\n    #if HAS_EXPORTED_GLOSSINESS\n      inGlossiness = glossiness;\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec4 albedo = baseColor;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    s.normal = v_normal;\n    #if USE_NORMAL_MAP\n      vec3 nmmp = texture(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n      s.normal =\n        (nmmp.x * normalScale) * normalize(v_tangent) +\n        (nmmp.y * normalScale) * normalize(v_bitangent) +\n        nmmp.z * normalize(s.normal);\n    #endif\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      packHighpData(s.position, s.position_fract_part, v_position);\n      #else\n      s.position = v_position;\n      #endif\n    s.albedo = albedo;\n    s.occlusion = 1.0;\n    s.roughness = 1.0 - inGlossiness;\n    s.metallic = inMetallic;\n    s.specularIntensity = inSpecularIntensity * 0.5;\n    s.emissive = vec3(0.0);\n  #if USE_EMISSIVE_MAP\n    s.emissive = texture(emissiveMap, TEXTURE_UV).xyz;\n  #endif\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n      s.lightmap = lightColor.xyz * v_luv.z;\n      s.lightmap_test = v_luv.z;\n    #endif\n  }\n    #if CC_FORWARD_ADD\n      #if CC_PIPELINE_TYPE == 0\n        #define LIGHTS_PER_PASS 1\n      #else\n        #define LIGHTS_PER_PASS 10\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      layout(std140) uniform CCForwardLight {\n        highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n        vec4 cc_lightColor[LIGHTS_PER_PASS];\n        vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n        vec4 cc_lightDir[LIGHTS_PER_PASS];\n      };\n      #endif\n      float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n        float factor = distSqr * invSqrAttRadius;\n        float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n        return smoothFactor * smoothFactor;\n      }\n      float GetDistAtt (float distSqr, float invSqrAttRadius) {\n        float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n        attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n        return attenuation;\n      }\n      float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n        float cd = dot(litDir, L);\n        float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n        return (attenuation * attenuation);\n      }\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.0);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n        for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n          if (i >= numLights) break;\n          vec3 SLU = cc_lightPos[i].xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.0);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = cc_lightSizeRangeAngle[i].x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n          float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (cc_lightPos[i].w > 0.0) {\n            float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n            float cosOuter = cc_lightSizeRangeAngle[i].z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = cc_lightColor[i].rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n      layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n      layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n      layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n      struct CCLight\n      {\n        vec4 cc_lightPos;\n        vec4 cc_lightColor;\n        vec4 cc_lightSizeRangeAngle;\n        vec4 cc_lightDir;\n      };\n      struct Cluster\n      {\n        vec3 minBounds;\n        vec3 maxBounds;\n      };\n      struct LightGrid\n      {\n        uint offset;\n        uint ccLights;\n      };\n      CCLight getCCLight(uint i)\n      {\n        CCLight light;\n        light.cc_lightPos = b_ccLights[4u * i + 0u];\n        light.cc_lightColor = b_ccLights[4u * i + 1u];\n        light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n        light.cc_lightDir = b_ccLights[4u * i + 3u];\n        return light;\n      }\n      LightGrid getLightGrid(uint cluster)\n      {\n        uvec4 gridvec = b_clusterLightGrid[cluster];\n        LightGrid grid;\n        grid.offset = gridvec.x;\n        grid.ccLights = gridvec.y;\n        return grid;\n      }\n      uint getGridLightIndex(uint start, uint offset)\n      {\n        return b_clusterLightIndices[start + offset];\n      }\n      uint getClusterZIndex(vec4 worldPos)\n      {\n        float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n        float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n        float eyeDepth = -(cc_matView * worldPos).z;\n        uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n        return zIndex;\n      }\n      uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n      {\n        uint zIndex = getClusterZIndex(worldPos);\n        float clusterSizeX = ceil(cc_viewPort.z / float(16));\n        float clusterSizeY = ceil(cc_viewPort.w / float(8));\n        uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n        uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n        return cluster;\n      }\n      vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.001);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n        LightGrid grid = getLightGrid(cluster);\n        uint numLights = grid.ccLights;\n        for (uint i = 0u; i < 100u; i++) {\n          if (i >= numLights) break;\n          uint lightIndex = getGridLightIndex(grid.offset, i);\n          CCLight light = getCCLight(lightIndex);\n          vec3 SLU = light.cc_lightPos.xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.001);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = light.cc_lightSizeRangeAngle.x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n          float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (light.cc_lightPos.w > 0.0) {\n            float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n            float cosOuter = light.cc_lightSizeRangeAngle.z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = light.cc_lightColor.rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (light.cc_lightPos.w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      layout(location = 0) out vec4 fragColorX;\n      void main () {\n        StandardSurface s; surf(s);\n        #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n        vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n        #else\n        vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n        #endif\n        fragColorX = CCFragOutput(color);\n      }\n    #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n      layout(location = 0) out vec4 fragColorX;\n      void main () {\n        StandardSurface s; surf(s);\n        vec4 color = CCStandardShadingBase(s, v_shadowPos);\n        CC_APPLY_FOG(color, s.position.xyz);\n        fragColorX = CCFragOutput(color);\n      }\n    #elif CC_PIPELINE_TYPE == 1\n      vec2 signNotZero(vec2 v) {\n        return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n      }\n      vec2 float32x3_to_oct(in vec3 v) {\n        vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n        return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n      }\n      layout(location = 0) out vec4 fragColor0;\n      layout(location = 1) out vec4 fragColor1;\n      layout(location = 2) out vec4 fragColor2;\n      void main () {\n        StandardSurface s; surf(s);\n        fragColor0 = s.albedo;\n        fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n        fragColor2 = vec4(s.emissive, s.occlusion);\n      }\n    #endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\n  precision highp float;\n  uniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n             uniform vec4 albedo;\n           uniform vec4 albedoScaleAndCutoff;\n           uniform vec4 diffuseColor;\n           uniform vec4 specularColor;\n           uniform vec4 emissive;\n           uniform float shininessExponent;\n           uniform float glossiness;\n           uniform float metallic;\n           uniform float normalScale;\n           uniform float transparencyFactor;\n           uniform float diffuseFactor;\n           uniform float specularFactor;\n  float LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n  }\n  float ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n  }\n  float LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n      if (wPos.y < _FogTop) {\n        fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n        fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n      } else {\n        fDeltaY = 0.;\n        fDensityIntegral = 0.;\n      }\n    } else {\n      if (wPos.y < _FogTop) {\n        float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n        fDeltaY = abs(fDeltaA - fDeltaB);\n        fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n      } else {\n        fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n      }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n      fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n      fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n  }\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n    #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      factor = LayeredFog(pos);\n    #else\n      factor = 1.0;\n    #endif\n  }\n  void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n    color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n  }\n  #if !CC_USE_ACCURATE_FOG\n  varying float v_fog_factor;\n  #endif\n    void CC_APPLY_FOG(inout vec4 color) {\n  #if !CC_USE_ACCURATE_FOG\n      CC_APPLY_FOG_BASE(color, v_fog_factor);\n  #endif\n  }\n  void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n  #if CC_USE_ACCURATE_FOG\n      float factor;\n      CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n  #else\n      float factor = v_fog_factor;\n  #endif\n      CC_APPLY_FOG_BASE(color, factor);\n  }\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n  vec3 SRGBToLinear (vec3 gamma) {\n    return gamma * gamma;\n  }\n  uniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(normalBias > EPSILON_LOWP)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n    }else {\n      return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    float realtimeShadow = 1.0;\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n    }else {\n      realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n    }\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #endif\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n        #ifdef GL_EXT_shader_texture_lod\n          return texture2DLodEXT(tex, coord, lod);\n        #else\n          return texture2D(tex, coord, lod);\n        #endif\n    }\n    vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n        #ifdef GL_EXT_shader_texture_lod\n          return textureCubeLodEXT(tex, coord, lod);\n        #else\n          return textureCube(tex, coord, lod);\n        #endif\n    }\n    vec3 unpackRGBE (vec4 rgbe) {\n      return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n    }\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n    vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n      #if CC_USE_IBL\n      \tfloat mip = roughness * mipCount;\n      \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n      \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n       \tvec4 filtered = textureCube(cc_environment, R);\n        #if CC_USE_IBL == 2\n        \tbiased.rgb = unpackRGBE(biased);\n        \tfiltered.rgb = unpackRGBE(filtered);\n        #else\n        \tbiased.rgb = SRGBToLinear(biased.rgb);\n        \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n        #endif\n        return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n      #else\n        return vec3(0.0, 0.0, 0.0);\n      #endif\n    }\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      vec3 position, position_fract_part;\n      #else\n      vec3 position;\n      #endif\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n    float specularIntensity;\n    #if CC_RECEIVE_SHADOW\n      vec2 shadowBias;\n    #endif\n  };\n  vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW\n      if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      }\n    #endif\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      if (s.lightmap_test > EPSILON_LOWP) {\n        finalColor = diffuse * s.lightmap.rgb * shadow;\n      }\n    #endif\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n    #if CC_USE_IBL\n      #if CC_USE_DIFFUSEMAP\n        vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n        #if CC_USE_DIFFUSEMAP == 2\n          ambDiff = unpackRGBE(diffuseMap);\n        #else\n          ambDiff = SRGBToLinear(diffuseMap.rgb);\n        #endif\n      #endif\n      vec3 R = normalize(reflect(-V, N));\n      #if USE_REFLECTION_DENOISE\n        vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n        #if CC_USE_IBL == 2\n          vec3 env = unpackRGBE(envmap);\n        #else\n          vec3 env = SRGBToLinear(envmap.rgb);\n        #endif\n      #endif\n      finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n    #endif\n    finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.albedo.a);\n  }\n  vec3 ACESToneMap (vec3 color) {\n    color = min(color, vec3(8.0));\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n  }\n  vec4 CCFragOutput (vec4 color) {\n    #if CC_USE_HDR\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = sqrt(color.rgb);\n    return color;\n  }\n  varying highp vec4 v_shadowPos;\n    #if CC_RECEIVE_SHADOW\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    varying vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n  #endif\n  varying vec3 v_position;\n  varying vec2 v_uv;\n  varying vec2 v_uv1;\n  varying vec3 v_normal;\n  #define DCC_APP_AUTODESK 0\n  #define DCC_APP_BLENDER 1\n  #define DCC_APP_CINEMA4D 2\n  #if USE_SHININESS_MAP\n    uniform sampler2D shininessExponentMap;\n  #endif\n  #if USE_SPECULAR_MAP\n    uniform sampler2D specularMap;\n  #endif\n   #if USE_METALLIC_MAP\n    uniform sampler2D metallicMap;\n  #endif\n  #if USE_VERTEX_COLOR\n    varying vec4 v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    uniform sampler2D albedoMap;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    uniform sampler2D transparencyMap;\n  #endif\n  #if USE_NORMAL_MAP\n    varying vec3 v_tangent;\n    varying vec3 v_bitangent;\n    uniform sampler2D normalMap;\n  #endif\n  #if USE_EMISSIVE_MAP\n    uniform sampler2D emissiveMap;\n  #endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n  float d = max(max(diffuse.x, diffuse.y), diffuse.z);\n  vec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n  normalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n  float s = max(max(specular.x, specular.y), specular.z);\n  float delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n  float deltaSqrt = sqrt(max(0.0, delta));\n  float solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n  vec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n  bool isValidSolver = delta >= 0.0;\n  metallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n  albedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n  return isValidSolver;\n}\n  float discolor(vec3 srcColor) {\n    return dot(GRAY_VECTOR, srcColor);\n  }\n  float convertShininessExponent(float shininessExp)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    #else\n      float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n      float glossiness = pow(l2, 0.5);\n    #endif\n      return glossiness;\n  }\n  float getSpecularIntensityFromRoughness(float roughness)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n    #else\n      float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n    #endif\n      return specularIntensityMultiplier;\n  }\n  vec4 getSpecularColorAndFactor()\n  {\n    vec3 inSpecular = specularColor.rgb;\n    #if USE_SPECULAR_MAP\n        vec4 specularTex = texture2D(specularMap, TEXTURE_UV);\n        specularTex.rgb = SRGBToLinear(specularTex.rgb);\n        inSpecular = specularTex.rgb;\n    #endif\n    return vec4(inSpecular, specularFactor);\n  }\n  void surf (out StandardSurface s) {\n    vec4 baseColor = diffuseColor;\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(v_color.rgb);\n      baseColor.a *= v_color.a;\n    #endif\n    float diffuseScale = diffuseFactor;\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      baseColor = texColor;\n      diffuseScale = 1.0;\n    #endif\n    baseColor.rgb *= diffuseScale;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture2D(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < albedoScaleAndCutoff.w) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = specularColorAndFactor.w;\n    #if HAS_EXPORTED_GLOSSINESS\n      inGlossiness = glossiness;\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture2D(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture2D(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec4 albedo = baseColor;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    s.normal = v_normal;\n    #if USE_NORMAL_MAP\n      vec3 nmmp = texture2D(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n      s.normal =\n        (nmmp.x * normalScale) * normalize(v_tangent) +\n        (nmmp.y * normalScale) * normalize(v_bitangent) +\n        nmmp.z * normalize(s.normal);\n    #endif\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      packHighpData(s.position, s.position_fract_part, v_position);\n      #else\n      s.position = v_position;\n      #endif\n    s.albedo = albedo;\n    s.occlusion = 1.0;\n    s.roughness = 1.0 - inGlossiness;\n    s.metallic = inMetallic;\n    s.specularIntensity = inSpecularIntensity * 0.5;\n    s.emissive = vec3(0.0);\n  #if USE_EMISSIVE_MAP\n    s.emissive = texture2D(emissiveMap, TEXTURE_UV).xyz;\n  #endif\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n      s.lightmap = lightColor.xyz * v_luv.z;\n      s.lightmap_test = v_luv.z;\n    #endif\n  }\n    #if CC_FORWARD_ADD\n      #if CC_PIPELINE_TYPE == 0\n        #define LIGHTS_PER_PASS 1\n      #else\n        #define LIGHTS_PER_PASS 10\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n      #endif\n      float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n        float factor = distSqr * invSqrAttRadius;\n        float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n        return smoothFactor * smoothFactor;\n      }\n      float GetDistAtt (float distSqr, float invSqrAttRadius) {\n        float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n        attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n        return attenuation;\n      }\n      float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n        float cd = dot(litDir, L);\n        float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n        return (attenuation * attenuation);\n      }\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.0);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n        for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n          if (i >= numLights) break;\n          vec3 SLU = cc_lightPos[i].xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.0);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = cc_lightSizeRangeAngle[i].x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n          float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (cc_lightPos[i].w > 0.0) {\n            float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n            float cosOuter = cc_lightSizeRangeAngle[i].z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = cc_lightColor[i].rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n      readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n      readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n      readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n      struct CCLight\n      {\n        vec4 cc_lightPos;\n        vec4 cc_lightColor;\n        vec4 cc_lightSizeRangeAngle;\n        vec4 cc_lightDir;\n      };\n      struct Cluster\n      {\n        vec3 minBounds;\n        vec3 maxBounds;\n      };\n      struct LightGrid\n      {\n        uint offset;\n        uint ccLights;\n      };\n      CCLight getCCLight(uint i)\n      {\n        CCLight light;\n        light.cc_lightPos = b_ccLights[4u * i + 0u];\n        light.cc_lightColor = b_ccLights[4u * i + 1u];\n        light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n        light.cc_lightDir = b_ccLights[4u * i + 3u];\n        return light;\n      }\n      LightGrid getLightGrid(uint cluster)\n      {\n        uvec4 gridvec = b_clusterLightGrid[cluster];\n        LightGrid grid;\n        grid.offset = gridvec.x;\n        grid.ccLights = gridvec.y;\n        return grid;\n      }\n      uint getGridLightIndex(uint start, uint offset)\n      {\n        return b_clusterLightIndices[start + offset];\n      }\n      uint getClusterZIndex(vec4 worldPos)\n      {\n        float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n        float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n        float eyeDepth = -(cc_matView * worldPos).z;\n        uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n        return zIndex;\n      }\n      uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n      {\n        uint zIndex = getClusterZIndex(worldPos);\n        float clusterSizeX = ceil(cc_viewPort.z / float(16));\n        float clusterSizeY = ceil(cc_viewPort.w / float(8));\n        uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n        uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n        return cluster;\n      }\n      vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.001);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n        LightGrid grid = getLightGrid(cluster);\n        uint numLights = grid.ccLights;\n        for (uint i = 0u; i < 100u; i++) {\n          if (i >= numLights) break;\n          uint lightIndex = getGridLightIndex(grid.offset, i);\n          CCLight light = getCCLight(lightIndex);\n          vec3 SLU = light.cc_lightPos.xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.001);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = light.cc_lightSizeRangeAngle.x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n          float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (light.cc_lightPos.w > 0.0) {\n            float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n            float cosOuter = light.cc_lightSizeRangeAngle.z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = light.cc_lightColor.rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (light.cc_lightPos.w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      void main () {\n        StandardSurface s; surf(s);\n        #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n        vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n        #else\n        vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n        #endif\n        gl_FragData[0] = CCFragOutput(color);\n      }\n    #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n      void main () {\n        StandardSurface s; surf(s);\n        vec4 color = CCStandardShadingBase(s, v_shadowPos);\n        CC_APPLY_FOG(color, s.position.xyz);\n        gl_FragData[0] = CCFragOutput(color);\n      }\n    #elif CC_PIPELINE_TYPE == 1\n      vec2 signNotZero(vec2 v) {\n        return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n      }\n      vec2 float32x3_to_oct(in vec3 v) {\n        vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n        return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n      }\n      void main () {\n        StandardSurface s; surf(s);\n        gl_FragData[0] = s.albedo;\n        gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n        gl_FragData[2] = vec4(s.emissive, s.occlusion);\n      }\n    #endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":231,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":83}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"TEXTURE_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","defines":[],"range":[0,2]},{"name":"USE_SHININESS_MAP","type":"boolean","defines":[]},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","defines":["USE_SHININESS_MAP"],"options":["r","g","b","a"]},{"name":"USE_SPECULAR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_MAP","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"HAS_EXPORTED_GLOSSINESS","type":"boolean","defines":[]},{"name":"GLOSSINESS_MAP_USE_SINGLE_CHANNEL","type":"boolean","defines":["!HAS_EXPORTED_GLOSSINESS","USE_SHININESS_MAP"]},{"name":"HAS_EXPORTED_METALLIC","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":1243567465,"name":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TRANSPARENCY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  layout(set = 1, binding = 2) uniform sampler2D transparencyMap;\n#endif\nvec4 frag () {\n  vec4 baseColor = diffuseColor;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    baseColor *= texColor;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\nvec4 frag () {\n  vec4 baseColor = diffuseColor;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    baseColor *= texColor;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedoScaleAndCutoff;\n   uniform vec4 diffuseColor;\n   uniform float transparencyFactor;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\nvec4 frag () {\n  vec4 baseColor = diffuseColor;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n    baseColor *= texColor;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture2D(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":192,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":83}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"TEXTURE_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}]}],[{"name":"opaque","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","properties":{"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"DiffuseMap"},"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"DiffuseColor","type":"color"},"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"editor":{"displayName":"diffuseFactor"},"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28,"editor":{"parent":"!HAS_EXPORTED_GLOSSINESS"}},"shininessExponent":{"type":13,"value":[100],"editor":{"parent":"!HAS_EXPORTED_GLOSSINESS"}},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0],"editor":{"displayName":"SpecularColor","type":"color"}},"specularMap":{"value":"grey","type":28,"editor":{"parent":"!HAS_EXPORTED_METALLIC"}},"specularFactor":{"type":13,"value":[1],"editor":{"parent":"!HAS_EXPORTED_METALLIC"}},"transparencyMap":{"value":"grey","type":28,"editor":{"displayName":"TransparencyMap"}},"transparencyFactor":{"type":13,"value":[0],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"editor":{"displayName":"bumpFactor","parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0],"editor":{"parent":"HAS_EXPORTED_GLOSSINESS","slide":true,"step":0.001,"range":[0,1]}},"metallic":{"type":13,"value":[0],"editor":{"parent":"HAS_EXPORTED_METALLIC","slide":true,"step":0.001,"range":[0,1]}},"metallicMap":{"value":"grey","type":28,"editor":{"parent":"HAS_EXPORTED_METALLIC"}},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}},"diffuseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"diffuseFactor":{"type":13,"editor":{"visible":false,"deprecated":true},"value":[1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0,0,0,0.5]},"normalScale":{"type":13,"editor":{"visible":false,"deprecated":true},"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"DiffuseMap"},"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"DiffuseColor","type":"color"},"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"editor":{"displayName":"diffuseFactor"},"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28,"editor":{"parent":"!HAS_EXPORTED_GLOSSINESS"}},"shininessExponent":{"type":13,"value":[100],"editor":{"parent":"!HAS_EXPORTED_GLOSSINESS"}},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0],"editor":{"displayName":"SpecularColor","type":"color"}},"specularMap":{"value":"grey","type":28,"editor":{"parent":"!HAS_EXPORTED_METALLIC"}},"specularFactor":{"type":13,"value":[1],"editor":{"parent":"!HAS_EXPORTED_METALLIC"}},"transparencyMap":{"value":"grey","type":28,"editor":{"displayName":"TransparencyMap"}},"transparencyFactor":{"type":13,"value":[0],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"editor":{"displayName":"bumpFactor","parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0],"editor":{"parent":"HAS_EXPORTED_GLOSSINESS","slide":true,"step":0.001,"range":[0,1]}},"metallic":{"type":13,"value":[0],"editor":{"parent":"HAS_EXPORTED_METALLIC","slide":true,"step":0.001,"range":[0,1]}},"metallicMap":{"value":"grey","type":28,"editor":{"parent":"HAS_EXPORTED_METALLIC"}},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}},"diffuseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"diffuseFactor":{"type":13,"editor":{"visible":false,"deprecated":true},"value":[1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0,0,0,0.5]},"normalScale":{"type":13,"editor":{"visible":false,"deprecated":true},"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]]]]
