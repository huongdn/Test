System.register([], function (exports, module) {
  'use strict';
  return {
    execute: function () {

      exports({
        BitMask: BitMask,
        CCClass: CCClass,
        CacheMode: void 0,
        DebugMode: void 0,
        Enum: Enum,
        Eventify: Eventify,
        ExtrapolationMode: void 0,
        HorizontalTextAlignment: void 0,
        InstanceMaterialType: void 0,
        KeyCode: void 0,
        NodeEventType: void 0,
        NodeSpace: void 0,
        Overflow: void 0,
        PipelineEventType: void 0,
        QuatInterpolationMode: void 0,
        RealInterpolationMode: void 0,
        SystemEventType: void 0,
        TangentWeightMode: void 0,
        TransformBit: void 0,
        VerticalTextAlignment: void 0,
        WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
        WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI,
        absMax: absMax,
        absMaxComponent: absMaxComponent,
        approx: approx,
        assert: assert,
        assertID: assertID,
        ccenum: ccenum,
        clamp: clamp,
        clamp01: clamp01,
        color: color,
        createDefaultPipeline: createDefaultPipeline,
        debug: debug,
        deserialize: deserialize,
        earcut: earcut,
        enumerableProps: enumerableProps,
        equals: equals,
        error: error,
        errorID: errorID,
        find: find,
        fragmentText: fragmentText,
        getBaselineOffset: getBaselineOffset,
        getEnglishWordPartAtFirst: getEnglishWordPartAtFirst,
        getEnglishWordPartAtLast: getEnglishWordPartAtLast,
        getError: getError,
        getSerializationMetadata: getSerializationMetadata,
        instantiate: instantiate,
        inverseLerp: inverseLerp,
        isDisplayStats: isDisplayStats,
        isEnglishWordPartAtFirst: isEnglishWordPartAtFirst,
        isEnglishWordPartAtLast: isEnglishWordPartAtLast,
        isUnicodeCJK: isUnicodeCJK,
        isUnicodeSpace: isUnicodeSpace,
        isValid: isValid,
        lerp: lerp,
        log: log,
        logID: logID,
        markAsWarning: void 0,
        mat4: mat4,
        murmurhash2_32_gc: murmurhash2_32_gc,
        nextPow2: nextPow2$1,
        pingPong: pingPong,
        pseudoRandom: pseudoRandom,
        pseudoRandomRange: pseudoRandomRange,
        pseudoRandomRangeInt: pseudoRandomRangeInt,
        quat: quat,
        randomRange: randomRange,
        randomRangeInt: randomRangeInt,
        rect: rect,
        removeProperty: void 0,
        repeat: repeat,
        replaceProperty: void 0,
        safeMeasureText: safeMeasureText,
        setDefaultLogTimes: setDefaultLogTimes,
        setDisplayStats: setDisplayStats,
        size: size,
        toDegree: toDegree,
        toRadian: toRadian,
        v2: v2,
        v3: v3,
        v4: v4,
        warn: warn,
        warnID: warnID
      });

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;

        _setPrototypeOf(subClass, superClass);
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
          };
        }

        return _construct.apply(null, arguments);
      }

      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }

      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? new Map() : undefined;

        _wrapNativeSuper = function _wrapNativeSuper(Class) {
          if (Class === null || !_isNativeFunction(Class)) return Class;

          if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }

          if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);

            _cache.set(Class, Wrapper);
          }

          function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
          }

          Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class);
        };

        return _wrapNativeSuper(Class);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
      }

      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it;

        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            return function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            };
          }

          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        it = o[Symbol.iterator]();
        return it.next.bind(it);
      }

      function _initializerDefineProperty(target, property, descriptor, context) {
        if (!descriptor) return;
        Object.defineProperty(target, property, {
          enumerable: descriptor.enumerable,
          configurable: descriptor.configurable,
          writable: descriptor.writable,
          value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
        });
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }

      const WECHAT = false;
      const ALIPAY = false;
      const BAIDU = false;
      const XIAOMI = false;
      const BYTEDANCE = false;
      const OPPO = false;
      const VIVO = false;
      const HUAWEI = false;
      const NATIVE = false;
      const COCOSPLAY = false;
      const EDITOR = false;
      const PREVIEW = false;
      const BUILD = true;
      const TEST = false;
      const DEBUG = true;
      const DEV = false;
      const RUNTIME_BASED = false;
      const MINIGAME = false;
      const JSB = false;
      const SUPPORT_JIT = true;

      var _global = typeof window === 'undefined' ? global : window;

      var legacyCC = exports('cclegacy', {
        _global: _global
      });
      legacyCC.internal = {};

      {
        _global.CC_BUILD = BUILD;
        _global.CC_TEST = TEST;
        _global.CC_EDITOR = EDITOR;
        _global.CC_PREVIEW = PREVIEW;
        _global.CC_DEV = DEV;
        _global.CC_DEBUG = DEBUG;
        _global.CC_JSB = JSB;
        _global.CC_BYTEDANCE = BYTEDANCE;
        _global.CC_WECHAT = WECHAT;
        _global.CC_ALIPAY = ALIPAY;
        _global.CC_XIAOMI = XIAOMI;
        _global.CC_BAIDU = BAIDU;
        _global.CC_COCOSPLAY = COCOSPLAY;
        _global.CC_HUAWEI = HUAWEI;
        _global.CC_OPPO = OPPO;
        _global.CC_VIVO = VIVO;
        _global.CC_MINIGAME = MINIGAME;
        _global.CC_RUNTIME_BASED = RUNTIME_BASED;
        _global.CC_SUPPORT_JIT = SUPPORT_JIT;
      }

      var engineVersion = exports('VERSION', '3.5.2');
      _global.CocosEngine = legacyCC.ENGINE_VERSION = engineVersion;
      _global.cc = legacyCC;

      var INT_BITS = 32;
      var INT_MAX = 0x7fffffff;
      var INT_MIN = -1 << INT_BITS - 1;
      function sign(v) {
        return (v > 0) - (v < 0);
      }
      function abs(v) {
        var mask = v >> INT_BITS - 1;
        return (v ^ mask) - mask;
      }
      function min(x, y) {
        return y ^ (x ^ y) & -(x < y);
      }
      function max(x, y) {
        return x ^ (x ^ y) & -(x < y);
      }
      function isPow2(v) {
        return !(v & v - 1) && !!v;
      }
      function log2(v) {
        var r;
        var shift;
        r = (v > 0xFFFF) << 4;
        v >>>= r;
        shift = (v > 0xFF) << 3;
        v >>>= shift;
        r |= shift;
        shift = (v > 0xF) << 2;
        v >>>= shift;
        r |= shift;
        shift = (v > 0x3) << 1;
        v >>>= shift;
        r |= shift;
        return r | v >> 1;
      }
      function log10(v) {
        return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
      }
      function popCount(v) {
        v -= v >>> 1 & 0x55555555;
        v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
        return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
      }
      function countTrailingZeros(v) {
        var c = 32;
        v &= -v;

        if (v) {
          c--;
        }

        if (v & 0x0000FFFF) {
          c -= 16;
        }

        if (v & 0x00FF00FF) {
          c -= 8;
        }

        if (v & 0x0F0F0F0F) {
          c -= 4;
        }

        if (v & 0x33333333) {
          c -= 2;
        }

        if (v & 0x55555555) {
          c -= 1;
        }

        return c;
      }
      function nextPow2(v) {
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
      }
      function prevPow2(v) {
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v - (v >>> 1);
      }
      function parity(v) {
        v ^= v >>> 16;
        v ^= v >>> 8;
        v ^= v >>> 4;
        v &= 0xf;
        return 0x6996 >>> v & 1;
      }
      var REVERSE_TABLE = new Array(256);

      (function (tab) {
        for (var i = 0; i < 256; ++i) {
          var v = i;
          var r = i;
          var s = 7;

          for (v >>>= 1; v; v >>>= 1) {
            r <<= 1;
            r |= v & 1;
            --s;
          }

          tab[i] = r << s & 0xff;
        }
      })(REVERSE_TABLE);

      function reverse(v) {
        return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
      }
      function interleave2(x, y) {
        x &= 0xFFFF;
        x = (x | x << 8) & 0x00FF00FF;
        x = (x | x << 4) & 0x0F0F0F0F;
        x = (x | x << 2) & 0x33333333;
        x = (x | x << 1) & 0x55555555;
        y &= 0xFFFF;
        y = (y | y << 8) & 0x00FF00FF;
        y = (y | y << 4) & 0x0F0F0F0F;
        y = (y | y << 2) & 0x33333333;
        y = (y | y << 1) & 0x55555555;
        return x | y << 1;
      }
      function deinterleave2(v, n) {
        v = v >>> n & 0x55555555;
        v = (v | v >>> 1) & 0x33333333;
        v = (v | v >>> 2) & 0x0F0F0F0F;
        v = (v | v >>> 4) & 0x00FF00FF;
        v = (v | v >>> 16) & 0x000FFFF;
        return v << 16 >> 16;
      }
      function interleave3(x, y, z) {
        x &= 0x3FF;
        x = (x | x << 16) & 4278190335;
        x = (x | x << 8) & 251719695;
        x = (x | x << 4) & 3272356035;
        x = (x | x << 2) & 1227133513;
        y &= 0x3FF;
        y = (y | y << 16) & 4278190335;
        y = (y | y << 8) & 251719695;
        y = (y | y << 4) & 3272356035;
        y = (y | y << 2) & 1227133513;
        x |= y << 1;
        z &= 0x3FF;
        z = (z | z << 16) & 4278190335;
        z = (z | z << 8) & 251719695;
        z = (z | z << 4) & 3272356035;
        z = (z | z << 2) & 1227133513;
        return x | z << 2;
      }
      function deinterleave3(v, n) {
        v = v >>> n & 1227133513;
        v = (v | v >>> 2) & 3272356035;
        v = (v | v >>> 4) & 251719695;
        v = (v | v >>> 8) & 4278190335;
        v = (v | v >>> 16) & 0x3FF;
        return v << 22 >> 22;
      }
      function nextCombination(v) {
        var t = v | v - 1;
        return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
      }

      var bits = /*#__PURE__*/Object.freeze({
        __proto__: null,
        INT_BITS: INT_BITS,
        INT_MAX: INT_MAX,
        INT_MIN: INT_MIN,
        sign: sign,
        abs: abs,
        min: min,
        max: max,
        isPow2: isPow2,
        log2: log2,
        log10: log10,
        popCount: popCount,
        countTrailingZeros: countTrailingZeros,
        nextPow2: nextPow2,
        prevPow2: prevPow2,
        parity: parity,
        reverse: reverse,
        interleave2: interleave2,
        deinterleave2: deinterleave2,
        interleave3: interleave3,
        deinterleave3: deinterleave3,
        nextCombination: nextCombination
      });
      exports('bits', bits);

      var debugInfos = {
      	"1006": "[Action step]. override me",
      	"1007": "[Action update]. override me",
      	"1008": "[Action reverse]. override me",
      	"1100": "Expected 'data' dict, but not found. Config file: %s",
      	"1101": "Please load the resource first : %s",
      	"1200": "cocos2d: Director: Error in gettimeofday",
      	"1204": "Running scene should not be null",
      	"1205": "The scene should not be null",
      	"1206": "loadScene: The scene index to load (%s) is out of range.",
      	"1207": "loadScene: Unknown name type to load: '%s'",
      	"1208": "loadScene: Failed to load scene '%s' because '%s' is already being loaded.",
      	"1209": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      	"1210": "Failed to preload '%s', %s",
      	"1211": "loadScene: The scene index to load (%s) is out of range.",
      	"1212": "loadScene: Unknown name type to load: '%s'",
      	"1213": "loadScene: Failed to load scene '%s' because '%s' is already loading",
      	"1214": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      	"1215": "Failed to preload '%s', %s",
      	"1216": "Director.runSceneImmediate: scene is not valid",
      	"1217": "Director._initOnEngineInitialized: renderer root initialization failed",
      	"1218": "Forward render pipeline initialized.",
      	"1219": "Deferred render pipeline initialized. Note that non-transparent materials with no lighting will not be rendered, such as builtin-unlit.",
      	"1220": "Failed to set shading scale, pipelineSceneData is invalid.",
      	"1221": "Setting orientation is not supported yet.",
      	"1300": "%s is not in the model pool and cannot be destroyed by destroyModel.",
      	"1400": "'%s' is deprecated, please use '%s' instead.",
      	"1404": "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
      	"1406": "'%s.%s' is removed",
      	"1408": "'%s' is removed",
      	"1409": "element type is wrong!",
      	"1502": "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
      	"1503": "cc.Scheduler.pauseTarget():target should be non-null",
      	"1504": "cc.Scheduler.resumeTarget():target should be non-null",
      	"1505": "cc.Scheduler.isTargetPaused():target should be non-null",
      	"1506": "warning: you CANNOT change update priority in scheduled function",
      	"1507": "scheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
      	"1508": "Argument callback must not be empty",
      	"1509": "Argument target must be non-nullptr",
      	"1510": "cc.Scheduler: Illegal target which doesn't have id, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
      	"1511": "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
      	"1513": "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
      	"1607": "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
      	"1619": "callback function must be non-null",
      	"1620": "interval must be positive",
      	"1623": "Set '%s' to normal node (not persist root node).",
      	"1624": "Replacing with the same sgNode",
      	"1625": "The replacement sgNode should not contain any child.",
      	"1626": "Should not set alpha via 'color', set 'opacity' please.",
      	"1627": "Not support for asynchronous creating node in SG",
      	"1632": "Node name can not include '/'.",
      	"1633": "Internal error, should not remove unknown node from parent.",
      	"1635": "reorderChild: this child is not in children list.",
      	"1636": "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
      	"1637": "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
      	"1638": "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
      	"1800": "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
      	"1801": "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
      	"1802": "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
      	"1803": "cc._EventListenerAcceleration.checkAvailable():_onAccelerationEvent must be non-nil",
      	"1900": "Invalid parameter.",
      	"2104": "Layer collision. The name of layer (%s) is collided with the name or value of some layer",
      	"2200": "Design resolution not valid",
      	"2201": "should set resolutionPolicy",
      	"2300": "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
      	"2402": "Forward pipeline startup failed!",
      	"3103": "cc.Texture.addImage(): path should be non-null",
      	"3119": "Lazy init texture with image element failed due to image loading failure: %s",
      	"3120": "Loading texture with unsupported type: '%s'. Add '%s' into 'cc.macro.SUPPORT_TEXTURE_FORMATS' please.",
      	"3121": "Can't find a texture format supported by the current platform! Please add a fallback format in the editor.",
      	"3122": "Error Texture in %s.",
      	"3123": "Set same texture %s.",
      	"3124": "Texture: setMipRange failed because base level is larger than max level",
      	"3300": "Rect width exceeds maximum margin: %s",
      	"3301": "Rect height exceeds maximum margin: %s",
      	"3500": "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
      	"3501": "Invalid listener type!",
      	"3502": "Can't set fixed priority with scene graph based listener.",
      	"3503": "Invalid parameters.",
      	"3504": "listener must be a cc.EventListener object when adding a fixed priority listener",
      	"3505": "The listener has been registered, please don't register it again.",
      	"3506": "Unsupported listener target.",
      	"3507": "Invalid scene graph priority!",
      	"3508": "If program goes here, there should be event in dispatch.",
      	"3509": "_inDispatch should be 1 here.",
      	"3510": "%s's scene graph node not contains in the parent's children",
      	"3511": "event is undefined",
      	"3512": "Event manager only support scene graph priority for ui nodes which contain UIComponent",
      	"3520": "Device Motion Event request permission: %s",
      	"3521": "Device Motion Event request permission failed: %s",
      	"3601": "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
      	"3602": "Unknown editor property '%s' in class '%s'.",
      	"3603": "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
      	"3604": "Can only indicate one type attribute for %s.",
      	"3605": "The default value of %s is not instance of %s.",
      	"3606": "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
      	"3607": "The default value of %s must be an empty string.",
      	"3608": "The type of %s must be CCString, not String.",
      	"3609": "The type of %s must be CCBoolean, not Boolean.",
      	"3610": "The type of %s must be CCFloat or CCInteger, not Number.",
      	"3611": "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
      	"3612": "%s Just set the default value to 'new %s()' and it will be handled properly.",
      	"3613": "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
      	"3614": "Should not define constructor for cc.Component %s.",
      	"3615": "Each script can have at most one Component.",
      	"3616": "Should not specify class name %s for Component which defines in project.",
      	"3618": "ctor of '%s' can not be another CCClass",
      	"3623": "Can not use 'editor' attribute, '%s' not inherits from Components.",
      	"3625": "[isChildClassOf] superclass should be function type, not",
      	"3626": "Can't remove '%s' because '%s' depends on it.",
      	"3627": "Should not add renderer component (%s) to a Canvas node.",
      	"3628": "Should not add %s to a node which size is already used by its other component.",
      	"3633": "Properties function of '%s' should return an object!",
      	"3634": "Disallow to use '.' in property name",
      	"3637": "Can not declare %s.%s, it is already defined in the prototype of %s",
      	"3639": "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
      	"3640": "'%s': the setter of '%s' is already defined!",
      	"3641": "Can not construct %s because it contains object property.",
      	"3644": "Please define 'type' parameter of %s.%s as the actual constructor.",
      	"3645": "Please define 'type' parameter of %s.%s as the constructor of %s.",
      	"3646": "Unknown 'type' parameter of %s.%s：%s",
      	"3647": "The length of range array must be equal or greater than 2",
      	"3648": "Can not declare %s.%s method, it is already defined in the properties of %s.",
      	"3652": "Failed to `new %s()` under the hood, %s\nIt is used for getting default values declared in TypeScript in the first place.\nPlease ensure the constructor can be called during the script's initialization.",
      	"3653": "Please do not specifiy \"default\" attribute in decorator of \"%s\" property in \"%s\" class.\nDefault value must be initialized at their declaration:\n\n \n// Before:\n@property({\n  type: cc.SpriteFrame\n  default: null  // <--\n})\nmyProp;\n// After:\n@property({\n  type: cc.SpriteFrame\n})\nmyProp = null;   // <--",
      	"3654": "Please specifiy a default value for \"%s.%s\" property at its declaration:\n\n \n// Before:\n@property(...)\nmyProp;\n// After:\n@property(...)\nmyProp = 0;",
      	"3655": "Can not specifiy \"get\" or \"set\"  attribute in decorator for \"%s\" property in \"%s\" class.\nPlease use:\n\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}",
      	"3659": "Violation error: extending enumerations shall have non-overlaped member names or member values",
      	"3660": "You are explicitly specifying `undefined` type to cc property \"%s\" of cc class \"%s\".\nIs this intended? If not, this may indicate a circular reference.\nFor example:\n\n \n// foo.ts\nimport { _decorator } from 'cc';\nimport { Bar } from './bar';  // Given that './bar' also reference 'foo.ts'.\n                              // When importing './bar', execution of './bar' is hung on to wait execution of 'foo.ts',\n                              // the `Bar` imported here is `undefined` until './bar' finish its execution.\n                              // It leads to that\n@_decorator.ccclass           //  ↓\nexport class Foo {            //  ↓\n    @_decorator.type(Bar)     //  → is equivalent to `@_decorator.type(undefined)`\n    public bar: Bar;          // To eliminate this error, either:\n                              // - Refactor your module structure(recommended), or\n                              // - specify the type as cc class name: `@_decorator.type('Bar'/* or any name you specified for `Bar` */)`\n}",
      	"3700": "internal error: _prefab is undefined",
      	"3701": "Failed to load prefab asset for node '%s'",
      	"3800": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      	"3801": "The node can not be made persist because it's not under root node.",
      	"3802": "The node can not be made persist because it's not in current scene.",
      	"3803": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      	"3804": "getComponent: Type must be non-nil",
      	"3805": "Can't add component '%s' because %s already contains the same component.",
      	"3806": "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
      	"3807": "addComponent: Failed to get class '%s'",
      	"3808": "addComponent: Should not add component ('%s') when the scripts are still loading.",
      	"3809": "addComponent: The component to add must be a constructor",
      	"3810": "addComponent: The component to add must be child class of cc.Component",
      	"3811": "_addComponentAt: The component to add must be a constructor",
      	"3812": "_addComponentAt: Index out of range",
      	"3813": "removeComponent: Component must be non-nil",
      	"3814": "Argument must be non-nil",
      	"3815": "Component not owned by this entity",
      	"3816": "Node '%s' is already activating",
      	"3817": "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
      	"3818": "Failed to read or parse project.json",
      	"3819": "Warning: target element is not a DIV or CANVAS",
      	"3820": "The renderer doesn't support the renderMode %s",
      	"3821": "Cannot change hierarchy while activating or deactivating the parent.",
      	"3822": "addComponent: Cannot add any component to the scene.",
      	"3823": "The enabled component (id: %s, name: %s) doesn't have a valid node",
      	"3900": "Invalid clip to add",
      	"3901": "Invalid clip to remove",
      	"3902": "clip is defaultClip, set force to true to force remove clip and animation state",
      	"3903": "animation state is playing, set force to true to force stop and remove clip and animation state",
      	"3904": "motion path of target [%s] in prop [%s] frame [%s] is not valid",
      	"3905": "sprite frames must be an Array.",
      	"3906": "Can't find easing type [%s]",
      	"3907": "Animation state is not playing or already removed",
      	"3912": "already-playing",
      	"3920": "Current context does not allow root motion.",
      	"3921": "You provided a ill-formed track path. The last component of track path should be property key, or the setter should not be empty.",
      	"3923": "Root motion is ignored since root bone could not be located in animation.",
      	"3924": "Root motion is ignored since the root bone could not be located in scene.",
      	"3925": "Target of hierarchy path should be of type Node.",
      	"3926": "Node \"%s\" has no path \"%s\".",
      	"3927": "Target of component path should be of type Node.",
      	"3928": "Node \"%s\" has no component \"%s\".",
      	"3929": "Target object has no property \"%s\".",
      	"3930": "Can not decide type for untyped track: runtime binding does not provide a getter.",
      	"3931": "Can not decide type for untyped track: got a unsupported value from runtime binding.",
      	"3932": "Common targets should only target Vectors/`Size`/`Color`.",
      	"3933": "Each curve that has common target should be numeric curve and targets string property.",
      	"3934": "Misconfigured legacy curve: the first keyframe value is number but others aren't.",
      	"3935": "We don't currently support conversion of \\`CubicSplineQuatValue\\`.",
      	"3936": "Instancing/Batching enabled for non-baked skinning model '%s', this may result in unexpected rendering artifacts. Consider turning it off in the material if you do not intend to do this.",
      	"4003": "Label font size can't be shirnked less than 0!",
      	"4004": "force notify all fonts loaded!",
      	"4011": "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
      	"4012": "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
      	"4013": "Sorry, lineHeight of system font not supported on JSB.",
      	"4200": "MaskType: IMAGE_STENCIL only support WebGL mode.",
      	"4201": "The alphaThreshold invalid in Canvas Mode.",
      	"4202": "The inverted invalid in Canvas Mode.",
      	"4300": "Can not found the %s page.",
      	"4301": "Can not add a page without UITransform.",
      	"4302": "Can not set the scroll view content when it hasn't UITransform or its parent hasn't UITransform.",
      	"4400": "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
      	"4500": "Graphics: There is no model in %s.",
      	"4600": "Script attached to '%s' is missing or invalid.",
      	"4700": "The dom control is not created!",
      	"4800": "unknown asset type",
      	"4901": "loadRes: should not specify the extname in %s %s",
      	"4902": "No need to release non-cached asset.",
      	"4914": "Resources url '%s' does not exist.",
      	"4915": "Pack indices and data do not match in size",
      	"4916": "Failed to download package for %s",
      	"4921": "Invalid pipe or invalid index provided!",
      	"4922": "The pipe to be inserted is already in the pipeline!",
      	"4923": "Uuid Loader: Parse asset [ %s ] failed : %s",
      	"4924": "JSON Loader: Input item doesn't contain string content",
      	"4925": "Uuid Loader: Deserialize asset [ %s ] failed : %s",
      	"4926": "Audio Downloader: no web audio context.",
      	"4927": "Audio Downloader: audio not supported on this browser!",
      	"4928": "Load %s failed!",
      	"4929": "Load Webp ( %s ) failed",
      	"4930": "Load image ( %s ) failed",
      	"4932": "Since v1.10, for any atlas (\"%s\") in the \"resources\" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.",
      	"4933": "Download Font [ %s ] failed, using Arial or system default font instead",
      	"4934": "Please assure that the full path of sub asset is correct!",
      	"4935": "Failed to skip prefab asset while deserializing PrefabInfo",
      	"5000": "You are trying to destroy a object twice or more.",
      	"5001": "object not yet destroyed",
      	"5100": "Not a plist file!",
      	"5200": "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
      	"5201": "browser don't support web audio",
      	"5202": "This feature supports WebGL render mode only.",
      	"5300": "Type of target to deserialize not matched with data: target is %s, data is %s",
      	"5301": "Can not find script '%s'",
      	"5302": "Can not find class '%s'",
      	"5303": "Failed to deserialize %s, missing _deserialize function.",
      	"5304": "Unable to deserialize version %s data.",
      	"5402": "cc.js.addon called on non-object:",
      	"5403": "cc.js.mixin: arguments must be type object:",
      	"5404": "The base class to extend from must be non-nil",
      	"5405": "The class to extend must be non-nil",
      	"5406": "Class should be extended before assigning any prototype members.",
      	"5500": "'notify' can not be used in 'get/set' !",
      	"5501": "'notify' must be used with 'default' !",
      	"5507": "The 'default' attribute of '%s.%s' must be an array",
      	"5508": "Invalid type of %s.%s",
      	"5510": "The 'type' attribute of '%s.%s' can not be 'Number', use cc.Float or cc.Integer instead please.",
      	"5511": "The 'type' attribute of '%s.%s' is undefined when loading script",
      	"5512": "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
      	"5513": "The 'default' value of '%s.%s' should not be used with a 'get' function.",
      	"5514": "The 'default' value of '%s.%s' should not be used with a 'set' function.",
      	"5515": "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
      	"5517": "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
      	"5601": "Can not get current scene.",
      	"5602": "Scene is destroyed",
      	"5603": "reference node is destroyed",
      	"5700": "no %s or %s on %s",
      	"5800": "%s.lerp not yet implemented.",
      	"5801": "%s.clone not yet implemented.",
      	"5802": "%s.equals not yet implemented.",
      	"5900": "MotionStreak only support WebGL mode.",
      	"5901": "cc.MotionStreak.getOpacity has not been supported.",
      	"5902": "cc.MotionStreak.setOpacity has not been supported.",
      	"6000": "Custom should not be false if file is not specified.",
      	"6001": "The new %s must not be NaN",
      	"6017": "Incomplete or corrupt PNG file",
      	"6018": "Invalid filter algorithm: %s",
      	"6019": "Invalid byte order value.",
      	"6020": "You forgot your towel!",
      	"6021": "Unknown Field Tag: %s",
      	"6022": "Too many bits requested",
      	"6023": "No bits requested",
      	"6024": "Cannot recover from missing StripByteCounts",
      	"6025": "Cannot handle sub-byte bits per sample",
      	"6026": "Cannot handle sub-byte bits per pixel",
      	"6027": "Palette image missing color map",
      	"6028": "Unknown Photometric Interpretation: %s",
      	"6029": "Unkown error",
      	"6030": "cc.ParticleSystem: error decoding or ungzipping textureImageData",
      	"6031": "cc.ParticleSystem: unknown image format with Data",
      	"6032": "cc.ParticleSystem.initWithDictionary() : error loading the texture",
      	"6033": "cc.ParticleSystem: not allowing create to be invoked twice with different particle system",
      	"6034": "cc.ParticleSystem: shouldn't be initialized repetitively, otherwise there will be potential leak",
      	"6400": "asset.url is not usable in core process",
      	"6402": "AssetLibrary has already been initialized!",
      	"6500": "Widget target must be one of the parent nodes of it",
      	"6600": "collider not added or already removed",
      	"6601": "Can't find testFunc for (%s, $s).",
      	"6700": "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time.",
      	"6705": "Argument must be non-nil",
      	"6706": "Priority can't be set in RenderRoot2D node",
      	"6800": "Callback of event must be non-nil",
      	"6801": "The message must be provided",
      	"6900": "The thing you want to instantiate must be an object",
      	"6901": "The thing you want to instantiate is nil",
      	"6902": "The thing you want to instantiate is destroyed",
      	"6903": "The instantiate method for given asset do not implemented",
      	"6904": "Can not instantiate array",
      	"6905": "Can not instantiate DOM element",
      	"7100": "%s already defined in Enum.",
      	"7101": "Sorry, 'cc.Enum' not available on this platform, please report this error here: <https://github.com/cocos-creator/engine/issues/new>",
      	"7200": "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
      	"7201": "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
      	"7202": "Add component TiledLayer into node failed.",
      	"7203": "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
      	"7210": "TMX Hexa zOrder not supported",
      	"7211": "TMX invalid value",
      	"7215": "cocos2d: Warning: TMX Layer %s has no tiles",
      	"7216": "cocos2d: TMXFormat: Unsupported TMX version: %s",
      	"7217": "cocos2d: TMXFomat: Unsupported orientation: %s",
      	"7218": "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
      	"7219": "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
      	"7221": "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
      	"7222": "Parse %s failed.",
      	"7236": "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
      	"7237": "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
      	"7238": "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
      	"7239": "cc.TMXLayer.setTileGID(): invalid gid: %s",
      	"7240": "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
      	"7241": "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
      	"7401": "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
      	"7402": "Failed to set _animationIndex for '%s' because the index is out of range.",
      	"7501": "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
      	"7502": "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
      	"7503": "Failed to set _animationIndex for '%s' because the index is out of range.",
      	"7504": "Can not render dynamic created SkeletonData",
      	"7506": "Failed to load spine atlas '$s'",
      	"7507": "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
      	"7508": "The atlas asset of '%s' is not exists!",
      	"7509": "Spine: Animation not found: %s",
      	"7510": "Spine: Animation not found: %s",
      	"7600": "The context of RenderTexture is invalid.",
      	"7601": "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
      	"7602": "Could not attach texture to the framebuffer",
      	"7603": "clearDepth isn't supported on Cocos2d-Html5",
      	"7604": "saveToFile isn't supported on Cocos2d-Html5",
      	"7605": "newCCImage isn't supported on Cocos2d-Html5",
      	"7606": "GFXTexture is null",
      	"7607": "readPixels buffer size smaller than %d",
      	"7700": "On the web is always keep the aspect ratio",
      	"7701": "Can't know status",
      	"7702": "Video player's duration is not ready to get now!",
      	"7703": "Video Downloader: video not supported on this browser!",
      	"7800": "Web does not support loading",
      	"7801": "Web does not support query history",
      	"7802": "Web does not support query history",
      	"7803": "The current browser does not support the GoBack",
      	"7804": "The current browser does not support the GoForward",
      	"7805": "Web does not support zoom",
      	"7900": "cc.math.Matrix3.assign(): current matrix equals matIn",
      	"7901": "cc.math.mat4Assign(): pOut equals pIn",
      	"7902": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      	"7903": "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
      	"7904": "cc.math.Matrix4.extractPlane: Invalid plane index",
      	"7905": "cc.math.mat4Assign(): pOut equals pIn",
      	"7906": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      	"7907": "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
      	"7908": "Invalid matrix mode specified",
      	"7909": "current quaternion is an invalid value",
      	"8000": "Can't handle this field type or size",
      	"8001": "No bytes requested",
      	"8002": "Too many bytes requested",
      	"8003": "Missing StripByteCounts!",
      	"8100": "cocos2d: ERROR: Failed to compile shader:\n %s",
      	"8101": "cocos2d: ERROR: Failed to compile vertex shader",
      	"8102": "cocos2d: ERROR: Failed to compile fragment shader",
      	"8103": "cc.GLProgram.link(): Cannot link invalid program",
      	"8104": "cocos2d: ERROR: Failed to link program: %s",
      	"8105": "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
      	"8106": "Please load the resource firset : %s",
      	"8107": "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
      	"8108": "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
      	"8109": "modelView matrix is undefined.",
      	"8200": "Please set node's active instead of rigidbody's enabled.",
      	"8300": "Should only one camera exists, please check your project.",
      	"8301": "Camera does not support Canvas Mode.",
      	"8302": "Camera.viewport is deprecated, please use setViewportInOrientedSpace instead.",
      	"8400": "Wrong type arguments, 'filePath' must be a String.",
      	"9000": "Stencil manager does not support level bigger than %d in this device.",
      	"9001": "Stencil manager is already empty, cannot pop any mask",
      	"9002": "Failed to request any buffer from a mesh buffer without accessor",
      	"9003": "The internal state of LinearBufferAccessor have severe issue and irreversible, please check the reason",
      	"9004": "Failed to allocate chunk in StaticVBAccessor, the requested buffer might be too large: %d bytes",
      	"9005": "BATCHER2D_MEM_INCREMENT is too large, the Max value for BATCHER2D_MEM_INCREMENT is 2303KB (smaller than 65536 * 9 * 4 / 1024 = 2304KB)",
      	"9006": "QuadRenderData is removed, please use MeshRenderData instead.",
      	"9100": "texture size exceeds current device limits %d/%d",
      	"9201": "Cannot access game frame or container.",
      	"9202": "Setting window size is not supported.",
      	"9300": "The current buffer beyond the limit in ui static component, please reduce the amount",
      	"9301": "The UI has not been initialized",
      	"9302": "Can't getGFXSampler with out device",
      	"9600": "[Physics]: please check to see if physics modules are included",
      	"9610": "[Physics]: cannon.js physics system doesn't support capsule collider",
      	"9611": "[Physics]: builtin physics system doesn't support mesh collider",
      	"9612": "[Physics]: builtin physics system doesn't support cylinder collider",
      	"9620": "[Physics][Ammo]: changing the mesh is not supported after the initialization is completed",
      	"10001": "The sub-mesh contains %d vertices, which beyonds the capability (%d vertices most) of renderer of your platform.",
      	"10002": "Sub-mesh may include at most %d morph targets, but you specified %d.",
      	"11000": "WebGL context lost.",
      	"12001": "BlendFactors are disabled when using custom material, please modify the blend state in the material instead.",
      	"12002": "Can't add renderable component to this node because it already have one.",
      	"12004": "SubModel can only support %d passes.",
      	"12005": "Material already initialized, request aborted.",
      	"12006": "Pass already destroyed.",
      	"12007": "This is old usage, please swap the parameters.",
      	"12008": "GeometryRenderer: too many lines.",
      	"12009": "GeometryRenderer: too many triangles.",
      	"12100": "The font size is too big to be fitted into texture atlas. Please switch to other label cache modes or choose a smaller font size.",
      	"12101": "The asset %s has been destroyed!",
      	"13100": "Incorrect CCON magic.",
      	"13101": "Unknown CCON version number: %d.",
      	"13102": "CCON Format error.",
      	"13103": "Can not encode CCON binary: lack of text encoder.",
      	"13104": "Can not decode CCON binary: lack of text decoder.",
      	"14000": "Graph update has been interrupted since too many transitions(greater than %s) occurred during one frame.",
      	"14100": "Pool.destroy no longer take a function as parameter, Please specify destruct function in the construction of Pool instead",
      	"14200": "Can not keep world transform due to the zero scaling of parent node\n\n<!-- Rendering algorithm reserved: 15000 - 16000 -->",
      	"15000": "Can not find corresponding diffuse map for environment lighting, use hemisphere diffuse instead, change environment lighting type to regenerate diffuse map",
      	"15001": "Can not find environment map, disable IBL lighting",
      	"15002": "Diffuse map resource is missing, please change environment lighting type to regenerate resource",
      	"0100": "%s not yet implemented.",
      	"0200": "You should specify a valid DOM canvas element."
      };

      var logList = null;
      var ccLog = console.log.bind(console);
      var ccWarn = ccLog;
      var ccError = ccLog;

      var ccAssert = function ccAssert(condition, message) {
        if (!condition) {
          for (var _len = arguments.length, optionalParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            optionalParams[_key - 2] = arguments[_key];
          }

          console.log("ASSERT: " + formatString.apply(void 0, [message].concat(optionalParams)));
        }
      };

      var ccDebug = ccLog;

      function formatString(message) {
        for (var _len2 = arguments.length, optionalParams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          optionalParams[_key2 - 1] = arguments[_key2];
        }

        return legacyCC.js.formatStr.apply(null, [message].concat(optionalParams));
      }

      function log(message) {
        for (var _len3 = arguments.length, optionalParams = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          optionalParams[_key3 - 1] = arguments[_key3];
        }

        return ccLog.apply(void 0, [message].concat(optionalParams));
      }
      function warn(message) {
        for (var _len4 = arguments.length, optionalParams = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          optionalParams[_key4 - 1] = arguments[_key4];
        }

        return ccWarn.apply(void 0, [message].concat(optionalParams));
      }
      function error(message) {
        for (var _len5 = arguments.length, optionalParams = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          optionalParams[_key5 - 1] = arguments[_key5];
        }

        return ccError.apply(void 0, [message].concat(optionalParams));
      }
      function assert(value, message) {
        for (var _len6 = arguments.length, optionalParams = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
          optionalParams[_key6 - 2] = arguments[_key6];
        }

        return ccAssert.apply(void 0, [value, message].concat(optionalParams));
      }
      function debug() {
        return ccDebug.apply(void 0, arguments);
      }
      function _resetDebugSetting(mode) {
        ccLog = ccWarn = ccError = ccAssert = ccDebug = function ccDebug() {};

        if (mode === DebugMode.NONE) {
          return;
        }

        if (mode > DebugMode.ERROR) {
          var logToWebPage = function logToWebPage(msg) {
            if (!legacyCC.game.canvas) {
              return;
            }

            if (!logList) {
              var logDiv = document.createElement('Div');
              logDiv.setAttribute('id', 'logInfoDiv');
              logDiv.setAttribute('width', '200');
              logDiv.setAttribute('height', legacyCC.game.canvas.height);
              var logDivStyle = logDiv.style;
              logDivStyle.zIndex = '99999';
              logDivStyle.position = 'absolute';
              logDivStyle.top = logDivStyle.left = '0';
              logList = document.createElement('textarea');
              logList.setAttribute('rows', '20');
              logList.setAttribute('cols', '30');
              logList.setAttribute('disabled', 'true');
              var logListStyle = logList.style;
              logListStyle.backgroundColor = 'transparent';
              logListStyle.borderBottom = '1px solid #cccccc';
              logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = '0px';
              logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = 'none';
              logListStyle.padding = '0px';
              logListStyle.margin = '0px';
              logDiv.appendChild(logList);
              legacyCC.game.canvas.parentNode.appendChild(logDiv);
            }

            logList.value = logList.value + msg + "\r\n";
            logList.scrollTop = logList.scrollHeight;
          };

          ccError = function ccError(message) {
            for (var _len7 = arguments.length, optionalParams = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
              optionalParams[_key7 - 1] = arguments[_key7];
            }

            logToWebPage("ERROR :  " + formatString.apply(void 0, [message].concat(optionalParams)));
          };

          ccAssert = function ccAssert(condition, message) {
            if (!condition) {
              for (var _len8 = arguments.length, optionalParams = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {
                optionalParams[_key8 - 2] = arguments[_key8];
              }

              logToWebPage("ASSERT: " + formatString.apply(void 0, [message].concat(optionalParams)));
            }
          };

          if (mode !== DebugMode.ERROR_FOR_WEB_PAGE) {
            ccWarn = function ccWarn(message) {
              for (var _len9 = arguments.length, optionalParams = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
                optionalParams[_key9 - 1] = arguments[_key9];
              }

              logToWebPage("WARN :  " + formatString.apply(void 0, [message].concat(optionalParams)));
            };
          }

          if (mode === DebugMode.INFO_FOR_WEB_PAGE) {
            ccLog = function ccLog(message) {
              for (var _len10 = arguments.length, optionalParams = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
                optionalParams[_key10 - 1] = arguments[_key10];
              }

              logToWebPage(formatString.apply(void 0, [message].concat(optionalParams)));
            };
          }
        } else if (console) {
          if (!console.error) {
            console.error = console.log;
          }

          if (!console.warn) {
            console.warn = console.log;
          }

          if ( console.error.bind) {
            ccError = console.error.bind(console);
          } else {
            ccError =  function (message) {
              for (var _len11 = arguments.length, optionalParams = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
                optionalParams[_key11 - 1] = arguments[_key11];
              }

              return console.error.apply(console, [message].concat(optionalParams));
            };
          }

          ccAssert = function ccAssert(condition, message) {
            if (!condition) {
              for (var _len12 = arguments.length, optionalParams = new Array(_len12 > 2 ? _len12 - 2 : 0), _key12 = 2; _key12 < _len12; _key12++) {
                optionalParams[_key12 - 2] = arguments[_key12];
              }

              var errorText = formatString.apply(void 0, [message].concat(optionalParams));

              {
                throw new Error(errorText);
              }
            }
          };
        }

        if (mode !== DebugMode.ERROR) {
          if (console.warn.bind) {
            ccWarn = console.warn.bind(console);
          } else {
            ccWarn =  function (message) {
              for (var _len13 = arguments.length, optionalParams = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
                optionalParams[_key13 - 1] = arguments[_key13];
              }

              return console.warn.apply(console, [message].concat(optionalParams));
            };
          }
        }

        if (mode <= DebugMode.INFO) {
          if (console.log.bind) {
            ccLog = console.log.bind(console);
          } else {
            ccLog = function ccLog(message) {
              for (var _len15 = arguments.length, optionalParams = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
                optionalParams[_key15 - 1] = arguments[_key15];
              }

              return console.log.apply(console, [message].concat(optionalParams));
            };
          }
        }

        if (mode <= DebugMode.VERBOSE) {
          if (typeof console.debug === 'function') {
            var vendorDebug = console.debug.bind(console);

            ccDebug = function ccDebug() {
              return vendorDebug.apply(void 0, arguments);
            };
          }
        }
      }
      function _throw(error_) {
        {
          var stack = error_.stack;

          if (stack) {
            error( stack);
          } else {
            error(error_);
          }

          return undefined;
        }
      }

      function getTypedFormatter(type) {
        return function (id) {
          var msg =  debugInfos[id] || 'unknown id' ;

          for (var _len16 = arguments.length, args = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {
            args[_key16 - 1] = arguments[_key16];
          }

          if (args.length === 0) {
            return msg;
          }

          return  formatString.apply(void 0, [msg].concat(args)) ;
        };
      }

      var logFormatter = getTypedFormatter();
      function logID(id) {
        for (var _len17 = arguments.length, optionalParams = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {
          optionalParams[_key17 - 1] = arguments[_key17];
        }

        log(logFormatter.apply(void 0, [id].concat(optionalParams)));
      }
      var warnFormatter = getTypedFormatter();
      function warnID(id) {
        for (var _len18 = arguments.length, optionalParams = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {
          optionalParams[_key18 - 1] = arguments[_key18];
        }

        warn(warnFormatter.apply(void 0, [id].concat(optionalParams)));
      }
      var errorFormatter = getTypedFormatter();
      function errorID(id) {
        for (var _len19 = arguments.length, optionalParams = new Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {
          optionalParams[_key19 - 1] = arguments[_key19];
        }

        error(errorFormatter.apply(void 0, [id].concat(optionalParams)));
      }
      var assertFormatter = getTypedFormatter();
      function assertID(condition, id) {
        if (condition) {
          return;
        }

        for (var _len20 = arguments.length, optionalParams = new Array(_len20 > 2 ? _len20 - 2 : 0), _key20 = 2; _key20 < _len20; _key20++) {
          optionalParams[_key20 - 2] = arguments[_key20];
        }

        assert(false, assertFormatter.apply(void 0, [id].concat(optionalParams)));
      }
      var DebugMode;

      (function (DebugMode) {
        DebugMode[DebugMode["NONE"] = 0] = "NONE";
        DebugMode[DebugMode["VERBOSE"] = 1] = "VERBOSE";
        DebugMode[DebugMode["INFO"] = 2] = "INFO";
        DebugMode[DebugMode["WARN"] = 3] = "WARN";
        DebugMode[DebugMode["ERROR"] = 4] = "ERROR";
        DebugMode[DebugMode["INFO_FOR_WEB_PAGE"] = 5] = "INFO_FOR_WEB_PAGE";
        DebugMode[DebugMode["WARN_FOR_WEB_PAGE"] = 6] = "WARN_FOR_WEB_PAGE";
        DebugMode[DebugMode["ERROR_FOR_WEB_PAGE"] = 7] = "ERROR_FOR_WEB_PAGE";
      })(DebugMode || (DebugMode = exports('DebugMode', {})));

      function getError(errorId) {
        for (var _len21 = arguments.length, param = new Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {
          param[_key21 - 1] = arguments[_key21];
        }

        return errorFormatter.apply(void 0, [errorId].concat(param));
      }
      function isDisplayStats() {
        return legacyCC.profiler ? legacyCC.profiler.isShowingStats() : false;
      }
      function setDisplayStats(displayStats) {
        if (legacyCC.profiler) {
          displayStats ? legacyCC.profiler.showStats() : legacyCC.profiler.hideStats();
          legacyCC.game.config.showFPS = !!displayStats;
        }
      }

      var debug$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        log: log,
        warn: warn,
        error: error,
        assert: assert,
        debug: debug,
        _resetDebugSetting: _resetDebugSetting,
        _throw: _throw,
        logID: logID,
        warnID: warnID,
        errorID: errorID,
        assertID: assertID,
        get DebugMode () { return DebugMode; },
        getError: getError,
        isDisplayStats: isDisplayStats,
        setDisplayStats: setDisplayStats
      });

      var defaultLogTimes = 10;
      function setDefaultLogTimes(times) {
        if (times > 0) {
          defaultLogTimes = times;
        }
      }
      var replaceProperty;
      var removeProperty;
      var markAsWarning;
      var replacePropertyLog;
      var markAsWarningLog;
      var removePropertyLog;
      var messageID = 0;
      var messageMap = new Map();

      replacePropertyLog = function replacePropertyLog(n, dp, n2, newp, f, id, s) {
        var item = messageMap.get(id);

        if (item && item.logTimes > item.count) {
          f("'%s' is deprecated, please use '%s' instead. " + s, n + "." + dp, n2 + "." + newp);
          item.count++;
        }
      };

      replaceProperty = exports('replaceProperty', function replaceProperty(owner, ownerName, properties) {
        if (owner == null) return;
        properties.forEach(function (item) {
          var id = messageID++;
          messageMap.set(id, {
            id: id,
            count: 0,
            logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
          });
          var target = item.target != null ? item.target : owner;
          var newName = item.newName != null ? item.newName : item.name;
          var targetName = item.targetName != null ? item.targetName : ownerName;
          var sameTarget = target === owner;
          var suggest = item.suggest ? "(" + item.suggest + ")" : '';

          if (item.customFunction != null) {
            owner[item.name] = function () {
              var _ref;

              replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
              return (_ref = item.customFunction).call.apply(_ref, [this].concat(Array.prototype.slice.call(arguments)));
            };
          } else if (item.customSetter != null || item.customGetter != null) {
            var hasSetter = item.customSetter != null;
            var hasGetter = item.customGetter != null;

            if (hasSetter && hasGetter) {
              Object.defineProperty(owner, item.name, {
                get: function get() {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  return item.customGetter.call(this);
                },
                set: function set(v) {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  item.customSetter.call(this, v);
                },
                enumerable: false
              });
            } else if (hasSetter) {
              Object.defineProperty(owner, item.name, {
                set: function set(v) {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  item.customSetter.call(this, v);
                },
                enumerable: false
              });
            } else if (hasGetter) {
              Object.defineProperty(owner, item.name, {
                get: function get() {
                  replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                  return item.customGetter.call(this);
                },
                enumerable: false
              });
            }
          } else {
            Object.defineProperty(owner, item.name, {
              get: function get() {
                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                return sameTarget ? this[newName] : target[newName];
              },
              set: function set(v) {
                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);

                if (sameTarget) {
                  this[newName] = v;
                } else {
                  target[newName] = v;
                }
              },
              enumerable: false
            });
          }
        });
      });

      removePropertyLog = function removePropertyLog(n, dp, f, id, s) {
        var item = messageMap.get(id);

        if (item && item.logTimes > item.count) {
          f("'%s' has been removed. " + s, n + "." + dp);
          item.count++;
        }
      };

      removeProperty = exports('removeProperty', function removeProperty(owner, ownerName, properties) {
        if (owner == null) return;
        properties.forEach(function (item) {
          var id = messageID++;
          messageMap.set(id, {
            id: id,
            count: 0,
            logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
          });
          var suggest = item.suggest ? "(" + item.suggest + ")" : '';
          Object.defineProperty(owner, item.name, {
            get: function get() {
              return removePropertyLog(ownerName, item.name, error, id, suggest);
            },
            set: function set() {
              removePropertyLog(ownerName, item.name, error, id, suggest);
            },
            enumerable: false
          });
        });
      });

      markAsWarningLog = function markAsWarningLog(n, dp, f, id, s) {
        var item = messageMap.get(id);

        if (item && item.logTimes > item.count) {
          f("'%s' is deprecated. " + s, n + "." + dp);
          item.count++;
        }
      };

      markAsWarning = exports('markAsWarning', function markAsWarning(owner, ownerName, properties) {
        if (owner == null) return;

        var _defaultGetSet = function _defaultGetSet(d, n, dp, f, id, s) {
          if (d.get) {
            var oldGet = d.get;

            d.get = function () {
              markAsWarningLog(n, dp, f, id, s);
              return oldGet.call(this);
            };
          }

          if (d.set) {
            var oldSet = d.set;

            d.set = function (v) {
              markAsWarningLog(n, dp, f, id, s);
              oldSet.call(this, v);
            };
          }

          Object.defineProperty(owner, dp, d);
        };

        properties.forEach(function (item) {
          var deprecatedProp = item.name;
          var descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);

          if (!descriptor || !descriptor.configurable) {
            return;
          }

          var id = messageID++;
          messageMap.set(id, {
            id: id,
            count: 0,
            logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
          });
          var suggest = item.suggest ? "(" + item.suggest + ")" : '';

          if (typeof descriptor.value !== 'undefined') {
            if (typeof descriptor.value === 'function') {
              var oldValue = descriptor.value;

              owner[deprecatedProp] = function () {
                markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                return oldValue.call.apply(oldValue, [this].concat(Array.prototype.slice.call(arguments)));
              };
            } else {
              var _oldValue = descriptor.value;
              Object.defineProperty(owner, deprecatedProp, {
                configurable: true,
                get: function get() {
                  markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                  return _oldValue;
                }
              });

              if (descriptor.writable) {
                Object.defineProperty(owner, deprecatedProp, {
                  set: function set(value) {
                    markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                    _oldValue = value;
                  }
                });
              }
            }
          } else {
            _defaultGetSet(descriptor, ownerName, deprecatedProp, warn, id, suggest);
          }

          Object.defineProperty(owner, deprecatedProp, {
            enumerable: false
          });
        });
      });

      var MutableForwardIterator = function () {
        function MutableForwardIterator(array) {
          this.i = 0;
          this.array = array;
        }

        var _proto = MutableForwardIterator.prototype;

        _proto.remove = function remove(value) {
          var index = this.array.indexOf(value);

          if (index >= 0) {
            this.removeAt(index);
          }
        };

        _proto.removeAt = function removeAt(i) {
          this.array.splice(i, 1);

          if (i <= this.i) {
            --this.i;
          }
        };

        _proto.fastRemove = function fastRemove(value) {
          var index = this.array.indexOf(value);

          if (index >= 0) {
            this.fastRemoveAt(index);
          }
        };

        _proto.fastRemoveAt = function fastRemoveAt(i) {
          var array = this.array;
          array[i] = array[array.length - 1];
          --array.length;

          if (i <= this.i) {
            --this.i;
          }
        };

        _proto.push = function push(item) {
          this.array.push(item);
        };

        _createClass(MutableForwardIterator, [{
          key: "length",
          get: function get() {
            return this.array.length;
          },
          set: function set(value) {
            this.array.length = value;

            if (this.i >= value) {
              this.i = value - 1;
            }
          }
        }]);

        return MutableForwardIterator;
      }();

      function removeAt(array, index) {
        array.splice(index, 1);
      }
      function fastRemoveAt(array, index) {
        var length = array.length;

        if (index < 0 || index >= length) {
          return;
        }

        array[index] = array[length - 1];
        array.length = length - 1;
      }
      function remove(array, value) {
        var index = array.indexOf(value);

        if (index >= 0) {
          removeAt(array, index);
          return true;
        } else {
          return false;
        }
      }
      function fastRemove(array, value) {
        var index = array.indexOf(value);

        if (index >= 0) {
          array[index] = array[array.length - 1];
          --array.length;
        }
      }
      function removeIf(array, predicate) {
        var index = array.findIndex(predicate);

        if (index >= 0) {
          var _value = array[index];
          removeAt(array, index);
          return _value;
        }
      }
      function verifyType(array, type) {
        if (array && array.length > 0) {
          for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done;) {
            var item = _step.value;

            if (!(item instanceof type)) {
              logID(1300);
              return false;
            }
          }
        }

        return true;
      }
      function removeArray(array, removals) {
        for (var i = 0, l = removals.length; i < l; i++) {
          remove(array, removals[i]);
        }
      }
      function appendObjectsAt(array, objects, index) {
        array.splice.apply(array, [index, 0].concat(objects));
        return array;
      }
      function contains(array, value) {
        return array.indexOf(value) >= 0;
      }
      function copy(array) {
        var len = array.length;
        var cloned = new Array(len);

        for (var i = 0; i < len; i += 1) {
          cloned[i] = array[i];
        }

        return cloned;
      }

      var jsarray = /*#__PURE__*/Object.freeze({
        __proto__: null,
        removeAt: removeAt,
        fastRemoveAt: fastRemoveAt,
        remove: remove,
        fastRemove: fastRemove,
        removeIf: removeIf,
        verifyType: verifyType,
        removeArray: removeArray,
        appendObjectsAt: appendObjectsAt,
        contains: contains,
        copy: copy,
        MutableForwardIterator: MutableForwardIterator
      });

      var NonUuidMark = '.';

      var IDGenerator = function () {
        function IDGenerator(category) {
          this.id = void 0;
          this.prefix = void 0;
          this.id = 0 | Math.random() * 998;
          this.prefix = category ? category + NonUuidMark : '';
        }

        var _proto = IDGenerator.prototype;

        _proto.getNewId = function getNewId() {

          return this.prefix + ++this.id;
        };

        return IDGenerator;
      }();

      IDGenerator.global = new IDGenerator('global');

      var tempCIDGenerator = new IDGenerator('TmpCId.');
      var aliasesTag = typeof Symbol === 'undefined' ? '__aliases__' : Symbol('[[Aliases]]');
      var classNameTag = '__classname__';
      var classIdTag = '__cid__';
      function isNumber(object) {
        return typeof object === 'number' || object instanceof Number;
      }
      function isString(object) {
        return typeof object === 'string' || object instanceof String;
      }
      function isEmptyObject(obj) {
        for (var key in obj) {
          return false;
        }

        return true;
      }
      var value = function () {
        var descriptor = {
          value: undefined,
          enumerable: false,
          writable: false,
          configurable: true
        };
        return function (object, propertyName, value_, writable, enumerable) {
          descriptor.value = value_;
          descriptor.writable = writable;
          descriptor.enumerable = enumerable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.value = undefined;
        };
      }();
      var getset = function () {
        var descriptor = {
          get: undefined,
          set: undefined,
          enumerable: false
        };
        return function (object, propertyName, getter, setter, enumerable, configurable) {
          if (enumerable === void 0) {
            enumerable = false;
          }

          if (configurable === void 0) {
            configurable = false;
          }

          if (typeof setter === 'boolean') {
            enumerable = setter;
            setter = undefined;
          }

          descriptor.get = getter;
          descriptor.set = setter;
          descriptor.enumerable = enumerable;
          descriptor.configurable = configurable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.get = undefined;
          descriptor.set = undefined;
        };
      }();
      var get = function () {
        var descriptor = {
          get: undefined,
          enumerable: false,
          configurable: false
        };
        return function (object, propertyName, getter, enumerable, configurable) {
          descriptor.get = getter;
          descriptor.enumerable = enumerable;
          descriptor.configurable = configurable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.get = undefined;
        };
      }();
      var set = function () {
        var descriptor = {
          set: undefined,
          enumerable: false,
          configurable: false
        };
        return function (object, propertyName, setter, enumerable, configurable) {
          descriptor.set = setter;
          descriptor.enumerable = enumerable;
          descriptor.configurable = configurable;
          Object.defineProperty(object, propertyName, descriptor);
          descriptor.set = undefined;
        };
      }();
      function createMap(forceDictMode) {
        var map = Object.create(null);

        if (forceDictMode) {
          var INVALID_IDENTIFIER_1 = '.';
          var INVALID_IDENTIFIER_2 = '/';
          map[INVALID_IDENTIFIER_1] = 1;
          map[INVALID_IDENTIFIER_2] = 1;
          delete map[INVALID_IDENTIFIER_1];
          delete map[INVALID_IDENTIFIER_2];
        }

        return map;
      }
      function getClassName(objOrCtor) {
        if (typeof objOrCtor === 'function') {
          var prototype = objOrCtor.prototype;

          if (prototype && prototype.hasOwnProperty(classNameTag) && prototype[classNameTag]) {
            return prototype[classNameTag];
          }

          var retval = '';

          if (objOrCtor.name) {
            retval = objOrCtor.name;
          }

          if (objOrCtor.toString) {
            var arr;
            var str = objOrCtor.toString();

            if (str.charAt(0) === '[') {
              arr = /\[\w+\s*(\w+)\]/.exec(str);
            } else {
              arr = /function\s*(\w+)/.exec(str);
            }

            if (arr && arr.length === 2) {
              retval = arr[1];
            }
          }

          return retval !== 'Object' ? retval : '';
        } else if (objOrCtor && objOrCtor.constructor) {
          return getClassName(objOrCtor.constructor);
        }

        return '';
      }
      function obsolete(object, obsoleted, newExpr, writable) {
        var extractPropName = /([^.]+)$/;
        var oldProp = extractPropName.exec(obsoleted)[0];
        var newProp = extractPropName.exec(newExpr)[0];

        function getter() {

          return this[newProp];
        }

        function setter(value_) {

          this[newProp] = value_;
        }

        if (writable) {
          getset(object, oldProp, getter, setter);
        } else {
          get(object, oldProp, getter);
        }
      }
      function obsoletes(obj, objName, props, writable) {
        for (var obsoleted in props) {
          var newName = props[obsoleted];
          obsolete(obj, objName + "." + obsoleted, newName, writable);
        }
      }
      var REGEXP_NUM_OR_STR = /(%d)|(%s)/;
      var REGEXP_STR = /%s/;
      function formatStr(msg) {
        for (var _len = arguments.length, subst = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          subst[_key - 1] = arguments[_key];
        }

        if (arguments.length === 0) {
          return '';
        }

        if (subst.length === 0) {
          return "" + msg;
        }

        var hasSubstitution = typeof msg === 'string' && REGEXP_NUM_OR_STR.test(msg);

        if (hasSubstitution) {
          for (var _iterator = _createForOfIteratorHelperLoose(subst), _step; !(_step = _iterator()).done;) {
            var arg = _step.value;
            var regExpToTest = typeof arg === 'number' ? REGEXP_NUM_OR_STR : REGEXP_STR;

            if (regExpToTest.test(msg)) {
              var notReplaceFunction = "" + arg;
              msg = msg.replace(regExpToTest, notReplaceFunction);
            } else {
              msg += " " + arg;
            }
          }
        } else {
          for (var _iterator2 = _createForOfIteratorHelperLoose(subst), _step2; !(_step2 = _iterator2()).done;) {
            var _arg = _step2.value;
            msg += " " + _arg;
          }
        }

        return msg;
      }
      function shiftArguments() {
        var len = arguments.length - 1;
        var args = new Array(len);

        for (var i = 0; i < len; ++i) {
          args[i] = arguments[i + 1];
        }

        return args;
      }
      function getPropertyDescriptor(object, propertyName) {
        while (object) {
          var pd = Object.getOwnPropertyDescriptor(object, propertyName);

          if (pd) {
            return pd;
          }

          object = Object.getPrototypeOf(object);
        }

        return null;
      }

      function _copyprop(name, source, target) {
        var pd = getPropertyDescriptor(source, name);

        if (pd) {
          Object.defineProperty(target, name, pd);
        }
      }

      function addon(object) {
        object = object || {};

        for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          sources[_key2 - 1] = arguments[_key2];
        }

        for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {
          var source = _sources[_i];

          if (source) {
            if (typeof source !== 'object') {
              errorID(5402, source);
              continue;
            }

            for (var name in source) {
              if (!(name in object)) {
                _copyprop(name, source, object);
              }
            }
          }
        }

        return object;
      }
      function mixin(object) {
        object = object || {};

        for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          sources[_key3 - 1] = arguments[_key3];
        }

        for (var _i2 = 0, _sources2 = sources; _i2 < _sources2.length; _i2++) {
          var source = _sources2[_i2];

          if (source) {
            if (typeof source !== 'object') {
              errorID(5403, source);
              continue;
            }

            for (var name in source) {
              _copyprop(name, source, object);
            }
          }
        }

        return object;
      }
      function extend(cls, base) {

        for (var p in base) {
          if (base.hasOwnProperty(p)) {
            cls[p] = base[p];
          }
        }

        cls.prototype = Object.create(base.prototype, {
          constructor: {
            value: cls,
            writable: true,
            configurable: true
          }
        });
        return cls;
      }
      function getSuper(constructor) {
        var proto = constructor.prototype;
        var dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
      }
      function isChildClassOf(subclass, superclass) {
        if (subclass && superclass) {
          if (typeof subclass !== 'function') {
            return false;
          }

          if (typeof superclass !== 'function') {

            return false;
          }

          if (subclass === superclass) {
            return true;
          }

          for (;;) {
            subclass = getSuper(subclass);

            if (!subclass) {
              return false;
            }

            if (subclass === superclass) {
              return true;
            }
          }
        }

        return false;
      }
      function clear(object) {
        for (var _i3 = 0, _Object$keys = Object.keys(object); _i3 < _Object$keys.length; _i3++) {
          var key = _Object$keys[_i3];
          delete object[key];
        }
      }

      function isTempClassId(id) {
        return typeof id !== 'string' || id.startsWith(tempCIDGenerator.prefix);
      }

      var _idToClass = createMap(true);
      var _nameToClass = createMap(true);

      function setup(tag, table) {
        return function (id, constructor) {
          if (constructor.prototype.hasOwnProperty(tag)) {
            delete table[constructor.prototype[tag]];
          }

          value(constructor.prototype, tag, id);

          if (id) {
            var registered = table[id];

            if (registered && registered !== constructor) {
              var err = "A Class already exists with the same " + tag + " : \"" + id + "\".";

              error(err);
            } else {
              table[id] = constructor;
            }
          }
        };
      }

      var _setClassId = setup('__cid__', _idToClass);
      var doSetClassName = setup('__classname__', _nameToClass);
      function setClassName(className, constructor) {
        doSetClassName(className, constructor);

        if (!constructor.prototype.hasOwnProperty(classIdTag)) {
          var id = className || tempCIDGenerator.getNewId();

          if (id) {
            _setClassId(id, constructor);
          }
        }
      }
      function setClassAlias(target, alias) {
        var nameRegistry = _nameToClass[alias];
        var idRegistry = _idToClass[alias];
        var ok = true;

        if (nameRegistry && nameRegistry !== target) {
          error("\"" + alias + "\" has already been set as name or alias of another class.");
          ok = false;
        }

        if (idRegistry && idRegistry !== target) {
          error("\"" + alias + "\" has already been set as id or alias of another class.");
          ok = false;
        }

        if (ok) {
          var classAliases = target[aliasesTag];

          if (!classAliases) {
            classAliases = [];
            target[aliasesTag] = classAliases;
          }

          classAliases.push(alias);
          _nameToClass[alias] = target;
          _idToClass[alias] = target;
        }
      }
      function unregisterClass() {
        for (var _len4 = arguments.length, constructors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          constructors[_key4] = arguments[_key4];
        }

        for (var _i4 = 0, _constructors = constructors; _i4 < _constructors.length; _i4++) {
          var _constructor = _constructors[_i4];
          var p = _constructor.prototype;
          var classId = p[classIdTag];

          if (classId) {
            delete _idToClass[classId];
          }

          var classname = p[classNameTag];

          if (classname) {
            delete _nameToClass[classname];
          }

          var aliases = p[aliasesTag];

          if (aliases) {
            for (var iAlias = 0; iAlias < aliases.length; ++iAlias) {
              var alias = aliases[iAlias];
              delete _nameToClass[alias];
              delete _idToClass[alias];
            }
          }
        }
      }
      function _getClassById(classId) {
        return _idToClass[classId];
      }
      function getClassByName(classname) {
        return _nameToClass[classname];
      }
      function _getClassId(obj, allowTempId) {
        allowTempId = typeof allowTempId !== 'undefined' ? allowTempId : true;
        var res;

        if (typeof obj === 'function' && obj.prototype.hasOwnProperty(classIdTag)) {
          res = obj.prototype[classIdTag];

          if (!allowTempId && ( EDITOR) && isTempClassId(res)) {
            return '';
          }

          return res;
        }

        if (obj && obj.constructor) {
          var prototype = obj.constructor.prototype;

          if (prototype && prototype.hasOwnProperty(classIdTag)) {
            res = obj[classIdTag];

            if (!allowTempId && ( EDITOR) && isTempClassId(res)) {
              return '';
            }

            return res;
          }
        }

        return '';
      }

      var Pool = function () {
        var _proto = Pool.prototype;

        _proto.get = function get() {
          return this._get();
        };

        function Pool(_0, _1) {
          this.count = void 0;
          this._pool = void 0;
          this._cleanup = void 0;
          var size = _1 === undefined ? _0 : _1;
          var cleanupFunc = _1 === undefined ? null : _0;
          this.count = 0;
          this._pool = new Array(size);
          this._cleanup = cleanupFunc;
        }

        _proto._get = function _get() {
          if (this.count > 0) {
            --this.count;
            var cache = this._pool[this.count];
            this._pool[this.count] = null;
            return cache;
          }

          return null;
        };

        _proto.put = function put(obj) {
          var pool = this._pool;

          if (this.count < pool.length) {
            if (this._cleanup && this._cleanup(obj) === false) {
              return;
            }

            pool[this.count] = obj;
            ++this.count;
          }
        };

        _proto.resize = function resize(length) {
          if (length >= 0) {
            this._pool.length = length;

            if (this.count > length) {
              this.count = length;
            }
          }
        };

        return Pool;
      }();

      var array = jsarray;
      var js = {
        IDGenerator: IDGenerator,
        Pool: Pool,
        array: jsarray,
        isNumber: isNumber,
        isString: isString,
        isEmptyObject: isEmptyObject,
        getPropertyDescriptor: getPropertyDescriptor,
        addon: addon,
        mixin: mixin,
        extend: extend,
        getSuper: getSuper,
        isChildClassOf: isChildClassOf,
        clear: clear,
        value: value,
        getset: getset,
        get: get,
        set: set,
        unregisterClass: unregisterClass,
        getClassName: getClassName,
        setClassName: setClassName,
        setClassAlias: setClassAlias,
        getClassByName: getClassByName,

        get _registeredClassNames() {
          return _extends({}, _nameToClass);
        },

        set _registeredClassNames(value) {
          clear(_nameToClass);
          Object.assign(_nameToClass, value);
        },

        get _registeredClassIds() {
          return _extends({}, _idToClass);
        },

        set _registeredClassIds(value) {
          clear(_idToClass);
          Object.assign(_idToClass, value);
        },

        _getClassId: _getClassId,
        _setClassId: _setClassId,
        _getClassById: _getClassById,
        obsolete: obsolete,
        obsoletes: obsoletes,
        formatStr: formatStr,
        shiftArguments: shiftArguments,
        createMap: createMap
      };
      legacyCC.js = js;

      var js$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        array: array,
        js: js,
        IDGenerator: IDGenerator,
        Pool: Pool,
        isNumber: isNumber,
        isString: isString,
        isEmptyObject: isEmptyObject,
        value: value,
        getset: getset,
        get: get,
        set: set,
        createMap: createMap,
        getClassName: getClassName,
        obsolete: obsolete,
        obsoletes: obsoletes,
        formatStr: formatStr,
        shiftArguments: shiftArguments,
        getPropertyDescriptor: getPropertyDescriptor,
        addon: addon,
        mixin: mixin,
        extend: extend,
        getSuper: getSuper,
        isChildClassOf: isChildClassOf,
        clear: clear,
        _idToClass: _idToClass,
        _nameToClass: _nameToClass,
        _setClassId: _setClassId,
        setClassName: setClassName,
        setClassAlias: setClassAlias,
        unregisterClass: unregisterClass,
        _getClassById: _getClassById,
        getClassByName: getClassByName,
        _getClassId: _getClassId
      });
      exports('js', js$1);

      function BitMask(obj) {
        if ('__bitmask__' in obj) {
          return obj;
        }

        value(obj, '__bitmask__', null, true);
        var lastIndex = -1;
        var keys = Object.keys(obj);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var val = obj[key];

          if (val === -1) {
            val = ++lastIndex;
            obj[key] = val;
          } else if (typeof val === 'number') {
            lastIndex = val;
          } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
            continue;
          }

          var reverseKey = "" + val;

          if (key !== reverseKey) {

            value(obj, reverseKey, key);
          }
        }

        return obj;
      }

      BitMask.isBitMask = function (BitMaskType) {
        return BitMaskType && BitMaskType.hasOwnProperty('__bitmask__');
      };

      BitMask.getList = function (BitMaskDef) {
        if (BitMaskDef.__bitmask__) {
          return BitMaskDef.__bitmask__;
        }

        var bitlist = BitMaskDef.__bitmask__ = [];

        for (var name in BitMaskDef) {
          var v = BitMaskDef[name];

          if (Number.isInteger(v)) {
            bitlist.push({
              name: name,
              value: v
            });
          }
        }

        bitlist.sort(function (a, b) {
          return a.value - b.value;
        });
        return bitlist;
      };
      legacyCC.BitMask = BitMask;

      function assertIsNonNullable(expr, message) {
        assertIsTrue(!(expr === null || expr === undefined), message);
      }
      function assertIsTrue(expr, message) {
        if ( !expr) {
          throw new Error("Assertion failed: " + (message !== null && message !== void 0 ? message : '<no-message>'));
        }
      }

      function Enum(obj) {
        if ('__enums__' in obj) {
          return obj;
        }

        value(obj, '__enums__', null, true);
        return Enum.update(obj);
      }

      Enum.update = function (obj) {
        var lastIndex = -1;
        var keys = Object.keys(obj);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var val = obj[key];

          if (val === -1) {
            val = ++lastIndex;
            obj[key] = val;
          } else if (typeof val === 'number') {
            lastIndex = val;
          } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
            continue;
          }

          var reverseKey = "" + val;

          if (key !== reverseKey) {

            value(obj, reverseKey, key);
          }
        }

        if (Array.isArray(obj.__enums__)) {
          updateList(obj);
        }

        return obj;
      };

      (function (_Enum) {})(Enum || (Enum = exports('Enum', {})));

      Enum.isEnum = function (enumType) {
        return enumType && enumType.hasOwnProperty('__enums__');
      };

      function assertIsEnum(enumType) {
        assertIsTrue(enumType.hasOwnProperty('__enums__'));
      }

      Enum.getList = function (enumType) {
        assertIsEnum(enumType);

        if (enumType.__enums__) {
          return enumType.__enums__;
        }

        return updateList(enumType);
      };

      function updateList(enumType) {
        assertIsEnum(enumType);
        var enums = enumType.__enums__ || [];
        enums.length = 0;

        for (var name in enumType) {
          var v = enumType[name];

          if (Number.isInteger(v)) {
            enums.push({
              name: name,
              value: v
            });
          }
        }

        enums.sort(function (a, b) {
          return a.value - b.value;
        });
        enumType.__enums__ = enums;
        return enums;
      }

      function ccenum(enumType) {
        if (!('__enums__' in enumType)) {
          value(enumType, '__enums__', null, true);
        }
      }
      legacyCC.Enum = Enum;

      var ValueType = exports('ValueType', function () {
        function ValueType() {}

        var _proto = ValueType.prototype;

        _proto.clone = function clone() {
          errorID(100, getClassName(this) + ".clone");
          return this;
        };

        _proto.equals = function equals(other) {
          return false;
        };

        _proto.set = function set(other) {
          errorID(100, getClassName(this) + ".set");
        };

        _proto.toString = function toString() {
          return "";
        };

        return ValueType;
      }());
      setClassName('cc.ValueType', ValueType);
      legacyCC.ValueType = ValueType;

      var SUPPORT_TEXTURE_FORMATS = ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png'];
      var KEY = {
        none: 0,
        back: 6,
        menu: 18,
        backspace: 8,
        tab: 9,
        enter: 13,
        shift: 16,
        ctrl: 17,
        alt: 18,
        pause: 19,
        capslock: 20,
        escape: 27,
        space: 32,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        select: 41,
        insert: 45,
        Delete: 46,
        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        num0: 96,
        num1: 97,
        num2: 98,
        num3: 99,
        num4: 100,
        num5: 101,
        num6: 102,
        num7: 103,
        num8: 104,
        num9: 105,
        '*': 106,
        '+': 107,
        '-': 109,
        numdel: 110,
        '/': 111,
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123,
        numlock: 144,
        scrolllock: 145,
        ';': 186,
        semicolon: 186,
        equal: 187,
        '=': 187,
        ',': 188,
        comma: 188,
        dash: 189,
        '.': 190,
        period: 190,
        forwardslash: 191,
        grave: 192,
        '[': 219,
        openbracket: 219,
        backslash: 220,
        ']': 221,
        closebracket: 221,
        quote: 222,
        dpadLeft: 1000,
        dpadRight: 1001,
        dpadUp: 1003,
        dpadDown: 1004,
        dpadCenter: 1005
      };
      var macro = exports('macro', {
        SUPPORT_TEXTURE_FORMATS: SUPPORT_TEXTURE_FORMATS,
        KEY: KEY,
        RAD: Math.PI / 180,
        DEG: 180 / Math.PI,
        REPEAT_FOREVER: Number.MAX_VALUE - 1,
        FLT_EPSILON: 0.0000001192092896,
        ORIENTATION_PORTRAIT: 1,
        ORIENTATION_LANDSCAPE: 2,
        ORIENTATION_AUTO: 3,
        ENABLE_TILEDMAP_CULLING: true,
        TOUCH_TIMEOUT: 5000,
        ENABLE_TRANSPARENT_CANVAS: false,
        ENABLE_WEBGL_ANTIALIAS: true,
        ENABLE_ANTIALIAS_FXAA: false,
        ENABLE_BLOOM: false,
        CLEANUP_IMAGE_CACHE: false,
        ENABLE_MULTI_TOUCH: true,
        MAX_LABEL_CANVAS_POOL_SIZE: 20,
        ENABLE_WEBGL_HIGHP_STRUCT_VALUES: false,
        BATCHER2D_MEM_INCREMENT: 144
      });
      legacyCC.macro = macro;

      var BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
      var BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
      var values = new Array(123);

      for (var i = 0; i < 123; ++i) {
        values[i] = 64;
      }

      for (var _i = 0; _i < 64; ++_i) {
        values[BASE64_KEYS.charCodeAt(_i)] = _i;
      }

      var BASE64_VALUES = values;
      function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
        function define(np, propName, getter, setter) {
          var pd = Object.getOwnPropertyDescriptor(np, propName);

          if (pd) {
            if (pd.get) {
              np[getter] = pd.get;
            }

            if (pd.set && setter) {
              np[setter] = pd.set;
            }
          } else {
            var getterFunc = np[getter];

            {
              getset(np, propName, getterFunc, np[setter]);
            }
          }
        }

        var propName;
        var np = ctor.prototype;

        for (var _i2 = 0; _i2 < sameNameGetSets.length; _i2++) {
          propName = sameNameGetSets[_i2];
          var suffix = propName[0].toUpperCase() + propName.slice(1);
          define(np, propName, "get" + suffix, "set" + suffix);
        }

        for (propName in diffNameGetSets) {
          var gs = diffNameGetSets[propName];
          define(np, propName, gs[0], gs[1]);
        }
      }
      function pushToMap(map, key, value, pushFront) {
        var exists = map[key];

        if (exists) {
          if (Array.isArray(exists)) {
            if (pushFront) {
              exists.push(exists[0]);
              exists[0] = value;
            } else {
              exists.push(value);
            }
          } else {
            map[key] = pushFront ? [value, exists] : [exists, value];
          }
        } else {
          map[key] = value;
        }
      }
      function contains$1(refNode, otherNode) {
        if (typeof refNode.contains === 'function') {
          return refNode.contains(otherNode);
        } else if (typeof refNode.compareDocumentPosition === 'function') {
          return !!(refNode.compareDocumentPosition(otherNode) & 16);
        } else {
          var node = otherNode.parentNode;

          if (node) {
            do {
              if (node === refNode) {
                return true;
              } else {
                node = node.parentNode;
              }
            } while (node !== null);
          }

          return false;
        }
      }
      function isDomNode(obj) {
        if (typeof window === 'object' && typeof Node === 'function') {
          return obj instanceof Node;
        } else {
          return obj && typeof obj === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
        }
      }
      function callInNextTick(callback, p1, p2) {
        if (callback) {
          setTimeout(function () {
            callback(p1, p2);
          }, 0);
        }
      }
      function tryCatchFunctor_EDITOR(funcName) {
        return Function('target', "" + ('try {\n' + '  target.') + funcName + "();\n" + "}\n" + "catch (e) {\n" + "  cc._throw(e);\n" + "}");
      }
      function isPlainEmptyObj_DEV(obj) {
        if (!obj || obj.constructor !== Object) {
          return false;
        }

        return isEmptyObject(obj);
      }
      function clampf(value, min_inclusive, max_inclusive) {
        if (min_inclusive > max_inclusive) {
          var temp = min_inclusive;
          min_inclusive = max_inclusive;
          max_inclusive = temp;
        }

        return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
      }
      function degreesToRadians(angle) {
        return angle * macro.RAD;
      }
      function radiansToDegrees(angle) {
        return angle * macro.DEG;
      }
      legacyCC.misc = {
        BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
        BASE64_VALUES: BASE64_VALUES,
        propertyDefine: propertyDefine,
        pushToMap: pushToMap,
        contains: contains$1,
        isDomNode: isDomNode,
        callInNextTick: callInNextTick,
        isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
        clampf: clampf,
        degreesToRadians: degreesToRadians,
        radiansToDegrees: radiansToDegrees
      };

      var misc = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
        BASE64_VALUES: BASE64_VALUES,
        propertyDefine: propertyDefine,
        pushToMap: pushToMap,
        contains: contains$1,
        isDomNode: isDomNode,
        callInNextTick: callInNextTick,
        tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
        isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
        clampf: clampf,
        degreesToRadians: degreesToRadians,
        radiansToDegrees: radiansToDegrees
      });
      exports('misc', misc);

      var DELIMETER = '$_$';
      function createAttrsSingle(owner, superAttrs) {
        var attrs = superAttrs ? Object.create(superAttrs) : {};
        value(owner, '__attrs__', attrs);
        return attrs;
      }
      function createAttrs(subclass) {
        if (typeof subclass !== 'function') {
          var instance = subclass;
          return createAttrsSingle(instance, getClassAttrs(instance.constructor));
        }

        var superClass;
        var chains = legacyCC.Class.getInheritanceChain(subclass);

        for (var i = chains.length - 1; i >= 0; i--) {
          var cls = chains[i];

          var attrs = cls.hasOwnProperty('__attrs__') && cls.__attrs__;

          if (!attrs) {
            superClass = chains[i + 1];
            createAttrsSingle(cls, superClass && superClass.__attrs__);
          }
        }

        superClass = chains[0];
        createAttrsSingle(subclass, superClass && superClass.__attrs__);
        return subclass.__attrs__;
      }
      function attr(constructor, propertyName) {
        var attrs = getClassAttrs(constructor);
        var prefix = propertyName + DELIMETER;
        var ret = {};

        for (var key in attrs) {
          if (key.startsWith(prefix)) {
            ret[key.slice(prefix.length)] = attrs[key];
          }
        }

        return ret;
      }
      function getClassAttrs(constructor) {
        return constructor.hasOwnProperty('__attrs__') && constructor.__attrs__ || createAttrs(constructor);
      }
      function setClassAttr(ctor, propName, key, value) {
        getClassAttrs(ctor)[propName + DELIMETER + key] = value;
      }
      var PrimitiveType = function () {
        function PrimitiveType(name, defaultValue) {
          this.name = void 0;
          this["default"] = void 0;
          this.name = name;
          this["default"] = defaultValue;
        }

        var _proto = PrimitiveType.prototype;

        _proto.toString = function toString() {
          return this.name;
        };

        return PrimitiveType;
      }();
      var CCInteger = exports('CCInteger', new PrimitiveType('Integer', 0));
      legacyCC.Integer = CCInteger;
      legacyCC.CCInteger = CCInteger;
      var CCFloat = exports('CCFloat', new PrimitiveType('Float', 0.0));
      legacyCC.Float = CCFloat;
      legacyCC.CCFloat = CCFloat;

      var CCBoolean = exports('CCBoolean', new PrimitiveType('Boolean', false));
      legacyCC.Boolean = CCBoolean;
      legacyCC.CCBoolean = CCBoolean;
      var CCString = exports('CCString', new PrimitiveType('String', ''));
      legacyCC.String = CCString;
      legacyCC.CCString = CCString;
      function getTypeChecker_ET(type, attributeName) {
        return function (constructor, mainPropertyName) {
          var propInfo = "\"" + getClassName(constructor) + "." + mainPropertyName + "\"";
          var mainPropAttrs = attr(constructor, mainPropertyName);
          var mainPropAttrsType = mainPropAttrs.type;

          if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat) {
            mainPropAttrsType = 'Number';
          } else if (mainPropAttrsType === CCString || mainPropAttrsType === CCBoolean) {
            mainPropAttrsType = "" + mainPropAttrsType;
          }

          if (mainPropAttrsType !== type) {
            warnID(3604, propInfo);
            return;
          }

          if (!mainPropAttrs.hasOwnProperty('default')) {
            return;
          }

          var defaultVal = mainPropAttrs["default"];

          if (typeof defaultVal === 'undefined') {
            return;
          }

          var isContainer = Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal);

          if (isContainer) {
            return;
          }

          var defaultType = typeof defaultVal;
          var type_lowerCase = type.toLowerCase();

          if (defaultType === type_lowerCase) {
            if (type_lowerCase === 'object') {
              if (defaultVal && !(defaultVal instanceof mainPropAttrs.ctor)) {
                warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
              } else {
                return;
              }
            } else if (type !== 'Number') {
              warnID(3606, attributeName, propInfo, type);
            }
          } else if (defaultType !== 'function') {
            if (type === CCString["default"] && defaultVal == null) {
              warnID(3607, propInfo);
            } else {
              warnID(3611, attributeName, propInfo, defaultType);
            }
          } else {
            return;
          }

          delete mainPropAttrs.type;
        };
      }
      function getObjTypeChecker_ET(typeCtor) {
        return function (classCtor, mainPropName) {
          getTypeChecker_ET('Object', 'type')(classCtor, mainPropName);
          var defaultDef = getClassAttrs(classCtor)[mainPropName + DELIMETER + "default"];
          var defaultVal = legacyCC.Class.getDefault(defaultDef);

          if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, legacyCC.ValueType)) {
            var typename = getClassName(typeCtor);
            var info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);

            if (defaultDef) {
              log(info);
            } else {
              warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
            }
          }
        };
      }

      var attributeUtils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DELIMETER: DELIMETER,
        createAttrsSingle: createAttrsSingle,
        createAttrs: createAttrs,
        attr: attr,
        getClassAttrs: getClassAttrs,
        setClassAttr: setClassAttr,
        PrimitiveType: PrimitiveType,
        CCInteger: CCInteger,
        CCFloat: CCFloat,
        CCBoolean: CCBoolean,
        CCString: CCString,
        getTypeChecker_ET: getTypeChecker_ET,
        getObjTypeChecker_ET: getObjTypeChecker_ET
      });

      var SerializableAttrs = {
        "default": {},
        serializable: {},
        editorOnly: {},
        formerlySerializedAs: {}
      };

      function parseNotify(val, propName, notify, properties) {
        if (val.get || val.set) {

          return;
        }

        if (val.hasOwnProperty('default')) {
          var newKey = "_N$" + propName;

          val.get = function () {
            return this[newKey];
          };

          val.set = function (value) {
            var oldValue = this[newKey];
            this[newKey] = value;
            notify.call(this, oldValue);
          };

          var newValue = {};
          properties[newKey] = newValue;

          for (var attr in SerializableAttrs) {
            var v = SerializableAttrs[attr];

            if (val.hasOwnProperty(attr)) {
              newValue[attr] = val[attr];

              if (!v.canUsedInGet) {
                delete val[attr];
              }
            }
          }
        }
      }

      function parseType(val, type, className, propName) {

        if (Array.isArray(type)) {

          if (type.length > 0) {
            val.type = type = type[0];
          } else {
            return errorID(5508, className, propName);
          }
        }

        if (typeof type === 'function') {
          if (type === String) {
            val.type = legacyCC.String;
          } else if (type === Boolean) {
            val.type = legacyCC.Boolean;
          } else if (type === Number) {
            val.type = legacyCC.Float;
          }
        }
      }

      function _wrapOptions(isGetset, _default, type) {
        var res = isGetset ? {
          _short: true
        } : {
          _short: true,
          "default": _default
        };

        if (type) {
          res.type = type;
        }

        return res;
      }

      function getFullFormOfProperty(options, isGetset) {
        var isLiteral = options && options.constructor === Object;

        if (!isLiteral) {
          if (Array.isArray(options) && options.length > 0) {
            return _wrapOptions(isGetset, [], options);
          } else if (typeof options === 'function') {
            var type = options;
            return _wrapOptions(isGetset, isChildClassOf(type, legacyCC.ValueType) ? new type() : null, type);
          } else if (options instanceof PrimitiveType) {
            return _wrapOptions(isGetset, options["default"]);
          } else {
            return _wrapOptions(isGetset, options);
          }
        }

        return null;
      }
      function preprocessAttrs(properties, className, cls) {
        for (var propName in properties) {
          var val = properties[propName];
          var fullForm = getFullFormOfProperty(val, false);

          if (fullForm) {
            val = properties[propName] = fullForm;
          }

          if (val) {

            var notify = val.notify;

            if (notify) {
              {
                parseNotify(val, propName, notify, properties);
              }
            }

            if ('type' in val) {
              parseType(val, val.type, className, propName);
            }
          }
        }
      }

      var requiringFrames = [];
      function push(module, uuid, script, importMeta) {
        if (script === undefined) {
          script = uuid;
          uuid = '';
        }

        requiringFrames.push({
          uuid: uuid,
          script: script,
          module: module,
          exports: module.exports,
          beh: null,
          importMeta: importMeta
        });
      }
      function pop() {
        var frameInfo = requiringFrames.pop();
        var module = frameInfo.module;
        var exports = module.exports;

        if (exports === frameInfo.exports) {
          for (var anykey in exports) {
            return;
          }

          module.exports = exports = frameInfo.cls;
        }
      }
      function peek() {
        return requiringFrames[requiringFrames.length - 1];
      }
      legacyCC._RF = {
        push: push,
        pop: pop,
        peek: peek
      };

      var PropertyStashInternalFlag;

      (function (PropertyStashInternalFlag) {
        PropertyStashInternalFlag[PropertyStashInternalFlag["STANDALONE"] = 1] = "STANDALONE";
        PropertyStashInternalFlag[PropertyStashInternalFlag["IMPLICIT_VISIBLE"] = 2] = "IMPLICIT_VISIBLE";
        PropertyStashInternalFlag[PropertyStashInternalFlag["IMPLICIT_SERIALIZABLE"] = 4] = "IMPLICIT_SERIALIZABLE";
      })(PropertyStashInternalFlag || (PropertyStashInternalFlag = {}));

      var DELIMETER$1 = DELIMETER;

      function pushUnique(array, item) {
        if (array.indexOf(item) < 0) {
          array.push(item);
        }
      }

      var deferredInitializer = {
        datas: null,
        push: function push(data) {
          if (this.datas) {
            this.datas.push(data);
          } else {
            this.datas = [data];
            var self = this;
            setTimeout(function () {
              self.init();
            }, 0);
          }
        },
        init: function init() {
          var datas = this.datas;

          if (datas) {
            for (var i = 0; i < datas.length; ++i) {
              var data = datas[i];
              var cls = data.cls;
              var properties = data.props;

              if (typeof properties === 'function') {
                properties = properties();
              }

              var name = getClassName(cls);

              if (properties) {
                declareProperties(cls, name, properties, cls.$super, data.mixins);
              } else {
                errorID(3633, name);
              }
            }

            this.datas = null;
          }
        }
      };

      function appendProp(cls, name) {

        pushUnique(cls.__props__, name);
      }

      function defineProp(cls, className, propName, val) {

        appendProp(cls, propName);
        parseAttributes(cls, val, className, propName);
      }

      function defineGetSet(cls, name, propName, val) {
        var getter = val.get;
        var setter = val.set;

        if (getter) {
          parseAttributes(cls, val, name, propName);

          setClassAttr(cls, propName, 'serializable', false);
        }
      }

      function getDefault(defaultVal) {
        if (typeof defaultVal === 'function') {
          {
            return defaultVal();
          }
        }

        return defaultVal;
      }

      function mixinWithInherited(dest, src, filter) {
        for (var prop in src) {
          if (!dest.hasOwnProperty(prop) && (!filter || filter(prop))) {
            Object.defineProperty(dest, prop, getPropertyDescriptor(src, prop));
          }
        }
      }

      function doDefine(className, baseClass, mixins, options) {
        var ctor = options.ctor;

        var ctors = [ctor];
        var fireClass = ctor;
        value(fireClass, '__ctors__', ctors.length > 0 ? ctors : null, true);
        var prototype = fireClass.prototype;

        if (baseClass) {
          fireClass.$super = baseClass;
        }

        if (mixins) {
          for (var m = mixins.length - 1; m >= 0; m--) {
            var mixin = mixins[m];
            mixinWithInherited(prototype, mixin.prototype);

            if (CCClass._isCCClass(mixin)) {
              mixinWithInherited(getClassAttrs(fireClass), getClassAttrs(mixin));
            }
          }

          prototype.constructor = fireClass;
        }

        setClassName(className, fireClass);
        return fireClass;
      }

      function define(className, baseClass, mixins, options) {
        var Component = legacyCC.Component;
        var frame = peek();

        if (frame && isChildClassOf(baseClass, Component)) {
          if (isChildClassOf(frame.cls, Component)) {
            errorID(3615);
            return null;
          }

          className = className || frame.script;
        }

        var cls = doDefine(className, baseClass, mixins, options);

        if (frame) {
          if (isChildClassOf(baseClass, Component)) {
            var uuid = frame.uuid;

            if (uuid) {
              _setClassId(uuid, cls);
            }

            frame.cls = cls;
          } else if (!isChildClassOf(frame.cls, Component)) {
            frame.cls = cls;
          }
        }

        return cls;
      }

      function getNewValueTypeCodeJit(value) {
        var clsName = getClassName(value);
        var type = value.constructor;
        var res = "new " + clsName + "(";

        for (var i = 0; i < type.__props__.length; i++) {
          var prop = type.__props__[i];
          var propVal = value[prop];

          res += propVal;

          if (i < type.__props__.length - 1) {
            res += ',';
          }
        }

        return res + ")";
      }

      function escapeForJS(s) {
        return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }

      var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;

      function declareProperties(cls, className, properties, baseClass, mixins) {
        cls.__props__ = [];

        if (baseClass && baseClass.__props__) {
          cls.__props__ = baseClass.__props__.slice();
        }

        if (mixins) {
          for (var m = 0; m < mixins.length; ++m) {
            var mixin = mixins[m];

            if (mixin.__props__) {
              cls.__props__ = cls.__props__.concat(mixin.__props__.filter(function (x) {
                return cls.__props__.indexOf(x) < 0;
              }));
            }
          }
        }

        if (properties) {
          preprocessAttrs(properties, className);

          for (var propName in properties) {
            var val = properties[propName];

            if (!val.get && !val.set) {
              defineProp(cls, className, propName, val);
            } else {
              defineGetSet(cls, className, propName, val);
            }
          }
        }

        var attrs = getClassAttrs(cls);
        cls.__values__ = cls.__props__.filter(function (prop) {
          return attrs[prop + DELIMETER$1 + "serializable"] !== false;
        });
      }

      function CCClass(options) {
        var name = options.name;
        var base = options["extends"];
        var mixins = options.mixins;
        var cls = define(name, base, mixins, options);

        if (!name) {
          name = legacyCC.js.getClassName(cls);
        }

        cls._sealed = true;

        if (base) {
          base._sealed = false;
        }

        var properties = options.properties;

        if (typeof properties === 'function' || base && base.__props__ === null || mixins && mixins.some(function (x) {
          return x.__props__ === null;
        })) {
          {
            deferredInitializer.push({
              cls: cls,
              props: properties,
              mixins: mixins
            });
            cls.__props__ = cls.__values__ = null;
          }
        } else {
          declareProperties(cls, name, properties, base, options.mixins);
        }

        var editor = options.editor;

        if (editor) {
          if (isChildClassOf(base, legacyCC.Component)) {
            legacyCC.Component._registerEditorProps(cls, editor);
          }
        }

        return cls;
      }

      CCClass._isCCClass = function isCCClass(constructor) {
        var _constructor$hasOwnPr;

        return constructor === null || constructor === void 0 ? void 0 : (_constructor$hasOwnPr = constructor.hasOwnProperty) === null || _constructor$hasOwnPr === void 0 ? void 0 : _constructor$hasOwnPr.call(constructor, '__ctors__');
      };

      CCClass.fastDefine = function (className, constructor, serializableFields) {
        setClassName(className, constructor);
        var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields);
        var attrs = getClassAttrs(constructor);

        for (var i = 0; i < props.length; i++) {
          var key = props[i];
          attrs[key + DELIMETER$1 + "visible"] = false;
          attrs[key + DELIMETER$1 + "default"] = serializableFields[key];
        }
      };

      CCClass.Attr = attributeUtils;
      CCClass.attr = attr;
      function isCCClassOrFastDefined(constructor) {
        var _constructor$hasOwnPr2;

        return constructor === null || constructor === void 0 ? void 0 : (_constructor$hasOwnPr2 = constructor.hasOwnProperty) === null || _constructor$hasOwnPr2 === void 0 ? void 0 : _constructor$hasOwnPr2.call(constructor, '__values__');
      }

      function getInheritanceChain(constructor) {
        var chain = [];

        for (;;) {
          constructor = getSuper(constructor);

          if (!constructor) {
            break;
          }

          if (constructor !== Object) {
            chain.push(constructor);
          }
        }

        return chain;
      }

      CCClass.getInheritanceChain = getInheritanceChain;
      var PrimitiveTypes = {
        Integer: 'Number',
        Float: 'Number',
        Boolean: 'Boolean',
        String: 'String'
      };

      function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
        var attrs = null;
        var propertyNamePrefix = '';

        function initAttrs() {
          propertyNamePrefix = propertyName + DELIMETER$1;
          return attrs = getClassAttrs(constructor);
        }

        if ('type' in attributes && typeof attributes.type === 'undefined') {
          warnID(3660, propertyName, className);
        }
        var type = attributes.type;

        if (type) {
          var primitiveType = PrimitiveTypes[type];

          if (primitiveType) {
            (attrs || initAttrs())[propertyNamePrefix + "type"] = type;
          } else if (type === 'Object') ; else if (typeof type === 'object') {
              if (Enum.isEnum(type)) {
                (attrs || initAttrs())[propertyNamePrefix + "type"] = 'Enum';
                attrs[propertyNamePrefix + "enumList"] = Enum.getList(type);
              } else if (BitMask.isBitMask(type)) {
                (attrs || initAttrs())[propertyNamePrefix + "type"] = 'BitMask';
                attrs[propertyNamePrefix + "bitmaskList"] = BitMask.getList(type);
              } else ;
            } else if (typeof type === 'function') {
              (attrs || initAttrs())[propertyNamePrefix + "type"] = 'Object';
              attrs[propertyNamePrefix + "ctor"] = type;
            } else ;
        }

        if ('default' in attributes) {
          (attrs || initAttrs())[propertyNamePrefix + "default"] = attributes["default"];
        }

        var parseSimpleAttribute = function parseSimpleAttribute(attributeName, expectType) {
          if (attributeName in attributes) {
            var val = attributes[attributeName];

            if (typeof val === expectType) {
              (attrs || initAttrs())[propertyNamePrefix + attributeName] = val;
            }
          }
        };

        if (attributes.editorOnly) {
          {
            (attrs || initAttrs())[propertyNamePrefix + "editorOnly"] = true;
          }
        }

        var isStandaloneMode = attributes.__internalFlags & PropertyStashInternalFlag.STANDALONE;
        var normalizedSerializable;

        if (isStandaloneMode) {
          normalizedSerializable = attributes.serializable === true || (attributes.__internalFlags & PropertyStashInternalFlag.IMPLICIT_SERIALIZABLE) !== 0;
        } else if (attributes.serializable === false) {
          normalizedSerializable = false;
        }

        if (typeof normalizedSerializable !== 'undefined') {
          (attrs || initAttrs())[propertyNamePrefix + "serializable"] = normalizedSerializable;
        }

        parseSimpleAttribute('formerlySerializedAs', 'string');

        var range = attributes.range;

        if (range) {
          if (Array.isArray(range)) {
            if (range.length >= 2) {
              (attrs || initAttrs())[propertyNamePrefix + "min"] = range[0];
              attrs[propertyNamePrefix + "max"] = range[1];

              if (range.length > 2) {
                attrs[propertyNamePrefix + "step"] = range[2];
              }
            }
          }
        }

        parseSimpleAttribute('min', 'number');
        parseSimpleAttribute('max', 'number');
        parseSimpleAttribute('step', 'number');
      }

      CCClass.isArray = function (defaultVal) {
        defaultVal = getDefault(defaultVal);
        return Array.isArray(defaultVal);
      };

      CCClass.getDefault = getDefault;
      CCClass.escapeForJS = escapeForJS;
      CCClass.IDENTIFIER_RE = IDENTIFIER_RE;
      CCClass.getNewValueTypeCode =  getNewValueTypeCodeJit;
      legacyCC.Class = CCClass;

      var _d2r = Math.PI / 180.0;

      var _r2d = 180.0 / Math.PI;

      var EPSILON = exports('EPSILON', 0.000001);
      function equals(a, b) {
        return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
      }
      function approx(a, b, maxDiff) {
        maxDiff = maxDiff || EPSILON;
        return Math.abs(a - b) <= maxDiff;
      }
      function clamp(val, min, max) {
        if (min > max) {
          var temp = min;
          min = max;
          max = temp;
        }

        return val < min ? min : val > max ? max : val;
      }
      function clamp01(val) {
        return val < 0 ? 0 : val > 1 ? 1 : val;
      }
      function lerp(from, to, ratio) {
        return from + (to - from) * ratio;
      }
      function toRadian(a) {
        return a * _d2r;
      }
      function toDegree(a) {
        return a * _r2d;
      }
      var random = exports('random', Math.random);
      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }
      function randomRangeInt(min, max) {
        return Math.floor(randomRange(min, max));
      }
      function pseudoRandom(seed) {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280.0;
      }
      function pseudoRandomRange(seed, min, max) {
        return pseudoRandom(seed) * (max - min) + min;
      }
      function pseudoRandomRangeInt(seed, min, max) {
        return Math.floor(pseudoRandomRange(seed, min, max));
      }
      function nextPow2$1(val) {
        --val;
        val |= val >> 1;
        val |= val >> 2;
        val |= val >> 4;
        val |= val >> 8;
        val |= val >> 16;
        ++val;
        return val;
      }
      function repeat(t, length) {
        return t - Math.floor(t / length) * length;
      }
      function pingPong(t, length) {
        t = repeat(t, length * 2);
        t = length - Math.abs(t - length);
        return t;
      }
      function inverseLerp(from, to, value) {
        return (value - from) / (to - from);
      }
      function absMaxComponent(v) {
        if (Math.abs(v.x) > Math.abs(v.y)) {
          if (Math.abs(v.x) > Math.abs(v.z)) {
            return v.x;
          } else {
            return v.z;
          }
        } else if (Math.abs(v.y) > Math.abs(v.z)) {
          return v.y;
        } else {
          return v.z;
        }
      }
      function absMax(a, b) {
        if (Math.abs(a) > Math.abs(b)) {
          return a;
        } else {
          return b;
        }
      }
      function enumerableProps(prototype, attrs) {
        attrs.forEach(function (key) {
          Object.defineProperty(prototype, key, {
            enumerable: true
          });
        });
      }

      var toFloat = 1 / 255;
      var Color = exports('Color', function (_ValueType) {
        _inheritsLoose(Color, _ValueType);

        Color.clone = function clone(a) {
          var out = new Color();

          if (a._val) {
            out._val = a._val;
          } else {
            out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r;
          }

          return out;
        };

        Color.copy = function copy(out, a) {
          out.r = a.r;
          out.g = a.g;
          out.b = a.b;
          out.a = a.a;
          return out;
        };

        Color.set = function set(out, r, g, b, a) {
          out.r = r;
          out.g = g;
          out.b = b;
          out.a = a;
          return out;
        };

        Color.fromHEX = function fromHEX(out, hexString) {
          hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
          out.r = parseInt(hexString.substr(0, 2), 16) || 0;
          out.g = parseInt(hexString.substr(2, 2), 16) || 0;
          out.b = parseInt(hexString.substr(4, 2), 16) || 0;
          var a = parseInt(hexString.substr(6, 2), 16);
          out.a = !Number.isNaN(a) ? a : 255;
          out._val = (out.a << 24 >>> 0) + (out.b << 16) + (out.g << 8) + out.r;
          return out;
        };

        Color.add = function add(out, a, b) {
          out.r = a.r + b.r;
          out.g = a.g + b.g;
          out.b = a.b + b.b;
          out.a = a.a + b.a;
          return out;
        };

        Color.subtract = function subtract(out, a, b) {
          out.r = a.r - b.r;
          out.g = a.g - b.g;
          out.b = a.b - b.b;
          out.a = a.a - b.a;
          return out;
        };

        Color.multiply = function multiply(out, a, b) {
          out.r = a.r * b.r;
          out.g = a.g * b.g;
          out.b = a.b * b.b;
          out.a = a.a * b.a;
          return out;
        };

        Color.divide = function divide(out, a, b) {
          out.r = a.r / b.r;
          out.g = a.g / b.g;
          out.b = a.b / b.b;
          out.a = a.a / b.a;
          return out;
        };

        Color.scale = function scale(out, a, b) {
          out.r = a.r * b;
          out.g = a.g * b;
          out.b = a.b * b;
          out.a = a.a * b;
          return out;
        };

        Color.lerp = function lerp(out, from, to, ratio) {
          var r = from.r;
          var g = from.g;
          var b = from.b;
          var a = from.a;
          r += (to.r - r) * ratio;
          g += (to.g - g) * ratio;
          b += (to.b - b) * ratio;
          a += (to.a - a) * ratio;
          out._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
          return out;
        };

        Color.toArray = function toArray(out, a, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          var scale = a instanceof Color || a.a > 1 ? 1 / 255 : 1;
          out[ofs + 0] = a.r * scale;
          out[ofs + 1] = a.g * scale;
          out[ofs + 2] = a.b * scale;
          out[ofs + 3] = a.a * scale;
          return out;
        };

        Color.fromArray = function fromArray(arr, out, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out.r = arr[ofs + 0] * 255;
          out.g = arr[ofs + 1] * 255;
          out.b = arr[ofs + 2] * 255;
          out.a = arr[ofs + 3] * 255;
          return out;
        };

        Color.strictEquals = function strictEquals(a, b) {
          return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
        };

        Color.equals = function equals(a, b, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(a.r - b.r) <= epsilon * Math.max(1.0, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1.0, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1.0, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1.0, Math.abs(a.a), Math.abs(b.a));
        };

        Color.hex = function hex(a) {
          return (a.r * 255 << 24 | a.g * 255 << 16 | a.b * 255 << 8 | a.a * 255) >>> 0;
        };

        function Color(r, g, b, a) {
          var _this;

          _this = _ValueType.call(this) || this;
          _this._val = 0;

          if (typeof r === 'string') {
            _this.fromHEX(r);
          } else if (g !== undefined) {
            _this.set(r, g, b, a);
          } else {
            _this.set(r);
          }

          return _this;
        }

        var _proto = Color.prototype;

        _proto.clone = function clone() {
          var ret = new Color();
          ret._val = this._val;
          return ret;
        };

        _proto.equals = function equals(other) {
          return other && this._val === other._val;
        };

        _proto.lerp = function lerp(to, ratio) {
          var r = this.r;
          var g = this.g;
          var b = this.b;
          var a = this.a;
          r += (to.r - r) * ratio;
          g += (to.g - g) * ratio;
          b += (to.b - b) * ratio;
          a += (to.a - a) * ratio;
          this._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
          return this;
        };

        _proto.toString = function toString() {
          return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
        };

        _proto.toCSS = function toCSS(opt) {
          if (opt === void 0) {
            opt = 'rgba';
          }

          if (opt === 'rgba') {
            return "rgba(" + this.r + "," + this.g + "," + this.b + "," + (this.a * toFloat).toFixed(2) + ")";
          } else if (opt === 'rgb') {
            return "rgb(" + this.r + "," + this.g + "," + this.b + ")";
          } else {
            return "#" + this.toHEX(opt);
          }
        };

        _proto.fromHEX = function fromHEX(hexString) {
          hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
          var r = parseInt(hexString.substr(0, 2), 16) || 0;
          var g = parseInt(hexString.substr(2, 2), 16) || 0;
          var b = parseInt(hexString.substr(4, 2), 16) || 0;
          var a = parseInt(hexString.substr(6, 2), 16);
          a = !Number.isNaN(a) ? a : 255;
          this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
          return this;
        };

        _proto.toHEX = function toHEX(fmt) {
          if (fmt === void 0) {
            fmt = '#rrggbb';
          }

          var prefix = '0';
          var hex = [(this.r < 16 ? prefix : '') + this.r.toString(16), (this.g < 16 ? prefix : '') + this.g.toString(16), (this.b < 16 ? prefix : '') + this.b.toString(16)];

          if (fmt === '#rgb') {
            hex[0] = hex[0][0];
            hex[1] = hex[1][0];
            hex[2] = hex[2][0];
          } else if (fmt === '#rrggbbaa') {
            hex.push((this.a < 16 ? prefix : '') + this.a.toString(16));
          }

          return hex.join('');
        };

        _proto.toRGBValue = function toRGBValue() {
          return this._val & 0x00ffffff;
        };

        _proto.fromHSV = function fromHSV(h, s, v) {
          var r = 0;
          var g = 0;
          var b = 0;

          if (s === 0) {
            r = g = b = v;
          } else if (v === 0) {
            r = g = b = 0;
          } else {
            if (h === 1) {
              h = 0;
            }

            h *= 6;
            var i = Math.floor(h);
            var f = h - i;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));

            switch (i) {
              case 0:
                r = v;
                g = t;
                b = p;
                break;

              case 1:
                r = q;
                g = v;
                b = p;
                break;

              case 2:
                r = p;
                g = v;
                b = t;
                break;

              case 3:
                r = p;
                g = q;
                b = v;
                break;

              case 4:
                r = t;
                g = p;
                b = v;
                break;

              case 5:
                r = v;
                g = p;
                b = q;
                break;
            }
          }

          r *= 255;
          g *= 255;
          b *= 255;
          this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
          return this;
        };

        _proto.toHSV = function toHSV() {
          var r = this.r * toFloat;
          var g = this.g * toFloat;
          var b = this.b * toFloat;
          var hsv = {
            h: 0,
            s: 0,
            v: 0
          };
          var max = Math.max(r, g, b);
          var min = Math.min(r, g, b);
          var delta = 0;
          hsv.v = max;
          hsv.s = max ? (max - min) / max : 0;

          if (!hsv.s) {
            hsv.h = 0;
          } else {
            delta = max - min;

            if (r === max) {
              hsv.h = (g - b) / delta;
            } else if (g === max) {
              hsv.h = 2 + (b - r) / delta;
            } else {
              hsv.h = 4 + (r - g) / delta;
            }

            hsv.h /= 6;

            if (hsv.h < 0) {
              hsv.h += 1.0;
            }
          }

          return hsv;
        };

        _proto.set = function set(r, g, b, a) {
          if (typeof r === 'object') {
            if (r._val != null) {
              this._val = r._val;
            } else {
              g = r.g || 0;
              b = r.b || 0;
              a = typeof r.a === 'number' ? r.a : 255;
              r = r.r || 0;
              this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
            }
          } else {
            r = r || 0;
            g = g || 0;
            b = b || 0;
            a = typeof a === 'number' ? a : 255;
            this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
          }

          return this;
        };

        _proto.multiply = function multiply(other) {
          var r = (this._val & 0x000000ff) * other.r >> 8;
          var g = (this._val & 0x0000ff00) * other.g >> 8;
          var b = (this._val & 0x00ff0000) * other.b >> 8;
          var a = ((this._val & 0xff000000) >>> 8) * other.a;
          this._val = a & 0xff000000 | b & 0x00ff0000 | g & 0x0000ff00 | r & 0x000000ff;
          return this;
        };

        _proto._set_r_unsafe = function _set_r_unsafe(red) {
          this._val = (this._val & 0xffffff00 | red) >>> 0;
          return this;
        };

        _proto._set_g_unsafe = function _set_g_unsafe(green) {
          this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
          return this;
        };

        _proto._set_b_unsafe = function _set_b_unsafe(blue) {
          this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
          return this;
        };

        _proto._set_a_unsafe = function _set_a_unsafe(alpha) {
          this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
          return this;
        };

        _createClass(Color, [{
          key: "r",
          get: function get() {
            return this._val & 0x000000ff;
          },
          set: function set(red) {
            red = ~~clamp(red, 0, 255);
            this._val = (this._val & 0xffffff00 | red) >>> 0;
          }
        }, {
          key: "g",
          get: function get() {
            return (this._val & 0x0000ff00) >> 8;
          },
          set: function set(green) {
            green = ~~clamp(green, 0, 255);
            this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
          }
        }, {
          key: "b",
          get: function get() {
            return (this._val & 0x00ff0000) >> 16;
          },
          set: function set(blue) {
            blue = ~~clamp(blue, 0, 255);
            this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
          }
        }, {
          key: "a",
          get: function get() {
            return (this._val & 0xff000000) >>> 24;
          },
          set: function set(alpha) {
            alpha = ~~clamp(alpha, 0, 255);
            this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
          }
        }, {
          key: "x",
          get: function get() {
            return this.r * toFloat;
          },
          set: function set(value) {
            this.r = value * 255;
          }
        }, {
          key: "y",
          get: function get() {
            return this.g * toFloat;
          },
          set: function set(value) {
            this.g = value * 255;
          }
        }, {
          key: "z",
          get: function get() {
            return this.b * toFloat;
          },
          set: function set(value) {
            this.b = value * 255;
          }
        }, {
          key: "w",
          get: function get() {
            return this.a * toFloat;
          },
          set: function set(value) {
            this.a = value * 255;
          }
        }]);

        return Color;
      }(ValueType));
      Color.WHITE = Object.freeze(new Color(255, 255, 255, 255));
      Color.GRAY = Object.freeze(new Color(127, 127, 127, 255));
      Color.BLACK = Object.freeze(new Color(0, 0, 0, 255));
      Color.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0));
      Color.RED = Object.freeze(new Color(255, 0, 0, 255));
      Color.GREEN = Object.freeze(new Color(0, 255, 0, 255));
      Color.BLUE = Object.freeze(new Color(0, 0, 255, 255));
      Color.CYAN = Object.freeze(new Color(0, 255, 255, 255));
      Color.MAGENTA = Object.freeze(new Color(255, 0, 255, 255));
      Color.YELLOW = Object.freeze(new Color(255, 255, 0, 255));
      CCClass.fastDefine('cc.Color', Color, {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      });
      legacyCC.Color = Color;
      function color(r, g, b, a) {
        return new Color(r, g, b, a);
      }
      legacyCC.color = color;

      var Vec3 = exports('Vec3', function (_ValueType) {
        _inheritsLoose(Vec3, _ValueType);

        Vec3.zero = function zero(out) {
          out.x = 0;
          out.y = 0;
          out.z = 0;
          return out;
        };

        Vec3.clone = function clone(a) {
          return new Vec3(a.x, a.y, a.z);
        };

        Vec3.copy = function copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          return out;
        };

        Vec3.set = function set(out, x, y, z) {
          out.x = x;
          out.y = y;
          out.z = z;
          return out;
        };

        Vec3.add = function add(out, a, b) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          out.z = a.z + b.z;
          return out;
        };

        Vec3.subtract = function subtract(out, a, b) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          out.z = a.z - b.z;
          return out;
        };

        Vec3.multiply = function multiply(out, a, b) {
          out.x = a.x * b.x;
          out.y = a.y * b.y;
          out.z = a.z * b.z;
          return out;
        };

        Vec3.divide = function divide(out, a, b) {
          out.x = a.x / b.x;
          out.y = a.y / b.y;
          out.z = a.z / b.z;
          return out;
        };

        Vec3.ceil = function ceil(out, a) {
          out.x = Math.ceil(a.x);
          out.y = Math.ceil(a.y);
          out.z = Math.ceil(a.z);
          return out;
        };

        Vec3.floor = function floor(out, a) {
          out.x = Math.floor(a.x);
          out.y = Math.floor(a.y);
          out.z = Math.floor(a.z);
          return out;
        };

        Vec3.min = function min(out, a, b) {
          out.x = Math.min(a.x, b.x);
          out.y = Math.min(a.y, b.y);
          out.z = Math.min(a.z, b.z);
          return out;
        };

        Vec3.max = function max(out, a, b) {
          out.x = Math.max(a.x, b.x);
          out.y = Math.max(a.y, b.y);
          out.z = Math.max(a.z, b.z);
          return out;
        };

        Vec3.round = function round(out, a) {
          out.x = Math.round(a.x);
          out.y = Math.round(a.y);
          out.z = Math.round(a.z);
          return out;
        };

        Vec3.multiplyScalar = function multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          return out;
        };

        Vec3.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          out.z = a.z + b.z * scale;
          return out;
        };

        Vec3.distance = function distance(a, b) {
          var x = b.x - a.x;
          var y = b.y - a.y;
          var z = b.z - a.z;
          return Math.sqrt(x * x + y * y + z * z);
        };

        Vec3.squaredDistance = function squaredDistance(a, b) {
          var x = b.x - a.x;
          var y = b.y - a.y;
          var z = b.z - a.z;
          return x * x + y * y + z * z;
        };

        Vec3.len = function len(a) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          return Math.sqrt(x * x + y * y + z * z);
        };

        Vec3.lengthSqr = function lengthSqr(a) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          return x * x + y * y + z * z;
        };

        Vec3.negate = function negate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          out.z = -a.z;
          return out;
        };

        Vec3.invert = function invert(out, a) {
          out.x = 1.0 / a.x;
          out.y = 1.0 / a.y;
          out.z = 1.0 / a.z;
          return out;
        };

        Vec3.invertSafe = function invertSafe(out, a) {
          var x = a.x;
          var y = a.y;
          var z = a.z;

          if (Math.abs(x) < EPSILON) {
            out.x = 0;
          } else {
            out.x = 1.0 / x;
          }

          if (Math.abs(y) < EPSILON) {
            out.y = 0;
          } else {
            out.y = 1.0 / y;
          }

          if (Math.abs(z) < EPSILON) {
            out.z = 0;
          } else {
            out.z = 1.0 / z;
          }

          return out;
        };

        Vec3.normalize = function normalize(out, a) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          var len = x * x + y * y + z * z;

          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = x * len;
            out.y = y * len;
            out.z = z * len;
          }

          return out;
        };

        Vec3.dot = function dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z;
        };

        Vec3.cross = function cross(out, a, b) {
          var ax = a.x,
              ay = a.y,
              az = a.z;
          var bx = b.x,
              by = b.y,
              bz = b.z;
          out.x = ay * bz - az * by;
          out.y = az * bx - ax * bz;
          out.z = ax * by - ay * bx;
          return out;
        };

        Vec3.lerp = function lerp(out, a, b, t) {
          out.x = a.x + t * (b.x - a.x);
          out.y = a.y + t * (b.y - a.y);
          out.z = a.z + t * (b.z - a.z);
          return out;
        };

        Vec3.random = function random$1(out, scale) {
          scale = scale || 1.0;
          var phi = random() * 2.0 * Math.PI;
          var cosTheta = random() * 2 - 1;
          var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
          out.x = sinTheta * Math.cos(phi) * scale;
          out.y = sinTheta * Math.sin(phi) * scale;
          out.z = cosTheta * scale;
          return out;
        };

        Vec3.transformMat4 = function transformMat4(out, a, m) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          var rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
          rhw = rhw ? Math.abs(1 / rhw) : 1;
          out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
          out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
          out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
          return out;
        };

        Vec3.transformMat4Normal = function transformMat4Normal(out, a, m) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          var rhw = m.m03 * x + m.m07 * y + m.m11 * z;
          rhw = rhw ? Math.abs(1 / rhw) : 1;
          out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw;
          out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw;
          out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw;
          return out;
        };

        Vec3.transformMat3 = function transformMat3(out, a, m) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          out.x = x * m.m00 + y * m.m03 + z * m.m06;
          out.y = x * m.m01 + y * m.m04 + z * m.m07;
          out.z = x * m.m02 + y * m.m05 + z * m.m08;
          return out;
        };

        Vec3.transformAffine = function transformAffine(out, v, m) {
          var x = v.x;
          var y = v.y;
          var z = v.z;
          out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12;
          out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13;
          out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14;
          return out;
        };

        Vec3.transformQuat = function transformQuat(out, a, q) {
          var ix = q.w * a.x + q.y * a.z - q.z * a.y;
          var iy = q.w * a.y + q.z * a.x - q.x * a.z;
          var iz = q.w * a.z + q.x * a.y - q.y * a.x;
          var iw = -q.x * a.x - q.y * a.y - q.z * a.z;
          out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
          out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
          out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
          return out;
        };

        Vec3.transformRTS = function transformRTS(out, a, r, t, s) {
          var x = a.x * s.x;
          var y = a.y * s.y;
          var z = a.z * s.z;
          var ix = r.w * x + r.y * z - r.z * y;
          var iy = r.w * y + r.z * x - r.x * z;
          var iz = r.w * z + r.x * y - r.y * x;
          var iw = -r.x * x - r.y * y - r.z * z;
          out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x;
          out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y;
          out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z;
          return out;
        };

        Vec3.transformInverseRTS = function transformInverseRTS(out, a, r, t, s) {
          var x = a.x - t.x;
          var y = a.y - t.y;
          var z = a.z - t.z;
          var ix = r.w * x - r.y * z + r.z * y;
          var iy = r.w * y - r.z * x + r.x * z;
          var iz = r.w * z - r.x * y + r.y * x;
          var iw = r.x * x + r.y * y + r.z * z;
          out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x;
          out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y;
          out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z;
          return out;
        };

        Vec3.rotateX = function rotateX(out, v, o, a) {
          var x = v.x - o.x;
          var y = v.y - o.y;
          var z = v.z - o.z;
          var cos = Math.cos(a);
          var sin = Math.sin(a);
          var rx = x;
          var ry = y * cos - z * sin;
          var rz = y * sin + z * cos;
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        };

        Vec3.rotateY = function rotateY(out, v, o, a) {
          var x = v.x - o.x;
          var y = v.y - o.y;
          var z = v.z - o.z;
          var cos = Math.cos(a);
          var sin = Math.sin(a);
          var rx = z * sin + x * cos;
          var ry = y;
          var rz = z * cos - x * sin;
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        };

        Vec3.rotateZ = function rotateZ(out, v, o, a) {
          var x = v.x - o.x;
          var y = v.y - o.y;
          var z = v.z - o.z;
          var cos = Math.cos(a);
          var sin = Math.sin(a);
          var rx = x * cos - y * sin;
          var ry = x * sin + y * cos;
          var rz = z;
          out.x = rx + o.x;
          out.y = ry + o.y;
          out.z = rz + o.z;
          return out;
        };

        Vec3.toArray = function toArray(out, v, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out[ofs + 0] = v.x;
          out[ofs + 1] = v.y;
          out[ofs + 2] = v.z;
          return out;
        };

        Vec3.fromArray = function fromArray(out, arr, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          out.z = arr[ofs + 2];
          return out;
        };

        Vec3.strictEquals = function strictEquals(a, b) {
          return a.x === b.x && a.y === b.y && a.z === b.z;
        };

        Vec3.equals = function equals(a, b, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          var a0 = a.x,
              a1 = a.y,
              a2 = a.z;
          var b0 = b.x,
              b1 = b.y,
              b2 = b.z;
          return Math.abs(a0 - b0) <= epsilon * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1.0, Math.abs(a2), Math.abs(b2));
        };

        Vec3.angle = function angle(a, b) {
          Vec3.normalize(v3_1, a);
          Vec3.normalize(v3_2, b);
          var cosine = Vec3.dot(v3_1, v3_2);

          if (cosine > 1.0) {
            return 0;
          }

          if (cosine < -1.0) {
            return Math.PI;
          }

          return Math.acos(cosine);
        };

        Vec3.projectOnPlane = function projectOnPlane(out, a, n) {
          return Vec3.subtract(out, a, Vec3.project(out, a, n));
        };

        Vec3.project = function project(out, a, b) {
          var sqrLen = Vec3.lengthSqr(b);

          if (sqrLen < 0.000001) {
            return Vec3.set(out, 0, 0, 0);
          } else {
            return Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
          }
        };

        function Vec3(x, y, z) {
          var _this;

          _this = _ValueType.call(this) || this;

          if (x && typeof x === 'object') {
            _this.x = x.x;
            _this.y = x.y;
            _this.z = x.z;
          } else {
            _this.x = x || 0;
            _this.y = y || 0;
            _this.z = z || 0;
          }

          return _this;
        }

        var _proto = Vec3.prototype;

        _proto.clone = function clone() {
          return new Vec3(this.x, this.y, this.z);
        };

        _proto.set = function set(x, y, z) {
          if (x && typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          }

          return this;
        };

        _proto.equals = function equals(other, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(other.z));
        };

        _proto.equals3f = function equals3f(x, y, z, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(z));
        };

        _proto.strictEquals = function strictEquals(other) {
          return this.x === other.x && this.y === other.y && this.z === other.z;
        };

        _proto.strictEquals3f = function strictEquals3f(x, y, z) {
          return this.x === x && this.y === y && this.z === z;
        };

        _proto.toString = function toString() {
          return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.z.toFixed(2) + ")";
        };

        _proto.lerp = function lerp(to, ratio) {
          this.x += ratio * (to.x - this.x);
          this.y += ratio * (to.y - this.y);
          this.z += ratio * (to.z - this.z);
          return this;
        };

        _proto.add = function add(other) {
          this.x += other.x;
          this.y += other.y;
          this.z += other.z;
          return this;
        };

        _proto.add3f = function add3f(x, y, z) {
          this.x += x;
          this.y += y;
          this.z += z;
          return this;
        };

        _proto.subtract = function subtract(other) {
          this.x -= other.x;
          this.y -= other.y;
          this.z -= other.z;
          return this;
        };

        _proto.subtract3f = function subtract3f(x, y, z) {
          this.x -= x;
          this.y -= y;
          this.z -= z;
          return this;
        };

        _proto.multiplyScalar = function multiplyScalar(scalar) {
          if (typeof scalar === 'object') {
            console.warn('should use Vec3.multiply for vector * vector operation');
          }

          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        };

        _proto.multiply = function multiply(other) {
          if (typeof other !== 'object') {
            console.warn('should use Vec3.scale for vector * scalar operation');
          }

          this.x *= other.x;
          this.y *= other.y;
          this.z *= other.z;
          return this;
        };

        _proto.multiply3f = function multiply3f(x, y, z) {
          this.x *= x;
          this.y *= y;
          this.z *= z;
          return this;
        };

        _proto.divide = function divide(other) {
          this.x /= other.x;
          this.y /= other.y;
          this.z /= other.z;
          return this;
        };

        _proto.divide3f = function divide3f(x, y, z) {
          this.x /= x;
          this.y /= y;
          this.z /= z;
          return this;
        };

        _proto.negative = function negative() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        };

        _proto.clampf = function clampf(minInclusive, maxInclusive) {
          this.x = clamp(this.x, minInclusive.x, maxInclusive.x);
          this.y = clamp(this.y, minInclusive.y, maxInclusive.y);
          this.z = clamp(this.z, minInclusive.z, maxInclusive.z);
          return this;
        };

        _proto.dot = function dot(other) {
          return this.x * other.x + this.y * other.y + this.z * other.z;
        };

        _proto.cross = function cross(other) {
          var ax = this.x,
              ay = this.y,
              az = this.z;
          var bx = other.x,
              by = other.y,
              bz = other.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        };

        _proto.length = function length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        };

        _proto.lengthSqr = function lengthSqr() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        };

        _proto.normalize = function normalize() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var len = x * x + y * y + z * z;

          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
          }

          return this;
        };

        _proto.transformMat4 = function transformMat4(matrix) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var rhw = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15;
          rhw = rhw ? 1 / rhw : 1;
          this.x = (matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12) * rhw;
          this.y = (matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13) * rhw;
          this.z = (matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14) * rhw;
          return this;
        };

        return Vec3;
      }(ValueType));
      Vec3.UNIT_X = Object.freeze(new Vec3(1, 0, 0));
      Vec3.UNIT_Y = Object.freeze(new Vec3(0, 1, 0));
      Vec3.UNIT_Z = Object.freeze(new Vec3(0, 0, 1));
      Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
      Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
      Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
      Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
      Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
      Vec3.NEG_ONE = Object.freeze(new Vec3(-1, -1, -1));
      var v3_1 = new Vec3();
      var v3_2 = new Vec3();
      CCClass.fastDefine('cc.Vec3', Vec3, {
        x: 0,
        y: 0,
        z: 0
      });
      legacyCC.Vec3 = Vec3;
      function v3(x, y, z) {
        return new Vec3(x, y, z);
      }
      legacyCC.v3 = v3;

      var Mat3 = exports('Mat3', function (_ValueType) {
        _inheritsLoose(Mat3, _ValueType);

        Mat3.clone = function clone(a) {
          return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
        };

        Mat3.copy = function copy(out, a) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m03;
          out.m04 = a.m04;
          out.m05 = a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m08 = a.m08;
          return out;
        };

        Mat3.set = function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
          out.m00 = m00;
          out.m01 = m01;
          out.m02 = m02;
          out.m03 = m10;
          out.m04 = m11;
          out.m05 = m12;
          out.m06 = m20;
          out.m07 = m21;
          out.m08 = m22;
          return out;
        };

        Mat3.identity = function identity(out) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 1;
          out.m05 = 0;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 1;
          return out;
        };

        Mat3.transpose = function transpose(out, a) {
          if (out === a) {
            var a01 = a.m01;
            var a02 = a.m02;
            var a12 = a.m05;
            out.m01 = a.m03;
            out.m02 = a.m06;
            out.m03 = a01;
            out.m05 = a.m07;
            out.m06 = a02;
            out.m07 = a12;
          } else {
            out.m00 = a.m00;
            out.m01 = a.m03;
            out.m02 = a.m06;
            out.m03 = a.m01;
            out.m04 = a.m04;
            out.m05 = a.m07;
            out.m06 = a.m02;
            out.m07 = a.m05;
            out.m08 = a.m08;
          }

          return out;
        };

        Mat3.invert = function invert(out, a) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a10 = a.m03;
          var a11 = a.m04;
          var a12 = a.m05;
          var a20 = a.m06;
          var a21 = a.m07;
          var a22 = a.m08;
          var b01 = a22 * a11 - a12 * a21;
          var b11 = -a22 * a10 + a12 * a20;
          var b21 = a21 * a10 - a11 * a20;
          var det = a00 * b01 + a01 * b11 + a02 * b21;

          if (det === 0) {
            out.m00 = 0;
            out.m01 = 0;
            out.m02 = 0;
            out.m03 = 0;
            out.m04 = 0;
            out.m05 = 0;
            out.m06 = 0;
            out.m07 = 0;
            out.m08 = 0;
            return out;
          }

          det = 1.0 / det;
          out.m00 = b01 * det;
          out.m01 = (-a22 * a01 + a02 * a21) * det;
          out.m02 = (a12 * a01 - a02 * a11) * det;
          out.m03 = b11 * det;
          out.m04 = (a22 * a00 - a02 * a20) * det;
          out.m05 = (-a12 * a00 + a02 * a10) * det;
          out.m06 = b21 * det;
          out.m07 = (-a21 * a00 + a01 * a20) * det;
          out.m08 = (a11 * a00 - a01 * a10) * det;
          return out;
        };

        Mat3.determinant = function determinant(a) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a10 = a.m03;
          var a11 = a.m04;
          var a12 = a.m05;
          var a20 = a.m06;
          var a21 = a.m07;
          var a22 = a.m08;
          return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        };

        Mat3.multiply = function multiply(out, a, b) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a10 = a.m03;
          var a11 = a.m04;
          var a12 = a.m05;
          var a20 = a.m06;
          var a21 = a.m07;
          var a22 = a.m08;
          var b00 = b.m00;
          var b01 = b.m01;
          var b02 = b.m02;
          var b10 = b.m03;
          var b11 = b.m04;
          var b12 = b.m05;
          var b20 = b.m06;
          var b21 = b.m07;
          var b22 = b.m08;
          out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
          out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
          out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
          out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
          out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
          out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
          out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
          out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
          out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
          return out;
        };

        Mat3.multiplyMat4 = function multiplyMat4(out, a, b) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a10 = a.m03;
          var a11 = a.m04;
          var a12 = a.m05;
          var a20 = a.m06;
          var a21 = a.m07;
          var a22 = a.m08;
          var b00 = b.m00;
          var b01 = b.m01;
          var b02 = b.m02;
          var b10 = b.m04;
          var b11 = b.m05;
          var b12 = b.m06;
          var b20 = b.m08;
          var b21 = b.m09;
          var b22 = b.m10;
          out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
          out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
          out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
          out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
          out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
          out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
          out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
          out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
          out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
          return out;
        };

        Mat3.transform = function transform(out, a, v) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a10 = a.m03;
          var a11 = a.m04;
          var a12 = a.m05;
          var a20 = a.m06;
          var a21 = a.m07;
          var a22 = a.m08;
          var x = v.x;
          var y = v.y;
          out.m00 = a00;
          out.m01 = a01;
          out.m02 = a02;
          out.m03 = a10;
          out.m04 = a11;
          out.m05 = a12;
          out.m06 = x * a00 + y * a10 + a20;
          out.m07 = x * a01 + y * a11 + a21;
          out.m08 = x * a02 + y * a12 + a22;
          return out;
        };

        Mat3.scale = function scale(out, a, v) {
          var x = v.x;
          var y = v.y;
          out.m00 = x * a.m00;
          out.m01 = x * a.m01;
          out.m02 = x * a.m02;
          out.m03 = y * a.m03;
          out.m04 = y * a.m04;
          out.m05 = y * a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m08 = a.m08;
          return out;
        };

        Mat3.rotate = function rotate(out, a, rad) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a10 = a.m03;
          var a11 = a.m04;
          var a12 = a.m05;
          var a20 = a.m06;
          var a21 = a.m07;
          var a22 = a.m08;
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          out.m00 = c * a00 + s * a10;
          out.m01 = c * a01 + s * a11;
          out.m02 = c * a02 + s * a12;
          out.m03 = c * a10 - s * a00;
          out.m04 = c * a11 - s * a01;
          out.m05 = c * a12 - s * a02;
          out.m06 = a20;
          out.m07 = a21;
          out.m08 = a22;
          return out;
        };

        Mat3.fromMat4 = function fromMat4(out, a) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m04;
          out.m04 = a.m05;
          out.m05 = a.m06;
          out.m06 = a.m08;
          out.m07 = a.m09;
          out.m08 = a.m10;
          return out;
        };

        Mat3.fromViewUp = function fromViewUp(out, view, up) {
          if (Vec3.lengthSqr(view) < EPSILON * EPSILON) {
            Mat3.identity(out);
            return out;
          }

          up = up || Vec3.UNIT_Y;
          Vec3.normalize(v3_1$1, Vec3.cross(v3_1$1, up, view));

          if (Vec3.lengthSqr(v3_1$1) < EPSILON * EPSILON) {
            Mat3.identity(out);
            return out;
          }

          Vec3.cross(v3_2$1, view, v3_1$1);
          Mat3.set(out, v3_1$1.x, v3_1$1.y, v3_1$1.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z);
          return out;
        };

        Mat3.fromTranslation = function fromTranslation(out, v) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 1;
          out.m05 = 0;
          out.m06 = v.x;
          out.m07 = v.y;
          out.m08 = 1;
          return out;
        };

        Mat3.fromScaling = function fromScaling(out, v) {
          out.m00 = v.x;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = v.y;
          out.m05 = 0;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 1;
          return out;
        };

        Mat3.fromRotation = function fromRotation(out, rad) {
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          out.m00 = c;
          out.m01 = s;
          out.m02 = 0;
          out.m03 = -s;
          out.m04 = c;
          out.m05 = 0;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 1;
          return out;
        };

        Mat3.fromQuat = function fromQuat(out, q) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var yx = y * x2;
          var yy = y * y2;
          var zx = z * x2;
          var zy = z * y2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          out.m00 = 1 - yy - zz;
          out.m03 = yx - wz;
          out.m06 = zx + wy;
          out.m01 = yx + wz;
          out.m04 = 1 - xx - zz;
          out.m07 = zy - wx;
          out.m02 = zx - wy;
          out.m05 = zy + wx;
          out.m08 = 1 - xx - yy;
          return out;
        };

        Mat3.inverseTransposeMat4 = function inverseTransposeMat4(out, a) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a03 = a.m03;
          var a10 = a.m04;
          var a11 = a.m05;
          var a12 = a.m06;
          var a13 = a.m07;
          var a20 = a.m08;
          var a21 = a.m09;
          var a22 = a.m10;
          var a23 = a.m11;
          var a30 = a.m12;
          var a31 = a.m13;
          var a32 = a.m14;
          var a33 = a.m15;
          var b00 = a00 * a11 - a01 * a10;
          var b01 = a00 * a12 - a02 * a10;
          var b02 = a00 * a13 - a03 * a10;
          var b03 = a01 * a12 - a02 * a11;
          var b04 = a01 * a13 - a03 * a11;
          var b05 = a02 * a13 - a03 * a12;
          var b06 = a20 * a31 - a21 * a30;
          var b07 = a20 * a32 - a22 * a30;
          var b08 = a20 * a33 - a23 * a30;
          var b09 = a21 * a32 - a22 * a31;
          var b10 = a21 * a33 - a23 * a31;
          var b11 = a22 * a33 - a23 * a32;
          var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

          if (!det) {
            return null;
          }

          det = 1.0 / det;
          out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          return out;
        };

        Mat3.toArray = function toArray(out, m, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out[ofs + 0] = m.m00;
          out[ofs + 1] = m.m01;
          out[ofs + 2] = m.m02;
          out[ofs + 3] = m.m03;
          out[ofs + 4] = m.m04;
          out[ofs + 5] = m.m05;
          out[ofs + 6] = m.m06;
          out[ofs + 7] = m.m07;
          out[ofs + 8] = m.m08;
          return out;
        };

        Mat3.fromArray = function fromArray(out, arr, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out.m00 = arr[ofs + 0];
          out.m01 = arr[ofs + 1];
          out.m02 = arr[ofs + 2];
          out.m03 = arr[ofs + 3];
          out.m04 = arr[ofs + 4];
          out.m05 = arr[ofs + 5];
          out.m06 = arr[ofs + 6];
          out.m07 = arr[ofs + 7];
          out.m08 = arr[ofs + 8];
          return out;
        };

        Mat3.add = function add(out, a, b) {
          out.m00 = a.m00 + b.m00;
          out.m01 = a.m01 + b.m01;
          out.m02 = a.m02 + b.m02;
          out.m03 = a.m03 + b.m03;
          out.m04 = a.m04 + b.m04;
          out.m05 = a.m05 + b.m05;
          out.m06 = a.m06 + b.m06;
          out.m07 = a.m07 + b.m07;
          out.m08 = a.m08 + b.m08;
          return out;
        };

        Mat3.subtract = function subtract(out, a, b) {
          out.m00 = a.m00 - b.m00;
          out.m01 = a.m01 - b.m01;
          out.m02 = a.m02 - b.m02;
          out.m03 = a.m03 - b.m03;
          out.m04 = a.m04 - b.m04;
          out.m05 = a.m05 - b.m05;
          out.m06 = a.m06 - b.m06;
          out.m07 = a.m07 - b.m07;
          out.m08 = a.m08 - b.m08;
          return out;
        };

        Mat3.multiplyScalar = function multiplyScalar(out, a, b) {
          out.m00 = a.m00 * b;
          out.m01 = a.m01 * b;
          out.m02 = a.m02 * b;
          out.m03 = a.m03 * b;
          out.m04 = a.m04 * b;
          out.m05 = a.m05 * b;
          out.m06 = a.m06 * b;
          out.m07 = a.m07 * b;
          out.m08 = a.m08 * b;
          return out;
        };

        Mat3.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
          out.m00 = b.m00 * scale + a.m00;
          out.m01 = b.m01 * scale + a.m01;
          out.m02 = b.m02 * scale + a.m02;
          out.m03 = b.m03 * scale + a.m03;
          out.m04 = b.m04 * scale + a.m04;
          out.m05 = b.m05 * scale + a.m05;
          out.m06 = b.m06 * scale + a.m06;
          out.m07 = b.m07 * scale + a.m07;
          out.m08 = b.m08 * scale + a.m08;
          return out;
        };

        Mat3.strictEquals = function strictEquals(a, b) {
          return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
        };

        Mat3.equals = function equals(a, b, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08));
        };

        function Mat3(m00, m01, m02, m03, m04, m05, m06, m07, m08) {
          var _this;

          if (m00 === void 0) {
            m00 = 1;
          }

          if (m01 === void 0) {
            m01 = 0;
          }

          if (m02 === void 0) {
            m02 = 0;
          }

          if (m03 === void 0) {
            m03 = 0;
          }

          if (m04 === void 0) {
            m04 = 1;
          }

          if (m05 === void 0) {
            m05 = 0;
          }

          if (m06 === void 0) {
            m06 = 0;
          }

          if (m07 === void 0) {
            m07 = 0;
          }

          if (m08 === void 0) {
            m08 = 1;
          }

          _this = _ValueType.call(this) || this;

          if (typeof m00 === 'object') {
            _this.m00 = m00.m00;
            _this.m01 = m00.m01;
            _this.m02 = m00.m02;
            _this.m03 = m00.m03;
            _this.m04 = m00.m04;
            _this.m05 = m00.m05;
            _this.m06 = m00.m06;
            _this.m07 = m00.m07;
            _this.m08 = m00.m08;
          } else {
            _this.m00 = m00;
            _this.m01 = m01;
            _this.m02 = m02;
            _this.m03 = m03;
            _this.m04 = m04;
            _this.m05 = m05;
            _this.m06 = m06;
            _this.m07 = m07;
            _this.m08 = m08;
          }

          return _this;
        }

        var _proto = Mat3.prototype;

        _proto.clone = function clone() {
          var t = this;
          return new Mat3(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08);
        };

        _proto.set = function set(m00, m01, m02, m03, m04, m05, m06, m07, m08) {
          if (m00 === void 0) {
            m00 = 1;
          }

          if (m01 === void 0) {
            m01 = 0;
          }

          if (m02 === void 0) {
            m02 = 0;
          }

          if (m03 === void 0) {
            m03 = 0;
          }

          if (m04 === void 0) {
            m04 = 1;
          }

          if (m05 === void 0) {
            m05 = 0;
          }

          if (m06 === void 0) {
            m06 = 0;
          }

          if (m07 === void 0) {
            m07 = 0;
          }

          if (m08 === void 0) {
            m08 = 1;
          }

          if (typeof m00 === 'object') {
            this.m00 = m00.m00;
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
          } else {
            this.m00 = m00;
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
          }

          return this;
        };

        _proto.equals = function equals(other, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1.0, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1.0, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1.0, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1.0, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1.0, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1.0, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1.0, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1.0, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1.0, Math.abs(this.m08), Math.abs(other.m08));
        };

        _proto.strictEquals = function strictEquals(other) {
          return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08;
        };

        _proto.toString = function toString() {
          var t = this;
          return "[\n" + t.m00 + ", " + t.m01 + ", " + t.m02 + ",\n" + t.m03 + ",\n" + t.m04 + ", " + t.m05 + ",\n" + t.m06 + ", " + t.m07 + ",\n" + t.m08 + "\n" + "]";
        };

        _proto.identity = function identity() {
          this.m00 = 1;
          this.m01 = 0;
          this.m02 = 0;
          this.m03 = 0;
          this.m04 = 1;
          this.m05 = 0;
          this.m06 = 0;
          this.m07 = 0;
          this.m08 = 1;
          return this;
        };

        _proto.transpose = function transpose() {
          var a01 = this.m01;
          var a02 = this.m02;
          var a12 = this.m05;
          this.m01 = this.m03;
          this.m02 = this.m06;
          this.m03 = a01;
          this.m05 = this.m07;
          this.m06 = a02;
          this.m07 = a12;
          return this;
        };

        _proto.invert = function invert() {
          var a00 = this.m00;
          var a01 = this.m01;
          var a02 = this.m02;
          var a10 = this.m03;
          var a11 = this.m04;
          var a12 = this.m05;
          var a20 = this.m06;
          var a21 = this.m07;
          var a22 = this.m08;
          var b01 = a22 * a11 - a12 * a21;
          var b11 = -a22 * a10 + a12 * a20;
          var b21 = a21 * a10 - a11 * a20;
          var det = a00 * b01 + a01 * b11 + a02 * b21;

          if (det === 0) {
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            return this;
          }

          det = 1.0 / det;
          this.m00 = b01 * det;
          this.m01 = (-a22 * a01 + a02 * a21) * det;
          this.m02 = (a12 * a01 - a02 * a11) * det;
          this.m03 = b11 * det;
          this.m04 = (a22 * a00 - a02 * a20) * det;
          this.m05 = (-a12 * a00 + a02 * a10) * det;
          this.m06 = b21 * det;
          this.m07 = (-a21 * a00 + a01 * a20) * det;
          this.m08 = (a11 * a00 - a01 * a10) * det;
          return this;
        };

        _proto.determinant = function determinant() {
          var a00 = this.m00;
          var a01 = this.m01;
          var a02 = this.m02;
          var a10 = this.m03;
          var a11 = this.m04;
          var a12 = this.m05;
          var a20 = this.m06;
          var a21 = this.m07;
          var a22 = this.m08;
          return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        };

        _proto.add = function add(mat) {
          this.m00 += mat.m00;
          this.m01 += mat.m01;
          this.m02 += mat.m02;
          this.m03 += mat.m03;
          this.m04 += mat.m04;
          this.m05 += mat.m05;
          this.m06 += mat.m06;
          this.m07 += mat.m07;
          this.m08 += mat.m08;
          return this;
        };

        _proto.subtract = function subtract(mat) {
          this.m00 -= mat.m00;
          this.m01 -= mat.m01;
          this.m02 -= mat.m02;
          this.m03 -= mat.m03;
          this.m04 -= mat.m04;
          this.m05 -= mat.m05;
          this.m06 -= mat.m06;
          this.m07 -= mat.m07;
          this.m08 -= mat.m08;
          return this;
        };

        _proto.multiply = function multiply(mat) {
          var a00 = this.m00;
          var a01 = this.m01;
          var a02 = this.m02;
          var a10 = this.m03;
          var a11 = this.m04;
          var a12 = this.m05;
          var a20 = this.m06;
          var a21 = this.m07;
          var a22 = this.m08;
          var b00 = mat.m00;
          var b01 = mat.m01;
          var b02 = mat.m02;
          var b10 = mat.m03;
          var b11 = mat.m04;
          var b12 = mat.m05;
          var b20 = mat.m06;
          var b21 = mat.m07;
          var b22 = mat.m08;
          this.m00 = b00 * a00 + b01 * a10 + b02 * a20;
          this.m01 = b00 * a01 + b01 * a11 + b02 * a21;
          this.m02 = b00 * a02 + b01 * a12 + b02 * a22;
          this.m03 = b10 * a00 + b11 * a10 + b12 * a20;
          this.m04 = b10 * a01 + b11 * a11 + b12 * a21;
          this.m05 = b10 * a02 + b11 * a12 + b12 * a22;
          this.m06 = b20 * a00 + b21 * a10 + b22 * a20;
          this.m07 = b20 * a01 + b21 * a11 + b22 * a21;
          this.m08 = b20 * a02 + b21 * a12 + b22 * a22;
          return this;
        };

        _proto.multiplyScalar = function multiplyScalar(scalar) {
          this.m00 *= scalar;
          this.m01 *= scalar;
          this.m02 *= scalar;
          this.m03 *= scalar;
          this.m04 *= scalar;
          this.m05 *= scalar;
          this.m06 *= scalar;
          this.m07 *= scalar;
          this.m08 *= scalar;
          return this;
        };

        _proto.scale = function scale(vec) {
          var x = vec.x;
          var y = vec.y;
          this.m00 = x * this.m00;
          this.m01 = x * this.m01;
          this.m02 = x * this.m02;
          this.m03 = y * this.m03;
          this.m04 = y * this.m04;
          this.m05 = y * this.m05;
          this.m06 = this.m06;
          this.m07 = this.m07;
          this.m08 = this.m08;
          return this;
        };

        _proto.rotate = function rotate(rad) {
          var a00 = this.m00;
          var a01 = this.m01;
          var a02 = this.m02;
          var a10 = this.m03;
          var a11 = this.m04;
          var a12 = this.m05;
          var a20 = this.m06;
          var a21 = this.m07;
          var a22 = this.m08;
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          this.m00 = c * a00 + s * a10;
          this.m01 = c * a01 + s * a11;
          this.m02 = c * a02 + s * a12;
          this.m03 = c * a10 - s * a00;
          this.m04 = c * a11 - s * a01;
          this.m05 = c * a12 - s * a02;
          this.m06 = a20;
          this.m07 = a21;
          this.m08 = a22;
          return this;
        };

        _proto.fromQuat = function fromQuat(q) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var yx = y * x2;
          var yy = y * y2;
          var zx = z * x2;
          var zy = z * y2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          this.m00 = 1 - yy - zz;
          this.m03 = yx - wz;
          this.m06 = zx + wy;
          this.m01 = yx + wz;
          this.m04 = 1 - xx - zz;
          this.m07 = zy - wx;
          this.m02 = zx - wy;
          this.m05 = zy + wx;
          this.m08 = 1 - xx - yy;
          return this;
        };

        return Mat3;
      }(ValueType));
      Mat3.IDENTITY = Object.freeze(new Mat3());
      var v3_1$1 = new Vec3();
      var v3_2$1 = new Vec3();
      CCClass.fastDefine('cc.Mat3', Mat3, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 1,
        m05: 0,
        m06: 0,
        m07: 0,
        m08: 1
      });
      legacyCC.Mat3 = Mat3;

      var Quat = exports('Quat', function (_ValueType) {
        _inheritsLoose(Quat, _ValueType);

        Quat.clone = function clone(a) {
          return new Quat(a.x, a.y, a.z, a.w);
        };

        Quat.copy = function copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          out.w = a.w;
          return out;
        };

        Quat.set = function set(out, x, y, z, w) {
          out.x = x;
          out.y = y;
          out.z = z;
          out.w = w;
          return out;
        };

        Quat.identity = function identity(out) {
          out.x = 0;
          out.y = 0;
          out.z = 0;
          out.w = 1;
          return out;
        };

        Quat.rotationTo = function rotationTo(out, a, b) {
          var dot = Vec3.dot(a, b);

          if (dot < -0.999999) {
            Vec3.cross(v3_1$2, Vec3.UNIT_X, a);

            if (v3_1$2.length() < 0.000001) {
              Vec3.cross(v3_1$2, Vec3.UNIT_Y, a);
            }

            Vec3.normalize(v3_1$2, v3_1$2);
            Quat.fromAxisAngle(out, v3_1$2, Math.PI);
            return out;
          } else if (dot > 0.999999) {
            out.x = 0;
            out.y = 0;
            out.z = 0;
            out.w = 1;
            return out;
          } else {
            Vec3.cross(v3_1$2, a, b);
            out.x = v3_1$2.x;
            out.y = v3_1$2.y;
            out.z = v3_1$2.z;
            out.w = 1 + dot;
            return Quat.normalize(out, out);
          }
        };

        Quat.getAxisAngle = function getAxisAngle(outAxis, q) {
          var rad = Math.acos(q.w) * 2.0;
          var s = Math.sin(rad / 2.0);

          if (s !== 0.0) {
            outAxis.x = q.x / s;
            outAxis.y = q.y / s;
            outAxis.z = q.z / s;
          } else {
            outAxis.x = 1;
            outAxis.y = 0;
            outAxis.z = 0;
          }

          return rad;
        };

        Quat.multiply = function multiply(out, a, b) {
          var x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
          var y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
          var z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
          var w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
          out.x = x;
          out.y = y;
          out.z = z;
          out.w = w;
          return out;
        };

        Quat.multiplyScalar = function multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          out.w = a.w * b;
          return out;
        };

        Quat.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          out.z = a.z + b.z * scale;
          out.w = a.w + b.w * scale;
          return out;
        };

        Quat.rotateX = function rotateX(out, a, rad) {
          rad *= 0.5;
          var bx = Math.sin(rad);
          var bw = Math.cos(rad);
          var x = a.x,
              y = a.y,
              z = a.z,
              w = a.w;
          out.x = x * bw + w * bx;
          out.y = y * bw + z * bx;
          out.z = z * bw - y * bx;
          out.w = w * bw - x * bx;
          return out;
        };

        Quat.rotateY = function rotateY(out, a, rad) {
          rad *= 0.5;
          var by = Math.sin(rad);
          var bw = Math.cos(rad);
          var x = a.x,
              y = a.y,
              z = a.z,
              w = a.w;
          out.x = x * bw - z * by;
          out.y = y * bw + w * by;
          out.z = z * bw + x * by;
          out.w = w * bw - y * by;
          return out;
        };

        Quat.rotateZ = function rotateZ(out, a, rad) {
          rad *= 0.5;
          var bz = Math.sin(rad);
          var bw = Math.cos(rad);
          var x = a.x,
              y = a.y,
              z = a.z,
              w = a.w;
          out.x = x * bw + y * bz;
          out.y = y * bw - x * bz;
          out.z = z * bw + w * bz;
          out.w = w * bw - z * bz;
          return out;
        };

        Quat.rotateAround = function rotateAround(out, rot, axis, rad) {
          Quat.invert(qt_1, rot);
          Vec3.transformQuat(v3_1$2, axis, qt_1);
          Quat.fromAxisAngle(qt_1, v3_1$2, rad);
          Quat.multiply(out, rot, qt_1);
          return out;
        };

        Quat.rotateAroundLocal = function rotateAroundLocal(out, rot, axis, rad) {
          Quat.fromAxisAngle(qt_1, axis, rad);
          Quat.multiply(out, rot, qt_1);
          return out;
        };

        Quat.calculateW = function calculateW(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          out.w = Math.sqrt(Math.abs(1.0 - a.x * a.x - a.y * a.y - a.z * a.z));
          return out;
        };

        Quat.dot = function dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        };

        Quat.lerp = function lerp(out, a, b, t) {
          out.x = a.x + t * (b.x - a.x);
          out.y = a.y + t * (b.y - a.y);
          out.z = a.z + t * (b.z - a.z);
          out.w = a.w + t * (b.w - a.w);
          return out;
        };

        Quat.slerp = function slerp(out, a, b, t) {
          var scale0 = 0;
          var scale1 = 0;
          var bx = b.x;
          var by = b.y;
          var bz = b.z;
          var bw = b.w;
          var cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;

          if (cosom < 0.0) {
            cosom = -cosom;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
          }

          if (1.0 - cosom > 0.000001) {
            var omega = Math.acos(cosom);
            var sinom = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
          } else {
            scale0 = 1.0 - t;
            scale1 = t;
          }

          out.x = scale0 * a.x + scale1 * bx;
          out.y = scale0 * a.y + scale1 * by;
          out.z = scale0 * a.z + scale1 * bz;
          out.w = scale0 * a.w + scale1 * bw;
          return out;
        };

        Quat.sqlerp = function sqlerp(out, a, b, c, d, t) {
          Quat.slerp(qt_1, a, d, t);
          Quat.slerp(qt_2, b, c, t);
          Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t));
          return out;
        };

        Quat.invert = function invert(out, a) {
          var dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
          var invDot = dot ? 1.0 / dot : 0;
          out.x = -a.x * invDot;
          out.y = -a.y * invDot;
          out.z = -a.z * invDot;
          out.w = a.w * invDot;
          return out;
        };

        Quat.conjugate = function conjugate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          out.z = -a.z;
          out.w = a.w;
          return out;
        };

        Quat.len = function len(a) {
          return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
        };

        Quat.lengthSqr = function lengthSqr(a) {
          return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
        };

        Quat.normalize = function normalize(out, a) {
          var len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;

          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = a.x * len;
            out.y = a.y * len;
            out.z = a.z * len;
            out.w = a.w * len;
          }

          return out;
        };

        Quat.fromAxes = function fromAxes(out, xAxis, yAxis, zAxis) {
          Mat3.set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
          return Quat.normalize(out, Quat.fromMat3(out, m3_1));
        };

        Quat.fromViewUp = function fromViewUp(out, view, up) {
          Mat3.fromViewUp(m3_1, view, up);
          return Quat.normalize(out, Quat.fromMat3(out, m3_1));
        };

        Quat.fromAxisAngle = function fromAxisAngle(out, axis, rad) {
          rad *= 0.5;
          var s = Math.sin(rad);
          out.x = s * axis.x;
          out.y = s * axis.y;
          out.z = s * axis.z;
          out.w = Math.cos(rad);
          return out;
        };

        Quat.fromMat3 = function fromMat3(out, m) {
          var m00 = m.m00,
              m01 = m.m03,
              m02 = m.m06,
              m10 = m.m01,
              m11 = m.m04,
              m12 = m.m07,
              m20 = m.m02,
              m21 = m.m05,
              m22 = m.m08;
          var trace = m00 + m11 + m22;

          if (trace > 0) {
            var s = 0.5 / Math.sqrt(trace + 1.0);
            out.w = 0.25 / s;
            out.x = (m21 - m12) * s;
            out.y = (m02 - m20) * s;
            out.z = (m10 - m01) * s;
          } else if (m00 > m11 && m00 > m22) {
            var _s = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);

            out.w = (m21 - m12) / _s;
            out.x = 0.25 * _s;
            out.y = (m01 + m10) / _s;
            out.z = (m02 + m20) / _s;
          } else if (m11 > m22) {
            var _s2 = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);

            out.w = (m02 - m20) / _s2;
            out.x = (m01 + m10) / _s2;
            out.y = 0.25 * _s2;
            out.z = (m12 + m21) / _s2;
          } else {
            var _s3 = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);

            out.w = (m10 - m01) / _s3;
            out.x = (m02 + m20) / _s3;
            out.y = (m12 + m21) / _s3;
            out.z = 0.25 * _s3;
          }

          return out;
        };

        Quat.fromEuler = function fromEuler(out, x, y, z) {
          x *= halfToRad;
          y *= halfToRad;
          z *= halfToRad;
          var sx = Math.sin(x);
          var cx = Math.cos(x);
          var sy = Math.sin(y);
          var cy = Math.cos(y);
          var sz = Math.sin(z);
          var cz = Math.cos(z);
          out.x = sx * cy * cz + cx * sy * sz;
          out.y = cx * sy * cz + sx * cy * sz;
          out.z = cx * cy * sz - sx * sy * cz;
          out.w = cx * cy * cz - sx * sy * sz;
          return out;
        };

        Quat.fromAngleZ = function fromAngleZ(out, z) {
          z *= halfToRad;
          out.x = out.y = 0;
          out.z = Math.sin(z);
          out.w = Math.cos(z);
          return out;
        };

        Quat.toAxisX = function toAxisX(out, q) {
          var fy = 2.0 * q.y;
          var fz = 2.0 * q.z;
          out.x = 1.0 - fy * q.y - fz * q.z;
          out.y = fy * q.x + fz * q.w;
          out.z = fz * q.x + fy * q.w;
          return out;
        };

        Quat.toAxisY = function toAxisY(out, q) {
          var fx = 2.0 * q.x;
          var fy = 2.0 * q.y;
          var fz = 2.0 * q.z;
          out.x = fy * q.x - fz * q.w;
          out.y = 1.0 - fx * q.x - fz * q.z;
          out.z = fz * q.y + fx * q.w;
          return out;
        };

        Quat.toAxisZ = function toAxisZ(out, q) {
          var fx = 2.0 * q.x;
          var fy = 2.0 * q.y;
          var fz = 2.0 * q.z;
          out.x = fz * q.x - fy * q.w;
          out.y = fz * q.y - fx * q.w;
          out.z = 1.0 - fx * q.x - fy * q.y;
          return out;
        };

        Quat.toEuler = function toEuler(out, q, outerZ) {
          var x = q.x,
              y = q.y,
              z = q.z,
              w = q.w;
          var bank = 0;
          var heading = 0;
          var attitude = 0;
          var test = x * y + z * w;

          if (test > 0.499999) {
            bank = 0;
            heading = toDegree(2 * Math.atan2(x, w));
            attitude = 90;
          } else if (test < -0.499999) {
            bank = 0;
            heading = -toDegree(2 * Math.atan2(x, w));
            attitude = -90;
          } else {
            var sqx = x * x;
            var sqy = y * y;
            var sqz = z * z;
            bank = toDegree(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz));
            heading = toDegree(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz));
            attitude = toDegree(Math.asin(2 * test));

            if (outerZ) {
              bank = -180 * Math.sign(bank + 1e-6) + bank;
              heading = -180 * Math.sign(heading + 1e-6) + heading;
              attitude = 180 * Math.sign(attitude + 1e-6) - attitude;
            }
          }

          out.x = bank;
          out.y = heading;
          out.z = attitude;
          return out;
        };

        Quat.toArray = function toArray(out, q, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out[ofs + 0] = q.x;
          out[ofs + 1] = q.y;
          out[ofs + 2] = q.z;
          out[ofs + 3] = q.w;
          return out;
        };

        Quat.fromArray = function fromArray(out, arr, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          out.z = arr[ofs + 2];
          out.w = arr[ofs + 3];
          return out;
        };

        Quat.strictEquals = function strictEquals(a, b) {
          return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        };

        Quat.equals = function equals(a, b, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
        };

        function Quat(x, y, z, w) {
          var _this;

          _this = _ValueType.call(this) || this;

          if (x && typeof x === 'object') {
            _this.x = x.x;
            _this.y = x.y;
            _this.z = x.z;
            _this.w = x.w;
          } else {
            _this.x = x || 0;
            _this.y = y || 0;
            _this.z = z || 0;
            _this.w = w !== null && w !== void 0 ? w : 1;
          }

          return _this;
        }

        var _proto = Quat.prototype;

        _proto.clone = function clone() {
          return new Quat(this.x, this.y, this.z, this.w);
        };

        _proto.set = function set(x, y, z, w) {
          if (x && typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w !== null && w !== void 0 ? w : 1;
          }

          return this;
        };

        _proto.equals = function equals(other, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(other.w));
        };

        _proto.strictEquals = function strictEquals(other) {
          return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        };

        _proto.getEulerAngles = function getEulerAngles(out) {
          return Quat.toEuler(out, this);
        };

        _proto.lerp = function lerp(to, ratio) {
          this.x += ratio * (to.x - this.x);
          this.y += ratio * (to.y - this.y);
          this.z += ratio * (to.z - this.z);
          this.w += ratio * (to.w - this.w);
          return this;
        };

        _proto.slerp = function slerp(to, ratio) {
          return Quat.slerp(this, this, to, ratio);
        };

        _proto.length = function length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        };

        _proto.lengthSqr = function lengthSqr() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        };

        return Quat;
      }(ValueType));
      Quat.IDENTITY = Object.freeze(new Quat());
      var qt_1 = new Quat();
      var qt_2 = new Quat();
      var v3_1$2 = new Vec3();
      var m3_1 = new Mat3();
      var halfToRad = 0.5 * Math.PI / 180.0;
      CCClass.fastDefine('cc.Quat', Quat, {
        x: 0,
        y: 0,
        z: 0,
        w: 1
      });
      legacyCC.Quat = Quat;
      function quat(x, y, z, w) {
        if (x === void 0) {
          x = 0;
        }

        if (y === void 0) {
          y = 0;
        }

        if (z === void 0) {
          z = 0;
        }

        if (w === void 0) {
          w = 1;
        }

        return new Quat(x, y, z, w);
      }
      legacyCC.quat = quat;

      var preTransforms = Object.freeze([Object.freeze([1, 0, 0, 1]), Object.freeze([0, 1, -1, 0]), Object.freeze([-1, 0, 0, -1]), Object.freeze([0, -1, 1, 0])]);
      var Mat4 = exports('Mat4', function (_ValueType) {
        _inheritsLoose(Mat4, _ValueType);

        Mat4.clone = function clone(a) {
          return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
        };

        Mat4.copy = function copy(out, a) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m03;
          out.m04 = a.m04;
          out.m05 = a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m08 = a.m08;
          out.m09 = a.m09;
          out.m10 = a.m10;
          out.m11 = a.m11;
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
          return out;
        };

        Mat4.set = function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
          out.m00 = m00;
          out.m01 = m01;
          out.m02 = m02;
          out.m03 = m03;
          out.m04 = m10;
          out.m05 = m11;
          out.m06 = m12;
          out.m07 = m13;
          out.m08 = m20;
          out.m09 = m21;
          out.m10 = m22;
          out.m11 = m23;
          out.m12 = m30;
          out.m13 = m31;
          out.m14 = m32;
          out.m15 = m33;
          return out;
        };

        Mat4.identity = function identity(out) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = 1;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = 1;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        };

        Mat4.transpose = function transpose(out, a) {
          if (out === a) {
            var a01 = a.m01;
            var a02 = a.m02;
            var a03 = a.m03;
            var a12 = a.m06;
            var a13 = a.m07;
            var a23 = a.m11;
            out.m01 = a.m04;
            out.m02 = a.m08;
            out.m03 = a.m12;
            out.m04 = a01;
            out.m06 = a.m09;
            out.m07 = a.m13;
            out.m08 = a02;
            out.m09 = a12;
            out.m11 = a.m14;
            out.m12 = a03;
            out.m13 = a13;
            out.m14 = a23;
          } else {
            out.m00 = a.m00;
            out.m01 = a.m04;
            out.m02 = a.m08;
            out.m03 = a.m12;
            out.m04 = a.m01;
            out.m05 = a.m05;
            out.m06 = a.m09;
            out.m07 = a.m13;
            out.m08 = a.m02;
            out.m09 = a.m06;
            out.m10 = a.m10;
            out.m11 = a.m14;
            out.m12 = a.m03;
            out.m13 = a.m07;
            out.m14 = a.m11;
            out.m15 = a.m15;
          }

          return out;
        };

        Mat4.invert = function invert(out, a) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a03 = a.m03;
          var a10 = a.m04;
          var a11 = a.m05;
          var a12 = a.m06;
          var a13 = a.m07;
          var a20 = a.m08;
          var a21 = a.m09;
          var a22 = a.m10;
          var a23 = a.m11;
          var a30 = a.m12;
          var a31 = a.m13;
          var a32 = a.m14;
          var a33 = a.m15;
          var b00 = a00 * a11 - a01 * a10;
          var b01 = a00 * a12 - a02 * a10;
          var b02 = a00 * a13 - a03 * a10;
          var b03 = a01 * a12 - a02 * a11;
          var b04 = a01 * a13 - a03 * a11;
          var b05 = a02 * a13 - a03 * a12;
          var b06 = a20 * a31 - a21 * a30;
          var b07 = a20 * a32 - a22 * a30;
          var b08 = a20 * a33 - a23 * a30;
          var b09 = a21 * a32 - a22 * a31;
          var b10 = a21 * a33 - a23 * a31;
          var b11 = a22 * a33 - a23 * a32;
          var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

          if (det === 0) {
            out.m00 = 0;
            out.m01 = 0;
            out.m02 = 0;
            out.m03 = 0;
            out.m04 = 0;
            out.m05 = 0;
            out.m06 = 0;
            out.m07 = 0;
            out.m08 = 0;
            out.m09 = 0;
            out.m10 = 0;
            out.m11 = 0;
            out.m12 = 0;
            out.m13 = 0;
            out.m14 = 0;
            out.m15 = 0;
            return out;
          }

          det = 1.0 / det;
          out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return out;
        };

        Mat4.determinant = function determinant(a) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a03 = a.m03;
          var a10 = a.m04;
          var a11 = a.m05;
          var a12 = a.m06;
          var a13 = a.m07;
          var a20 = a.m08;
          var a21 = a.m09;
          var a22 = a.m10;
          var a23 = a.m11;
          var a30 = a.m12;
          var a31 = a.m13;
          var a32 = a.m14;
          var a33 = a.m15;
          var b00 = a00 * a11 - a01 * a10;
          var b01 = a00 * a12 - a02 * a10;
          var b02 = a00 * a13 - a03 * a10;
          var b03 = a01 * a12 - a02 * a11;
          var b04 = a01 * a13 - a03 * a11;
          var b05 = a02 * a13 - a03 * a12;
          var b06 = a20 * a31 - a21 * a30;
          var b07 = a20 * a32 - a22 * a30;
          var b08 = a20 * a33 - a23 * a30;
          var b09 = a21 * a32 - a22 * a31;
          var b10 = a21 * a33 - a23 * a31;
          var b11 = a22 * a33 - a23 * a32;
          return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        };

        Mat4.multiply = function multiply(out, a, b) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a03 = a.m03;
          var a10 = a.m04;
          var a11 = a.m05;
          var a12 = a.m06;
          var a13 = a.m07;
          var a20 = a.m08;
          var a21 = a.m09;
          var a22 = a.m10;
          var a23 = a.m11;
          var a30 = a.m12;
          var a31 = a.m13;
          var a32 = a.m14;
          var a33 = a.m15;
          var b0 = b.m00;
          var b1 = b.m01;
          var b2 = b.m02;
          var b3 = b.m03;
          out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b.m04;
          b1 = b.m05;
          b2 = b.m06;
          b3 = b.m07;
          out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b.m08;
          b1 = b.m09;
          b2 = b.m10;
          b3 = b.m11;
          out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b.m12;
          b1 = b.m13;
          b2 = b.m14;
          b3 = b.m15;
          out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return out;
        };

        Mat4.transform = function transform(out, a, v) {
          var x = v.x;
          var y = v.y;
          var z = v.z;

          if (a === out) {
            out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
            out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
            out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
            out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
          } else {
            var a00 = a.m00;
            var a01 = a.m01;
            var a02 = a.m02;
            var a03 = a.m03;
            var a10 = a.m04;
            var a11 = a.m05;
            var a12 = a.m06;
            var a13 = a.m07;
            var a20 = a.m08;
            var a21 = a.m09;
            var a22 = a.m10;
            var a23 = a.m11;
            var a30 = a.m12;
            var a31 = a.m13;
            var a32 = a.m14;
            var a33 = a.m15;
            out.m00 = a00;
            out.m01 = a01;
            out.m02 = a02;
            out.m03 = a03;
            out.m04 = a10;
            out.m05 = a11;
            out.m06 = a12;
            out.m07 = a13;
            out.m08 = a20;
            out.m09 = a21;
            out.m10 = a22;
            out.m11 = a23;
            out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
            out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
            out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
            out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
          }

          return out;
        };

        Mat4.translate = function translate(out, a, v) {
          console.warn('function changed');

          if (a === out) {
            out.m12 += v.x;
            out.m13 += v.y;
            out.m14 += v.z;
          } else {
            out.m00 = a.m00;
            out.m01 = a.m01;
            out.m02 = a.m02;
            out.m03 = a.m03;
            out.m04 = a.m04;
            out.m05 = a.m05;
            out.m06 = a.m06;
            out.m07 = a.m07;
            out.m08 = a.m08;
            out.m09 = a.m09;
            out.m10 = a.m10;
            out.m11 = a.m11;
            out.m12 += v.x;
            out.m13 += v.y;
            out.m14 += v.z;
            out.m15 = a.m15;
          }

          return out;
        };

        Mat4.scale = function scale(out, a, v) {
          var x = v.x;
          var y = v.y;
          var z = v.z;
          out.m00 = a.m00 * x;
          out.m01 = a.m01 * x;
          out.m02 = a.m02 * x;
          out.m03 = a.m03 * x;
          out.m04 = a.m04 * y;
          out.m05 = a.m05 * y;
          out.m06 = a.m06 * y;
          out.m07 = a.m07 * y;
          out.m08 = a.m08 * z;
          out.m09 = a.m09 * z;
          out.m10 = a.m10 * z;
          out.m11 = a.m11 * z;
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
          return out;
        };

        Mat4.rotate = function rotate(out, a, rad, axis) {
          var x = axis.x;
          var y = axis.y;
          var z = axis.z;
          var len = Math.sqrt(x * x + y * y + z * z);

          if (Math.abs(len) < EPSILON) {
            return null;
          }

          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var t = 1 - c;
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a03 = a.m03;
          var a10 = a.m04;
          var a11 = a.m05;
          var a12 = a.m06;
          var a13 = a.m07;
          var a20 = a.m08;
          var a21 = a.m09;
          var a22 = a.m10;
          var a23 = a.m11;
          var b00 = x * x * t + c;
          var b01 = y * x * t + z * s;
          var b02 = z * x * t - y * s;
          var b10 = x * y * t - z * s;
          var b11 = y * y * t + c;
          var b12 = z * y * t + x * s;
          var b20 = x * z * t + y * s;
          var b21 = y * z * t - x * s;
          var b22 = z * z * t + c;
          out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
          out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
          out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
          out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
          out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
          out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
          out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
          out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
          out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
          out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
          out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
          out.m11 = a03 * b20 + a13 * b21 + a23 * b22;

          if (a !== out) {
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }

          return out;
        };

        Mat4.rotateX = function rotateX(out, a, rad) {
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var a10 = a.m04;
          var a11 = a.m05;
          var a12 = a.m06;
          var a13 = a.m07;
          var a20 = a.m08;
          var a21 = a.m09;
          var a22 = a.m10;
          var a23 = a.m11;

          if (a !== out) {
            out.m00 = a.m00;
            out.m01 = a.m01;
            out.m02 = a.m02;
            out.m03 = a.m03;
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }

          out.m04 = a10 * c + a20 * s;
          out.m05 = a11 * c + a21 * s;
          out.m06 = a12 * c + a22 * s;
          out.m07 = a13 * c + a23 * s;
          out.m08 = a20 * c - a10 * s;
          out.m09 = a21 * c - a11 * s;
          out.m10 = a22 * c - a12 * s;
          out.m11 = a23 * c - a13 * s;
          return out;
        };

        Mat4.rotateY = function rotateY(out, a, rad) {
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a03 = a.m03;
          var a20 = a.m08;
          var a21 = a.m09;
          var a22 = a.m10;
          var a23 = a.m11;

          if (a !== out) {
            out.m04 = a.m04;
            out.m05 = a.m05;
            out.m06 = a.m06;
            out.m07 = a.m07;
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }

          out.m00 = a00 * c - a20 * s;
          out.m01 = a01 * c - a21 * s;
          out.m02 = a02 * c - a22 * s;
          out.m03 = a03 * c - a23 * s;
          out.m08 = a00 * s + a20 * c;
          out.m09 = a01 * s + a21 * c;
          out.m10 = a02 * s + a22 * c;
          out.m11 = a03 * s + a23 * c;
          return out;
        };

        Mat4.rotateZ = function rotateZ(out, a, rad) {
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a03 = a.m03;
          var a10 = a.m04;
          var a11 = a.m05;
          var a12 = a.m06;
          var a13 = a.m07;

          if (a !== out) {
            out.m08 = a.m08;
            out.m09 = a.m09;
            out.m10 = a.m10;
            out.m11 = a.m11;
            out.m12 = a.m12;
            out.m13 = a.m13;
            out.m14 = a.m14;
            out.m15 = a.m15;
          }

          out.m00 = a00 * c + a10 * s;
          out.m01 = a01 * c + a11 * s;
          out.m02 = a02 * c + a12 * s;
          out.m03 = a03 * c + a13 * s;
          out.m04 = a10 * c - a00 * s;
          out.m05 = a11 * c - a01 * s;
          out.m06 = a12 * c - a02 * s;
          out.m07 = a13 * c - a03 * s;
          return out;
        };

        Mat4.fromTranslation = function fromTranslation(out, v) {
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = 1;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = 1;
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        };

        Mat4.fromScaling = function fromScaling(out, v) {
          out.m00 = v.x;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = v.y;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = v.z;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        };

        Mat4.fromRotation = function fromRotation(out, rad, axis) {
          var x = axis.x;
          var y = axis.y;
          var z = axis.z;
          var len = Math.sqrt(x * x + y * y + z * z);

          if (Math.abs(len) < EPSILON) {
            return null;
          }

          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var t = 1 - c;
          out.m00 = x * x * t + c;
          out.m01 = y * x * t + z * s;
          out.m02 = z * x * t - y * s;
          out.m03 = 0;
          out.m04 = x * y * t - z * s;
          out.m05 = y * y * t + c;
          out.m06 = z * y * t + x * s;
          out.m07 = 0;
          out.m08 = x * z * t + y * s;
          out.m09 = y * z * t - x * s;
          out.m10 = z * z * t + c;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        };

        Mat4.fromXRotation = function fromXRotation(out, rad) {
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          out.m00 = 1;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = c;
          out.m06 = s;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = -s;
          out.m10 = c;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        };

        Mat4.fromYRotation = function fromYRotation(out, rad) {
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          out.m00 = c;
          out.m01 = 0;
          out.m02 = -s;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = 1;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = s;
          out.m09 = 0;
          out.m10 = c;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        };

        Mat4.fromZRotation = function fromZRotation(out, rad) {
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          out.m00 = c;
          out.m01 = s;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = -s;
          out.m05 = c;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = 1;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        };

        Mat4.fromRT = function fromRT(out, q, v) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var xy = x * y2;
          var xz = x * z2;
          var yy = y * y2;
          var yz = y * z2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          out.m00 = 1 - (yy + zz);
          out.m01 = xy + wz;
          out.m02 = xz - wy;
          out.m03 = 0;
          out.m04 = xy - wz;
          out.m05 = 1 - (xx + zz);
          out.m06 = yz + wx;
          out.m07 = 0;
          out.m08 = xz + wy;
          out.m09 = yz - wx;
          out.m10 = 1 - (xx + yy);
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        };

        Mat4.getTranslation = function getTranslation(out, mat) {
          out.x = mat.m12;
          out.y = mat.m13;
          out.z = mat.m14;
          return out;
        };

        Mat4.getScaling = function getScaling(out, mat) {
          var m00 = m3_1$1.m00 = mat.m00;
          var m01 = m3_1$1.m01 = mat.m01;
          var m02 = m3_1$1.m02 = mat.m02;
          var m04 = m3_1$1.m03 = mat.m04;
          var m05 = m3_1$1.m04 = mat.m05;
          var m06 = m3_1$1.m05 = mat.m06;
          var m08 = m3_1$1.m06 = mat.m08;
          var m09 = m3_1$1.m07 = mat.m09;
          var m10 = m3_1$1.m08 = mat.m10;
          out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
          out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
          out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);

          if (Mat3.determinant(m3_1$1) < 0) {
            out.x *= -1;
          }

          return out;
        };

        Mat4.getRotation = function getRotation(out, mat) {
          var trace = mat.m00 + mat.m05 + mat.m10;
          var S = 0;

          if (trace > 0) {
            S = Math.sqrt(trace + 1.0) * 2;
            out.w = 0.25 * S;
            out.x = (mat.m06 - mat.m09) / S;
            out.y = (mat.m08 - mat.m02) / S;
            out.z = (mat.m01 - mat.m04) / S;
          } else if (mat.m00 > mat.m05 && mat.m00 > mat.m10) {
            S = Math.sqrt(1.0 + mat.m00 - mat.m05 - mat.m10) * 2;
            out.w = (mat.m06 - mat.m09) / S;
            out.x = 0.25 * S;
            out.y = (mat.m01 + mat.m04) / S;
            out.z = (mat.m08 + mat.m02) / S;
          } else if (mat.m05 > mat.m10) {
            S = Math.sqrt(1.0 + mat.m05 - mat.m00 - mat.m10) * 2;
            out.w = (mat.m08 - mat.m02) / S;
            out.x = (mat.m01 + mat.m04) / S;
            out.y = 0.25 * S;
            out.z = (mat.m06 + mat.m09) / S;
          } else {
            S = Math.sqrt(1.0 + mat.m10 - mat.m00 - mat.m05) * 2;
            out.w = (mat.m01 - mat.m04) / S;
            out.x = (mat.m08 + mat.m02) / S;
            out.y = (mat.m06 + mat.m09) / S;
            out.z = 0.25 * S;
          }

          return out;
        };

        Mat4.toRTS = function toRTS(m, q, v, s) {
          s.x = Vec3.set(v3_1$3, m.m00, m.m01, m.m02).length();
          m3_1$1.m00 = m.m00 / s.x;
          m3_1$1.m01 = m.m01 / s.x;
          m3_1$1.m02 = m.m02 / s.x;
          s.y = Vec3.set(v3_1$3, m.m04, m.m05, m.m06).length();
          m3_1$1.m03 = m.m04 / s.y;
          m3_1$1.m04 = m.m05 / s.y;
          m3_1$1.m05 = m.m06 / s.y;
          s.z = Vec3.set(v3_1$3, m.m08, m.m09, m.m10).length();
          m3_1$1.m06 = m.m08 / s.z;
          m3_1$1.m07 = m.m09 / s.z;
          m3_1$1.m08 = m.m10 / s.z;
          var det = Mat3.determinant(m3_1$1);

          if (det < 0) {
            s.x *= -1;
            m3_1$1.m00 *= -1;
            m3_1$1.m01 *= -1;
            m3_1$1.m02 *= -1;
          }

          Quat.fromMat3(q, m3_1$1);
          Vec3.set(v, m.m12, m.m13, m.m14);
        };

        Mat4.fromRTS = function fromRTS(out, q, v, s) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var xy = x * y2;
          var xz = x * z2;
          var yy = y * y2;
          var yz = y * z2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          var sx = s.x;
          var sy = s.y;
          var sz = s.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x;
          out.m13 = v.y;
          out.m14 = v.z;
          out.m15 = 1;
          return out;
        };

        Mat4.fromRTSOrigin = function fromRTSOrigin(out, q, v, s, o) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var xy = x * y2;
          var xz = x * z2;
          var yy = y * y2;
          var yz = y * z2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          var sx = s.x;
          var sy = s.y;
          var sz = s.z;
          var ox = o.x;
          var oy = o.y;
          var oz = o.z;
          out.m00 = (1 - (yy + zz)) * sx;
          out.m01 = (xy + wz) * sx;
          out.m02 = (xz - wy) * sx;
          out.m03 = 0;
          out.m04 = (xy - wz) * sy;
          out.m05 = (1 - (xx + zz)) * sy;
          out.m06 = (yz + wx) * sy;
          out.m07 = 0;
          out.m08 = (xz + wy) * sz;
          out.m09 = (yz - wx) * sz;
          out.m10 = (1 - (xx + yy)) * sz;
          out.m11 = 0;
          out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
          out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
          out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
          out.m15 = 1;
          return out;
        };

        Mat4.fromQuat = function fromQuat(out, q) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var yx = y * x2;
          var yy = y * y2;
          var zx = z * x2;
          var zy = z * y2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          out.m00 = 1 - yy - zz;
          out.m01 = yx + wz;
          out.m02 = zx - wy;
          out.m03 = 0;
          out.m04 = yx - wz;
          out.m05 = 1 - xx - zz;
          out.m06 = zy + wx;
          out.m07 = 0;
          out.m08 = zx + wy;
          out.m09 = zy - wx;
          out.m10 = 1 - xx - yy;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        };

        Mat4.frustum = function frustum(out, left, right, bottom, top, near, far) {
          var rl = 1 / (right - left);
          var tb = 1 / (top - bottom);
          var nf = 1 / (near - far);
          out.m00 = near * 2 * rl;
          out.m01 = 0;
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = 0;
          out.m05 = near * 2 * tb;
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = (right + left) * rl;
          out.m09 = (top + bottom) * tb;
          out.m10 = (far + near) * nf;
          out.m11 = -1;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = far * near * 2 * nf;
          out.m15 = 0;
          return out;
        };

        Mat4.perspective = function perspective(out, fov, aspect, near, far, isFOVY, minClipZ, projectionSignY, orientation) {
          if (isFOVY === void 0) {
            isFOVY = true;
          }

          if (minClipZ === void 0) {
            minClipZ = -1;
          }

          if (projectionSignY === void 0) {
            projectionSignY = 1;
          }

          if (orientation === void 0) {
            orientation = 0;
          }

          var f = 1.0 / Math.tan(fov / 2);
          var nf = 1 / (near - far);
          var x = isFOVY ? f / aspect : f;
          var y = (isFOVY ? f : f * aspect) * projectionSignY;
          var preTransform = preTransforms[orientation];
          out.m00 = x * preTransform[0];
          out.m01 = x * preTransform[1];
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = y * preTransform[2];
          out.m05 = y * preTransform[3];
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = (far - minClipZ * near) * nf;
          out.m11 = -1;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = far * near * nf * (1 - minClipZ);
          out.m15 = 0;
          return out;
        };

        Mat4.ortho = function ortho(out, left, right, bottom, top, near, far, minClipZ, projectionSignY, orientation) {
          if (minClipZ === void 0) {
            minClipZ = -1;
          }

          if (projectionSignY === void 0) {
            projectionSignY = 1;
          }

          if (orientation === void 0) {
            orientation = 0;
          }

          var lr = 1 / (left - right);
          var bt = 1 / (bottom - top) * projectionSignY;
          var nf = 1 / (near - far);
          var x = -2 * lr;
          var y = -2 * bt;
          var dx = (left + right) * lr;
          var dy = (top + bottom) * bt;
          var preTransform = preTransforms[orientation];
          out.m00 = x * preTransform[0];
          out.m01 = x * preTransform[1];
          out.m02 = 0;
          out.m03 = 0;
          out.m04 = y * preTransform[2];
          out.m05 = y * preTransform[3];
          out.m06 = 0;
          out.m07 = 0;
          out.m08 = 0;
          out.m09 = 0;
          out.m10 = nf * (1 - minClipZ);
          out.m11 = 0;
          out.m12 = dx * preTransform[0] + dy * preTransform[2];
          out.m13 = dx * preTransform[1] + dy * preTransform[3];
          out.m14 = (near - minClipZ * far) * nf;
          out.m15 = 1;
          return out;
        };

        Mat4.lookAt = function lookAt(out, eye, center, up) {
          var eyex = eye.x;
          var eyey = eye.y;
          var eyez = eye.z;
          var upx = up.x;
          var upy = up.y;
          var upz = up.z;
          var centerx = center.x;
          var centery = center.y;
          var centerz = center.z;
          var z0 = eyex - centerx;
          var z1 = eyey - centery;
          var z2 = eyez - centerz;
          var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
          z0 *= len;
          z1 *= len;
          z2 *= len;
          var x0 = upy * z2 - upz * z1;
          var x1 = upz * z0 - upx * z2;
          var x2 = upx * z1 - upy * z0;
          len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
          x0 *= len;
          x1 *= len;
          x2 *= len;
          var y0 = z1 * x2 - z2 * x1;
          var y1 = z2 * x0 - z0 * x2;
          var y2 = z0 * x1 - z1 * x0;
          out.m00 = x0;
          out.m01 = y0;
          out.m02 = z0;
          out.m03 = 0;
          out.m04 = x1;
          out.m05 = y1;
          out.m06 = z1;
          out.m07 = 0;
          out.m08 = x2;
          out.m09 = y2;
          out.m10 = z2;
          out.m11 = 0;
          out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
          out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
          out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
          out.m15 = 1;
          return out;
        };

        Mat4.inverseTranspose = function inverseTranspose(out, a) {
          var a00 = a.m00;
          var a01 = a.m01;
          var a02 = a.m02;
          var a03 = a.m03;
          var a10 = a.m04;
          var a11 = a.m05;
          var a12 = a.m06;
          var a13 = a.m07;
          var a20 = a.m08;
          var a21 = a.m09;
          var a22 = a.m10;
          var a23 = a.m11;
          var a30 = a.m12;
          var a31 = a.m13;
          var a32 = a.m14;
          var a33 = a.m15;
          var b00 = a00 * a11 - a01 * a10;
          var b01 = a00 * a12 - a02 * a10;
          var b02 = a00 * a13 - a03 * a10;
          var b03 = a01 * a12 - a02 * a11;
          var b04 = a01 * a13 - a03 * a11;
          var b05 = a02 * a13 - a03 * a12;
          var b06 = a20 * a31 - a21 * a30;
          var b07 = a20 * a32 - a22 * a30;
          var b08 = a20 * a33 - a23 * a30;
          var b09 = a21 * a32 - a22 * a31;
          var b10 = a21 * a33 - a23 * a31;
          var b11 = a22 * a33 - a23 * a32;
          var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

          if (!det) {
            return null;
          }

          det = 1.0 / det;
          out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out.m03 = 0;
          out.m04 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out.m06 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out.m07 = 0;
          out.m08 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out.m09 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out.m11 = 0;
          out.m12 = 0;
          out.m13 = 0;
          out.m14 = 0;
          out.m15 = 1;
          return out;
        };

        Mat4.toArray = function toArray(out, m, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out[ofs + 0] = m.m00;
          out[ofs + 1] = m.m01;
          out[ofs + 2] = m.m02;
          out[ofs + 3] = m.m03;
          out[ofs + 4] = m.m04;
          out[ofs + 5] = m.m05;
          out[ofs + 6] = m.m06;
          out[ofs + 7] = m.m07;
          out[ofs + 8] = m.m08;
          out[ofs + 9] = m.m09;
          out[ofs + 10] = m.m10;
          out[ofs + 11] = m.m11;
          out[ofs + 12] = m.m12;
          out[ofs + 13] = m.m13;
          out[ofs + 14] = m.m14;
          out[ofs + 15] = m.m15;
          return out;
        };

        Mat4.fromArray = function fromArray(out, arr, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out.m00 = arr[ofs + 0];
          out.m01 = arr[ofs + 1];
          out.m02 = arr[ofs + 2];
          out.m03 = arr[ofs + 3];
          out.m04 = arr[ofs + 4];
          out.m05 = arr[ofs + 5];
          out.m06 = arr[ofs + 6];
          out.m07 = arr[ofs + 7];
          out.m08 = arr[ofs + 8];
          out.m09 = arr[ofs + 9];
          out.m10 = arr[ofs + 10];
          out.m11 = arr[ofs + 11];
          out.m12 = arr[ofs + 12];
          out.m13 = arr[ofs + 13];
          out.m14 = arr[ofs + 14];
          out.m15 = arr[ofs + 15];
          return out;
        };

        Mat4.add = function add(out, a, b) {
          out.m00 = a.m00 + b.m00;
          out.m01 = a.m01 + b.m01;
          out.m02 = a.m02 + b.m02;
          out.m03 = a.m03 + b.m03;
          out.m04 = a.m04 + b.m04;
          out.m05 = a.m05 + b.m05;
          out.m06 = a.m06 + b.m06;
          out.m07 = a.m07 + b.m07;
          out.m08 = a.m08 + b.m08;
          out.m09 = a.m09 + b.m09;
          out.m10 = a.m10 + b.m10;
          out.m11 = a.m11 + b.m11;
          out.m12 = a.m12 + b.m12;
          out.m13 = a.m13 + b.m13;
          out.m14 = a.m14 + b.m14;
          out.m15 = a.m15 + b.m15;
          return out;
        };

        Mat4.subtract = function subtract(out, a, b) {
          out.m00 = a.m00 - b.m00;
          out.m01 = a.m01 - b.m01;
          out.m02 = a.m02 - b.m02;
          out.m03 = a.m03 - b.m03;
          out.m04 = a.m04 - b.m04;
          out.m05 = a.m05 - b.m05;
          out.m06 = a.m06 - b.m06;
          out.m07 = a.m07 - b.m07;
          out.m08 = a.m08 - b.m08;
          out.m09 = a.m09 - b.m09;
          out.m10 = a.m10 - b.m10;
          out.m11 = a.m11 - b.m11;
          out.m12 = a.m12 - b.m12;
          out.m13 = a.m13 - b.m13;
          out.m14 = a.m14 - b.m14;
          out.m15 = a.m15 - b.m15;
          return out;
        };

        Mat4.multiplyScalar = function multiplyScalar(out, a, b) {
          out.m00 = a.m00 * b;
          out.m01 = a.m01 * b;
          out.m02 = a.m02 * b;
          out.m03 = a.m03 * b;
          out.m04 = a.m04 * b;
          out.m05 = a.m05 * b;
          out.m06 = a.m06 * b;
          out.m07 = a.m07 * b;
          out.m08 = a.m08 * b;
          out.m09 = a.m09 * b;
          out.m10 = a.m10 * b;
          out.m11 = a.m11 * b;
          out.m12 = a.m12 * b;
          out.m13 = a.m13 * b;
          out.m14 = a.m14 * b;
          out.m15 = a.m15 * b;
          return out;
        };

        Mat4.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
          out.m00 = a.m00 + b.m00 * scale;
          out.m01 = a.m01 + b.m01 * scale;
          out.m02 = a.m02 + b.m02 * scale;
          out.m03 = a.m03 + b.m03 * scale;
          out.m04 = a.m04 + b.m04 * scale;
          out.m05 = a.m05 + b.m05 * scale;
          out.m06 = a.m06 + b.m06 * scale;
          out.m07 = a.m07 + b.m07 * scale;
          out.m08 = a.m08 + b.m08 * scale;
          out.m09 = a.m09 + b.m09 * scale;
          out.m10 = a.m10 + b.m10 * scale;
          out.m11 = a.m11 + b.m11 * scale;
          out.m12 = a.m12 + b.m12 * scale;
          out.m13 = a.m13 + b.m13 * scale;
          out.m14 = a.m14 + b.m14 * scale;
          out.m15 = a.m15 + b.m15 * scale;
          return out;
        };

        Mat4.strictEquals = function strictEquals(a, b) {
          return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
        };

        Mat4.equals = function equals(a, b, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1.0, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1.0, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1.0, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1.0, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1.0, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1.0, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1.0, Math.abs(a.m15), Math.abs(b.m15));
        };

        function Mat4(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15) {
          var _this;

          if (m00 === void 0) {
            m00 = 1;
          }

          if (m01 === void 0) {
            m01 = 0;
          }

          if (m02 === void 0) {
            m02 = 0;
          }

          if (m03 === void 0) {
            m03 = 0;
          }

          if (m04 === void 0) {
            m04 = 0;
          }

          if (m05 === void 0) {
            m05 = 1;
          }

          if (m06 === void 0) {
            m06 = 0;
          }

          if (m07 === void 0) {
            m07 = 0;
          }

          if (m08 === void 0) {
            m08 = 0;
          }

          if (m09 === void 0) {
            m09 = 0;
          }

          if (m10 === void 0) {
            m10 = 1;
          }

          if (m11 === void 0) {
            m11 = 0;
          }

          if (m12 === void 0) {
            m12 = 0;
          }

          if (m13 === void 0) {
            m13 = 0;
          }

          if (m14 === void 0) {
            m14 = 0;
          }

          if (m15 === void 0) {
            m15 = 1;
          }

          _this = _ValueType.call(this) || this;
          _this.m00 = void 0;
          _this.m01 = void 0;
          _this.m02 = void 0;
          _this.m03 = void 0;
          _this.m04 = void 0;
          _this.m05 = void 0;
          _this.m06 = void 0;
          _this.m07 = void 0;
          _this.m08 = void 0;
          _this.m09 = void 0;
          _this.m10 = void 0;
          _this.m11 = void 0;
          _this.m12 = void 0;
          _this.m13 = void 0;
          _this.m14 = void 0;
          _this.m15 = void 0;

          if (typeof m00 === 'object') {
            _this.m00 = m00.m00;
            _this.m01 = m00.m01;
            _this.m02 = m00.m02;
            _this.m03 = m00.m03;
            _this.m04 = m00.m04;
            _this.m05 = m00.m05;
            _this.m06 = m00.m06;
            _this.m07 = m00.m07;
            _this.m08 = m00.m08;
            _this.m09 = m00.m09;
            _this.m10 = m00.m10;
            _this.m11 = m00.m11;
            _this.m12 = m00.m12;
            _this.m13 = m00.m13;
            _this.m14 = m00.m14;
            _this.m15 = m00.m15;
          } else {
            _this.m00 = m00;
            _this.m01 = m01;
            _this.m02 = m02;
            _this.m03 = m03;
            _this.m04 = m04;
            _this.m05 = m05;
            _this.m06 = m06;
            _this.m07 = m07;
            _this.m08 = m08;
            _this.m09 = m09;
            _this.m10 = m10;
            _this.m11 = m11;
            _this.m12 = m12;
            _this.m13 = m13;
            _this.m14 = m14;
            _this.m15 = m15;
          }

          return _this;
        }

        var _proto = Mat4.prototype;

        _proto.clone = function clone() {
          return new Mat4(this.m00, this.m01, this.m02, this.m03, this.m04, this.m05, this.m06, this.m07, this.m08, this.m09, this.m10, this.m11, this.m12, this.m13, this.m14, this.m15);
        };

        _proto.set = function set(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15) {
          if (m00 === void 0) {
            m00 = 1;
          }

          if (m01 === void 0) {
            m01 = 0;
          }

          if (m02 === void 0) {
            m02 = 0;
          }

          if (m03 === void 0) {
            m03 = 0;
          }

          if (m04 === void 0) {
            m04 = 0;
          }

          if (m05 === void 0) {
            m05 = 1;
          }

          if (m06 === void 0) {
            m06 = 0;
          }

          if (m07 === void 0) {
            m07 = 0;
          }

          if (m08 === void 0) {
            m08 = 0;
          }

          if (m09 === void 0) {
            m09 = 0;
          }

          if (m10 === void 0) {
            m10 = 1;
          }

          if (m11 === void 0) {
            m11 = 0;
          }

          if (m12 === void 0) {
            m12 = 0;
          }

          if (m13 === void 0) {
            m13 = 0;
          }

          if (m14 === void 0) {
            m14 = 0;
          }

          if (m15 === void 0) {
            m15 = 1;
          }

          if (typeof m00 === 'object') {
            this.m01 = m00.m01;
            this.m02 = m00.m02;
            this.m03 = m00.m03;
            this.m04 = m00.m04;
            this.m05 = m00.m05;
            this.m06 = m00.m06;
            this.m07 = m00.m07;
            this.m08 = m00.m08;
            this.m09 = m00.m09;
            this.m10 = m00.m10;
            this.m11 = m00.m11;
            this.m12 = m00.m12;
            this.m13 = m00.m13;
            this.m14 = m00.m14;
            this.m15 = m00.m15;
            this.m00 = m00.m00;
          } else {
            this.m01 = m01;
            this.m02 = m02;
            this.m03 = m03;
            this.m04 = m04;
            this.m05 = m05;
            this.m06 = m06;
            this.m07 = m07;
            this.m08 = m08;
            this.m09 = m09;
            this.m10 = m10;
            this.m11 = m11;
            this.m12 = m12;
            this.m13 = m13;
            this.m14 = m14;
            this.m15 = m15;
            this.m00 = m00;
          }

          return this;
        };

        _proto.equals = function equals(other, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1.0, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1.0, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1.0, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1.0, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1.0, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1.0, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1.0, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1.0, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1.0, Math.abs(this.m08), Math.abs(other.m08)) && Math.abs(this.m09 - other.m09) <= epsilon * Math.max(1.0, Math.abs(this.m09), Math.abs(other.m09)) && Math.abs(this.m10 - other.m10) <= epsilon * Math.max(1.0, Math.abs(this.m10), Math.abs(other.m10)) && Math.abs(this.m11 - other.m11) <= epsilon * Math.max(1.0, Math.abs(this.m11), Math.abs(other.m11)) && Math.abs(this.m12 - other.m12) <= epsilon * Math.max(1.0, Math.abs(this.m12), Math.abs(other.m12)) && Math.abs(this.m13 - other.m13) <= epsilon * Math.max(1.0, Math.abs(this.m13), Math.abs(other.m13)) && Math.abs(this.m14 - other.m14) <= epsilon * Math.max(1.0, Math.abs(this.m14), Math.abs(other.m14)) && Math.abs(this.m15 - other.m15) <= epsilon * Math.max(1.0, Math.abs(this.m15), Math.abs(other.m15));
        };

        _proto.strictEquals = function strictEquals(other) {
          return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08 && this.m09 === other.m09 && this.m10 === other.m10 && this.m11 === other.m11 && this.m12 === other.m12 && this.m13 === other.m13 && this.m14 === other.m14 && this.m15 === other.m15;
        };

        _proto.toString = function toString() {
          return "[\n" + this.m00 + ", " + this.m01 + ", " + this.m02 + ", " + this.m03 + ",\n" + this.m04 + ", " + this.m05 + ", " + this.m06 + ", " + this.m07 + ",\n" + this.m08 + ", " + this.m09 + ", " + this.m10 + ", " + this.m11 + ",\n" + this.m12 + ", " + this.m13 + ", " + this.m14 + ", " + this.m15 + "\n" + ']';
        };

        _proto.identity = function identity() {
          this.m00 = 1;
          this.m01 = 0;
          this.m02 = 0;
          this.m03 = 0;
          this.m04 = 0;
          this.m05 = 1;
          this.m06 = 0;
          this.m07 = 0;
          this.m08 = 0;
          this.m09 = 0;
          this.m10 = 1;
          this.m11 = 0;
          this.m12 = 0;
          this.m13 = 0;
          this.m14 = 0;
          this.m15 = 1;
          return this;
        };

        _proto.zero = function zero() {
          this.m00 = 0;
          this.m01 = 0;
          this.m02 = 0;
          this.m03 = 0;
          this.m04 = 0;
          this.m05 = 0;
          this.m06 = 0;
          this.m07 = 0;
          this.m08 = 0;
          this.m09 = 0;
          this.m10 = 0;
          this.m11 = 0;
          this.m12 = 0;
          this.m13 = 0;
          this.m14 = 0;
          this.m15 = 0;
          return this;
        };

        _proto.transpose = function transpose() {
          var a01 = this.m01;
          var a02 = this.m02;
          var a03 = this.m03;
          var a12 = this.m06;
          var a13 = this.m07;
          var a23 = this.m11;
          this.m01 = this.m04;
          this.m02 = this.m08;
          this.m03 = this.m12;
          this.m04 = a01;
          this.m06 = this.m09;
          this.m07 = this.m13;
          this.m08 = a02;
          this.m09 = a12;
          this.m11 = this.m14;
          this.m12 = a03;
          this.m13 = a13;
          this.m14 = a23;
          return this;
        };

        _proto.invert = function invert() {
          var a00 = this.m00;
          var a01 = this.m01;
          var a02 = this.m02;
          var a03 = this.m03;
          var a10 = this.m04;
          var a11 = this.m05;
          var a12 = this.m06;
          var a13 = this.m07;
          var a20 = this.m08;
          var a21 = this.m09;
          var a22 = this.m10;
          var a23 = this.m11;
          var a30 = this.m12;
          var a31 = this.m13;
          var a32 = this.m14;
          var a33 = this.m15;
          var b00 = a00 * a11 - a01 * a10;
          var b01 = a00 * a12 - a02 * a10;
          var b02 = a00 * a13 - a03 * a10;
          var b03 = a01 * a12 - a02 * a11;
          var b04 = a01 * a13 - a03 * a11;
          var b05 = a02 * a13 - a03 * a12;
          var b06 = a20 * a31 - a21 * a30;
          var b07 = a20 * a32 - a22 * a30;
          var b08 = a20 * a33 - a23 * a30;
          var b09 = a21 * a32 - a22 * a31;
          var b10 = a21 * a33 - a23 * a31;
          var b11 = a22 * a33 - a23 * a32;
          var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

          if (det === 0) {
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            return this;
          }

          det = 1.0 / det;
          this.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          this.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          this.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          this.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          this.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          this.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          this.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          this.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          this.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          this.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          this.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          this.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          this.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          this.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          this.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          this.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return this;
        };

        _proto.determinant = function determinant() {
          var a00 = this.m00;
          var a01 = this.m01;
          var a02 = this.m02;
          var a03 = this.m03;
          var a10 = this.m04;
          var a11 = this.m05;
          var a12 = this.m06;
          var a13 = this.m07;
          var a20 = this.m08;
          var a21 = this.m09;
          var a22 = this.m10;
          var a23 = this.m11;
          var a30 = this.m12;
          var a31 = this.m13;
          var a32 = this.m14;
          var a33 = this.m15;
          var b00 = a00 * a11 - a01 * a10;
          var b01 = a00 * a12 - a02 * a10;
          var b02 = a00 * a13 - a03 * a10;
          var b03 = a01 * a12 - a02 * a11;
          var b04 = a01 * a13 - a03 * a11;
          var b05 = a02 * a13 - a03 * a12;
          var b06 = a20 * a31 - a21 * a30;
          var b07 = a20 * a32 - a22 * a30;
          var b08 = a20 * a33 - a23 * a30;
          var b09 = a21 * a32 - a22 * a31;
          var b10 = a21 * a33 - a23 * a31;
          var b11 = a22 * a33 - a23 * a32;
          return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        };

        _proto.add = function add(mat) {
          this.m00 += mat.m00;
          this.m01 += mat.m01;
          this.m02 += mat.m02;
          this.m03 += mat.m03;
          this.m04 += mat.m04;
          this.m05 += mat.m05;
          this.m06 += mat.m06;
          this.m07 += mat.m07;
          this.m08 += mat.m08;
          this.m09 += mat.m09;
          this.m10 += mat.m10;
          this.m11 += mat.m11;
          this.m12 += mat.m12;
          this.m13 += mat.m13;
          this.m14 += mat.m14;
          this.m15 += mat.m15;
          return this;
        };

        _proto.subtract = function subtract(mat) {
          this.m00 -= mat.m00;
          this.m01 -= mat.m01;
          this.m02 -= mat.m02;
          this.m03 -= mat.m03;
          this.m04 -= mat.m04;
          this.m05 -= mat.m05;
          this.m06 -= mat.m06;
          this.m07 -= mat.m07;
          this.m08 -= mat.m08;
          this.m09 -= mat.m09;
          this.m10 -= mat.m10;
          this.m11 -= mat.m11;
          this.m12 -= mat.m12;
          this.m13 -= mat.m13;
          this.m14 -= mat.m14;
          this.m15 -= mat.m15;
          return this;
        };

        _proto.multiply = function multiply(mat) {
          var a00 = this.m00;
          var a01 = this.m01;
          var a02 = this.m02;
          var a03 = this.m03;
          var a10 = this.m04;
          var a11 = this.m05;
          var a12 = this.m06;
          var a13 = this.m07;
          var a20 = this.m08;
          var a21 = this.m09;
          var a22 = this.m10;
          var a23 = this.m11;
          var a30 = this.m12;
          var a31 = this.m13;
          var a32 = this.m14;
          var a33 = this.m15;
          var b0 = mat.m00;
          var b1 = mat.m01;
          var b2 = mat.m02;
          var b3 = mat.m03;
          this.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = mat.m04;
          b1 = mat.m05;
          b2 = mat.m06;
          b3 = mat.m07;
          this.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = mat.m08;
          b1 = mat.m09;
          b2 = mat.m10;
          b3 = mat.m11;
          this.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = mat.m12;
          b1 = mat.m13;
          b2 = mat.m14;
          b3 = mat.m15;
          this.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return this;
        };

        _proto.multiplyScalar = function multiplyScalar(scalar) {
          this.m00 *= scalar;
          this.m01 *= scalar;
          this.m02 *= scalar;
          this.m03 *= scalar;
          this.m04 *= scalar;
          this.m05 *= scalar;
          this.m06 *= scalar;
          this.m07 *= scalar;
          this.m08 *= scalar;
          this.m09 *= scalar;
          this.m10 *= scalar;
          this.m11 *= scalar;
          this.m12 *= scalar;
          this.m13 *= scalar;
          this.m14 *= scalar;
          this.m15 *= scalar;
          return this;
        };

        _proto.translate = function translate(vec) {
          console.warn('function changed');
          this.m12 += vec.x;
          this.m13 += vec.y;
          this.m14 += vec.z;
          return this;
        };

        _proto.scale = function scale(vec) {
          var x = vec.x;
          var y = vec.y;
          var z = vec.z;
          this.m00 *= x;
          this.m01 *= x;
          this.m02 *= x;
          this.m03 *= x;
          this.m04 *= y;
          this.m05 *= y;
          this.m06 *= y;
          this.m07 *= y;
          this.m08 *= z;
          this.m09 *= z;
          this.m10 *= z;
          this.m11 *= z;
          return this;
        };

        _proto.rotate = function rotate(rad, axis) {
          var x = axis.x;
          var y = axis.y;
          var z = axis.z;
          var len = Math.sqrt(x * x + y * y + z * z);

          if (Math.abs(len) < EPSILON) {
            return null;
          }

          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          var t = 1 - c;
          var a00 = this.m00;
          var a01 = this.m01;
          var a02 = this.m02;
          var a03 = this.m03;
          var a10 = this.m04;
          var a11 = this.m05;
          var a12 = this.m06;
          var a13 = this.m07;
          var a20 = this.m08;
          var a21 = this.m09;
          var a22 = this.m10;
          var a23 = this.m11;
          var b00 = x * x * t + c;
          var b01 = y * x * t + z * s;
          var b02 = z * x * t - y * s;
          var b10 = x * y * t - z * s;
          var b11 = y * y * t + c;
          var b12 = z * y * t + x * s;
          var b20 = x * z * t + y * s;
          var b21 = y * z * t - x * s;
          var b22 = z * z * t + c;
          this.m00 = a00 * b00 + a10 * b01 + a20 * b02;
          this.m01 = a01 * b00 + a11 * b01 + a21 * b02;
          this.m02 = a02 * b00 + a12 * b01 + a22 * b02;
          this.m03 = a03 * b00 + a13 * b01 + a23 * b02;
          this.m04 = a00 * b10 + a10 * b11 + a20 * b12;
          this.m05 = a01 * b10 + a11 * b11 + a21 * b12;
          this.m06 = a02 * b10 + a12 * b11 + a22 * b12;
          this.m07 = a03 * b10 + a13 * b11 + a23 * b12;
          this.m08 = a00 * b20 + a10 * b21 + a20 * b22;
          this.m09 = a01 * b20 + a11 * b21 + a21 * b22;
          this.m10 = a02 * b20 + a12 * b21 + a22 * b22;
          this.m11 = a03 * b20 + a13 * b21 + a23 * b22;
          return this;
        };

        _proto.getTranslation = function getTranslation(out) {
          out.x = this.m12;
          out.y = this.m13;
          out.z = this.m14;
          return out;
        };

        _proto.getScale = function getScale(out) {
          var m00 = m3_1$1.m00 = this.m00;
          var m01 = m3_1$1.m01 = this.m01;
          var m02 = m3_1$1.m02 = this.m02;
          var m04 = m3_1$1.m03 = this.m04;
          var m05 = m3_1$1.m04 = this.m05;
          var m06 = m3_1$1.m05 = this.m06;
          var m08 = m3_1$1.m06 = this.m08;
          var m09 = m3_1$1.m07 = this.m09;
          var m10 = m3_1$1.m08 = this.m10;
          out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
          out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
          out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);

          if (Mat3.determinant(m3_1$1) < 0) {
            out.x *= -1;
          }

          return out;
        };

        _proto.getRotation = function getRotation(out) {
          var trace = this.m00 + this.m05 + this.m10;
          var S = 0;

          if (trace > 0) {
            S = Math.sqrt(trace + 1.0) * 2;
            out.w = 0.25 * S;
            out.x = (this.m06 - this.m09) / S;
            out.y = (this.m08 - this.m02) / S;
            out.z = (this.m01 - this.m04) / S;
          } else if (this.m00 > this.m05 && this.m00 > this.m10) {
            S = Math.sqrt(1.0 + this.m00 - this.m05 - this.m10) * 2;
            out.w = (this.m06 - this.m09) / S;
            out.x = 0.25 * S;
            out.y = (this.m01 + this.m04) / S;
            out.z = (this.m08 + this.m02) / S;
          } else if (this.m05 > this.m10) {
            S = Math.sqrt(1.0 + this.m05 - this.m00 - this.m10) * 2;
            out.w = (this.m08 - this.m02) / S;
            out.x = (this.m01 + this.m04) / S;
            out.y = 0.25 * S;
            out.z = (this.m06 + this.m09) / S;
          } else {
            S = Math.sqrt(1.0 + this.m10 - this.m00 - this.m05) * 2;
            out.w = (this.m01 - this.m04) / S;
            out.x = (this.m08 + this.m02) / S;
            out.y = (this.m06 + this.m09) / S;
            out.z = 0.25 * S;
          }

          return out;
        };

        _proto.fromRTS = function fromRTS(q, v, s) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var xy = x * y2;
          var xz = x * z2;
          var yy = y * y2;
          var yz = y * z2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          var sx = s.x;
          var sy = s.y;
          var sz = s.z;
          this.m00 = (1 - (yy + zz)) * sx;
          this.m01 = (xy + wz) * sx;
          this.m02 = (xz - wy) * sx;
          this.m03 = 0;
          this.m04 = (xy - wz) * sy;
          this.m05 = (1 - (xx + zz)) * sy;
          this.m06 = (yz + wx) * sy;
          this.m07 = 0;
          this.m08 = (xz + wy) * sz;
          this.m09 = (yz - wx) * sz;
          this.m10 = (1 - (xx + yy)) * sz;
          this.m11 = 0;
          this.m12 = v.x;
          this.m13 = v.y;
          this.m14 = v.z;
          this.m15 = 1;
          return this;
        };

        _proto.fromQuat = function fromQuat(q) {
          var x = q.x;
          var y = q.y;
          var z = q.z;
          var w = q.w;
          var x2 = x + x;
          var y2 = y + y;
          var z2 = z + z;
          var xx = x * x2;
          var yx = y * x2;
          var yy = y * y2;
          var zx = z * x2;
          var zy = z * y2;
          var zz = z * z2;
          var wx = w * x2;
          var wy = w * y2;
          var wz = w * z2;
          this.m00 = 1 - yy - zz;
          this.m01 = yx + wz;
          this.m02 = zx - wy;
          this.m03 = 0;
          this.m04 = yx - wz;
          this.m05 = 1 - xx - zz;
          this.m06 = zy + wx;
          this.m07 = 0;
          this.m08 = zx + wy;
          this.m09 = zy - wx;
          this.m10 = 1 - xx - yy;
          this.m11 = 0;
          this.m12 = 0;
          this.m13 = 0;
          this.m14 = 0;
          this.m15 = 1;
          return this;
        };

        return Mat4;
      }(ValueType));
      Mat4.IDENTITY = Object.freeze(new Mat4());
      var v3_1$3 = new Vec3();
      var m3_1$1 = new Mat3();
      CCClass.fastDefine('cc.Mat4', Mat4, {
        m00: 1,
        m01: 0,
        m02: 0,
        m03: 0,
        m04: 0,
        m05: 1,
        m06: 0,
        m07: 0,
        m08: 0,
        m09: 0,
        m10: 1,
        m11: 0,
        m12: 0,
        m13: 0,
        m14: 0,
        m15: 1
      });
      legacyCC.Mat4 = Mat4;
      function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      }
      legacyCC.mat4 = mat4;

      var Vec2 = exports('Vec2', function (_ValueType) {
        _inheritsLoose(Vec2, _ValueType);

        Vec2.clone = function clone(a) {
          return new Vec2(a.x, a.y);
        };

        Vec2.copy = function copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          return out;
        };

        Vec2.set = function set(out, x, y) {
          out.x = x;
          out.y = y;
          return out;
        };

        Vec2.add = function add(out, a, b) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          return out;
        };

        Vec2.subtract = function subtract(out, a, b) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          return out;
        };

        Vec2.multiply = function multiply(out, a, b) {
          out.x = a.x * b.x;
          out.y = a.y * b.y;
          return out;
        };

        Vec2.divide = function divide(out, a, b) {
          out.x = a.x / b.x;
          out.y = a.y / b.y;
          return out;
        };

        Vec2.ceil = function ceil(out, a) {
          out.x = Math.ceil(a.x);
          out.y = Math.ceil(a.y);
          return out;
        };

        Vec2.floor = function floor(out, a) {
          out.x = Math.floor(a.x);
          out.y = Math.floor(a.y);
          return out;
        };

        Vec2.min = function min(out, a, b) {
          out.x = Math.min(a.x, b.x);
          out.y = Math.min(a.y, b.y);
          return out;
        };

        Vec2.max = function max(out, a, b) {
          out.x = Math.max(a.x, b.x);
          out.y = Math.max(a.y, b.y);
          return out;
        };

        Vec2.round = function round(out, a) {
          out.x = Math.round(a.x);
          out.y = Math.round(a.y);
          return out;
        };

        Vec2.multiplyScalar = function multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          return out;
        };

        Vec2.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          return out;
        };

        Vec2.distance = function distance(a, b) {
          var x = b.x - a.x;
          var y = b.y - a.y;
          return Math.sqrt(x * x + y * y);
        };

        Vec2.squaredDistance = function squaredDistance(a, b) {
          var x = b.x - a.x;
          var y = b.y - a.y;
          return x * x + y * y;
        };

        Vec2.len = function len(a) {
          var x = a.x;
          var y = a.y;
          return Math.sqrt(x * x + y * y);
        };

        Vec2.lengthSqr = function lengthSqr(a) {
          var x = a.x;
          var y = a.y;
          return x * x + y * y;
        };

        Vec2.negate = function negate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          return out;
        };

        Vec2.inverse = function inverse(out, a) {
          out.x = 1.0 / a.x;
          out.y = 1.0 / a.y;
          return out;
        };

        Vec2.inverseSafe = function inverseSafe(out, a) {
          var x = a.x;
          var y = a.y;

          if (Math.abs(x) < EPSILON) {
            out.x = 0;
          } else {
            out.x = 1.0 / x;
          }

          if (Math.abs(y) < EPSILON) {
            out.y = 0;
          } else {
            out.y = 1.0 / y;
          }

          return out;
        };

        Vec2.normalize = function normalize(out, a) {
          var x = a.x;
          var y = a.y;
          var len = x * x + y * y;

          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = x * len;
            out.y = y * len;
          }

          return out;
        };

        Vec2.dot = function dot(a, b) {
          return a.x * b.x + a.y * b.y;
        };

        Vec2.cross = function cross(out, a, b) {
          if (out instanceof Vec3) {
            out.x = out.y = 0;
            out.z = a.x * b.y - a.y * b.x;
            return out;
          } else {
            return out.x * a.y - out.y * a.x;
          }
        };

        Vec2.lerp = function lerp(out, a, b, t) {
          var x = a.x;
          var y = a.y;
          out.x = x + t * (b.x - x);
          out.y = y + t * (b.y - y);
          return out;
        };

        Vec2.random = function random$1(out, scale) {
          scale = scale || 1.0;
          var r = random() * 2.0 * Math.PI;
          out.x = Math.cos(r) * scale;
          out.y = Math.sin(r) * scale;
          return out;
        };

        Vec2.transformMat3 = function transformMat3(out, a, m) {
          var x = a.x;
          var y = a.y;
          out.x = m.m00 * x + m.m03 * y + m.m06;
          out.y = m.m01 * x + m.m04 * y + m.m07;
          return out;
        };

        Vec2.transformMat4 = function transformMat4(out, a, m) {
          var x = a.x;
          var y = a.y;
          out.x = m.m00 * x + m.m04 * y + m.m12;
          out.y = m.m01 * x + m.m05 * y + m.m13;
          return out;
        };

        Vec2.str = function str(a) {
          return "Vec2(" + a.x + ", " + a.y + ")";
        };

        Vec2.toArray = function toArray(out, v, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out[ofs + 0] = v.x;
          out[ofs + 1] = v.y;
          return out;
        };

        Vec2.fromArray = function fromArray(out, arr, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          return out;
        };

        Vec2.strictEquals = function strictEquals(a, b) {
          return a.x === b.x && a.y === b.y;
        };

        Vec2.equals = function equals(a, b, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y));
        };

        Vec2.angle = function angle(a, b) {
          Vec2.normalize(v2_1, a);
          Vec2.normalize(v2_2, b);
          var cosine = Vec2.dot(v2_1, v2_2);

          if (cosine > 1.0) {
            return 0;
          }

          if (cosine < -1.0) {
            return Math.PI;
          }

          return Math.acos(cosine);
        };

        function Vec2(x, y) {
          var _this;

          _this = _ValueType.call(this) || this;

          if (x && typeof x === 'object') {
            _this.x = x.x;
            _this.y = x.y;
          } else {
            _this.x = x || 0;
            _this.y = y || 0;
          }

          return _this;
        }

        var _proto = Vec2.prototype;

        _proto.clone = function clone() {
          return new Vec2(this.x, this.y);
        };

        _proto.set = function set(x, y) {
          if (x && typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
          } else {
            this.x = x || 0;
            this.y = y || 0;
          }

          return this;
        };

        _proto.equals = function equals(other, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y));
        };

        _proto.equals2f = function equals2f(x, y, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y));
        };

        _proto.strictEquals = function strictEquals(other) {
          return other && this.x === other.x && this.y === other.y;
        };

        _proto.strictEquals2f = function strictEquals2f(x, y) {
          return this.x === x && this.y === y;
        };

        _proto.toString = function toString() {
          return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ")";
        };

        _proto.lerp = function lerp(to, ratio) {
          var x = this.x;
          var y = this.y;
          this.x = x + ratio * (to.x - x);
          this.y = y + ratio * (to.y - y);
          return this;
        };

        _proto.clampf = function clampf(minInclusive, maxInclusive) {
          this.x = clamp(this.x, minInclusive.x, maxInclusive.x);
          this.y = clamp(this.y, minInclusive.y, maxInclusive.y);
          return this;
        };

        _proto.add = function add(other) {
          this.x += other.x;
          this.y += other.y;
          return this;
        };

        _proto.add2f = function add2f(x, y) {
          this.x += x;
          this.y += y;
          return this;
        };

        _proto.subtract = function subtract(other) {
          this.x -= other.x;
          this.y -= other.y;
          return this;
        };

        _proto.subtract2f = function subtract2f(x, y) {
          this.x -= x;
          this.y -= y;
          return this;
        };

        _proto.multiplyScalar = function multiplyScalar(scalar) {
          if (typeof scalar === 'object') {
            console.warn('should use Vec2.multiply for vector * vector operation');
          }

          this.x *= scalar;
          this.y *= scalar;
          return this;
        };

        _proto.multiply = function multiply(other) {
          if (typeof other !== 'object') {
            console.warn('should use Vec2.scale for vector * scalar operation');
          }

          this.x *= other.x;
          this.y *= other.y;
          return this;
        };

        _proto.multiply2f = function multiply2f(x, y) {
          this.x *= x;
          this.y *= y;
          return this;
        };

        _proto.divide = function divide(other) {
          this.x /= other.x;
          this.y /= other.y;
          return this;
        };

        _proto.divide2f = function divide2f(x, y) {
          this.x /= x;
          this.y /= y;
          return this;
        };

        _proto.negative = function negative() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        };

        _proto.dot = function dot(other) {
          return this.x * other.x + this.y * other.y;
        };

        _proto.cross = function cross(other) {
          return this.x * other.y - this.y * other.x;
        };

        _proto.length = function length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        };

        _proto.lengthSqr = function lengthSqr() {
          return this.x * this.x + this.y * this.y;
        };

        _proto.normalize = function normalize() {
          var x = this.x;
          var y = this.y;
          var len = x * x + y * y;

          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x *= len;
            this.y *= len;
          }

          return this;
        };

        _proto.angle = function angle(other) {
          var magSqr1 = this.lengthSqr();
          var magSqr2 = other.lengthSqr();

          if (magSqr1 === 0 || magSqr2 === 0) {
            console.warn('Can\'t get angle between zero vector');
            return 0.0;
          }

          var dot = this.dot(other);
          var theta = dot / Math.sqrt(magSqr1 * magSqr2);
          theta = clamp(theta, -1.0, 1.0);
          return Math.acos(theta);
        };

        _proto.signAngle = function signAngle(other) {
          var angle = this.angle(other);
          return this.cross(other) < 0 ? -angle : angle;
        };

        _proto.rotate = function rotate(radians) {
          var x = this.x;
          var y = this.y;
          var sin = Math.sin(radians);
          var cos = Math.cos(radians);
          this.x = cos * x - sin * y;
          this.y = sin * x + cos * y;
          return this;
        };

        _proto.project = function project(other) {
          var scalar = this.dot(other) / other.dot(other);
          this.x = other.x * scalar;
          this.y = other.y * scalar;
          return this;
        };

        _proto.transformMat4 = function transformMat4(matrix) {
          var x = this.x;
          var y = this.y;
          this.x = matrix.m00 * x + matrix.m04 * y + matrix.m12;
          this.y = matrix.m01 * x + matrix.m05 * y + matrix.m13;
          return this;
        };

        return Vec2;
      }(ValueType));
      Vec2.ZERO = Object.freeze(new Vec2(0, 0));
      Vec2.ONE = Object.freeze(new Vec2(1, 1));
      Vec2.NEG_ONE = Object.freeze(new Vec2(-1, -1));
      Vec2.UNIT_X = Object.freeze(new Vec2(1, 0));
      Vec2.UNIT_Y = Object.freeze(new Vec2(0, 1));
      var v2_1 = new Vec2();
      var v2_2 = new Vec2();
      CCClass.fastDefine('cc.Vec2', Vec2, {
        x: 0,
        y: 0
      });
      legacyCC.Vec2 = Vec2;
      function v2(x, y) {
        return new Vec2(x, y);
      }
      legacyCC.v2 = v2;

      var Vec4 = exports('Vec4', function (_ValueType) {
        _inheritsLoose(Vec4, _ValueType);

        Vec4.clone = function clone(a) {
          return new Vec4(a.x, a.y, a.z, a.w);
        };

        Vec4.copy = function copy(out, a) {
          out.x = a.x;
          out.y = a.y;
          out.z = a.z;
          out.w = a.w;
          return out;
        };

        Vec4.set = function set(out, x, y, z, w) {
          out.x = x;
          out.y = y;
          out.z = z;
          out.w = w;
          return out;
        };

        Vec4.add = function add(out, a, b) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          out.z = a.z + b.z;
          out.w = a.w + b.w;
          return out;
        };

        Vec4.subtract = function subtract(out, a, b) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          out.z = a.z - b.z;
          out.w = a.w - b.w;
          return out;
        };

        Vec4.multiply = function multiply(out, a, b) {
          out.x = a.x * b.x;
          out.y = a.y * b.y;
          out.z = a.z * b.z;
          out.w = a.w * b.w;
          return out;
        };

        Vec4.divide = function divide(out, a, b) {
          out.x = a.x / b.x;
          out.y = a.y / b.y;
          out.z = a.z / b.z;
          out.w = a.w / b.w;
          return out;
        };

        Vec4.ceil = function ceil(out, a) {
          out.x = Math.ceil(a.x);
          out.y = Math.ceil(a.y);
          out.z = Math.ceil(a.z);
          out.w = Math.ceil(a.w);
          return out;
        };

        Vec4.floor = function floor(out, a) {
          out.x = Math.floor(a.x);
          out.y = Math.floor(a.y);
          out.z = Math.floor(a.z);
          out.w = Math.floor(a.w);
          return out;
        };

        Vec4.min = function min(out, a, b) {
          out.x = Math.min(a.x, b.x);
          out.y = Math.min(a.y, b.y);
          out.z = Math.min(a.z, b.z);
          out.w = Math.min(a.w, b.w);
          return out;
        };

        Vec4.max = function max(out, a, b) {
          out.x = Math.max(a.x, b.x);
          out.y = Math.max(a.y, b.y);
          out.z = Math.max(a.z, b.z);
          out.w = Math.max(a.w, b.w);
          return out;
        };

        Vec4.round = function round(out, a) {
          out.x = Math.round(a.x);
          out.y = Math.round(a.y);
          out.z = Math.round(a.z);
          out.w = Math.round(a.w);
          return out;
        };

        Vec4.multiplyScalar = function multiplyScalar(out, a, b) {
          out.x = a.x * b;
          out.y = a.y * b;
          out.z = a.z * b;
          out.w = a.w * b;
          return out;
        };

        Vec4.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
          out.x = a.x + b.x * scale;
          out.y = a.y + b.y * scale;
          out.z = a.z + b.z * scale;
          out.w = a.w + b.w * scale;
          return out;
        };

        Vec4.distance = function distance(a, b) {
          var x = b.x - a.x;
          var y = b.y - a.y;
          var z = b.z - a.z;
          var w = b.w - a.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        };

        Vec4.squaredDistance = function squaredDistance(a, b) {
          var x = b.x - a.x;
          var y = b.y - a.y;
          var z = b.z - a.z;
          var w = b.w - a.w;
          return x * x + y * y + z * z + w * w;
        };

        Vec4.len = function len(a) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          var w = a.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        };

        Vec4.lengthSqr = function lengthSqr(a) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          var w = a.w;
          return x * x + y * y + z * z + w * w;
        };

        Vec4.negate = function negate(out, a) {
          out.x = -a.x;
          out.y = -a.y;
          out.z = -a.z;
          out.w = -a.w;
          return out;
        };

        Vec4.inverse = function inverse(out, a) {
          out.x = 1.0 / a.x;
          out.y = 1.0 / a.y;
          out.z = 1.0 / a.z;
          out.w = 1.0 / a.w;
          return out;
        };

        Vec4.inverseSafe = function inverseSafe(out, a) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          var w = a.w;

          if (Math.abs(x) < EPSILON) {
            out.x = 0;
          } else {
            out.x = 1.0 / x;
          }

          if (Math.abs(y) < EPSILON) {
            out.y = 0;
          } else {
            out.y = 1.0 / y;
          }

          if (Math.abs(z) < EPSILON) {
            out.z = 0;
          } else {
            out.z = 1.0 / z;
          }

          if (Math.abs(w) < EPSILON) {
            out.w = 0;
          } else {
            out.w = 1.0 / w;
          }

          return out;
        };

        Vec4.normalize = function normalize(out, a) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          var w = a.w;
          var len = x * x + y * y + z * z + w * w;

          if (len > 0) {
            len = 1 / Math.sqrt(len);
            out.x = x * len;
            out.y = y * len;
            out.z = z * len;
            out.w = w * len;
          }

          return out;
        };

        Vec4.dot = function dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        };

        Vec4.lerp = function lerp(out, a, b, t) {
          out.x = a.x + t * (b.x - a.x);
          out.y = a.y + t * (b.y - a.y);
          out.z = a.z + t * (b.z - a.z);
          out.w = a.w + t * (b.w - a.w);
          return out;
        };

        Vec4.random = function random$1(out, scale) {
          scale = scale || 1.0;
          var phi = random() * 2.0 * Math.PI;
          var cosTheta = random() * 2 - 1;
          var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
          out.x = sinTheta * Math.cos(phi) * scale;
          out.y = sinTheta * Math.sin(phi) * scale;
          out.z = cosTheta * scale;
          out.w = 0;
          return out;
        };

        Vec4.transformMat4 = function transformMat4(out, a, m) {
          var x = a.x;
          var y = a.y;
          var z = a.z;
          var w = a.w;
          out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
          out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
          out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
          out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
          return out;
        };

        Vec4.transformAffine = function transformAffine(out, v, m) {
          var x = v.x;
          var y = v.y;
          var z = v.z;
          var w = v.w;
          out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
          out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
          out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
          out.w = v.w;
          return out;
        };

        Vec4.transformQuat = function transformQuat(out, a, q) {
          var x = a.x,
              y = a.y,
              z = a.z;
          var _x = q.x;
          var _y = q.y;
          var _z = q.z;
          var _w = q.w;
          var ix = _w * x + _y * z - _z * y;
          var iy = _w * y + _z * x - _x * z;
          var iz = _w * z + _x * y - _y * x;
          var iw = -_x * x - _y * y - _z * z;
          out.x = ix * _w + iw * -_x + iy * -_z - iz * -_y;
          out.y = iy * _w + iw * -_y + iz * -_x - ix * -_z;
          out.z = iz * _w + iw * -_z + ix * -_y - iy * -_x;
          out.w = a.w;
          return out;
        };

        Vec4.toArray = function toArray(out, v, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out[ofs + 0] = v.x;
          out[ofs + 1] = v.y;
          out[ofs + 2] = v.z;
          out[ofs + 3] = v.w;
          return out;
        };

        Vec4.fromArray = function fromArray(out, arr, ofs) {
          if (ofs === void 0) {
            ofs = 0;
          }

          out.x = arr[ofs + 0];
          out.y = arr[ofs + 1];
          out.z = arr[ofs + 2];
          out.w = arr[ofs + 3];
          return out;
        };

        Vec4.strictEquals = function strictEquals(a, b) {
          return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        };

        Vec4.equals = function equals(a, b, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
        };

        function Vec4(x, y, z, w) {
          var _this;

          _this = _ValueType.call(this) || this;

          if (x && typeof x === 'object') {
            _this.x = x.x;
            _this.y = x.y;
            _this.z = x.z;
            _this.w = x.w;
          } else {
            _this.x = x || 0;
            _this.y = y || 0;
            _this.z = z || 0;
            _this.w = w || 0;
          }

          return _this;
        }

        var _proto = Vec4.prototype;

        _proto.clone = function clone() {
          return new Vec4(this.x, this.y, this.z, this.w);
        };

        _proto.set = function set(x, y, z, w) {
          if (x && typeof x === 'object') {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z;
            this.w = x.w;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
          }

          return this;
        };

        _proto.equals = function equals(other, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(other.w));
        };

        _proto.equals4f = function equals4f(x, y, z, w, epsilon) {
          if (epsilon === void 0) {
            epsilon = EPSILON;
          }

          return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(w));
        };

        _proto.strictEquals = function strictEquals(other) {
          return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        };

        _proto.strictEquals4f = function strictEquals4f(x, y, z, w) {
          return this.x === x && this.y === y && this.z === z && this.w === w;
        };

        _proto.lerp = function lerp(to, ratio) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          this.x = x + ratio * (to.x - x);
          this.y = y + ratio * (to.y - y);
          this.z = z + ratio * (to.z - z);
          this.w = w + ratio * (to.w - w);
          return this;
        };

        _proto.toString = function toString() {
          return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.z.toFixed(2) + ", " + this.w.toFixed(2) + ")";
        };

        _proto.clampf = function clampf(minInclusive, maxInclusive) {
          this.x = clamp(this.x, minInclusive.x, maxInclusive.x);
          this.y = clamp(this.y, minInclusive.y, maxInclusive.y);
          this.z = clamp(this.z, minInclusive.z, maxInclusive.z);
          this.w = clamp(this.w, minInclusive.w, maxInclusive.w);
          return this;
        };

        _proto.add = function add(other) {
          this.x += other.x;
          this.y += other.y;
          this.z += other.z;
          this.w += other.w;
          return this;
        };

        _proto.add4f = function add4f(x, y, z, w) {
          this.x += x;
          this.y += y;
          this.z += z;
          this.w += w;
          return this;
        };

        _proto.subtract = function subtract(other) {
          this.x -= other.x;
          this.y -= other.y;
          this.z -= other.z;
          this.w -= other.w;
          return this;
        };

        _proto.subtract4f = function subtract4f(x, y, z, w) {
          this.x -= x;
          this.y -= y;
          this.z -= z;
          this.w -= w;
          return this;
        };

        _proto.multiplyScalar = function multiplyScalar(scalar) {
          if (typeof scalar === 'object') {
            console.warn('should use Vec4.multiply for vector * vector operation');
          }

          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        };

        _proto.multiply = function multiply(other) {
          if (typeof other !== 'object') {
            console.warn('should use Vec4.scale for vector * scalar operation');
          }

          this.x *= other.x;
          this.y *= other.y;
          this.z *= other.z;
          this.w *= other.w;
          return this;
        };

        _proto.multiply4f = function multiply4f(x, y, z, w) {
          this.x *= x;
          this.y *= y;
          this.z *= z;
          this.w *= w;
          return this;
        };

        _proto.divide = function divide(other) {
          this.x /= other.x;
          this.y /= other.y;
          this.z /= other.z;
          this.w /= other.w;
          return this;
        };

        _proto.divide4f = function divide4f(x, y, z, w) {
          this.x /= x;
          this.y /= y;
          this.z /= z;
          this.w /= w;
          return this;
        };

        _proto.negative = function negative() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        };

        _proto.dot = function dot(vector) {
          return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
        };

        _proto.cross = function cross(vector) {
          var ax = this.x,
              ay = this.y,
              az = this.z;
          var bx = vector.x,
              by = vector.y,
              bz = vector.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        };

        _proto.length = function length() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
        };

        _proto.lengthSqr = function lengthSqr() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          return x * x + y * y + z * z + w * w;
        };

        _proto.normalize = function normalize() {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          var len = x * x + y * y + z * z + w * w;

          if (len > 0) {
            len = 1 / Math.sqrt(len);
            this.x = x * len;
            this.y = y * len;
            this.z = z * len;
            this.w = w * len;
          }

          return this;
        };

        _proto.transformMat4 = function transformMat4(matrix) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var w = this.w;
          this.x = matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12 * w;
          this.y = matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13 * w;
          this.z = matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14 * w;
          this.w = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15 * w;
          return this;
        };

        return Vec4;
      }(ValueType));
      Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
      Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));
      Vec4.NEG_ONE = Object.freeze(new Vec4(-1, -1, -1, -1));
      CCClass.fastDefine('cc.Vec4', Vec4, {
        x: 0,
        y: 0,
        z: 0,
        w: 0
      });
      legacyCC.Vec4 = Vec4;
      function v4(x, y, z, w) {
        return new Vec4(x, y, z, w);
      }
      legacyCC.v4 = v4;

      replaceProperty(Vec2, 'Vec2', [{
        name: 'sub',
        newName: 'subtract',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'div',
        newName: 'divide',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'dist',
        newName: 'distance',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'sqrDist',
        newName: 'squaredDistance',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'mag',
        newName: 'len',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec2,
        targetName: 'Vec2'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec2,
        targetName: 'Vec2'
      }]);
      replaceProperty(Vec2.prototype, 'Vec2', [{
        name: 'mag',
        newName: 'length',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }, {
        name: 'magSqr',
        newName: 'lengthSqr',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec2.prototype,
        targetName: 'Vec2'
      }]);
      replaceProperty(Vec3, 'Vec3', [{
        name: 'sub',
        newName: 'subtract',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'div',
        newName: 'divide',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'dist',
        newName: 'distance',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'sqrDist',
        newName: 'squaredDistance',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'mag',
        newName: 'len',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec3,
        targetName: 'Vec3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec3,
        targetName: 'Vec3'
      }]);
      replaceProperty(Vec3.prototype, 'Vec3', [{
        name: 'mag',
        newName: 'length',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }, {
        name: 'magSqr',
        newName: 'lengthSqr',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec3.prototype,
        targetName: 'Vec3'
      }]);
      replaceProperty(Vec4, 'Vec4', [{
        name: 'sub',
        newName: 'subtract',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'div',
        newName: 'divide',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'dist',
        newName: 'distance',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'sqrDist',
        newName: 'squaredDistance',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'mag',
        newName: 'len',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec4,
        targetName: 'Vec4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec4,
        targetName: 'Vec4'
      }]);
      replaceProperty(Vec4.prototype, 'Vec4', [{
        name: 'mag',
        newName: 'length',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }, {
        name: 'magSqr',
        newName: 'lengthSqr',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Vec4.prototype,
        targetName: 'Vec4'
      }]);
      replaceProperty(Quat, 'Quat', [{
        name: 'mag',
        newName: 'len',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'sqrMag',
        newName: 'lengthSqr',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'scale',
        newName: 'multiplyScalar',
        target: Quat,
        targetName: 'Quat'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Quat,
        targetName: 'Quat'
      }]);
      replaceProperty(Quat.prototype, 'Quat', [{
        name: 'scale',
        newName: 'multiplyScalar',
        target: Quat.prototype,
        targetName: 'Quat'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Quat.prototype,
        targetName: 'Quat'
      }]);
      replaceProperty(Color, 'Color', [{
        name: 'sub',
        newName: 'subtract',
        target: Color,
        targetName: 'Color'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Color,
        targetName: 'Color'
      }, {
        name: 'div',
        newName: 'divide',
        target: Color,
        targetName: 'Color'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Color,
        targetName: 'Color'
      }, {
        name: 'fromHex',
        newName: 'fromHEX',
        customFunction: function customFunction() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var arg1 = args[1].toString(16);
          return legacyCC.Color.fromHEX(args[0], arg1);
        }
      }]);
      replaceProperty(Mat3, 'Mat3', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat3,
        targetName: 'Mat3'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat3,
        targetName: 'Mat3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat3,
        targetName: 'Mat3'
      }, {
        name: 'transfrom',
        newName: 'transform',
        target: Mat3,
        targetName: 'Mat3'
      }]);
      replaceProperty(Mat3.prototype, 'Mat3', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }, {
        name: 'mulScalar',
        newName: 'multiplyScalar',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat3.prototype,
        targetName: 'Mat3'
      }]);
      replaceProperty(Mat4, 'Mat4', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat4,
        targetName: 'Mat4'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat4,
        targetName: 'Mat4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat4,
        targetName: 'Mat4'
      }]);
      replaceProperty(Mat4.prototype, 'Mat4', [{
        name: 'sub',
        newName: 'subtract',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }, {
        name: 'mul',
        newName: 'multiply',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }, {
        name: 'mulScalar',
        newName: 'multiplyScalar',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }, {
        name: 'exactEquals',
        newName: 'strictEquals',
        target: Mat4.prototype,
        targetName: 'Mat4'
      }]);

      var AffineTransform = exports('AffineTransform', function () {
        AffineTransform.identity = function identity() {
          return new AffineTransform();
        };

        AffineTransform.clone = function clone(affineTransform) {
          return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
        };

        AffineTransform.concat = function concat(out, t1, t2) {
          var a = t1.a;
          var b = t1.b;
          var c = t1.c;
          var d = t1.d;
          var tx = t1.tx;
          var ty = t1.ty;
          out.a = a * t2.a + b * t2.c;
          out.b = a * t2.b + b * t2.d;
          out.c = c * t2.a + d * t2.c;
          out.d = c * t2.b + d * t2.d;
          out.tx = tx * t2.a + ty * t2.c + t2.tx;
          out.ty = tx * t2.b + ty * t2.d + t2.ty;
        };

        AffineTransform.invert = function invert(out, t) {
          var determinant = 1 / (t.a * t.d - t.b * t.c);
          out.a = determinant * t.d;
          out.b = -determinant * t.b;
          out.c = -determinant * t.c;
          out.d = determinant * t.a;
          out.tx = determinant * (t.c * t.ty - t.d * t.tx);
          out.ty = determinant * (t.b * t.tx - t.a * t.ty);
        };

        AffineTransform.fromMat4 = function fromMat4(out, mat) {
          out.a = mat.m00;
          out.b = mat.m01;
          out.c = mat.m04;
          out.d = mat.m05;
          out.tx = mat.m12;
          out.ty = mat.m13;
        };

        AffineTransform.transformVec2 = function transformVec2(out, point, transOrY, t) {
          var x;
          var y;

          if (!t) {
            t = transOrY;
            x = point.x;
            y = point.y;
          } else {
            x = point;
            y = transOrY;
          }

          out.x = t.a * x + t.c * y + t.tx;
          out.y = t.b * x + t.d * y + t.ty;
        };

        AffineTransform.transformSize = function transformSize(out, size, t) {
          out.width = t.a * size.width + t.c * size.height;
          out.height = t.b * size.width + t.d * size.height;
        };

        AffineTransform.transformRect = function transformRect(out, rect, t) {
          var or = rect.x + rect.width;
          var ot = rect.y + rect.height;
          var lbx = t.a * rect.x + t.c * rect.y + t.tx;
          var lby = t.b * rect.x + t.d * rect.y + t.ty;
          var rbx = t.a * or + t.c * rect.y + t.tx;
          var rby = t.b * or + t.d * rect.y + t.ty;
          var ltx = t.a * rect.x + t.c * ot + t.tx;
          var lty = t.b * rect.x + t.d * ot + t.ty;
          var rtx = t.a * or + t.c * ot + t.tx;
          var rty = t.b * or + t.d * ot + t.ty;
          var minX = Math.min(lbx, rbx, ltx, rtx);
          var maxX = Math.max(lbx, rbx, ltx, rtx);
          var minY = Math.min(lby, rby, lty, rty);
          var maxY = Math.max(lby, rby, lty, rty);
          out.x = minX;
          out.y = minY;
          out.width = maxX - minX;
          out.height = maxY - minY;
        };

        AffineTransform.transformObb = function transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
          var tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx;
          var ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty;
          var xa = anAffineTransform.a * rect.width;
          var xb = anAffineTransform.b * rect.width;
          var yc = anAffineTransform.c * rect.height;
          var yd = anAffineTransform.d * rect.height;
          out_tl.x = tx;
          out_tl.y = ty;
          out_tr.x = xa + tx;
          out_tr.y = xb + ty;
          out_bl.x = yc + tx;
          out_bl.y = yd + ty;
          out_br.x = xa + yc + tx;
          out_br.y = xb + yd + ty;
        };

        function AffineTransform(a, b, c, d, tx, ty) {
          if (a === void 0) {
            a = 1;
          }

          if (b === void 0) {
            b = 0;
          }

          if (c === void 0) {
            c = 0;
          }

          if (d === void 0) {
            d = 1;
          }

          if (tx === void 0) {
            tx = 0;
          }

          if (ty === void 0) {
            ty = 0;
          }

          this.a = a;
          this.b = b;
          this.c = c;
          this.d = d;
          this.tx = tx;
          this.ty = ty;
        }

        return AffineTransform;
      }());
      legacyCC.AffineTransform = AffineTransform;

      var Size = exports('Size', function (_ValueType) {
        _inheritsLoose(Size, _ValueType);

        Size.lerp = function lerp(out, from, to, ratio) {
          out.width = from.width + (to.width - from.width) * ratio;
          out.height = from.height + (to.height - from.height) * ratio;
          return out;
        };

        function Size(width, height) {
          var _this;

          _this = _ValueType.call(this) || this;

          if (width && typeof width === 'object') {
            _this.width = width.width;
            _this.height = width.height;
          } else {
            _this.width = width || 0;
            _this.height = height || 0;
          }

          return _this;
        }

        var _proto = Size.prototype;

        _proto.clone = function clone() {
          return new Size(this.width, this.height);
        };

        _proto.set = function set(width, height) {
          if (width && typeof width === 'object') {
            this.height = width.height;
            this.width = width.width;
          } else {
            this.width = width || 0;
            this.height = height || 0;
          }

          return this;
        };

        _proto.equals = function equals(other) {
          return this.width === other.width && this.height === other.height;
        };

        _proto.lerp = function lerp(to, ratio) {
          this.width += (to.width - this.width) * ratio;
          this.height += (to.height - this.height) * ratio;
          return this;
        };

        _proto.toString = function toString() {
          return "(" + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
        };

        _createClass(Size, [{
          key: "x",
          get: function get() {
            return this.width;
          },
          set: function set(val) {
            this.width = val;
          }
        }, {
          key: "y",
          get: function get() {
            return this.height;
          },
          set: function set(val) {
            this.height = val;
          }
        }]);

        return Size;
      }(ValueType));
      Size.ZERO = Object.freeze(new Size(0, 0));
      Size.ONE = Object.freeze(new Size(1, 1));
      CCClass.fastDefine('cc.Size', Size, {
        width: 0,
        height: 0
      });
      function size(width, height) {
        if (width === void 0) {
          width = 0;
        }

        if (height === void 0) {
          height = 0;
        }

        return new Size(width, height);
      }
      legacyCC.size = size;
      legacyCC.Size = Size;

      var Rect = exports('Rect', function (_ValueType) {
        _inheritsLoose(Rect, _ValueType);

        Rect.fromMinMax = function fromMinMax(out, v1, v2) {
          var minX = Math.min(v1.x, v2.x);
          var minY = Math.min(v1.y, v2.y);
          var maxX = Math.max(v1.x, v2.x);
          var maxY = Math.max(v1.y, v2.y);
          out.x = minX;
          out.y = minY;
          out.width = maxX - minX;
          out.height = maxY - minY;
          return out;
        };

        Rect.lerp = function lerp(out, from, to, ratio) {
          var x = from.x;
          var y = from.y;
          var w = from.width;
          var h = from.height;
          out.x = x + (to.x - x) * ratio;
          out.y = y + (to.y - y) * ratio;
          out.width = w + (to.width - w) * ratio;
          out.height = h + (to.height - h) * ratio;
          return out;
        };

        Rect.intersection = function intersection(out, one, other) {
          var axMin = one.x;
          var ayMin = one.y;
          var axMax = one.x + one.width;
          var ayMax = one.y + one.height;
          var bxMin = other.x;
          var byMin = other.y;
          var bxMax = other.x + other.width;
          var byMax = other.y + other.height;
          out.x = Math.max(axMin, bxMin);
          out.y = Math.max(ayMin, byMin);
          out.width = Math.min(axMax, bxMax) - out.x;
          out.height = Math.min(ayMax, byMax) - out.y;
          return out;
        };

        Rect.union = function union(out, one, other) {
          var x = one.x;
          var y = one.y;
          var w = one.width;
          var h = one.height;
          var bx = other.x;
          var by = other.y;
          var bw = other.width;
          var bh = other.height;
          out.x = Math.min(x, bx);
          out.y = Math.min(y, by);
          out.width = Math.max(x + w, bx + bw) - out.x;
          out.height = Math.max(y + h, by + bh) - out.y;
          return out;
        };

        function Rect(x, y, width, height) {
          var _this;

          _this = _ValueType.call(this) || this;

          if (x && typeof x === 'object') {
            _this.y = x.y;
            _this.width = x.width;
            _this.height = x.height;
            _this.x = x.x;
          } else {
            _this.x = x || 0;
            _this.y = y || 0;
            _this.width = width || 0;
            _this.height = height || 0;
          }

          return _this;
        }

        var _proto = Rect.prototype;

        _proto.clone = function clone() {
          return new Rect(this.x, this.y, this.width, this.height);
        };

        _proto.set = function set(x, y, width, height) {
          if (x && typeof x === 'object') {
            this.y = x.y;
            this.width = x.width;
            this.height = x.height;
            this.x = x.x;
          } else {
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
          }

          return this;
        };

        _proto.equals = function equals(other) {
          return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
        };

        _proto.lerp = function lerp(to, ratio) {
          var x = this.x;
          var y = this.y;
          var w = this.width;
          var h = this.height;
          this.x = x + (to.x - x) * ratio;
          this.y = y + (to.y - y) * ratio;
          this.width = w + (to.width - w) * ratio;
          this.height = h + (to.height - h) * ratio;
          return this;
        };

        _proto.toString = function toString() {
          return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
        };

        _proto.intersects = function intersects(other) {
          var maxax = this.x + this.width;
          var maxay = this.y + this.height;
          var maxbx = other.x + other.width;
          var maxby = other.y + other.height;
          return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
        };

        _proto.contains = function contains(point) {
          return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
        };

        _proto.containsRect = function containsRect(other) {
          return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
        };

        _proto.transformMat4 = function transformMat4(mat) {
          var ol = this.x;
          var ob = this.y;
          var or = ol + this.width;
          var ot = ob + this.height;
          var lbx = mat.m00 * ol + mat.m04 * ob + mat.m12;
          var lby = mat.m01 * ol + mat.m05 * ob + mat.m13;
          var rbx = mat.m00 * or + mat.m04 * ob + mat.m12;
          var rby = mat.m01 * or + mat.m05 * ob + mat.m13;
          var ltx = mat.m00 * ol + mat.m04 * ot + mat.m12;
          var lty = mat.m01 * ol + mat.m05 * ot + mat.m13;
          var rtx = mat.m00 * or + mat.m04 * ot + mat.m12;
          var rty = mat.m01 * or + mat.m05 * ot + mat.m13;
          var minX = Math.min(lbx, rbx, ltx, rtx);
          var maxX = Math.max(lbx, rbx, ltx, rtx);
          var minY = Math.min(lby, rby, lty, rty);
          var maxY = Math.max(lby, rby, lty, rty);
          this.x = minX;
          this.y = minY;
          this.width = maxX - minX;
          this.height = maxY - minY;
          return this;
        };

        _proto.transformMat4ToPoints = function transformMat4ToPoints(mat, out_lb, out_lt, out_rt, out_rb) {
          var ol = this.x;
          var ob = this.y;
          var or = ol + this.width;
          var ot = ob + this.height;
          out_lb.x = mat.m00 * ol + mat.m04 * ob + mat.m12;
          out_lb.y = mat.m01 * ol + mat.m05 * ob + mat.m13;
          out_rb.x = mat.m00 * or + mat.m04 * ob + mat.m12;
          out_rb.y = mat.m01 * or + mat.m05 * ob + mat.m13;
          out_lt.x = mat.m00 * ol + mat.m04 * ot + mat.m12;
          out_lt.y = mat.m01 * ol + mat.m05 * ot + mat.m13;
          out_rt.x = mat.m00 * or + mat.m04 * ot + mat.m12;
          out_rt.y = mat.m01 * or + mat.m05 * ot + mat.m13;
        };

        _createClass(Rect, [{
          key: "xMin",
          get: function get() {
            return this.x;
          },
          set: function set(value) {
            this.width += this.x - value;
            this.x = value;
          }
        }, {
          key: "yMin",
          get: function get() {
            return this.y;
          },
          set: function set(value) {
            this.height += this.y - value;
            this.y = value;
          }
        }, {
          key: "xMax",
          get: function get() {
            return this.x + this.width;
          },
          set: function set(value) {
            this.width = value - this.x;
          }
        }, {
          key: "yMax",
          get: function get() {
            return this.y + this.height;
          },
          set: function set(value) {
            this.height = value - this.y;
          }
        }, {
          key: "center",
          get: function get() {
            return new Vec2(this.x + this.width * 0.5, this.y + this.height * 0.5);
          },
          set: function set(value) {
            this.x = value.x - this.width * 0.5;
            this.y = value.y - this.height * 0.5;
          }
        }, {
          key: "origin",
          get: function get() {
            return new Vec2(this.x, this.y);
          },
          set: function set(value) {
            this.x = value.x;
            this.y = value.y;
          }
        }, {
          key: "size",
          get: function get() {
            return new Size(this.width, this.height);
          },
          set: function set(value) {
            this.width = value.width;
            this.height = value.height;
          }
        }, {
          key: "z",
          get: function get() {
            return this.width;
          },
          set: function set(val) {
            this.width = val;
          }
        }, {
          key: "w",
          get: function get() {
            return this.height;
          },
          set: function set(val) {
            this.height = val;
          }
        }]);

        return Rect;
      }(ValueType));
      CCClass.fastDefine('cc.Rect', Rect, {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      });
      legacyCC.Rect = Rect;
      function rect(x, y, width, height) {
        if (x === void 0) {
          x = 0;
        }

        if (y === void 0) {
          y = 0;
        }

        if (width === void 0) {
          width = 0;
        }

        if (height === void 0) {
          height = 0;
        }

        return new Rect(x, y, width, height);
      }
      legacyCC.rect = rect;

      var MATH_FLOAT_ARRAY = exports('MATH_FLOAT_ARRAY',  Float64Array);
      var MathBase = exports('MathBase', function (_ValueType) {
        _inheritsLoose(MathBase, _ValueType);

        function MathBase() {
          return _ValueType.apply(this, arguments) || this;
        }

        MathBase.createFloatArray = function createFloatArray(size) {
          return new MATH_FLOAT_ARRAY(size);
        };

        _createClass(MathBase, [{
          key: "array",
          get: function get() {
            return this._array;
          }
        }]);

        return MathBase;
      }(ValueType));

      var math = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bits: bits,
        Vec2: Vec2,
        v2: v2,
        Vec3: Vec3,
        v3: v3,
        Vec4: Vec4,
        v4: v4,
        Quat: Quat,
        quat: quat,
        Mat3: Mat3,
        Mat4: Mat4,
        mat4: mat4,
        AffineTransform: AffineTransform,
        Size: Size,
        size: size,
        Rect: Rect,
        rect: rect,
        Color: Color,
        color: color,
        EPSILON: EPSILON,
        equals: equals,
        approx: approx,
        clamp: clamp,
        clamp01: clamp01,
        lerp: lerp,
        toRadian: toRadian,
        toDegree: toDegree,
        random: random,
        randomRange: randomRange,
        randomRangeInt: randomRangeInt,
        pseudoRandom: pseudoRandom,
        pseudoRandomRange: pseudoRandomRange,
        pseudoRandomRangeInt: pseudoRandomRangeInt,
        nextPow2: nextPow2$1,
        repeat: repeat,
        pingPong: pingPong,
        inverseLerp: inverseLerp,
        absMaxComponent: absMaxComponent,
        absMax: absMax,
        enumerableProps: enumerableProps,
        MATH_FLOAT_ARRAY: MATH_FLOAT_ARRAY,
        MathBase: MathBase
      });
      exports('math', math);

      var X = new Vec3();
      var Y = new Vec3();
      var Z = new Vec3();
      var d = new Vec3();
      var min$1 = new Vec3();
      var max$1 = new Vec3();
      var u = new Array(3);
      var e = new Array(3);
      function point_plane(point, plane_) {
        return Vec3.dot(plane_.n, point) - plane_.d;
      }
      function pt_point_plane(out, point, plane_) {
        var t = point_plane(point, plane_);
        return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
      }
      function pt_point_aabb(out, point, aabb_) {
        Vec3.copy(out, point);
        Vec3.subtract(min$1, aabb_.center, aabb_.halfExtents);
        Vec3.add(max$1, aabb_.center, aabb_.halfExtents);
        out.x = out.x < min$1.x ? min$1.x : out.x;
        out.y = out.y < min$1.y ? min$1.y : out.y;
        out.z = out.z < min$1.z ? min$1.z : out.z;
        out.x = out.x > max$1.x ? max$1.x : out.x;
        out.y = out.y > max$1.y ? max$1.y : out.y;
        out.z = out.z > max$1.z ? max$1.z : out.z;
        return out;
      }
      function pt_point_obb(out, point, obb_) {
        Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02);
        Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05);
        Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08);
        u[0] = X;
        u[1] = Y;
        u[2] = Z;
        e[0] = obb_.halfExtents.x;
        e[1] = obb_.halfExtents.y;
        e[2] = obb_.halfExtents.z;
        Vec3.subtract(d, point, obb_.center);
        Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);

        for (var i = 0; i < 3; i++) {
          var dist = Vec3.dot(d, u[i]);

          if (dist > e[i]) {
            dist = e[i];
          }

          if (dist < -e[i]) {
            dist = -e[i];
          }

          out.x += dist * u[i].x;
          out.y += dist * u[i].y;
          out.z += dist * u[i].z;
        }

        return out;
      }
      function pt_point_line(out, point, linePointA, linePointB) {
        Vec3.subtract(X, linePointA, linePointB);
        var dir = X;
        var dirSquaredLength = Vec3.lengthSqr(dir);

        if (dirSquaredLength == 0) {
          Vec3.copy(out, linePointA);
        } else {
          Vec3.subtract(X, point, linePointA);
          var t = Vec3.dot(X, dir) / dirSquaredLength;

          if (t < 0) {
            Vec3.copy(out, linePointA);
          } else if (t > 1) {
            Vec3.copy(out, linePointB);
          } else {
            Vec3.scaleAndAdd(out, linePointA, dir, t);
          }
        }
      }

      var distance = /*#__PURE__*/Object.freeze({
        __proto__: null,
        point_plane: point_plane,
        pt_point_plane: pt_point_plane,
        pt_point_aabb: pt_point_aabb,
        pt_point_obb: pt_point_obb,
        pt_point_line: pt_point_line
      });

      var enums = {
        SHAPE_RAY: 1 << 0,
        SHAPE_LINE: 1 << 1,
        SHAPE_SPHERE: 1 << 2,
        SHAPE_AABB: 1 << 3,
        SHAPE_OBB: 1 << 4,
        SHAPE_PLANE: 1 << 5,
        SHAPE_TRIANGLE: 1 << 6,
        SHAPE_FRUSTUM: 1 << 7,
        SHAPE_FRUSTUM_ACCURATE: 1 << 8,
        SHAPE_CAPSULE: 1 << 9
      };

      var Line = function () {
        Line.create = function create(sx, sy, sz, ex, ey, ez) {
          return new Line(sx, sy, sz, ex, ey, ez);
        };

        Line.clone = function clone(a) {
          return new Line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
        };

        Line.copy = function copy(out, a) {
          Vec3.copy(out.s, a.s);
          Vec3.copy(out.e, a.e);
          return out;
        };

        Line.fromPoints = function fromPoints(out, start, end) {
          Vec3.copy(out.s, start);
          Vec3.copy(out.e, end);
          return out;
        };

        Line.set = function set(out, sx, sy, sz, ex, ey, ez) {
          out.s.x = sx;
          out.s.y = sy;
          out.s.z = sz;
          out.e.x = ex;
          out.e.y = ey;
          out.e.z = ez;
          return out;
        };

        Line.len = function len(a) {
          return Vec3.distance(a.s, a.e);
        };

        function Line(sx, sy, sz, ex, ey, ez) {
          if (sx === void 0) {
            sx = 0;
          }

          if (sy === void 0) {
            sy = 0;
          }

          if (sz === void 0) {
            sz = 0;
          }

          if (ex === void 0) {
            ex = 0;
          }

          if (ey === void 0) {
            ey = 0;
          }

          if (ez === void 0) {
            ez = -1;
          }

          this.s = void 0;
          this.e = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_LINE;
          this.s = new Vec3(sx, sy, sz);
          this.e = new Vec3(ex, ey, ez);
        }

        var _proto = Line.prototype;

        _proto.length = function length() {
          return Vec3.distance(this.s, this.e);
        };

        _createClass(Line, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }]);

        return Line;
      }();

      var Ray = function () {
        Ray.create = function create(ox, oy, oz, dx, dy, dz) {
          if (ox === void 0) {
            ox = 0;
          }

          if (oy === void 0) {
            oy = 0;
          }

          if (oz === void 0) {
            oz = 0;
          }

          if (dx === void 0) {
            dx = 0;
          }

          if (dy === void 0) {
            dy = 0;
          }

          if (dz === void 0) {
            dz = 1;
          }

          return new Ray(ox, oy, oz, dx, dy, dz);
        };

        Ray.clone = function clone(a) {
          return new Ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
        };

        Ray.copy = function copy(out, a) {
          Vec3.copy(out.o, a.o);
          Vec3.copy(out.d, a.d);
          return out;
        };

        Ray.fromPoints = function fromPoints(out, origin, target) {
          Vec3.copy(out.o, origin);
          Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin));
          return out;
        };

        Ray.set = function set(out, ox, oy, oz, dx, dy, dz) {
          out.o.x = ox;
          out.o.y = oy;
          out.o.z = oz;
          out.d.x = dx;
          out.d.y = dy;
          out.d.z = dz;
          return out;
        };

        function Ray(ox, oy, oz, dx, dy, dz) {
          if (ox === void 0) {
            ox = 0;
          }

          if (oy === void 0) {
            oy = 0;
          }

          if (oz === void 0) {
            oz = 0;
          }

          if (dx === void 0) {
            dx = 0;
          }

          if (dy === void 0) {
            dy = 0;
          }

          if (dz === void 0) {
            dz = -1;
          }

          this.o = void 0;
          this.d = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_RAY;
          this.o = new Vec3(ox, oy, oz);
          this.d = new Vec3(dx, dy, dz);
        }

        var _proto = Ray.prototype;

        _proto.computeHit = function computeHit(out, distance) {
          Vec3.normalize(out, this.d);
          Vec3.scaleAndAdd(out, this.o, out, distance);
        };

        _createClass(Ray, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }]);

        return Ray;
      }();

      var _v3_tmp = new Vec3();

      var _offset = new Vec3();

      var _min = new Vec3();

      var _max = new Vec3();

      function maxComponent(v) {
        return Math.max(Math.max(v.x, v.y), v.z);
      }

      var Sphere = function () {
        Sphere.create = function create(cx, cy, cz, r) {
          return new Sphere(cx, cy, cz, r);
        };

        Sphere.clone = function clone(p) {
          return new Sphere(p.center.x, p.center.y, p.center.z, p.radius);
        };

        Sphere.copy = function copy(out, p) {
          Vec3.copy(out.center, p.center);
          out.radius = p.radius;
          return out;
        };

        Sphere.fromPoints = function fromPoints(out, minPos, maxPos) {
          Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), 0.5);
          out.radius = Vec3.subtract(_v3_tmp, maxPos, minPos).length() * 0.5;
          return out;
        };

        Sphere.set = function set(out, cx, cy, cz, r) {
          out.center.x = cx;
          out.center.y = cy;
          out.center.z = cz;
          out.radius = r;
          return out;
        };

        function Sphere(cx, cy, cz, r) {
          if (cx === void 0) {
            cx = 0;
          }

          if (cy === void 0) {
            cy = 0;
          }

          if (cz === void 0) {
            cz = 0;
          }

          if (r === void 0) {
            r = 1;
          }

          this._center = new Vec3(0, 0, 0);
          this._radius = 0;
          this._type = void 0;
          this._type = enums.SHAPE_SPHERE;
          this._center = new Vec3(cx, cy, cz);
          this._radius = r;
        }

        var _proto = Sphere.prototype;

        _proto.destroy = function destroy() {};

        _proto.clone = function clone() {
          return Sphere.clone(this);
        };

        _proto.copy = function copy(a) {
          return Sphere.copy(this, a);
        };

        _proto.getBoundary = function getBoundary(minPos, maxPos) {
          Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius);
          Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
        };

        _proto.transform = function transform(m, pos, rot, scale, out) {
          Vec3.transformMat4(out.center, this.center, m);
          out.radius = this.radius * maxComponent(scale);
        };

        _proto.translateAndRotate = function translateAndRotate(m, rot, out) {
          Vec3.transformMat4(out.center, this.center, m);
        };

        _proto.setScale = function setScale(scale, out) {
          out.radius = this.radius * maxComponent(scale);
        };

        _proto.mergePoint = function mergePoint(point) {
          if (this.radius < 0.0) {
            this.center.set(point);
            this.radius = 0.0;
          }

          Vec3.subtract(_offset, point, this.center);

          var dist = _offset.length();

          if (dist > this.radius) {
            var half = (dist - this.radius) * 0.5;
            this.radius += half;
            Vec3.multiplyScalar(_offset, _offset, half / dist);
            Vec3.add(this.center, this.center, _offset);
          }
        };

        _proto.mergePoints = function mergePoints(points) {
          var length = points.length;
          if (length < 1) return;
          this.radius = -1.0;

          for (var i = 0; i < length; i++) {
            this.mergePoint(points[i]);
          }
        };

        _proto.mergeAABB = function mergeAABB(a) {
          a.getBoundary(_min, _max);
          this.mergePoint(_min);
          this.mergePoint(_max);
        };

        _createClass(Sphere, [{
          key: "center",
          get: function get() {
            return this._center;
          },
          set: function set(val) {
            this._center = val;
          }
        }, {
          key: "radius",
          get: function get() {
            return this._radius;
          },
          set: function set(val) {
            this._radius = val;
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          }
        }]);

        return Sphere;
      }();

      var Triangle = function () {
        Triangle.create = function create(ax, ay, az, bx, by, bz, cx, cy, cz) {
          if (ax === void 0) {
            ax = 1;
          }

          if (ay === void 0) {
            ay = 0;
          }

          if (az === void 0) {
            az = 0;
          }

          if (bx === void 0) {
            bx = 0;
          }

          if (by === void 0) {
            by = 0;
          }

          if (bz === void 0) {
            bz = 0;
          }

          if (cx === void 0) {
            cx = 0;
          }

          if (cy === void 0) {
            cy = 0;
          }

          if (cz === void 0) {
            cz = 1;
          }

          return new Triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
        };

        Triangle.clone = function clone(t) {
          return new Triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
        };

        Triangle.copy = function copy(out, t) {
          Vec3.copy(out.a, t.a);
          Vec3.copy(out.b, t.b);
          Vec3.copy(out.c, t.c);
          return out;
        };

        Triangle.fromPoints = function fromPoints(out, a, b, c) {
          Vec3.copy(out.a, a);
          Vec3.copy(out.b, b);
          Vec3.copy(out.c, c);
          return out;
        };

        Triangle.set = function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
          out.a.x = ax;
          out.a.y = ay;
          out.a.z = az;
          out.b.x = bx;
          out.b.y = by;
          out.b.z = bz;
          out.c.x = cx;
          out.c.y = cy;
          out.c.z = cz;
          return out;
        };

        function Triangle(ax, ay, az, bx, by, bz, cx, cy, cz) {
          if (ax === void 0) {
            ax = 0;
          }

          if (ay === void 0) {
            ay = 0;
          }

          if (az === void 0) {
            az = 0;
          }

          if (bx === void 0) {
            bx = 1;
          }

          if (by === void 0) {
            by = 0;
          }

          if (bz === void 0) {
            bz = 0;
          }

          if (cx === void 0) {
            cx = 0;
          }

          if (cy === void 0) {
            cy = 1;
          }

          if (cz === void 0) {
            cz = 0;
          }

          this.a = void 0;
          this.b = void 0;
          this.c = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_TRIANGLE;
          this.a = new Vec3(ax, ay, az);
          this.b = new Vec3(bx, by, bz);
          this.c = new Vec3(cx, cy, cz);
        }

        _createClass(Triangle, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }]);

        return Triangle;
      }();

      var GarbageCollectionManager = function () {
        function GarbageCollectionManager() {
          this._finalizationRegistry =  null;
          this._gcObjects = new WeakMap();
        }

        var _proto = GarbageCollectionManager.prototype;

        _proto.registerGCObject = function registerGCObject(gcObject) {
          {
            return gcObject;
          }
        };

        _proto.init = function init() {};

        _proto.finalizationRegistryCallback = function finalizationRegistryCallback(token) {
          var gcObject = this._gcObjects.get(token);

          if (gcObject) {
            this._gcObjects["delete"](token);

            gcObject.destroy();
          }

          this._finalizationRegistry.unregister(token);
        };

        _proto.destroy = function destroy() {};

        return GarbageCollectionManager;
      }();

      var garbageCollectionManager = new GarbageCollectionManager();

      var GCObject = function () {
        function GCObject() {
          return garbageCollectionManager.registerGCObject(this);
        }

        var _proto = GCObject.prototype;

        _proto.destroy = function destroy() {};

        return GCObject;
      }();

      var deepCopy = function deepCopy(target, source, Ctor) {
        for (var i = 0; i < source.length; ++i) {
          if (target.length <= i) target.push(new Ctor());
          target[i].copy(source[i]);
        }

        target.length = source.length;
      };

      var ObjectType;

      (function (ObjectType) {
        ObjectType[ObjectType["UNKNOWN"] = 0] = "UNKNOWN";
        ObjectType[ObjectType["SWAPCHAIN"] = 1] = "SWAPCHAIN";
        ObjectType[ObjectType["BUFFER"] = 2] = "BUFFER";
        ObjectType[ObjectType["TEXTURE"] = 3] = "TEXTURE";
        ObjectType[ObjectType["RENDER_PASS"] = 4] = "RENDER_PASS";
        ObjectType[ObjectType["FRAMEBUFFER"] = 5] = "FRAMEBUFFER";
        ObjectType[ObjectType["SAMPLER"] = 6] = "SAMPLER";
        ObjectType[ObjectType["SHADER"] = 7] = "SHADER";
        ObjectType[ObjectType["DESCRIPTOR_SET_LAYOUT"] = 8] = "DESCRIPTOR_SET_LAYOUT";
        ObjectType[ObjectType["PIPELINE_LAYOUT"] = 9] = "PIPELINE_LAYOUT";
        ObjectType[ObjectType["PIPELINE_STATE"] = 10] = "PIPELINE_STATE";
        ObjectType[ObjectType["DESCRIPTOR_SET"] = 11] = "DESCRIPTOR_SET";
        ObjectType[ObjectType["INPUT_ASSEMBLER"] = 12] = "INPUT_ASSEMBLER";
        ObjectType[ObjectType["COMMAND_BUFFER"] = 13] = "COMMAND_BUFFER";
        ObjectType[ObjectType["QUEUE"] = 14] = "QUEUE";
        ObjectType[ObjectType["QUERY_POOL"] = 15] = "QUERY_POOL";
        ObjectType[ObjectType["GLOBAL_BARRIER"] = 16] = "GLOBAL_BARRIER";
        ObjectType[ObjectType["TEXTURE_BARRIER"] = 17] = "TEXTURE_BARRIER";
        ObjectType[ObjectType["BUFFER_BARRIER"] = 18] = "BUFFER_BARRIER";
        ObjectType[ObjectType["COUNT"] = 19] = "COUNT";
      })(ObjectType || (ObjectType = {}));

      var Status;

      (function (Status) {
        Status[Status["UNREADY"] = 0] = "UNREADY";
        Status[Status["FAILED"] = 1] = "FAILED";
        Status[Status["SUCCESS"] = 2] = "SUCCESS";
      })(Status || (Status = {}));

      var API;

      (function (API) {
        API[API["UNKNOWN"] = 0] = "UNKNOWN";
        API[API["GLES2"] = 1] = "GLES2";
        API[API["GLES3"] = 2] = "GLES3";
        API[API["METAL"] = 3] = "METAL";
        API[API["VULKAN"] = 4] = "VULKAN";
        API[API["NVN"] = 5] = "NVN";
        API[API["WEBGL"] = 6] = "WEBGL";
        API[API["WEBGL2"] = 7] = "WEBGL2";
        API[API["WEBGPU"] = 8] = "WEBGPU";
      })(API || (API = {}));

      var SurfaceTransform;

      (function (SurfaceTransform) {
        SurfaceTransform[SurfaceTransform["IDENTITY"] = 0] = "IDENTITY";
        SurfaceTransform[SurfaceTransform["ROTATE_90"] = 1] = "ROTATE_90";
        SurfaceTransform[SurfaceTransform["ROTATE_180"] = 2] = "ROTATE_180";
        SurfaceTransform[SurfaceTransform["ROTATE_270"] = 3] = "ROTATE_270";
      })(SurfaceTransform || (SurfaceTransform = {}));

      var Feature;

      (function (Feature) {
        Feature[Feature["ELEMENT_INDEX_UINT"] = 0] = "ELEMENT_INDEX_UINT";
        Feature[Feature["INSTANCED_ARRAYS"] = 1] = "INSTANCED_ARRAYS";
        Feature[Feature["MULTIPLE_RENDER_TARGETS"] = 2] = "MULTIPLE_RENDER_TARGETS";
        Feature[Feature["BLEND_MINMAX"] = 3] = "BLEND_MINMAX";
        Feature[Feature["COMPUTE_SHADER"] = 4] = "COMPUTE_SHADER";
        Feature[Feature["INPUT_ATTACHMENT_BENEFIT"] = 5] = "INPUT_ATTACHMENT_BENEFIT";
        Feature[Feature["COUNT"] = 6] = "COUNT";
      })(Feature || (Feature = {}));

      var Format;

      (function (Format) {
        Format[Format["UNKNOWN"] = 0] = "UNKNOWN";
        Format[Format["A8"] = 1] = "A8";
        Format[Format["L8"] = 2] = "L8";
        Format[Format["LA8"] = 3] = "LA8";
        Format[Format["R8"] = 4] = "R8";
        Format[Format["R8SN"] = 5] = "R8SN";
        Format[Format["R8UI"] = 6] = "R8UI";
        Format[Format["R8I"] = 7] = "R8I";
        Format[Format["R16F"] = 8] = "R16F";
        Format[Format["R16UI"] = 9] = "R16UI";
        Format[Format["R16I"] = 10] = "R16I";
        Format[Format["R32F"] = 11] = "R32F";
        Format[Format["R32UI"] = 12] = "R32UI";
        Format[Format["R32I"] = 13] = "R32I";
        Format[Format["RG8"] = 14] = "RG8";
        Format[Format["RG8SN"] = 15] = "RG8SN";
        Format[Format["RG8UI"] = 16] = "RG8UI";
        Format[Format["RG8I"] = 17] = "RG8I";
        Format[Format["RG16F"] = 18] = "RG16F";
        Format[Format["RG16UI"] = 19] = "RG16UI";
        Format[Format["RG16I"] = 20] = "RG16I";
        Format[Format["RG32F"] = 21] = "RG32F";
        Format[Format["RG32UI"] = 22] = "RG32UI";
        Format[Format["RG32I"] = 23] = "RG32I";
        Format[Format["RGB8"] = 24] = "RGB8";
        Format[Format["SRGB8"] = 25] = "SRGB8";
        Format[Format["RGB8SN"] = 26] = "RGB8SN";
        Format[Format["RGB8UI"] = 27] = "RGB8UI";
        Format[Format["RGB8I"] = 28] = "RGB8I";
        Format[Format["RGB16F"] = 29] = "RGB16F";
        Format[Format["RGB16UI"] = 30] = "RGB16UI";
        Format[Format["RGB16I"] = 31] = "RGB16I";
        Format[Format["RGB32F"] = 32] = "RGB32F";
        Format[Format["RGB32UI"] = 33] = "RGB32UI";
        Format[Format["RGB32I"] = 34] = "RGB32I";
        Format[Format["RGBA8"] = 35] = "RGBA8";
        Format[Format["BGRA8"] = 36] = "BGRA8";
        Format[Format["SRGB8_A8"] = 37] = "SRGB8_A8";
        Format[Format["RGBA8SN"] = 38] = "RGBA8SN";
        Format[Format["RGBA8UI"] = 39] = "RGBA8UI";
        Format[Format["RGBA8I"] = 40] = "RGBA8I";
        Format[Format["RGBA16F"] = 41] = "RGBA16F";
        Format[Format["RGBA16UI"] = 42] = "RGBA16UI";
        Format[Format["RGBA16I"] = 43] = "RGBA16I";
        Format[Format["RGBA32F"] = 44] = "RGBA32F";
        Format[Format["RGBA32UI"] = 45] = "RGBA32UI";
        Format[Format["RGBA32I"] = 46] = "RGBA32I";
        Format[Format["R5G6B5"] = 47] = "R5G6B5";
        Format[Format["R11G11B10F"] = 48] = "R11G11B10F";
        Format[Format["RGB5A1"] = 49] = "RGB5A1";
        Format[Format["RGBA4"] = 50] = "RGBA4";
        Format[Format["RGB10A2"] = 51] = "RGB10A2";
        Format[Format["RGB10A2UI"] = 52] = "RGB10A2UI";
        Format[Format["RGB9E5"] = 53] = "RGB9E5";
        Format[Format["DEPTH"] = 54] = "DEPTH";
        Format[Format["DEPTH_STENCIL"] = 55] = "DEPTH_STENCIL";
        Format[Format["BC1"] = 56] = "BC1";
        Format[Format["BC1_ALPHA"] = 57] = "BC1_ALPHA";
        Format[Format["BC1_SRGB"] = 58] = "BC1_SRGB";
        Format[Format["BC1_SRGB_ALPHA"] = 59] = "BC1_SRGB_ALPHA";
        Format[Format["BC2"] = 60] = "BC2";
        Format[Format["BC2_SRGB"] = 61] = "BC2_SRGB";
        Format[Format["BC3"] = 62] = "BC3";
        Format[Format["BC3_SRGB"] = 63] = "BC3_SRGB";
        Format[Format["BC4"] = 64] = "BC4";
        Format[Format["BC4_SNORM"] = 65] = "BC4_SNORM";
        Format[Format["BC5"] = 66] = "BC5";
        Format[Format["BC5_SNORM"] = 67] = "BC5_SNORM";
        Format[Format["BC6H_UF16"] = 68] = "BC6H_UF16";
        Format[Format["BC6H_SF16"] = 69] = "BC6H_SF16";
        Format[Format["BC7"] = 70] = "BC7";
        Format[Format["BC7_SRGB"] = 71] = "BC7_SRGB";
        Format[Format["ETC_RGB8"] = 72] = "ETC_RGB8";
        Format[Format["ETC2_RGB8"] = 73] = "ETC2_RGB8";
        Format[Format["ETC2_SRGB8"] = 74] = "ETC2_SRGB8";
        Format[Format["ETC2_RGB8_A1"] = 75] = "ETC2_RGB8_A1";
        Format[Format["ETC2_SRGB8_A1"] = 76] = "ETC2_SRGB8_A1";
        Format[Format["ETC2_RGBA8"] = 77] = "ETC2_RGBA8";
        Format[Format["ETC2_SRGB8_A8"] = 78] = "ETC2_SRGB8_A8";
        Format[Format["EAC_R11"] = 79] = "EAC_R11";
        Format[Format["EAC_R11SN"] = 80] = "EAC_R11SN";
        Format[Format["EAC_RG11"] = 81] = "EAC_RG11";
        Format[Format["EAC_RG11SN"] = 82] = "EAC_RG11SN";
        Format[Format["PVRTC_RGB2"] = 83] = "PVRTC_RGB2";
        Format[Format["PVRTC_RGBA2"] = 84] = "PVRTC_RGBA2";
        Format[Format["PVRTC_RGB4"] = 85] = "PVRTC_RGB4";
        Format[Format["PVRTC_RGBA4"] = 86] = "PVRTC_RGBA4";
        Format[Format["PVRTC2_2BPP"] = 87] = "PVRTC2_2BPP";
        Format[Format["PVRTC2_4BPP"] = 88] = "PVRTC2_4BPP";
        Format[Format["ASTC_RGBA_4X4"] = 89] = "ASTC_RGBA_4X4";
        Format[Format["ASTC_RGBA_5X4"] = 90] = "ASTC_RGBA_5X4";
        Format[Format["ASTC_RGBA_5X5"] = 91] = "ASTC_RGBA_5X5";
        Format[Format["ASTC_RGBA_6X5"] = 92] = "ASTC_RGBA_6X5";
        Format[Format["ASTC_RGBA_6X6"] = 93] = "ASTC_RGBA_6X6";
        Format[Format["ASTC_RGBA_8X5"] = 94] = "ASTC_RGBA_8X5";
        Format[Format["ASTC_RGBA_8X6"] = 95] = "ASTC_RGBA_8X6";
        Format[Format["ASTC_RGBA_8X8"] = 96] = "ASTC_RGBA_8X8";
        Format[Format["ASTC_RGBA_10X5"] = 97] = "ASTC_RGBA_10X5";
        Format[Format["ASTC_RGBA_10X6"] = 98] = "ASTC_RGBA_10X6";
        Format[Format["ASTC_RGBA_10X8"] = 99] = "ASTC_RGBA_10X8";
        Format[Format["ASTC_RGBA_10X10"] = 100] = "ASTC_RGBA_10X10";
        Format[Format["ASTC_RGBA_12X10"] = 101] = "ASTC_RGBA_12X10";
        Format[Format["ASTC_RGBA_12X12"] = 102] = "ASTC_RGBA_12X12";
        Format[Format["ASTC_SRGBA_4X4"] = 103] = "ASTC_SRGBA_4X4";
        Format[Format["ASTC_SRGBA_5X4"] = 104] = "ASTC_SRGBA_5X4";
        Format[Format["ASTC_SRGBA_5X5"] = 105] = "ASTC_SRGBA_5X5";
        Format[Format["ASTC_SRGBA_6X5"] = 106] = "ASTC_SRGBA_6X5";
        Format[Format["ASTC_SRGBA_6X6"] = 107] = "ASTC_SRGBA_6X6";
        Format[Format["ASTC_SRGBA_8X5"] = 108] = "ASTC_SRGBA_8X5";
        Format[Format["ASTC_SRGBA_8X6"] = 109] = "ASTC_SRGBA_8X6";
        Format[Format["ASTC_SRGBA_8X8"] = 110] = "ASTC_SRGBA_8X8";
        Format[Format["ASTC_SRGBA_10X5"] = 111] = "ASTC_SRGBA_10X5";
        Format[Format["ASTC_SRGBA_10X6"] = 112] = "ASTC_SRGBA_10X6";
        Format[Format["ASTC_SRGBA_10X8"] = 113] = "ASTC_SRGBA_10X8";
        Format[Format["ASTC_SRGBA_10X10"] = 114] = "ASTC_SRGBA_10X10";
        Format[Format["ASTC_SRGBA_12X10"] = 115] = "ASTC_SRGBA_12X10";
        Format[Format["ASTC_SRGBA_12X12"] = 116] = "ASTC_SRGBA_12X12";
        Format[Format["COUNT"] = 117] = "COUNT";
      })(Format || (Format = {}));

      var FormatType;

      (function (FormatType) {
        FormatType[FormatType["NONE"] = 0] = "NONE";
        FormatType[FormatType["UNORM"] = 1] = "UNORM";
        FormatType[FormatType["SNORM"] = 2] = "SNORM";
        FormatType[FormatType["UINT"] = 3] = "UINT";
        FormatType[FormatType["INT"] = 4] = "INT";
        FormatType[FormatType["UFLOAT"] = 5] = "UFLOAT";
        FormatType[FormatType["FLOAT"] = 6] = "FLOAT";
      })(FormatType || (FormatType = {}));

      var Type;

      (function (Type) {
        Type[Type["UNKNOWN"] = 0] = "UNKNOWN";
        Type[Type["BOOL"] = 1] = "BOOL";
        Type[Type["BOOL2"] = 2] = "BOOL2";
        Type[Type["BOOL3"] = 3] = "BOOL3";
        Type[Type["BOOL4"] = 4] = "BOOL4";
        Type[Type["INT"] = 5] = "INT";
        Type[Type["INT2"] = 6] = "INT2";
        Type[Type["INT3"] = 7] = "INT3";
        Type[Type["INT4"] = 8] = "INT4";
        Type[Type["UINT"] = 9] = "UINT";
        Type[Type["UINT2"] = 10] = "UINT2";
        Type[Type["UINT3"] = 11] = "UINT3";
        Type[Type["UINT4"] = 12] = "UINT4";
        Type[Type["FLOAT"] = 13] = "FLOAT";
        Type[Type["FLOAT2"] = 14] = "FLOAT2";
        Type[Type["FLOAT3"] = 15] = "FLOAT3";
        Type[Type["FLOAT4"] = 16] = "FLOAT4";
        Type[Type["MAT2"] = 17] = "MAT2";
        Type[Type["MAT2X3"] = 18] = "MAT2X3";
        Type[Type["MAT2X4"] = 19] = "MAT2X4";
        Type[Type["MAT3X2"] = 20] = "MAT3X2";
        Type[Type["MAT3"] = 21] = "MAT3";
        Type[Type["MAT3X4"] = 22] = "MAT3X4";
        Type[Type["MAT4X2"] = 23] = "MAT4X2";
        Type[Type["MAT4X3"] = 24] = "MAT4X3";
        Type[Type["MAT4"] = 25] = "MAT4";
        Type[Type["SAMPLER1D"] = 26] = "SAMPLER1D";
        Type[Type["SAMPLER1D_ARRAY"] = 27] = "SAMPLER1D_ARRAY";
        Type[Type["SAMPLER2D"] = 28] = "SAMPLER2D";
        Type[Type["SAMPLER2D_ARRAY"] = 29] = "SAMPLER2D_ARRAY";
        Type[Type["SAMPLER3D"] = 30] = "SAMPLER3D";
        Type[Type["SAMPLER_CUBE"] = 31] = "SAMPLER_CUBE";
        Type[Type["SAMPLER"] = 32] = "SAMPLER";
        Type[Type["TEXTURE1D"] = 33] = "TEXTURE1D";
        Type[Type["TEXTURE1D_ARRAY"] = 34] = "TEXTURE1D_ARRAY";
        Type[Type["TEXTURE2D"] = 35] = "TEXTURE2D";
        Type[Type["TEXTURE2D_ARRAY"] = 36] = "TEXTURE2D_ARRAY";
        Type[Type["TEXTURE3D"] = 37] = "TEXTURE3D";
        Type[Type["TEXTURE_CUBE"] = 38] = "TEXTURE_CUBE";
        Type[Type["IMAGE1D"] = 39] = "IMAGE1D";
        Type[Type["IMAGE1D_ARRAY"] = 40] = "IMAGE1D_ARRAY";
        Type[Type["IMAGE2D"] = 41] = "IMAGE2D";
        Type[Type["IMAGE2D_ARRAY"] = 42] = "IMAGE2D_ARRAY";
        Type[Type["IMAGE3D"] = 43] = "IMAGE3D";
        Type[Type["IMAGE_CUBE"] = 44] = "IMAGE_CUBE";
        Type[Type["SUBPASS_INPUT"] = 45] = "SUBPASS_INPUT";
        Type[Type["COUNT"] = 46] = "COUNT";
      })(Type || (Type = {}));

      var BufferUsageBit;

      (function (BufferUsageBit) {
        BufferUsageBit[BufferUsageBit["NONE"] = 0] = "NONE";
        BufferUsageBit[BufferUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
        BufferUsageBit[BufferUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
        BufferUsageBit[BufferUsageBit["INDEX"] = 4] = "INDEX";
        BufferUsageBit[BufferUsageBit["VERTEX"] = 8] = "VERTEX";
        BufferUsageBit[BufferUsageBit["UNIFORM"] = 16] = "UNIFORM";
        BufferUsageBit[BufferUsageBit["STORAGE"] = 32] = "STORAGE";
        BufferUsageBit[BufferUsageBit["INDIRECT"] = 64] = "INDIRECT";
      })(BufferUsageBit || (BufferUsageBit = {}));

      var BufferFlagBit;

      (function (BufferFlagBit) {
        BufferFlagBit[BufferFlagBit["NONE"] = 0] = "NONE";
      })(BufferFlagBit || (BufferFlagBit = {}));

      var MemoryAccessBit;

      (function (MemoryAccessBit) {
        MemoryAccessBit[MemoryAccessBit["NONE"] = 0] = "NONE";
        MemoryAccessBit[MemoryAccessBit["READ_ONLY"] = 1] = "READ_ONLY";
        MemoryAccessBit[MemoryAccessBit["WRITE_ONLY"] = 2] = "WRITE_ONLY";
        MemoryAccessBit[MemoryAccessBit["READ_WRITE"] = 3] = "READ_WRITE";
      })(MemoryAccessBit || (MemoryAccessBit = {}));

      var MemoryUsageBit;

      (function (MemoryUsageBit) {
        MemoryUsageBit[MemoryUsageBit["NONE"] = 0] = "NONE";
        MemoryUsageBit[MemoryUsageBit["DEVICE"] = 1] = "DEVICE";
        MemoryUsageBit[MemoryUsageBit["HOST"] = 2] = "HOST";
      })(MemoryUsageBit || (MemoryUsageBit = {}));

      var TextureType;

      (function (TextureType) {
        TextureType[TextureType["TEX1D"] = 0] = "TEX1D";
        TextureType[TextureType["TEX2D"] = 1] = "TEX2D";
        TextureType[TextureType["TEX3D"] = 2] = "TEX3D";
        TextureType[TextureType["CUBE"] = 3] = "CUBE";
        TextureType[TextureType["TEX1D_ARRAY"] = 4] = "TEX1D_ARRAY";
        TextureType[TextureType["TEX2D_ARRAY"] = 5] = "TEX2D_ARRAY";
      })(TextureType || (TextureType = {}));

      var TextureUsageBit;

      (function (TextureUsageBit) {
        TextureUsageBit[TextureUsageBit["NONE"] = 0] = "NONE";
        TextureUsageBit[TextureUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
        TextureUsageBit[TextureUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
        TextureUsageBit[TextureUsageBit["SAMPLED"] = 4] = "SAMPLED";
        TextureUsageBit[TextureUsageBit["STORAGE"] = 8] = "STORAGE";
        TextureUsageBit[TextureUsageBit["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
        TextureUsageBit[TextureUsageBit["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
        TextureUsageBit[TextureUsageBit["INPUT_ATTACHMENT"] = 64] = "INPUT_ATTACHMENT";
      })(TextureUsageBit || (TextureUsageBit = {}));

      var TextureFlagBit;

      (function (TextureFlagBit) {
        TextureFlagBit[TextureFlagBit["NONE"] = 0] = "NONE";
        TextureFlagBit[TextureFlagBit["GEN_MIPMAP"] = 1] = "GEN_MIPMAP";
        TextureFlagBit[TextureFlagBit["GENERAL_LAYOUT"] = 2] = "GENERAL_LAYOUT";
      })(TextureFlagBit || (TextureFlagBit = {}));

      var FormatFeatureBit;

      (function (FormatFeatureBit) {
        FormatFeatureBit[FormatFeatureBit["NONE"] = 0] = "NONE";
        FormatFeatureBit[FormatFeatureBit["RENDER_TARGET"] = 1] = "RENDER_TARGET";
        FormatFeatureBit[FormatFeatureBit["SAMPLED_TEXTURE"] = 2] = "SAMPLED_TEXTURE";
        FormatFeatureBit[FormatFeatureBit["LINEAR_FILTER"] = 4] = "LINEAR_FILTER";
        FormatFeatureBit[FormatFeatureBit["STORAGE_TEXTURE"] = 8] = "STORAGE_TEXTURE";
        FormatFeatureBit[FormatFeatureBit["VERTEX_ATTRIBUTE"] = 16] = "VERTEX_ATTRIBUTE";
      })(FormatFeatureBit || (FormatFeatureBit = {}));

      var SampleCount;

      (function (SampleCount) {
        SampleCount[SampleCount["ONE"] = 0] = "ONE";
        SampleCount[SampleCount["MULTIPLE_PERFORMANCE"] = 1] = "MULTIPLE_PERFORMANCE";
        SampleCount[SampleCount["MULTIPLE_BALANCE"] = 2] = "MULTIPLE_BALANCE";
        SampleCount[SampleCount["MULTIPLE_QUALITY"] = 3] = "MULTIPLE_QUALITY";
      })(SampleCount || (SampleCount = {}));

      var VsyncMode;

      (function (VsyncMode) {
        VsyncMode[VsyncMode["OFF"] = 0] = "OFF";
        VsyncMode[VsyncMode["ON"] = 1] = "ON";
        VsyncMode[VsyncMode["RELAXED"] = 2] = "RELAXED";
        VsyncMode[VsyncMode["MAILBOX"] = 3] = "MAILBOX";
        VsyncMode[VsyncMode["HALF"] = 4] = "HALF";
      })(VsyncMode || (VsyncMode = {}));

      var Filter;

      (function (Filter) {
        Filter[Filter["NONE"] = 0] = "NONE";
        Filter[Filter["POINT"] = 1] = "POINT";
        Filter[Filter["LINEAR"] = 2] = "LINEAR";
        Filter[Filter["ANISOTROPIC"] = 3] = "ANISOTROPIC";
      })(Filter || (Filter = {}));

      var Address;

      (function (Address) {
        Address[Address["WRAP"] = 0] = "WRAP";
        Address[Address["MIRROR"] = 1] = "MIRROR";
        Address[Address["CLAMP"] = 2] = "CLAMP";
        Address[Address["BORDER"] = 3] = "BORDER";
      })(Address || (Address = {}));

      var ComparisonFunc;

      (function (ComparisonFunc) {
        ComparisonFunc[ComparisonFunc["NEVER"] = 0] = "NEVER";
        ComparisonFunc[ComparisonFunc["LESS"] = 1] = "LESS";
        ComparisonFunc[ComparisonFunc["EQUAL"] = 2] = "EQUAL";
        ComparisonFunc[ComparisonFunc["LESS_EQUAL"] = 3] = "LESS_EQUAL";
        ComparisonFunc[ComparisonFunc["GREATER"] = 4] = "GREATER";
        ComparisonFunc[ComparisonFunc["NOT_EQUAL"] = 5] = "NOT_EQUAL";
        ComparisonFunc[ComparisonFunc["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
        ComparisonFunc[ComparisonFunc["ALWAYS"] = 7] = "ALWAYS";
      })(ComparisonFunc || (ComparisonFunc = {}));

      var StencilOp;

      (function (StencilOp) {
        StencilOp[StencilOp["ZERO"] = 0] = "ZERO";
        StencilOp[StencilOp["KEEP"] = 1] = "KEEP";
        StencilOp[StencilOp["REPLACE"] = 2] = "REPLACE";
        StencilOp[StencilOp["INCR"] = 3] = "INCR";
        StencilOp[StencilOp["DECR"] = 4] = "DECR";
        StencilOp[StencilOp["INVERT"] = 5] = "INVERT";
        StencilOp[StencilOp["INCR_WRAP"] = 6] = "INCR_WRAP";
        StencilOp[StencilOp["DECR_WRAP"] = 7] = "DECR_WRAP";
      })(StencilOp || (StencilOp = {}));

      var BlendFactor;

      (function (BlendFactor) {
        BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
        BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
        BlendFactor[BlendFactor["SRC_ALPHA"] = 2] = "SRC_ALPHA";
        BlendFactor[BlendFactor["DST_ALPHA"] = 3] = "DST_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = 4] = "ONE_MINUS_SRC_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = 5] = "ONE_MINUS_DST_ALPHA";
        BlendFactor[BlendFactor["SRC_COLOR"] = 6] = "SRC_COLOR";
        BlendFactor[BlendFactor["DST_COLOR"] = 7] = "DST_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = 8] = "ONE_MINUS_SRC_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = 9] = "ONE_MINUS_DST_COLOR";
        BlendFactor[BlendFactor["SRC_ALPHA_SATURATE"] = 10] = "SRC_ALPHA_SATURATE";
        BlendFactor[BlendFactor["CONSTANT_COLOR"] = 11] = "CONSTANT_COLOR";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 12] = "ONE_MINUS_CONSTANT_COLOR";
        BlendFactor[BlendFactor["CONSTANT_ALPHA"] = 13] = "CONSTANT_ALPHA";
        BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 14] = "ONE_MINUS_CONSTANT_ALPHA";
      })(BlendFactor || (BlendFactor = {}));

      var BlendOp;

      (function (BlendOp) {
        BlendOp[BlendOp["ADD"] = 0] = "ADD";
        BlendOp[BlendOp["SUB"] = 1] = "SUB";
        BlendOp[BlendOp["REV_SUB"] = 2] = "REV_SUB";
        BlendOp[BlendOp["MIN"] = 3] = "MIN";
        BlendOp[BlendOp["MAX"] = 4] = "MAX";
      })(BlendOp || (BlendOp = {}));

      var ColorMask;

      (function (ColorMask) {
        ColorMask[ColorMask["NONE"] = 0] = "NONE";
        ColorMask[ColorMask["R"] = 1] = "R";
        ColorMask[ColorMask["G"] = 2] = "G";
        ColorMask[ColorMask["B"] = 4] = "B";
        ColorMask[ColorMask["A"] = 8] = "A";
        ColorMask[ColorMask["ALL"] = 15] = "ALL";
      })(ColorMask || (ColorMask = {}));

      var ShaderStageFlagBit;

      (function (ShaderStageFlagBit) {
        ShaderStageFlagBit[ShaderStageFlagBit["NONE"] = 0] = "NONE";
        ShaderStageFlagBit[ShaderStageFlagBit["VERTEX"] = 1] = "VERTEX";
        ShaderStageFlagBit[ShaderStageFlagBit["CONTROL"] = 2] = "CONTROL";
        ShaderStageFlagBit[ShaderStageFlagBit["EVALUATION"] = 4] = "EVALUATION";
        ShaderStageFlagBit[ShaderStageFlagBit["GEOMETRY"] = 8] = "GEOMETRY";
        ShaderStageFlagBit[ShaderStageFlagBit["FRAGMENT"] = 16] = "FRAGMENT";
        ShaderStageFlagBit[ShaderStageFlagBit["COMPUTE"] = 32] = "COMPUTE";
        ShaderStageFlagBit[ShaderStageFlagBit["ALL"] = 63] = "ALL";
      })(ShaderStageFlagBit || (ShaderStageFlagBit = {}));

      var LoadOp;

      (function (LoadOp) {
        LoadOp[LoadOp["LOAD"] = 0] = "LOAD";
        LoadOp[LoadOp["CLEAR"] = 1] = "CLEAR";
        LoadOp[LoadOp["DISCARD"] = 2] = "DISCARD";
      })(LoadOp || (LoadOp = {}));

      var StoreOp;

      (function (StoreOp) {
        StoreOp[StoreOp["STORE"] = 0] = "STORE";
        StoreOp[StoreOp["DISCARD"] = 1] = "DISCARD";
      })(StoreOp || (StoreOp = {}));

      var AccessFlagBit;

      (function (AccessFlagBit) {
        AccessFlagBit[AccessFlagBit["NONE"] = 0] = "NONE";
        AccessFlagBit[AccessFlagBit["INDIRECT_BUFFER"] = 1] = "INDIRECT_BUFFER";
        AccessFlagBit[AccessFlagBit["INDEX_BUFFER"] = 2] = "INDEX_BUFFER";
        AccessFlagBit[AccessFlagBit["VERTEX_BUFFER"] = 4] = "VERTEX_BUFFER";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_READ_UNIFORM_BUFFER"] = 8] = "VERTEX_SHADER_READ_UNIFORM_BUFFER";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_READ_TEXTURE"] = 16] = "VERTEX_SHADER_READ_TEXTURE";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_READ_OTHER"] = 32] = "VERTEX_SHADER_READ_OTHER";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_UNIFORM_BUFFER"] = 64] = "FRAGMENT_SHADER_READ_UNIFORM_BUFFER";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_TEXTURE"] = 128] = "FRAGMENT_SHADER_READ_TEXTURE";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT"] = 256] = "FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT"] = 512] = "FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_READ_OTHER"] = 1024] = "FRAGMENT_SHADER_READ_OTHER";
        AccessFlagBit[AccessFlagBit["COLOR_ATTACHMENT_READ"] = 2048] = "COLOR_ATTACHMENT_READ";
        AccessFlagBit[AccessFlagBit["DEPTH_STENCIL_ATTACHMENT_READ"] = 4096] = "DEPTH_STENCIL_ATTACHMENT_READ";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_READ_UNIFORM_BUFFER"] = 8192] = "COMPUTE_SHADER_READ_UNIFORM_BUFFER";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_READ_TEXTURE"] = 16384] = "COMPUTE_SHADER_READ_TEXTURE";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_READ_OTHER"] = 32768] = "COMPUTE_SHADER_READ_OTHER";
        AccessFlagBit[AccessFlagBit["TRANSFER_READ"] = 65536] = "TRANSFER_READ";
        AccessFlagBit[AccessFlagBit["HOST_READ"] = 131072] = "HOST_READ";
        AccessFlagBit[AccessFlagBit["PRESENT"] = 262144] = "PRESENT";
        AccessFlagBit[AccessFlagBit["VERTEX_SHADER_WRITE"] = 524288] = "VERTEX_SHADER_WRITE";
        AccessFlagBit[AccessFlagBit["FRAGMENT_SHADER_WRITE"] = 1048576] = "FRAGMENT_SHADER_WRITE";
        AccessFlagBit[AccessFlagBit["COLOR_ATTACHMENT_WRITE"] = 2097152] = "COLOR_ATTACHMENT_WRITE";
        AccessFlagBit[AccessFlagBit["DEPTH_STENCIL_ATTACHMENT_WRITE"] = 4194304] = "DEPTH_STENCIL_ATTACHMENT_WRITE";
        AccessFlagBit[AccessFlagBit["COMPUTE_SHADER_WRITE"] = 8388608] = "COMPUTE_SHADER_WRITE";
        AccessFlagBit[AccessFlagBit["TRANSFER_WRITE"] = 16777216] = "TRANSFER_WRITE";
        AccessFlagBit[AccessFlagBit["HOST_PREINITIALIZED"] = 33554432] = "HOST_PREINITIALIZED";
        AccessFlagBit[AccessFlagBit["HOST_WRITE"] = 67108864] = "HOST_WRITE";
      })(AccessFlagBit || (AccessFlagBit = {}));

      var ResolveMode;

      (function (ResolveMode) {
        ResolveMode[ResolveMode["NONE"] = 0] = "NONE";
        ResolveMode[ResolveMode["SAMPLE_ZERO"] = 1] = "SAMPLE_ZERO";
        ResolveMode[ResolveMode["AVERAGE"] = 2] = "AVERAGE";
        ResolveMode[ResolveMode["MIN"] = 3] = "MIN";
        ResolveMode[ResolveMode["MAX"] = 4] = "MAX";
      })(ResolveMode || (ResolveMode = {}));

      var PipelineBindPoint;

      (function (PipelineBindPoint) {
        PipelineBindPoint[PipelineBindPoint["GRAPHICS"] = 0] = "GRAPHICS";
        PipelineBindPoint[PipelineBindPoint["COMPUTE"] = 1] = "COMPUTE";
        PipelineBindPoint[PipelineBindPoint["RAY_TRACING"] = 2] = "RAY_TRACING";
      })(PipelineBindPoint || (PipelineBindPoint = {}));

      var PrimitiveMode;

      (function (PrimitiveMode) {
        PrimitiveMode[PrimitiveMode["POINT_LIST"] = 0] = "POINT_LIST";
        PrimitiveMode[PrimitiveMode["LINE_LIST"] = 1] = "LINE_LIST";
        PrimitiveMode[PrimitiveMode["LINE_STRIP"] = 2] = "LINE_STRIP";
        PrimitiveMode[PrimitiveMode["LINE_LOOP"] = 3] = "LINE_LOOP";
        PrimitiveMode[PrimitiveMode["LINE_LIST_ADJACENCY"] = 4] = "LINE_LIST_ADJACENCY";
        PrimitiveMode[PrimitiveMode["LINE_STRIP_ADJACENCY"] = 5] = "LINE_STRIP_ADJACENCY";
        PrimitiveMode[PrimitiveMode["ISO_LINE_LIST"] = 6] = "ISO_LINE_LIST";
        PrimitiveMode[PrimitiveMode["TRIANGLE_LIST"] = 7] = "TRIANGLE_LIST";
        PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP"] = 8] = "TRIANGLE_STRIP";
        PrimitiveMode[PrimitiveMode["TRIANGLE_FAN"] = 9] = "TRIANGLE_FAN";
        PrimitiveMode[PrimitiveMode["TRIANGLE_LIST_ADJACENCY"] = 10] = "TRIANGLE_LIST_ADJACENCY";
        PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP_ADJACENCY"] = 11] = "TRIANGLE_STRIP_ADJACENCY";
        PrimitiveMode[PrimitiveMode["TRIANGLE_PATCH_ADJACENCY"] = 12] = "TRIANGLE_PATCH_ADJACENCY";
        PrimitiveMode[PrimitiveMode["QUAD_PATCH_LIST"] = 13] = "QUAD_PATCH_LIST";
      })(PrimitiveMode || (PrimitiveMode = {}));

      var PolygonMode;

      (function (PolygonMode) {
        PolygonMode[PolygonMode["FILL"] = 0] = "FILL";
        PolygonMode[PolygonMode["POINT"] = 1] = "POINT";
        PolygonMode[PolygonMode["LINE"] = 2] = "LINE";
      })(PolygonMode || (PolygonMode = {}));

      var ShadeModel;

      (function (ShadeModel) {
        ShadeModel[ShadeModel["GOURAND"] = 0] = "GOURAND";
        ShadeModel[ShadeModel["FLAT"] = 1] = "FLAT";
      })(ShadeModel || (ShadeModel = {}));

      var CullMode;

      (function (CullMode) {
        CullMode[CullMode["NONE"] = 0] = "NONE";
        CullMode[CullMode["FRONT"] = 1] = "FRONT";
        CullMode[CullMode["BACK"] = 2] = "BACK";
      })(CullMode || (CullMode = {}));

      var DynamicStateFlagBit;

      (function (DynamicStateFlagBit) {
        DynamicStateFlagBit[DynamicStateFlagBit["NONE"] = 0] = "NONE";
        DynamicStateFlagBit[DynamicStateFlagBit["LINE_WIDTH"] = 1] = "LINE_WIDTH";
        DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BIAS"] = 2] = "DEPTH_BIAS";
        DynamicStateFlagBit[DynamicStateFlagBit["BLEND_CONSTANTS"] = 4] = "BLEND_CONSTANTS";
        DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BOUNDS"] = 8] = "DEPTH_BOUNDS";
        DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_WRITE_MASK"] = 16] = "STENCIL_WRITE_MASK";
        DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_COMPARE_MASK"] = 32] = "STENCIL_COMPARE_MASK";
      })(DynamicStateFlagBit || (DynamicStateFlagBit = {}));

      var StencilFace;

      (function (StencilFace) {
        StencilFace[StencilFace["FRONT"] = 1] = "FRONT";
        StencilFace[StencilFace["BACK"] = 2] = "BACK";
        StencilFace[StencilFace["ALL"] = 3] = "ALL";
      })(StencilFace || (StencilFace = {}));

      var DescriptorType;

      (function (DescriptorType) {
        DescriptorType[DescriptorType["UNKNOWN"] = 0] = "UNKNOWN";
        DescriptorType[DescriptorType["UNIFORM_BUFFER"] = 1] = "UNIFORM_BUFFER";
        DescriptorType[DescriptorType["DYNAMIC_UNIFORM_BUFFER"] = 2] = "DYNAMIC_UNIFORM_BUFFER";
        DescriptorType[DescriptorType["STORAGE_BUFFER"] = 4] = "STORAGE_BUFFER";
        DescriptorType[DescriptorType["DYNAMIC_STORAGE_BUFFER"] = 8] = "DYNAMIC_STORAGE_BUFFER";
        DescriptorType[DescriptorType["SAMPLER_TEXTURE"] = 16] = "SAMPLER_TEXTURE";
        DescriptorType[DescriptorType["SAMPLER"] = 32] = "SAMPLER";
        DescriptorType[DescriptorType["TEXTURE"] = 64] = "TEXTURE";
        DescriptorType[DescriptorType["STORAGE_IMAGE"] = 128] = "STORAGE_IMAGE";
        DescriptorType[DescriptorType["INPUT_ATTACHMENT"] = 256] = "INPUT_ATTACHMENT";
      })(DescriptorType || (DescriptorType = {}));

      var QueueType;

      (function (QueueType) {
        QueueType[QueueType["GRAPHICS"] = 0] = "GRAPHICS";
        QueueType[QueueType["COMPUTE"] = 1] = "COMPUTE";
        QueueType[QueueType["TRANSFER"] = 2] = "TRANSFER";
      })(QueueType || (QueueType = {}));

      var QueryType;

      (function (QueryType) {
        QueryType[QueryType["OCCLUSION"] = 0] = "OCCLUSION";
        QueryType[QueryType["PIPELINE_STATISTICS"] = 1] = "PIPELINE_STATISTICS";
        QueryType[QueryType["TIMESTAMP"] = 2] = "TIMESTAMP";
      })(QueryType || (QueryType = {}));

      var CommandBufferType;

      (function (CommandBufferType) {
        CommandBufferType[CommandBufferType["PRIMARY"] = 0] = "PRIMARY";
        CommandBufferType[CommandBufferType["SECONDARY"] = 1] = "SECONDARY";
      })(CommandBufferType || (CommandBufferType = {}));

      var ClearFlagBit;

      (function (ClearFlagBit) {
        ClearFlagBit[ClearFlagBit["NONE"] = 0] = "NONE";
        ClearFlagBit[ClearFlagBit["COLOR"] = 1] = "COLOR";
        ClearFlagBit[ClearFlagBit["DEPTH"] = 2] = "DEPTH";
        ClearFlagBit[ClearFlagBit["STENCIL"] = 4] = "STENCIL";
        ClearFlagBit[ClearFlagBit["DEPTH_STENCIL"] = 6] = "DEPTH_STENCIL";
        ClearFlagBit[ClearFlagBit["ALL"] = 7] = "ALL";
      })(ClearFlagBit || (ClearFlagBit = {}));

      var Size$1 = function () {
        function Size(x, y, z) {
          if (x === void 0) {
            x = 0;
          }

          if (y === void 0) {
            y = 0;
          }

          if (z === void 0) {
            z = 0;
          }

          this.x = x;
          this.y = y;
          this.z = z;
        }

        var _proto = Size.prototype;

        _proto.copy = function copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.z = info.z;
          return this;
        };

        return Size;
      }();
      var DeviceCaps = function () {
        function DeviceCaps(maxVertexAttributes, maxVertexUniformVectors, maxFragmentUniformVectors, maxTextureUnits, maxImageUnits, maxVertexTextureUnits, maxColorRenderTargets, maxShaderStorageBufferBindings, maxShaderStorageBlockSize, maxUniformBufferBindings, maxUniformBlockSize, maxTextureSize, maxCubeMapTextureSize, uboOffsetAlignment, maxComputeSharedMemorySize, maxComputeWorkGroupInvocations, maxComputeWorkGroupSize, maxComputeWorkGroupCount, supportQuery, clipSpaceMinZ, screenSpaceSignY, clipSpaceSignY) {
          if (maxVertexAttributes === void 0) {
            maxVertexAttributes = 0;
          }

          if (maxVertexUniformVectors === void 0) {
            maxVertexUniformVectors = 0;
          }

          if (maxFragmentUniformVectors === void 0) {
            maxFragmentUniformVectors = 0;
          }

          if (maxTextureUnits === void 0) {
            maxTextureUnits = 0;
          }

          if (maxImageUnits === void 0) {
            maxImageUnits = 0;
          }

          if (maxVertexTextureUnits === void 0) {
            maxVertexTextureUnits = 0;
          }

          if (maxColorRenderTargets === void 0) {
            maxColorRenderTargets = 0;
          }

          if (maxShaderStorageBufferBindings === void 0) {
            maxShaderStorageBufferBindings = 0;
          }

          if (maxShaderStorageBlockSize === void 0) {
            maxShaderStorageBlockSize = 0;
          }

          if (maxUniformBufferBindings === void 0) {
            maxUniformBufferBindings = 0;
          }

          if (maxUniformBlockSize === void 0) {
            maxUniformBlockSize = 0;
          }

          if (maxTextureSize === void 0) {
            maxTextureSize = 0;
          }

          if (maxCubeMapTextureSize === void 0) {
            maxCubeMapTextureSize = 0;
          }

          if (uboOffsetAlignment === void 0) {
            uboOffsetAlignment = 1;
          }

          if (maxComputeSharedMemorySize === void 0) {
            maxComputeSharedMemorySize = 0;
          }

          if (maxComputeWorkGroupInvocations === void 0) {
            maxComputeWorkGroupInvocations = 0;
          }

          if (maxComputeWorkGroupSize === void 0) {
            maxComputeWorkGroupSize = new Size$1();
          }

          if (maxComputeWorkGroupCount === void 0) {
            maxComputeWorkGroupCount = new Size$1();
          }

          if (supportQuery === void 0) {
            supportQuery = false;
          }

          if (clipSpaceMinZ === void 0) {
            clipSpaceMinZ = -1;
          }

          if (screenSpaceSignY === void 0) {
            screenSpaceSignY = 1;
          }

          if (clipSpaceSignY === void 0) {
            clipSpaceSignY = 1;
          }

          this.maxVertexAttributes = maxVertexAttributes;
          this.maxVertexUniformVectors = maxVertexUniformVectors;
          this.maxFragmentUniformVectors = maxFragmentUniformVectors;
          this.maxTextureUnits = maxTextureUnits;
          this.maxImageUnits = maxImageUnits;
          this.maxVertexTextureUnits = maxVertexTextureUnits;
          this.maxColorRenderTargets = maxColorRenderTargets;
          this.maxShaderStorageBufferBindings = maxShaderStorageBufferBindings;
          this.maxShaderStorageBlockSize = maxShaderStorageBlockSize;
          this.maxUniformBufferBindings = maxUniformBufferBindings;
          this.maxUniformBlockSize = maxUniformBlockSize;
          this.maxTextureSize = maxTextureSize;
          this.maxCubeMapTextureSize = maxCubeMapTextureSize;
          this.uboOffsetAlignment = uboOffsetAlignment;
          this.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
          this.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
          this.maxComputeWorkGroupSize = maxComputeWorkGroupSize;
          this.maxComputeWorkGroupCount = maxComputeWorkGroupCount;
          this.supportQuery = supportQuery;
          this.clipSpaceMinZ = clipSpaceMinZ;
          this.screenSpaceSignY = screenSpaceSignY;
          this.clipSpaceSignY = clipSpaceSignY;
        }

        var _proto2 = DeviceCaps.prototype;

        _proto2.copy = function copy(info) {
          this.maxVertexAttributes = info.maxVertexAttributes;
          this.maxVertexUniformVectors = info.maxVertexUniformVectors;
          this.maxFragmentUniformVectors = info.maxFragmentUniformVectors;
          this.maxTextureUnits = info.maxTextureUnits;
          this.maxImageUnits = info.maxImageUnits;
          this.maxVertexTextureUnits = info.maxVertexTextureUnits;
          this.maxColorRenderTargets = info.maxColorRenderTargets;
          this.maxShaderStorageBufferBindings = info.maxShaderStorageBufferBindings;
          this.maxShaderStorageBlockSize = info.maxShaderStorageBlockSize;
          this.maxUniformBufferBindings = info.maxUniformBufferBindings;
          this.maxUniformBlockSize = info.maxUniformBlockSize;
          this.maxTextureSize = info.maxTextureSize;
          this.maxCubeMapTextureSize = info.maxCubeMapTextureSize;
          this.uboOffsetAlignment = info.uboOffsetAlignment;
          this.maxComputeSharedMemorySize = info.maxComputeSharedMemorySize;
          this.maxComputeWorkGroupInvocations = info.maxComputeWorkGroupInvocations;
          this.maxComputeWorkGroupSize.copy(info.maxComputeWorkGroupSize);
          this.maxComputeWorkGroupCount.copy(info.maxComputeWorkGroupCount);
          this.supportQuery = info.supportQuery;
          this.clipSpaceMinZ = info.clipSpaceMinZ;
          this.screenSpaceSignY = info.screenSpaceSignY;
          this.clipSpaceSignY = info.clipSpaceSignY;
          return this;
        };

        return DeviceCaps;
      }();
      var Offset = function () {
        function Offset(x, y, z) {
          if (x === void 0) {
            x = 0;
          }

          if (y === void 0) {
            y = 0;
          }

          if (z === void 0) {
            z = 0;
          }

          this.x = x;
          this.y = y;
          this.z = z;
        }

        var _proto3 = Offset.prototype;

        _proto3.copy = function copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.z = info.z;
          return this;
        };

        return Offset;
      }();
      var Rect$1 = function () {
        function Rect(x, y, width, height) {
          if (x === void 0) {
            x = 0;
          }

          if (y === void 0) {
            y = 0;
          }

          if (width === void 0) {
            width = 0;
          }

          if (height === void 0) {
            height = 0;
          }

          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        }

        var _proto4 = Rect.prototype;

        _proto4.copy = function copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.width = info.width;
          this.height = info.height;
          return this;
        };

        return Rect;
      }();
      var Extent = function () {
        function Extent(width, height, depth) {
          if (width === void 0) {
            width = 0;
          }

          if (height === void 0) {
            height = 0;
          }

          if (depth === void 0) {
            depth = 1;
          }

          this.width = width;
          this.height = height;
          this.depth = depth;
        }

        var _proto5 = Extent.prototype;

        _proto5.copy = function copy(info) {
          this.width = info.width;
          this.height = info.height;
          this.depth = info.depth;
          return this;
        };

        return Extent;
      }();
      var TextureSubresLayers = function () {
        function TextureSubresLayers(mipLevel, baseArrayLayer, layerCount) {
          if (mipLevel === void 0) {
            mipLevel = 0;
          }

          if (baseArrayLayer === void 0) {
            baseArrayLayer = 0;
          }

          if (layerCount === void 0) {
            layerCount = 1;
          }

          this.mipLevel = mipLevel;
          this.baseArrayLayer = baseArrayLayer;
          this.layerCount = layerCount;
        }

        var _proto6 = TextureSubresLayers.prototype;

        _proto6.copy = function copy(info) {
          this.mipLevel = info.mipLevel;
          this.baseArrayLayer = info.baseArrayLayer;
          this.layerCount = info.layerCount;
          return this;
        };

        return TextureSubresLayers;
      }();
      var TextureSubresRange = function () {
        function TextureSubresRange(baseMipLevel, levelCount, baseArrayLayer, layerCount) {
          if (baseMipLevel === void 0) {
            baseMipLevel = 0;
          }

          if (levelCount === void 0) {
            levelCount = 1;
          }

          if (baseArrayLayer === void 0) {
            baseArrayLayer = 0;
          }

          if (layerCount === void 0) {
            layerCount = 1;
          }

          this.baseMipLevel = baseMipLevel;
          this.levelCount = levelCount;
          this.baseArrayLayer = baseArrayLayer;
          this.layerCount = layerCount;
        }

        var _proto7 = TextureSubresRange.prototype;

        _proto7.copy = function copy(info) {
          this.baseMipLevel = info.baseMipLevel;
          this.levelCount = info.levelCount;
          this.baseArrayLayer = info.baseArrayLayer;
          this.layerCount = info.layerCount;
          return this;
        };

        return TextureSubresRange;
      }();
      var TextureCopy = function () {
        function TextureCopy(srcSubres, srcOffset, dstSubres, dstOffset, extent) {
          if (srcSubres === void 0) {
            srcSubres = new TextureSubresLayers();
          }

          if (srcOffset === void 0) {
            srcOffset = new Offset();
          }

          if (dstSubres === void 0) {
            dstSubres = new TextureSubresLayers();
          }

          if (dstOffset === void 0) {
            dstOffset = new Offset();
          }

          if (extent === void 0) {
            extent = new Extent();
          }

          this.srcSubres = srcSubres;
          this.srcOffset = srcOffset;
          this.dstSubres = dstSubres;
          this.dstOffset = dstOffset;
          this.extent = extent;
        }

        var _proto8 = TextureCopy.prototype;

        _proto8.copy = function copy(info) {
          this.srcSubres.copy(info.srcSubres);
          this.srcOffset.copy(info.srcOffset);
          this.dstSubres.copy(info.dstSubres);
          this.dstOffset.copy(info.dstOffset);
          this.extent.copy(info.extent);
          return this;
        };

        return TextureCopy;
      }();
      var TextureBlit = function () {
        function TextureBlit(srcSubres, srcOffset, srcExtent, dstSubres, dstOffset, dstExtent) {
          if (srcSubres === void 0) {
            srcSubres = new TextureSubresLayers();
          }

          if (srcOffset === void 0) {
            srcOffset = new Offset();
          }

          if (srcExtent === void 0) {
            srcExtent = new Extent();
          }

          if (dstSubres === void 0) {
            dstSubres = new TextureSubresLayers();
          }

          if (dstOffset === void 0) {
            dstOffset = new Offset();
          }

          if (dstExtent === void 0) {
            dstExtent = new Extent();
          }

          this.srcSubres = srcSubres;
          this.srcOffset = srcOffset;
          this.srcExtent = srcExtent;
          this.dstSubres = dstSubres;
          this.dstOffset = dstOffset;
          this.dstExtent = dstExtent;
        }

        var _proto9 = TextureBlit.prototype;

        _proto9.copy = function copy(info) {
          this.srcSubres.copy(info.srcSubres);
          this.srcOffset.copy(info.srcOffset);
          this.srcExtent.copy(info.srcExtent);
          this.dstSubres.copy(info.dstSubres);
          this.dstOffset.copy(info.dstOffset);
          this.dstExtent.copy(info.dstExtent);
          return this;
        };

        return TextureBlit;
      }();
      var BufferTextureCopy = function () {
        function BufferTextureCopy(buffStride, buffTexHeight, texOffset, texExtent, texSubres) {
          if (buffStride === void 0) {
            buffStride = 0;
          }

          if (buffTexHeight === void 0) {
            buffTexHeight = 0;
          }

          if (texOffset === void 0) {
            texOffset = new Offset();
          }

          if (texExtent === void 0) {
            texExtent = new Extent();
          }

          if (texSubres === void 0) {
            texSubres = new TextureSubresLayers();
          }

          this.buffStride = buffStride;
          this.buffTexHeight = buffTexHeight;
          this.texOffset = texOffset;
          this.texExtent = texExtent;
          this.texSubres = texSubres;
        }

        var _proto10 = BufferTextureCopy.prototype;

        _proto10.copy = function copy(info) {
          this.buffStride = info.buffStride;
          this.buffTexHeight = info.buffTexHeight;
          this.texOffset.copy(info.texOffset);
          this.texExtent.copy(info.texExtent);
          this.texSubres.copy(info.texSubres);
          return this;
        };

        return BufferTextureCopy;
      }();
      var Viewport = function () {
        function Viewport(left, top, width, height, minDepth, maxDepth) {
          if (left === void 0) {
            left = 0;
          }

          if (top === void 0) {
            top = 0;
          }

          if (width === void 0) {
            width = 0;
          }

          if (height === void 0) {
            height = 0;
          }

          if (minDepth === void 0) {
            minDepth = 0;
          }

          if (maxDepth === void 0) {
            maxDepth = 1;
          }

          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
          this.minDepth = minDepth;
          this.maxDepth = maxDepth;
        }

        var _proto11 = Viewport.prototype;

        _proto11.copy = function copy(info) {
          this.left = info.left;
          this.top = info.top;
          this.width = info.width;
          this.height = info.height;
          this.minDepth = info.minDepth;
          this.maxDepth = info.maxDepth;
          return this;
        };

        return Viewport;
      }();
      var Color$1 = function () {
        function Color(x, y, z, w) {
          if (x === void 0) {
            x = 0;
          }

          if (y === void 0) {
            y = 0;
          }

          if (z === void 0) {
            z = 0;
          }

          if (w === void 0) {
            w = 0;
          }

          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        }

        var _proto12 = Color.prototype;

        _proto12.copy = function copy(info) {
          this.x = info.x;
          this.y = info.y;
          this.z = info.z;
          this.w = info.w;
          return this;
        };

        return Color;
      }();
      var BindingMappingInfo = function () {
        function BindingMappingInfo(maxBlockCounts, maxSamplerTextureCounts, maxSamplerCounts, maxTextureCounts, maxBufferCounts, maxImageCounts, maxSubpassInputCounts, setIndices) {
          if (maxBlockCounts === void 0) {
            maxBlockCounts = [0];
          }

          if (maxSamplerTextureCounts === void 0) {
            maxSamplerTextureCounts = [0];
          }

          if (maxSamplerCounts === void 0) {
            maxSamplerCounts = [0];
          }

          if (maxTextureCounts === void 0) {
            maxTextureCounts = [0];
          }

          if (maxBufferCounts === void 0) {
            maxBufferCounts = [0];
          }

          if (maxImageCounts === void 0) {
            maxImageCounts = [0];
          }

          if (maxSubpassInputCounts === void 0) {
            maxSubpassInputCounts = [0];
          }

          if (setIndices === void 0) {
            setIndices = [0];
          }

          this.maxBlockCounts = maxBlockCounts;
          this.maxSamplerTextureCounts = maxSamplerTextureCounts;
          this.maxSamplerCounts = maxSamplerCounts;
          this.maxTextureCounts = maxTextureCounts;
          this.maxBufferCounts = maxBufferCounts;
          this.maxImageCounts = maxImageCounts;
          this.maxSubpassInputCounts = maxSubpassInputCounts;
          this.setIndices = setIndices;
        }

        var _proto13 = BindingMappingInfo.prototype;

        _proto13.copy = function copy(info) {
          this.maxBlockCounts = info.maxBlockCounts.slice();
          this.maxSamplerTextureCounts = info.maxSamplerTextureCounts.slice();
          this.maxSamplerCounts = info.maxSamplerCounts.slice();
          this.maxTextureCounts = info.maxTextureCounts.slice();
          this.maxBufferCounts = info.maxBufferCounts.slice();
          this.maxImageCounts = info.maxImageCounts.slice();
          this.maxSubpassInputCounts = info.maxSubpassInputCounts.slice();
          this.setIndices = info.setIndices.slice();
          return this;
        };

        return BindingMappingInfo;
      }();
      var SwapchainInfo = function () {
        function SwapchainInfo(windowHandle, vsyncMode, width, height) {
          if (windowHandle === void 0) {
            windowHandle = null;
          }

          if (vsyncMode === void 0) {
            vsyncMode = VsyncMode.ON;
          }

          if (width === void 0) {
            width = 0;
          }

          if (height === void 0) {
            height = 0;
          }

          this.windowHandle = windowHandle;
          this.vsyncMode = vsyncMode;
          this.width = width;
          this.height = height;
        }

        var _proto14 = SwapchainInfo.prototype;

        _proto14.copy = function copy(info) {
          this.windowHandle = info.windowHandle;
          this.vsyncMode = info.vsyncMode;
          this.width = info.width;
          this.height = info.height;
          return this;
        };

        return SwapchainInfo;
      }();
      var DeviceInfo = function () {
        function DeviceInfo(bindingMappingInfo) {
          if (bindingMappingInfo === void 0) {
            bindingMappingInfo = new BindingMappingInfo();
          }

          this.bindingMappingInfo = bindingMappingInfo;
        }

        var _proto15 = DeviceInfo.prototype;

        _proto15.copy = function copy(info) {
          this.bindingMappingInfo.copy(info.bindingMappingInfo);
          return this;
        };

        return DeviceInfo;
      }();
      var BufferInfo = function () {
        function BufferInfo(usage, memUsage, size, stride, flags) {
          if (usage === void 0) {
            usage = BufferUsageBit.NONE;
          }

          if (memUsage === void 0) {
            memUsage = MemoryUsageBit.NONE;
          }

          if (size === void 0) {
            size = 0;
          }

          if (stride === void 0) {
            stride = 1;
          }

          if (flags === void 0) {
            flags = BufferFlagBit.NONE;
          }

          this.usage = usage;
          this.memUsage = memUsage;
          this.size = size;
          this.stride = stride;
          this.flags = flags;
        }

        var _proto16 = BufferInfo.prototype;

        _proto16.copy = function copy(info) {
          this.usage = info.usage;
          this.memUsage = info.memUsage;
          this.size = info.size;
          this.stride = info.stride;
          this.flags = info.flags;
          return this;
        };

        return BufferInfo;
      }();
      var BufferViewInfo = function () {
        function BufferViewInfo(buffer, offset, range) {
          if (buffer === void 0) {
            buffer = null;
          }

          if (offset === void 0) {
            offset = 0;
          }

          if (range === void 0) {
            range = 0;
          }

          this.buffer = buffer;
          this.offset = offset;
          this.range = range;
        }

        var _proto17 = BufferViewInfo.prototype;

        _proto17.copy = function copy(info) {
          this.buffer = info.buffer;
          this.offset = info.offset;
          this.range = info.range;
          return this;
        };

        return BufferViewInfo;
      }();
      var DrawInfo = function () {
        function DrawInfo(vertexCount, firstVertex, indexCount, firstIndex, vertexOffset, instanceCount, firstInstance) {
          if (vertexCount === void 0) {
            vertexCount = 0;
          }

          if (firstVertex === void 0) {
            firstVertex = 0;
          }

          if (indexCount === void 0) {
            indexCount = 0;
          }

          if (firstIndex === void 0) {
            firstIndex = 0;
          }

          if (vertexOffset === void 0) {
            vertexOffset = 0;
          }

          if (instanceCount === void 0) {
            instanceCount = 0;
          }

          if (firstInstance === void 0) {
            firstInstance = 0;
          }

          this.vertexCount = vertexCount;
          this.firstVertex = firstVertex;
          this.indexCount = indexCount;
          this.firstIndex = firstIndex;
          this.vertexOffset = vertexOffset;
          this.instanceCount = instanceCount;
          this.firstInstance = firstInstance;
        }

        var _proto18 = DrawInfo.prototype;

        _proto18.copy = function copy(info) {
          this.vertexCount = info.vertexCount;
          this.firstVertex = info.firstVertex;
          this.indexCount = info.indexCount;
          this.firstIndex = info.firstIndex;
          this.vertexOffset = info.vertexOffset;
          this.instanceCount = info.instanceCount;
          this.firstInstance = info.firstInstance;
          return this;
        };

        return DrawInfo;
      }();
      var DispatchInfo = function () {
        function DispatchInfo(groupCountX, groupCountY, groupCountZ, indirectBuffer, indirectOffset) {
          if (groupCountX === void 0) {
            groupCountX = 0;
          }

          if (groupCountY === void 0) {
            groupCountY = 0;
          }

          if (groupCountZ === void 0) {
            groupCountZ = 0;
          }

          if (indirectBuffer === void 0) {
            indirectBuffer = null;
          }

          if (indirectOffset === void 0) {
            indirectOffset = 0;
          }

          this.groupCountX = groupCountX;
          this.groupCountY = groupCountY;
          this.groupCountZ = groupCountZ;
          this.indirectBuffer = indirectBuffer;
          this.indirectOffset = indirectOffset;
        }

        var _proto19 = DispatchInfo.prototype;

        _proto19.copy = function copy(info) {
          this.groupCountX = info.groupCountX;
          this.groupCountY = info.groupCountY;
          this.groupCountZ = info.groupCountZ;
          this.indirectBuffer = info.indirectBuffer;
          this.indirectOffset = info.indirectOffset;
          return this;
        };

        return DispatchInfo;
      }();
      var IndirectBuffer = function () {
        function IndirectBuffer(drawInfos) {
          if (drawInfos === void 0) {
            drawInfos = [];
          }

          this.drawInfos = drawInfos;
        }

        var _proto20 = IndirectBuffer.prototype;

        _proto20.copy = function copy(info) {
          deepCopy(this.drawInfos, info.drawInfos, DrawInfo);
          return this;
        };

        return IndirectBuffer;
      }();
      var TextureInfo = function () {
        function TextureInfo(type, usage, format, width, height, flags, layerCount, levelCount, samples, depth, externalRes) {
          if (type === void 0) {
            type = TextureType.TEX2D;
          }

          if (usage === void 0) {
            usage = TextureUsageBit.NONE;
          }

          if (format === void 0) {
            format = Format.UNKNOWN;
          }

          if (width === void 0) {
            width = 0;
          }

          if (height === void 0) {
            height = 0;
          }

          if (flags === void 0) {
            flags = TextureFlagBit.NONE;
          }

          if (layerCount === void 0) {
            layerCount = 1;
          }

          if (levelCount === void 0) {
            levelCount = 1;
          }

          if (samples === void 0) {
            samples = SampleCount.ONE;
          }

          if (depth === void 0) {
            depth = 1;
          }

          if (externalRes === void 0) {
            externalRes = 0;
          }

          this.type = type;
          this.usage = usage;
          this.format = format;
          this.width = width;
          this.height = height;
          this.flags = flags;
          this.layerCount = layerCount;
          this.levelCount = levelCount;
          this.samples = samples;
          this.depth = depth;
          this.externalRes = externalRes;
        }

        var _proto21 = TextureInfo.prototype;

        _proto21.copy = function copy(info) {
          this.type = info.type;
          this.usage = info.usage;
          this.format = info.format;
          this.width = info.width;
          this.height = info.height;
          this.flags = info.flags;
          this.layerCount = info.layerCount;
          this.levelCount = info.levelCount;
          this.samples = info.samples;
          this.depth = info.depth;
          this.externalRes = info.externalRes;
          return this;
        };

        return TextureInfo;
      }();
      var TextureViewInfo = function () {
        function TextureViewInfo(texture, type, format, baseLevel, levelCount, baseLayer, layerCount) {
          if (texture === void 0) {
            texture = null;
          }

          if (type === void 0) {
            type = TextureType.TEX2D;
          }

          if (format === void 0) {
            format = Format.UNKNOWN;
          }

          if (baseLevel === void 0) {
            baseLevel = 0;
          }

          if (levelCount === void 0) {
            levelCount = 1;
          }

          if (baseLayer === void 0) {
            baseLayer = 0;
          }

          if (layerCount === void 0) {
            layerCount = 1;
          }

          this.texture = texture;
          this.type = type;
          this.format = format;
          this.baseLevel = baseLevel;
          this.levelCount = levelCount;
          this.baseLayer = baseLayer;
          this.layerCount = layerCount;
        }

        var _proto22 = TextureViewInfo.prototype;

        _proto22.copy = function copy(info) {
          this.texture = info.texture;
          this.type = info.type;
          this.format = info.format;
          this.baseLevel = info.baseLevel;
          this.levelCount = info.levelCount;
          this.baseLayer = info.baseLayer;
          this.layerCount = info.layerCount;
          return this;
        };

        return TextureViewInfo;
      }();
      var SamplerInfo = function () {
        function SamplerInfo(minFilter, magFilter, mipFilter, addressU, addressV, addressW, maxAnisotropy, cmpFunc) {
          if (minFilter === void 0) {
            minFilter = Filter.LINEAR;
          }

          if (magFilter === void 0) {
            magFilter = Filter.LINEAR;
          }

          if (mipFilter === void 0) {
            mipFilter = Filter.NONE;
          }

          if (addressU === void 0) {
            addressU = Address.WRAP;
          }

          if (addressV === void 0) {
            addressV = Address.WRAP;
          }

          if (addressW === void 0) {
            addressW = Address.WRAP;
          }

          if (maxAnisotropy === void 0) {
            maxAnisotropy = 0;
          }

          if (cmpFunc === void 0) {
            cmpFunc = ComparisonFunc.ALWAYS;
          }

          this.minFilter = minFilter;
          this.magFilter = magFilter;
          this.mipFilter = mipFilter;
          this.addressU = addressU;
          this.addressV = addressV;
          this.addressW = addressW;
          this.maxAnisotropy = maxAnisotropy;
          this.cmpFunc = cmpFunc;
        }

        var _proto23 = SamplerInfo.prototype;

        _proto23.copy = function copy(info) {
          this.minFilter = info.minFilter;
          this.magFilter = info.magFilter;
          this.mipFilter = info.mipFilter;
          this.addressU = info.addressU;
          this.addressV = info.addressV;
          this.addressW = info.addressW;
          this.maxAnisotropy = info.maxAnisotropy;
          this.cmpFunc = info.cmpFunc;
          return this;
        };

        return SamplerInfo;
      }();
      var Uniform = function () {
        function Uniform(name, type, count) {
          if (name === void 0) {
            name = '';
          }

          if (type === void 0) {
            type = Type.UNKNOWN;
          }

          if (count === void 0) {
            count = 0;
          }

          this.name = name;
          this.type = type;
          this.count = count;
        }

        var _proto24 = Uniform.prototype;

        _proto24.copy = function copy(info) {
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          return this;
        };

        return Uniform;
      }();
      var UniformBlock = function () {
        function UniformBlock(set, binding, name, members, count) {
          if (set === void 0) {
            set = 0;
          }

          if (binding === void 0) {
            binding = 0;
          }

          if (name === void 0) {
            name = '';
          }

          if (members === void 0) {
            members = [];
          }

          if (count === void 0) {
            count = 0;
          }

          this.set = set;
          this.binding = binding;
          this.name = name;
          this.members = members;
          this.count = count;
        }

        var _proto25 = UniformBlock.prototype;

        _proto25.copy = function copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          deepCopy(this.members, info.members, Uniform);
          this.count = info.count;
          return this;
        };

        return UniformBlock;
      }();
      var UniformSamplerTexture = function () {
        function UniformSamplerTexture(set, binding, name, type, count) {
          if (set === void 0) {
            set = 0;
          }

          if (binding === void 0) {
            binding = 0;
          }

          if (name === void 0) {
            name = '';
          }

          if (type === void 0) {
            type = Type.UNKNOWN;
          }

          if (count === void 0) {
            count = 0;
          }

          this.set = set;
          this.binding = binding;
          this.name = name;
          this.type = type;
          this.count = count;
        }

        var _proto26 = UniformSamplerTexture.prototype;

        _proto26.copy = function copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          return this;
        };

        return UniformSamplerTexture;
      }();
      var UniformSampler = function () {
        function UniformSampler(set, binding, name, count) {
          if (set === void 0) {
            set = 0;
          }

          if (binding === void 0) {
            binding = 0;
          }

          if (name === void 0) {
            name = '';
          }

          if (count === void 0) {
            count = 0;
          }

          this.set = set;
          this.binding = binding;
          this.name = name;
          this.count = count;
        }

        var _proto27 = UniformSampler.prototype;

        _proto27.copy = function copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.count = info.count;
          return this;
        };

        return UniformSampler;
      }();
      var UniformTexture = function () {
        function UniformTexture(set, binding, name, type, count) {
          if (set === void 0) {
            set = 0;
          }

          if (binding === void 0) {
            binding = 0;
          }

          if (name === void 0) {
            name = '';
          }

          if (type === void 0) {
            type = Type.UNKNOWN;
          }

          if (count === void 0) {
            count = 0;
          }

          this.set = set;
          this.binding = binding;
          this.name = name;
          this.type = type;
          this.count = count;
        }

        var _proto28 = UniformTexture.prototype;

        _proto28.copy = function copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          return this;
        };

        return UniformTexture;
      }();
      var UniformStorageImage = function () {
        function UniformStorageImage(set, binding, name, type, count, memoryAccess) {
          if (set === void 0) {
            set = 0;
          }

          if (binding === void 0) {
            binding = 0;
          }

          if (name === void 0) {
            name = '';
          }

          if (type === void 0) {
            type = Type.UNKNOWN;
          }

          if (count === void 0) {
            count = 0;
          }

          if (memoryAccess === void 0) {
            memoryAccess = MemoryAccessBit.READ_WRITE;
          }

          this.set = set;
          this.binding = binding;
          this.name = name;
          this.type = type;
          this.count = count;
          this.memoryAccess = memoryAccess;
        }

        var _proto29 = UniformStorageImage.prototype;

        _proto29.copy = function copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.type = info.type;
          this.count = info.count;
          this.memoryAccess = info.memoryAccess;
          return this;
        };

        return UniformStorageImage;
      }();
      var UniformStorageBuffer = function () {
        function UniformStorageBuffer(set, binding, name, count, memoryAccess) {
          if (set === void 0) {
            set = 0;
          }

          if (binding === void 0) {
            binding = 0;
          }

          if (name === void 0) {
            name = '';
          }

          if (count === void 0) {
            count = 0;
          }

          if (memoryAccess === void 0) {
            memoryAccess = MemoryAccessBit.READ_WRITE;
          }

          this.set = set;
          this.binding = binding;
          this.name = name;
          this.count = count;
          this.memoryAccess = memoryAccess;
        }

        var _proto30 = UniformStorageBuffer.prototype;

        _proto30.copy = function copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.count = info.count;
          this.memoryAccess = info.memoryAccess;
          return this;
        };

        return UniformStorageBuffer;
      }();
      var UniformInputAttachment = function () {
        function UniformInputAttachment(set, binding, name, count) {
          if (set === void 0) {
            set = 0;
          }

          if (binding === void 0) {
            binding = 0;
          }

          if (name === void 0) {
            name = '';
          }

          if (count === void 0) {
            count = 0;
          }

          this.set = set;
          this.binding = binding;
          this.name = name;
          this.count = count;
        }

        var _proto31 = UniformInputAttachment.prototype;

        _proto31.copy = function copy(info) {
          this.set = info.set;
          this.binding = info.binding;
          this.name = info.name;
          this.count = info.count;
          return this;
        };

        return UniformInputAttachment;
      }();
      var ShaderStage = function () {
        function ShaderStage(stage, source) {
          if (stage === void 0) {
            stage = ShaderStageFlagBit.NONE;
          }

          if (source === void 0) {
            source = '';
          }

          this.stage = stage;
          this.source = source;
        }

        var _proto32 = ShaderStage.prototype;

        _proto32.copy = function copy(info) {
          this.stage = info.stage;
          this.source = info.source;
          return this;
        };

        return ShaderStage;
      }();
      var Attribute = function () {
        function Attribute(name, format, isNormalized, stream, isInstanced, location) {
          if (name === void 0) {
            name = '';
          }

          if (format === void 0) {
            format = Format.UNKNOWN;
          }

          if (isNormalized === void 0) {
            isNormalized = false;
          }

          if (stream === void 0) {
            stream = 0;
          }

          if (isInstanced === void 0) {
            isInstanced = false;
          }

          if (location === void 0) {
            location = 0;
          }

          this.name = name;
          this.format = format;
          this.isNormalized = isNormalized;
          this.stream = stream;
          this.isInstanced = isInstanced;
          this.location = location;
        }

        var _proto33 = Attribute.prototype;

        _proto33.copy = function copy(info) {
          this.name = info.name;
          this.format = info.format;
          this.isNormalized = info.isNormalized;
          this.stream = info.stream;
          this.isInstanced = info.isInstanced;
          this.location = info.location;
          return this;
        };

        return Attribute;
      }();
      var ShaderInfo = function () {
        function ShaderInfo(name, stages, attributes, blocks, buffers, samplerTextures, samplers, textures, images, subpassInputs) {
          if (name === void 0) {
            name = '';
          }

          if (stages === void 0) {
            stages = [];
          }

          if (attributes === void 0) {
            attributes = [];
          }

          if (blocks === void 0) {
            blocks = [];
          }

          if (buffers === void 0) {
            buffers = [];
          }

          if (samplerTextures === void 0) {
            samplerTextures = [];
          }

          if (samplers === void 0) {
            samplers = [];
          }

          if (textures === void 0) {
            textures = [];
          }

          if (images === void 0) {
            images = [];
          }

          if (subpassInputs === void 0) {
            subpassInputs = [];
          }

          this.name = name;
          this.stages = stages;
          this.attributes = attributes;
          this.blocks = blocks;
          this.buffers = buffers;
          this.samplerTextures = samplerTextures;
          this.samplers = samplers;
          this.textures = textures;
          this.images = images;
          this.subpassInputs = subpassInputs;
        }

        var _proto34 = ShaderInfo.prototype;

        _proto34.copy = function copy(info) {
          this.name = info.name;
          deepCopy(this.stages, info.stages, ShaderStage);
          deepCopy(this.attributes, info.attributes, Attribute);
          deepCopy(this.blocks, info.blocks, UniformBlock);
          deepCopy(this.buffers, info.buffers, UniformStorageBuffer);
          deepCopy(this.samplerTextures, info.samplerTextures, UniformSamplerTexture);
          deepCopy(this.samplers, info.samplers, UniformSampler);
          deepCopy(this.textures, info.textures, UniformTexture);
          deepCopy(this.images, info.images, UniformStorageImage);
          deepCopy(this.subpassInputs, info.subpassInputs, UniformInputAttachment);
          return this;
        };

        return ShaderInfo;
      }();
      var InputAssemblerInfo = function () {
        function InputAssemblerInfo(attributes, vertexBuffers, indexBuffer, indirectBuffer) {
          if (attributes === void 0) {
            attributes = [];
          }

          if (vertexBuffers === void 0) {
            vertexBuffers = [];
          }

          if (indexBuffer === void 0) {
            indexBuffer = null;
          }

          if (indirectBuffer === void 0) {
            indirectBuffer = null;
          }

          this.attributes = attributes;
          this.vertexBuffers = vertexBuffers;
          this.indexBuffer = indexBuffer;
          this.indirectBuffer = indirectBuffer;
        }

        var _proto35 = InputAssemblerInfo.prototype;

        _proto35.copy = function copy(info) {
          deepCopy(this.attributes, info.attributes, Attribute);
          this.vertexBuffers = info.vertexBuffers.slice();
          this.indexBuffer = info.indexBuffer;
          this.indirectBuffer = info.indirectBuffer;
          return this;
        };

        return InputAssemblerInfo;
      }();
      var ColorAttachment = function () {
        function ColorAttachment(format, sampleCount, loadOp, storeOp, barrier, isGeneralLayout) {
          if (format === void 0) {
            format = Format.UNKNOWN;
          }

          if (sampleCount === void 0) {
            sampleCount = SampleCount.ONE;
          }

          if (loadOp === void 0) {
            loadOp = LoadOp.CLEAR;
          }

          if (storeOp === void 0) {
            storeOp = StoreOp.STORE;
          }

          if (barrier === void 0) {
            barrier = null;
          }

          if (isGeneralLayout === void 0) {
            isGeneralLayout = false;
          }

          this.format = format;
          this.sampleCount = sampleCount;
          this.loadOp = loadOp;
          this.storeOp = storeOp;
          this.barrier = barrier;
          this.isGeneralLayout = isGeneralLayout;
        }

        var _proto36 = ColorAttachment.prototype;

        _proto36.copy = function copy(info) {
          this.format = info.format;
          this.sampleCount = info.sampleCount;
          this.loadOp = info.loadOp;
          this.storeOp = info.storeOp;
          this.barrier = info.barrier;
          this.isGeneralLayout = info.isGeneralLayout;
          return this;
        };

        return ColorAttachment;
      }();
      var DepthStencilAttachment = function () {
        function DepthStencilAttachment(format, sampleCount, depthLoadOp, depthStoreOp, stencilLoadOp, stencilStoreOp, barrier, isGeneralLayout) {
          if (format === void 0) {
            format = Format.UNKNOWN;
          }

          if (sampleCount === void 0) {
            sampleCount = SampleCount.ONE;
          }

          if (depthLoadOp === void 0) {
            depthLoadOp = LoadOp.CLEAR;
          }

          if (depthStoreOp === void 0) {
            depthStoreOp = StoreOp.STORE;
          }

          if (stencilLoadOp === void 0) {
            stencilLoadOp = LoadOp.CLEAR;
          }

          if (stencilStoreOp === void 0) {
            stencilStoreOp = StoreOp.STORE;
          }

          if (barrier === void 0) {
            barrier = null;
          }

          if (isGeneralLayout === void 0) {
            isGeneralLayout = false;
          }

          this.format = format;
          this.sampleCount = sampleCount;
          this.depthLoadOp = depthLoadOp;
          this.depthStoreOp = depthStoreOp;
          this.stencilLoadOp = stencilLoadOp;
          this.stencilStoreOp = stencilStoreOp;
          this.barrier = barrier;
          this.isGeneralLayout = isGeneralLayout;
        }

        var _proto37 = DepthStencilAttachment.prototype;

        _proto37.copy = function copy(info) {
          this.format = info.format;
          this.sampleCount = info.sampleCount;
          this.depthLoadOp = info.depthLoadOp;
          this.depthStoreOp = info.depthStoreOp;
          this.stencilLoadOp = info.stencilLoadOp;
          this.stencilStoreOp = info.stencilStoreOp;
          this.barrier = info.barrier;
          this.isGeneralLayout = info.isGeneralLayout;
          return this;
        };

        return DepthStencilAttachment;
      }();
      var SubpassInfo = function () {
        function SubpassInfo(inputs, colors, resolves, preserves, depthStencil, depthStencilResolve, depthResolveMode, stencilResolveMode) {
          if (inputs === void 0) {
            inputs = [];
          }

          if (colors === void 0) {
            colors = [];
          }

          if (resolves === void 0) {
            resolves = [];
          }

          if (preserves === void 0) {
            preserves = [];
          }

          if (depthStencil === void 0) {
            depthStencil = -1;
          }

          if (depthStencilResolve === void 0) {
            depthStencilResolve = -1;
          }

          if (depthResolveMode === void 0) {
            depthResolveMode = ResolveMode.NONE;
          }

          if (stencilResolveMode === void 0) {
            stencilResolveMode = ResolveMode.NONE;
          }

          this.inputs = inputs;
          this.colors = colors;
          this.resolves = resolves;
          this.preserves = preserves;
          this.depthStencil = depthStencil;
          this.depthStencilResolve = depthStencilResolve;
          this.depthResolveMode = depthResolveMode;
          this.stencilResolveMode = stencilResolveMode;
        }

        var _proto38 = SubpassInfo.prototype;

        _proto38.copy = function copy(info) {
          this.inputs = info.inputs.slice();
          this.colors = info.colors.slice();
          this.resolves = info.resolves.slice();
          this.preserves = info.preserves.slice();
          this.depthStencil = info.depthStencil;
          this.depthStencilResolve = info.depthStencilResolve;
          this.depthResolveMode = info.depthResolveMode;
          this.stencilResolveMode = info.stencilResolveMode;
          return this;
        };

        return SubpassInfo;
      }();
      var SubpassDependency = function () {
        function SubpassDependency(srcSubpass, dstSubpass, barrier) {
          if (srcSubpass === void 0) {
            srcSubpass = 0;
          }

          if (dstSubpass === void 0) {
            dstSubpass = 0;
          }

          if (barrier === void 0) {
            barrier = null;
          }

          this.srcSubpass = srcSubpass;
          this.dstSubpass = dstSubpass;
          this.barrier = barrier;
        }

        var _proto39 = SubpassDependency.prototype;

        _proto39.copy = function copy(info) {
          this.srcSubpass = info.srcSubpass;
          this.dstSubpass = info.dstSubpass;
          this.barrier = info.barrier;
          return this;
        };

        return SubpassDependency;
      }();
      var RenderPassInfo = function () {
        function RenderPassInfo(colorAttachments, depthStencilAttachment, subpasses, dependencies) {
          if (colorAttachments === void 0) {
            colorAttachments = [];
          }

          if (depthStencilAttachment === void 0) {
            depthStencilAttachment = new DepthStencilAttachment();
          }

          if (subpasses === void 0) {
            subpasses = [];
          }

          if (dependencies === void 0) {
            dependencies = [];
          }

          this.colorAttachments = colorAttachments;
          this.depthStencilAttachment = depthStencilAttachment;
          this.subpasses = subpasses;
          this.dependencies = dependencies;
        }

        var _proto40 = RenderPassInfo.prototype;

        _proto40.copy = function copy(info) {
          deepCopy(this.colorAttachments, info.colorAttachments, ColorAttachment);
          this.depthStencilAttachment.copy(info.depthStencilAttachment);
          deepCopy(this.subpasses, info.subpasses, SubpassInfo);
          deepCopy(this.dependencies, info.dependencies, SubpassDependency);
          return this;
        };

        return RenderPassInfo;
      }();
      var GeneralBarrierInfo = function () {
        function GeneralBarrierInfo(prevAccesses, nextAccesses) {
          if (prevAccesses === void 0) {
            prevAccesses = AccessFlagBit.NONE;
          }

          if (nextAccesses === void 0) {
            nextAccesses = AccessFlagBit.NONE;
          }

          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
        }

        var _proto41 = GeneralBarrierInfo.prototype;

        _proto41.copy = function copy(info) {
          this.prevAccesses = info.prevAccesses;
          this.nextAccesses = info.nextAccesses;
          return this;
        };

        return GeneralBarrierInfo;
      }();
      var TextureBarrierInfo = function () {
        function TextureBarrierInfo(prevAccesses, nextAccesses, discardContents, srcQueue, dstQueue) {
          if (prevAccesses === void 0) {
            prevAccesses = AccessFlagBit.NONE;
          }

          if (nextAccesses === void 0) {
            nextAccesses = AccessFlagBit.NONE;
          }

          if (discardContents === void 0) {
            discardContents = false;
          }

          if (srcQueue === void 0) {
            srcQueue = null;
          }

          if (dstQueue === void 0) {
            dstQueue = null;
          }

          this.prevAccesses = prevAccesses;
          this.nextAccesses = nextAccesses;
          this.discardContents = discardContents;
          this.srcQueue = srcQueue;
          this.dstQueue = dstQueue;
        }

        var _proto42 = TextureBarrierInfo.prototype;

        _proto42.copy = function copy(info) {
          this.prevAccesses = info.prevAccesses;
          this.nextAccesses = info.nextAccesses;
          this.discardContents = info.discardContents;
          this.srcQueue = info.srcQueue;
          this.dstQueue = info.dstQueue;
          return this;
        };

        return TextureBarrierInfo;
      }();
      var FramebufferInfo = function () {
        function FramebufferInfo(renderPass, colorTextures, depthStencilTexture) {
          if (renderPass === void 0) {
            renderPass = null;
          }

          if (colorTextures === void 0) {
            colorTextures = [];
          }

          if (depthStencilTexture === void 0) {
            depthStencilTexture = null;
          }

          this.renderPass = renderPass;
          this.colorTextures = colorTextures;
          this.depthStencilTexture = depthStencilTexture;
        }

        var _proto43 = FramebufferInfo.prototype;

        _proto43.copy = function copy(info) {
          this.renderPass = info.renderPass;
          this.colorTextures = info.colorTextures.slice();
          this.depthStencilTexture = info.depthStencilTexture;
          return this;
        };

        return FramebufferInfo;
      }();
      var DescriptorSetLayoutBinding = function () {
        function DescriptorSetLayoutBinding(binding, descriptorType, count, stageFlags, immutableSamplers) {
          if (binding === void 0) {
            binding = -1;
          }

          if (descriptorType === void 0) {
            descriptorType = DescriptorType.UNKNOWN;
          }

          if (count === void 0) {
            count = 0;
          }

          if (stageFlags === void 0) {
            stageFlags = ShaderStageFlagBit.NONE;
          }

          if (immutableSamplers === void 0) {
            immutableSamplers = [];
          }

          this.binding = binding;
          this.descriptorType = descriptorType;
          this.count = count;
          this.stageFlags = stageFlags;
          this.immutableSamplers = immutableSamplers;
        }

        var _proto44 = DescriptorSetLayoutBinding.prototype;

        _proto44.copy = function copy(info) {
          this.binding = info.binding;
          this.descriptorType = info.descriptorType;
          this.count = info.count;
          this.stageFlags = info.stageFlags;
          this.immutableSamplers = info.immutableSamplers.slice();
          return this;
        };

        return DescriptorSetLayoutBinding;
      }();
      var DescriptorSetLayoutInfo = function () {
        function DescriptorSetLayoutInfo(bindings) {
          if (bindings === void 0) {
            bindings = [];
          }

          this.bindings = bindings;
        }

        var _proto45 = DescriptorSetLayoutInfo.prototype;

        _proto45.copy = function copy(info) {
          deepCopy(this.bindings, info.bindings, DescriptorSetLayoutBinding);
          return this;
        };

        return DescriptorSetLayoutInfo;
      }();
      var DescriptorSetInfo = function () {
        function DescriptorSetInfo(layout) {
          if (layout === void 0) {
            layout = null;
          }

          this.layout = layout;
        }

        var _proto46 = DescriptorSetInfo.prototype;

        _proto46.copy = function copy(info) {
          this.layout = info.layout;
          return this;
        };

        return DescriptorSetInfo;
      }();
      var PipelineLayoutInfo = function () {
        function PipelineLayoutInfo(setLayouts) {
          if (setLayouts === void 0) {
            setLayouts = [];
          }

          this.setLayouts = setLayouts;
        }

        var _proto47 = PipelineLayoutInfo.prototype;

        _proto47.copy = function copy(info) {
          this.setLayouts = info.setLayouts.slice();
          return this;
        };

        return PipelineLayoutInfo;
      }();
      var InputState = function () {
        function InputState(attributes) {
          if (attributes === void 0) {
            attributes = [];
          }

          this.attributes = attributes;
        }

        var _proto48 = InputState.prototype;

        _proto48.copy = function copy(info) {
          deepCopy(this.attributes, info.attributes, Attribute);
          return this;
        };

        return InputState;
      }();
      var CommandBufferInfo = function () {
        function CommandBufferInfo(queue, type) {
          if (queue === void 0) {
            queue = null;
          }

          if (type === void 0) {
            type = CommandBufferType.PRIMARY;
          }

          this.queue = queue;
          this.type = type;
        }

        var _proto49 = CommandBufferInfo.prototype;

        _proto49.copy = function copy(info) {
          this.queue = info.queue;
          this.type = info.type;
          return this;
        };

        return CommandBufferInfo;
      }();
      var QueueInfo = function () {
        function QueueInfo(type) {
          if (type === void 0) {
            type = QueueType.GRAPHICS;
          }

          this.type = type;
        }

        var _proto50 = QueueInfo.prototype;

        _proto50.copy = function copy(info) {
          this.type = info.type;
          return this;
        };

        return QueueInfo;
      }();
      var QueryPoolInfo = function () {
        function QueryPoolInfo(type, maxQueryObjects, forceWait) {
          if (type === void 0) {
            type = QueryType.OCCLUSION;
          }

          if (maxQueryObjects === void 0) {
            maxQueryObjects = 32767;
          }

          if (forceWait === void 0) {
            forceWait = true;
          }

          this.type = type;
          this.maxQueryObjects = maxQueryObjects;
          this.forceWait = forceWait;
        }

        var _proto51 = QueryPoolInfo.prototype;

        _proto51.copy = function copy(info) {
          this.type = info.type;
          this.maxQueryObjects = info.maxQueryObjects;
          this.forceWait = info.forceWait;
          return this;
        };

        return QueryPoolInfo;
      }();
      var FormatInfo = function FormatInfo(name, size, count, type, hasAlpha, hasDepth, hasStencil, isCompressed) {
        if (name === void 0) {
          name = '';
        }

        if (size === void 0) {
          size = 0;
        }

        if (count === void 0) {
          count = 0;
        }

        if (type === void 0) {
          type = FormatType.NONE;
        }

        if (hasAlpha === void 0) {
          hasAlpha = false;
        }

        if (hasDepth === void 0) {
          hasDepth = false;
        }

        if (hasStencil === void 0) {
          hasStencil = false;
        }

        if (isCompressed === void 0) {
          isCompressed = false;
        }

        this.name = name;
        this.size = size;
        this.count = count;
        this.type = type;
        this.hasAlpha = hasAlpha;
        this.hasDepth = hasDepth;
        this.hasStencil = hasStencil;
        this.isCompressed = isCompressed;
      };
      var MemoryStatus = function () {
        function MemoryStatus(bufferSize, textureSize) {
          if (bufferSize === void 0) {
            bufferSize = 0;
          }

          if (textureSize === void 0) {
            textureSize = 0;
          }

          this.bufferSize = bufferSize;
          this.textureSize = textureSize;
        }

        var _proto52 = MemoryStatus.prototype;

        _proto52.copy = function copy(info) {
          this.bufferSize = info.bufferSize;
          this.textureSize = info.textureSize;
          return this;
        };

        return MemoryStatus;
      }();
      var DynamicStencilStates = function () {
        function DynamicStencilStates(writeMask, compareMask, reference) {
          if (writeMask === void 0) {
            writeMask = 0;
          }

          if (compareMask === void 0) {
            compareMask = 0;
          }

          if (reference === void 0) {
            reference = 0;
          }

          this.writeMask = writeMask;
          this.compareMask = compareMask;
          this.reference = reference;
        }

        var _proto53 = DynamicStencilStates.prototype;

        _proto53.copy = function copy(info) {
          this.writeMask = info.writeMask;
          this.compareMask = info.compareMask;
          this.reference = info.reference;
          return this;
        };

        return DynamicStencilStates;
      }();
      var DynamicStates = function () {
        function DynamicStates(viewport, scissor, blendConstant, lineWidth, depthBiasConstant, depthBiasClamp, depthBiasSlope, depthMinBounds, depthMaxBounds, stencilStatesFront, stencilStatesBack) {
          if (viewport === void 0) {
            viewport = new Viewport();
          }

          if (scissor === void 0) {
            scissor = new Rect$1();
          }

          if (blendConstant === void 0) {
            blendConstant = new Color$1();
          }

          if (lineWidth === void 0) {
            lineWidth = 1;
          }

          if (depthBiasConstant === void 0) {
            depthBiasConstant = 0;
          }

          if (depthBiasClamp === void 0) {
            depthBiasClamp = 0;
          }

          if (depthBiasSlope === void 0) {
            depthBiasSlope = 0;
          }

          if (depthMinBounds === void 0) {
            depthMinBounds = 0;
          }

          if (depthMaxBounds === void 0) {
            depthMaxBounds = 0;
          }

          if (stencilStatesFront === void 0) {
            stencilStatesFront = new DynamicStencilStates();
          }

          if (stencilStatesBack === void 0) {
            stencilStatesBack = new DynamicStencilStates();
          }

          this.viewport = viewport;
          this.scissor = scissor;
          this.blendConstant = blendConstant;
          this.lineWidth = lineWidth;
          this.depthBiasConstant = depthBiasConstant;
          this.depthBiasClamp = depthBiasClamp;
          this.depthBiasSlope = depthBiasSlope;
          this.depthMinBounds = depthMinBounds;
          this.depthMaxBounds = depthMaxBounds;
          this.stencilStatesFront = stencilStatesFront;
          this.stencilStatesBack = stencilStatesBack;
        }

        var _proto54 = DynamicStates.prototype;

        _proto54.copy = function copy(info) {
          this.viewport.copy(info.viewport);
          this.scissor.copy(info.scissor);
          this.blendConstant.copy(info.blendConstant);
          this.lineWidth = info.lineWidth;
          this.depthBiasConstant = info.depthBiasConstant;
          this.depthBiasClamp = info.depthBiasClamp;
          this.depthBiasSlope = info.depthBiasSlope;
          this.depthMinBounds = info.depthMinBounds;
          this.depthMaxBounds = info.depthMaxBounds;
          this.stencilStatesFront.copy(info.stencilStatesFront);
          this.stencilStatesBack.copy(info.stencilStatesBack);
          return this;
        };

        return DynamicStates;
      }();
      var GFXObject = function (_GCObject) {
        _inheritsLoose(GFXObject, _GCObject);

        function GFXObject(objectType) {
          var _this;

          _this = _GCObject.call(this) || this;
          _this._objectType = ObjectType.UNKNOWN;
          _this._objectID = 0;
          _this._typedID = 0;
          _this._objectType = objectType;
          _this._objectID = GFXObject._idTable[ObjectType.UNKNOWN]++;
          _this._typedID = GFXObject._idTable[objectType]++;
          return _this;
        }

        _createClass(GFXObject, [{
          key: "objectType",
          get: function get() {
            return this._objectType;
          }
        }, {
          key: "objectID",
          get: function get() {
            return this._objectID;
          }
        }, {
          key: "typedID",
          get: function get() {
            return this._typedID;
          }
        }]);

        return GFXObject;
      }(GCObject);
      GFXObject._idTable = Array(ObjectType.COUNT).fill(1 << 16);
      var AttributeName;

      (function (AttributeName) {
        AttributeName["ATTR_POSITION"] = "a_position";
        AttributeName["ATTR_NORMAL"] = "a_normal";
        AttributeName["ATTR_TANGENT"] = "a_tangent";
        AttributeName["ATTR_BITANGENT"] = "a_bitangent";
        AttributeName["ATTR_WEIGHTS"] = "a_weights";
        AttributeName["ATTR_JOINTS"] = "a_joints";
        AttributeName["ATTR_COLOR"] = "a_color";
        AttributeName["ATTR_COLOR1"] = "a_color1";
        AttributeName["ATTR_COLOR2"] = "a_color2";
        AttributeName["ATTR_TEX_COORD"] = "a_texCoord";
        AttributeName["ATTR_TEX_COORD1"] = "a_texCoord1";
        AttributeName["ATTR_TEX_COORD2"] = "a_texCoord2";
        AttributeName["ATTR_TEX_COORD3"] = "a_texCoord3";
        AttributeName["ATTR_TEX_COORD4"] = "a_texCoord4";
        AttributeName["ATTR_TEX_COORD5"] = "a_texCoord5";
        AttributeName["ATTR_TEX_COORD6"] = "a_texCoord6";
        AttributeName["ATTR_TEX_COORD7"] = "a_texCoord7";
        AttributeName["ATTR_TEX_COORD8"] = "a_texCoord8";
        AttributeName["ATTR_BATCH_ID"] = "a_batch_id";
        AttributeName["ATTR_BATCH_UV"] = "a_batch_uv";
      })(AttributeName || (AttributeName = {}));

      var FormatInfos = Object.freeze([new FormatInfo('UNKNOWN', 0, 0, FormatType.NONE, false, false, false, false), new FormatInfo('A8', 1, 1, FormatType.UNORM, true, false, false, false), new FormatInfo('L8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('LA8', 1, 2, FormatType.UNORM, true, false, false, false), new FormatInfo('R8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('R8SN', 1, 1, FormatType.SNORM, false, false, false, false), new FormatInfo('R8UI', 1, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R8I', 1, 1, FormatType.INT, false, false, false, false), new FormatInfo('R16F', 2, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R16UI', 2, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R16I', 2, 1, FormatType.INT, false, false, false, false), new FormatInfo('R32F', 4, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R32UI', 4, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R32I', 4, 1, FormatType.INT, false, false, false, false), new FormatInfo('RG8', 2, 2, FormatType.UNORM, false, false, false, false), new FormatInfo('RG8SN', 2, 2, FormatType.SNORM, false, false, false, false), new FormatInfo('RG8UI', 2, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG8I', 2, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG16F', 4, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG16UI', 4, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG16I', 4, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG32F', 8, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG32UI', 8, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG32I', 8, 2, FormatType.INT, false, false, false, false), new FormatInfo('RGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('SRGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('RGB8SN', 3, 3, FormatType.SNORM, false, false, false, false), new FormatInfo('RGB8UI', 3, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB8I', 3, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB16F', 6, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB16UI', 6, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB16I', 6, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB32F', 12, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB32UI', 12, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB32I', 12, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGBA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('BGRA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('SRGB8_A8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA8SN', 4, 4, FormatType.SNORM, true, false, false, false), new FormatInfo('RGBA8UI', 4, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA8I', 4, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA16F', 8, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA16UI', 8, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA16I', 8, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA32F', 16, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA32UI', 16, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA32I', 16, 4, FormatType.INT, true, false, false, false), new FormatInfo('R5G6B5', 2, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('R11G11B10F', 4, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB5A1', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA4', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2UI', 2, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGB9E5', 2, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('DEPTH', 4, 1, FormatType.FLOAT, false, true, false, false), new FormatInfo('DEPTH_STENCIL', 5, 2, FormatType.FLOAT, false, true, true, false), new FormatInfo('BC1', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC1_SRGB', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_SRGB_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC4', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('BC4_SNORM', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('BC5', 1, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('BC5_SNORM', 1, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('BC6H_UF16', 1, 3, FormatType.UFLOAT, false, false, false, true), new FormatInfo('BC6H_SF16', 1, 3, FormatType.FLOAT, false, false, false, true), new FormatInfo('BC7', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC7_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_SRGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_RGBA8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('EAC_R11', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_R11SN', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('EAC_RG11', 2, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_RG11SN', 2, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('PVRTC_RGB2', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA2', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC_RGB4', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA4', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_2BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_4BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true)]);
      var DESCRIPTOR_BUFFER_TYPE = DescriptorType.UNIFORM_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER | DescriptorType.STORAGE_BUFFER | DescriptorType.DYNAMIC_STORAGE_BUFFER;
      var DESCRIPTOR_SAMPLER_TYPE = DescriptorType.SAMPLER_TEXTURE | DescriptorType.SAMPLER | DescriptorType.TEXTURE | DescriptorType.STORAGE_IMAGE | DescriptorType.INPUT_ATTACHMENT;
      var DESCRIPTOR_DYNAMIC_TYPE = DescriptorType.DYNAMIC_STORAGE_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER;
      var DRAW_INFO_SIZE = 28;
      function IsPowerOf2(x) {
        return x > 0 && (x & x - 1) === 0;
      }
      function FormatSize(format, width, height, depth) {
        if (!FormatInfos[format].isCompressed) {
          return width * height * depth * FormatInfos[format].size;
        } else {
          switch (format) {
            case Format.BC1:
            case Format.BC1_ALPHA:
            case Format.BC1_SRGB:
            case Format.BC1_SRGB_ALPHA:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

            case Format.BC2:
            case Format.BC2_SRGB:
            case Format.BC3:
            case Format.BC3_SRGB:
            case Format.BC4:
            case Format.BC4_SNORM:
            case Format.BC6H_SF16:
            case Format.BC6H_UF16:
            case Format.BC7:
            case Format.BC7_SRGB:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

            case Format.BC5:
            case Format.BC5_SNORM:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

            case Format.ETC_RGB8:
            case Format.ETC2_RGB8:
            case Format.ETC2_SRGB8:
            case Format.ETC2_RGB8_A1:
            case Format.EAC_R11:
            case Format.EAC_R11SN:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

            case Format.ETC2_RGBA8:
            case Format.ETC2_SRGB8_A1:
            case Format.EAC_RG11:
            case Format.EAC_RG11SN:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

            case Format.PVRTC_RGB2:
            case Format.PVRTC_RGBA2:
            case Format.PVRTC2_2BPP:
              return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

            case Format.PVRTC_RGB4:
            case Format.PVRTC_RGBA4:
            case Format.PVRTC2_4BPP:
              return Math.ceil(Math.max(width, 8) * Math.max(height, 8) / 2) * depth;

            case Format.ASTC_RGBA_4X4:
            case Format.ASTC_SRGBA_4X4:
              return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

            case Format.ASTC_RGBA_5X4:
            case Format.ASTC_SRGBA_5X4:
              return Math.ceil(width / 5) * Math.ceil(height / 4) * 16 * depth;

            case Format.ASTC_RGBA_5X5:
            case Format.ASTC_SRGBA_5X5:
              return Math.ceil(width / 5) * Math.ceil(height / 5) * 16 * depth;

            case Format.ASTC_RGBA_6X5:
            case Format.ASTC_SRGBA_6X5:
              return Math.ceil(width / 6) * Math.ceil(height / 5) * 16 * depth;

            case Format.ASTC_RGBA_6X6:
            case Format.ASTC_SRGBA_6X6:
              return Math.ceil(width / 6) * Math.ceil(height / 6) * 16 * depth;

            case Format.ASTC_RGBA_8X5:
            case Format.ASTC_SRGBA_8X5:
              return Math.ceil(width / 8) * Math.ceil(height / 5) * 16 * depth;

            case Format.ASTC_RGBA_8X6:
            case Format.ASTC_SRGBA_8X6:
              return Math.ceil(width / 8) * Math.ceil(height / 6) * 16 * depth;

            case Format.ASTC_RGBA_8X8:
            case Format.ASTC_SRGBA_8X8:
              return Math.ceil(width / 8) * Math.ceil(height / 8) * 16 * depth;

            case Format.ASTC_RGBA_10X5:
            case Format.ASTC_SRGBA_10X5:
              return Math.ceil(width / 10) * Math.ceil(height / 5) * 16 * depth;

            case Format.ASTC_RGBA_10X6:
            case Format.ASTC_SRGBA_10X6:
              return Math.ceil(width / 10) * Math.ceil(height / 6) * 16 * depth;

            case Format.ASTC_RGBA_10X8:
            case Format.ASTC_SRGBA_10X8:
              return Math.ceil(width / 10) * Math.ceil(height / 8) * 16 * depth;

            case Format.ASTC_RGBA_10X10:
            case Format.ASTC_SRGBA_10X10:
              return Math.ceil(width / 10) * Math.ceil(height / 10) * 16 * depth;

            case Format.ASTC_RGBA_12X10:
            case Format.ASTC_SRGBA_12X10:
              return Math.ceil(width / 12) * Math.ceil(height / 10) * 16 * depth;

            case Format.ASTC_RGBA_12X12:
            case Format.ASTC_SRGBA_12X12:
              return Math.ceil(width / 12) * Math.ceil(height / 12) * 16 * depth;

            default:
              {
                return 0;
              }
          }
        }
      }
      function FormatSurfaceSize(format, width, height, depth, mips) {
        var size = 0;

        for (var i = 0; i < mips; ++i) {
          size += FormatSize(format, width, height, depth);
          width = Math.max(width >> 1, 1);
          height = Math.max(height >> 1, 1);
        }

        return size;
      }
      var _type2size = [0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4];
      function GetTypeSize(type) {
        return _type2size[type] || 0;
      }
      function getTypedArrayConstructor(info) {
        var stride = info.size / info.count;

        switch (info.type) {
          case FormatType.UNORM:
          case FormatType.UINT:
            {
              switch (stride) {
                case 1:
                  return Uint8Array;

                case 2:
                  return Uint16Array;

                case 4:
                  return Uint32Array;
              }

              break;
            }

          case FormatType.SNORM:
          case FormatType.INT:
            {
              switch (stride) {
                case 1:
                  return Int8Array;

                case 2:
                  return Int16Array;

                case 4:
                  return Int32Array;
              }

              break;
            }

          case FormatType.FLOAT:
            {
              return Float32Array;
            }
        }

        return Float32Array;
      }

      var defines = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get ObjectType () { return ObjectType; },
        get Status () { return Status; },
        get API () { return API; },
        get SurfaceTransform () { return SurfaceTransform; },
        get Feature () { return Feature; },
        get Format () { return Format; },
        get FormatType () { return FormatType; },
        get Type () { return Type; },
        get BufferUsageBit () { return BufferUsageBit; },
        get BufferFlagBit () { return BufferFlagBit; },
        get MemoryAccessBit () { return MemoryAccessBit; },
        get MemoryUsageBit () { return MemoryUsageBit; },
        get TextureType () { return TextureType; },
        get TextureUsageBit () { return TextureUsageBit; },
        get TextureFlagBit () { return TextureFlagBit; },
        get FormatFeatureBit () { return FormatFeatureBit; },
        get SampleCount () { return SampleCount; },
        get VsyncMode () { return VsyncMode; },
        get Filter () { return Filter; },
        get Address () { return Address; },
        get ComparisonFunc () { return ComparisonFunc; },
        get StencilOp () { return StencilOp; },
        get BlendFactor () { return BlendFactor; },
        get BlendOp () { return BlendOp; },
        get ColorMask () { return ColorMask; },
        get ShaderStageFlagBit () { return ShaderStageFlagBit; },
        get LoadOp () { return LoadOp; },
        get StoreOp () { return StoreOp; },
        get AccessFlagBit () { return AccessFlagBit; },
        get ResolveMode () { return ResolveMode; },
        get PipelineBindPoint () { return PipelineBindPoint; },
        get PrimitiveMode () { return PrimitiveMode; },
        get PolygonMode () { return PolygonMode; },
        get ShadeModel () { return ShadeModel; },
        get CullMode () { return CullMode; },
        get DynamicStateFlagBit () { return DynamicStateFlagBit; },
        get StencilFace () { return StencilFace; },
        get DescriptorType () { return DescriptorType; },
        get QueueType () { return QueueType; },
        get QueryType () { return QueryType; },
        get CommandBufferType () { return CommandBufferType; },
        get ClearFlagBit () { return ClearFlagBit; },
        Size: Size$1,
        DeviceCaps: DeviceCaps,
        Offset: Offset,
        Rect: Rect$1,
        Extent: Extent,
        TextureSubresLayers: TextureSubresLayers,
        TextureSubresRange: TextureSubresRange,
        TextureCopy: TextureCopy,
        TextureBlit: TextureBlit,
        BufferTextureCopy: BufferTextureCopy,
        Viewport: Viewport,
        Color: Color$1,
        BindingMappingInfo: BindingMappingInfo,
        SwapchainInfo: SwapchainInfo,
        DeviceInfo: DeviceInfo,
        BufferInfo: BufferInfo,
        BufferViewInfo: BufferViewInfo,
        DrawInfo: DrawInfo,
        DispatchInfo: DispatchInfo,
        IndirectBuffer: IndirectBuffer,
        TextureInfo: TextureInfo,
        TextureViewInfo: TextureViewInfo,
        SamplerInfo: SamplerInfo,
        Uniform: Uniform,
        UniformBlock: UniformBlock,
        UniformSamplerTexture: UniformSamplerTexture,
        UniformSampler: UniformSampler,
        UniformTexture: UniformTexture,
        UniformStorageImage: UniformStorageImage,
        UniformStorageBuffer: UniformStorageBuffer,
        UniformInputAttachment: UniformInputAttachment,
        ShaderStage: ShaderStage,
        Attribute: Attribute,
        ShaderInfo: ShaderInfo,
        InputAssemblerInfo: InputAssemblerInfo,
        ColorAttachment: ColorAttachment,
        DepthStencilAttachment: DepthStencilAttachment,
        SubpassInfo: SubpassInfo,
        SubpassDependency: SubpassDependency,
        RenderPassInfo: RenderPassInfo,
        GeneralBarrierInfo: GeneralBarrierInfo,
        TextureBarrierInfo: TextureBarrierInfo,
        FramebufferInfo: FramebufferInfo,
        DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
        DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
        DescriptorSetInfo: DescriptorSetInfo,
        PipelineLayoutInfo: PipelineLayoutInfo,
        InputState: InputState,
        CommandBufferInfo: CommandBufferInfo,
        QueueInfo: QueueInfo,
        QueryPoolInfo: QueryPoolInfo,
        FormatInfo: FormatInfo,
        MemoryStatus: MemoryStatus,
        DynamicStencilStates: DynamicStencilStates,
        DynamicStates: DynamicStates,
        GFXObject: GFXObject,
        get AttributeName () { return AttributeName; },
        FormatInfos: FormatInfos,
        DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
        DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
        DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
        DRAW_INFO_SIZE: DRAW_INFO_SIZE,
        IsPowerOf2: IsPowerOf2,
        FormatSize: FormatSize,
        FormatSurfaceSize: FormatSurfaceSize,
        GetTypeSize: GetTypeSize,
        getTypedArrayConstructor: getTypedArrayConstructor
      });

      var Buffer = function (_GFXObject) {
        _inheritsLoose(Buffer, _GFXObject);

        function Buffer() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.BUFFER) || this;
          _this._usage = BufferUsageBit.NONE;
          _this._memUsage = MemoryUsageBit.NONE;
          _this._size = 0;
          _this._stride = 1;
          _this._count = 0;
          _this._flags = BufferFlagBit.NONE;
          _this._isBufferView = false;
          return _this;
        }

        _createClass(Buffer, [{
          key: "usage",
          get: function get() {
            return this._usage;
          }
        }, {
          key: "memUsage",
          get: function get() {
            return this._memUsage;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          }
        }, {
          key: "stride",
          get: function get() {
            return this._stride;
          }
        }, {
          key: "count",
          get: function get() {
            return this._count;
          }
        }, {
          key: "flags",
          get: function get() {
            return this._flags;
          }
        }]);

        return Buffer;
      }(GFXObject);

      var CommandBuffer = function (_GFXObject) {
        _inheritsLoose(CommandBuffer, _GFXObject);

        function CommandBuffer() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.COMMAND_BUFFER) || this;
          _this._queue = null;
          _this._type = CommandBufferType.PRIMARY;
          _this._numDrawCalls = 0;
          _this._numInstances = 0;
          _this._numTris = 0;
          return _this;
        }

        _createClass(CommandBuffer, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }, {
          key: "queue",
          get: function get() {
            return this._queue;
          }
        }, {
          key: "numDrawCalls",
          get: function get() {
            return this._numDrawCalls;
          }
        }, {
          key: "numInstances",
          get: function get() {
            return this._numInstances;
          }
        }, {
          key: "numTris",
          get: function get() {
            return this._numTris;
          }
        }]);

        return CommandBuffer;
      }(GFXObject);

      var Device = function () {
        function Device() {
          this._gfxAPI = API.UNKNOWN;
          this._renderer = '';
          this._vendor = '';
          this._features = new Array(Feature.COUNT);
          this._formatFeatures = new Array(Format.COUNT);
          this._queue = null;
          this._cmdBuff = null;
          this._numDrawCalls = 0;
          this._numInstances = 0;
          this._numTris = 0;
          this._memoryStatus = new MemoryStatus();
          this._caps = new DeviceCaps();
          this._bindingMappingInfo = new BindingMappingInfo();
          this._samplers = new Map();
          this._generalBarrierss = new Map();
          this._textureBarriers = new Map();
        }

        var _proto = Device.prototype;

        _proto.hasFeature = function hasFeature(feature) {
          return this._features[feature];
        };

        _proto.getFormatFeatures = function getFormatFeatures(format) {
          return this._formatFeatures[format];
        };

        _createClass(Device, [{
          key: "gfxAPI",
          get: function get() {
            return this._gfxAPI;
          }
        }, {
          key: "queue",
          get: function get() {
            return this._queue;
          }
        }, {
          key: "commandBuffer",
          get: function get() {
            return this._cmdBuff;
          }
        }, {
          key: "renderer",
          get: function get() {
            return this._renderer;
          }
        }, {
          key: "vendor",
          get: function get() {
            return this._vendor;
          }
        }, {
          key: "numDrawCalls",
          get: function get() {
            return this._numDrawCalls;
          }
        }, {
          key: "numInstances",
          get: function get() {
            return this._numInstances;
          }
        }, {
          key: "numTris",
          get: function get() {
            return this._numTris;
          }
        }, {
          key: "memoryStatus",
          get: function get() {
            return this._memoryStatus;
          }
        }, {
          key: "capabilities",
          get: function get() {
            return this._caps;
          }
        }, {
          key: "bindingMappingInfo",
          get: function get() {
            return this._bindingMappingInfo;
          }
        }]);

        return Device;
      }();
      Device.canvas = void 0;

      var Swapchain = function (_GFXObject) {
        _inheritsLoose(Swapchain, _GFXObject);

        function Swapchain() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.SWAPCHAIN) || this;
          _this._transform = SurfaceTransform.IDENTITY;
          _this._colorTexture = null;
          _this._depthStencilTexture = null;
          return _this;
        }

        _createClass(Swapchain, [{
          key: "colorTexture",
          get: function get() {
            return this._colorTexture;
          }
        }, {
          key: "depthStencilTexture",
          get: function get() {
            return this._depthStencilTexture;
          }
        }, {
          key: "surfaceTransform",
          get: function get() {
            return this._transform;
          }
        }, {
          key: "width",
          get: function get() {
            return this._colorTexture.width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._colorTexture.height;
          }
        }]);

        return Swapchain;
      }(GFXObject);

      var Framebuffer = function (_GFXObject) {
        _inheritsLoose(Framebuffer, _GFXObject);

        function Framebuffer() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.FRAMEBUFFER) || this;
          _this._renderPass = null;
          _this._colorTextures = [];
          _this._depthStencilTexture = null;
          return _this;
        }

        _createClass(Framebuffer, [{
          key: "renderPass",
          get: function get() {
            return this._renderPass;
          }
        }, {
          key: "colorTextures",
          get: function get() {
            return this._colorTextures;
          }
        }, {
          key: "depthStencilTexture",
          get: function get() {
            return this._depthStencilTexture;
          }
        }]);

        return Framebuffer;
      }(GFXObject);

      var getUint8ForString = String.prototype.charCodeAt;

      function getUint8ForArray(idx) {
        return this[idx];
      }

      function murmurhash2_32_gc(input, seed) {
        var l = input.length;
        var h = seed ^ l;
        var i = 0;
        var getUint8 = typeof input === 'string' ? getUint8ForString : getUint8ForArray;

        while (l >= 4) {
          var k = getUint8.call(input, i) & 0xff | (getUint8.call(input, ++i) & 0xff) << 8 | (getUint8.call(input, ++i) & 0xff) << 16 | (getUint8.call(input, ++i) & 0xff) << 24;
          k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
          k ^= k >>> 24;
          k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
          h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
          l -= 4;
          ++i;
        }

        switch (l) {
          case 3:
            h ^= (getUint8.call(input, i + 2) & 0xff) << 16;

          case 2:
            h ^= (getUint8.call(input, i + 1) & 0xff) << 8;

          case 1:
            h ^= getUint8.call(input, i) & 0xff;
            h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
        }

        h ^= h >>> 13;
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
        h ^= h >>> 15;
        return h >>> 0;
      }

      var InputAssembler = function (_GFXObject) {
        _inheritsLoose(InputAssembler, _GFXObject);

        function InputAssembler() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.INPUT_ASSEMBLER) || this;
          _this._attributes = [];
          _this._attributesHash = 0;
          _this._vertexBuffers = [];
          _this._indexBuffer = null;
          _this._indirectBuffer = null;
          _this._drawInfo = new DrawInfo();
          return _this;
        }

        var _proto = InputAssembler.prototype;

        _proto.getVertexBuffer = function getVertexBuffer(stream) {
          if (stream === void 0) {
            stream = 0;
          }

          if (stream < this._vertexBuffers.length) {
            return this._vertexBuffers[stream];
          } else {
            return null;
          }
        };

        _proto.computeAttributesHash = function computeAttributesHash() {
          var res = 'attrs';

          for (var i = 0; i < this.attributes.length; ++i) {
            var at = this.attributes[i];
            res += "," + at.name + "," + at.format + "," + at.isNormalized + "," + at.stream + "," + at.isInstanced;
          }

          return murmurhash2_32_gc(res, 666);
        };

        _createClass(InputAssembler, [{
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "vertexBuffers",
          get: function get() {
            return this._vertexBuffers;
          }
        }, {
          key: "indexBuffer",
          get: function get() {
            return this._indexBuffer;
          }
        }, {
          key: "indirectBuffer",
          get: function get() {
            return this._indirectBuffer;
          }
        }, {
          key: "attributesHash",
          get: function get() {
            return this._attributesHash;
          }
        }, {
          key: "vertexCount",
          get: function get() {
            return this._drawInfo.vertexCount;
          },
          set: function set(count) {
            this._drawInfo.vertexCount = count;
          }
        }, {
          key: "firstVertex",
          get: function get() {
            return this._drawInfo.firstVertex;
          },
          set: function set(first) {
            this._drawInfo.firstVertex = first;
          }
        }, {
          key: "indexCount",
          get: function get() {
            return this._drawInfo.indexCount;
          },
          set: function set(count) {
            this._drawInfo.indexCount = count;
          }
        }, {
          key: "firstIndex",
          get: function get() {
            return this._drawInfo.firstIndex;
          },
          set: function set(first) {
            this._drawInfo.firstIndex = first;
          }
        }, {
          key: "vertexOffset",
          get: function get() {
            return this._drawInfo.vertexOffset;
          },
          set: function set(offset) {
            this._drawInfo.vertexOffset = offset;
          }
        }, {
          key: "instanceCount",
          get: function get() {
            return this._drawInfo.instanceCount;
          },
          set: function set(count) {
            this._drawInfo.instanceCount = count;
          }
        }, {
          key: "firstInstance",
          get: function get() {
            return this._drawInfo.firstInstance;
          },
          set: function set(first) {
            this._drawInfo.firstInstance = first;
          }
        }, {
          key: "drawInfo",
          get: function get() {
            return this._drawInfo;
          }
        }]);

        return InputAssembler;
      }(GFXObject);

      var DescriptorSet = function (_GFXObject) {
        _inheritsLoose(DescriptorSet, _GFXObject);

        function DescriptorSet() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.DESCRIPTOR_SET) || this;
          _this._layout = null;
          _this._buffers = [];
          _this._textures = [];
          _this._samplers = [];
          _this._isDirty = false;
          return _this;
        }

        var _proto = DescriptorSet.prototype;

        _proto.bindBuffer = function bindBuffer(binding, buffer, index) {
          if (index === void 0) {
            index = 0;
          }

          var bindingIndex = this._layout.bindingIndices[binding];
          var info = this._layout.bindings[bindingIndex];

          if (!info) {
            return;
          }

          if (info.descriptorType & DESCRIPTOR_BUFFER_TYPE) {
            var descriptorIndex = this._layout.descriptorIndices[binding];

            if (this._buffers[descriptorIndex + index] !== buffer) {
              this._buffers[descriptorIndex + index] = buffer;
              this._isDirty = true;
            }
          }
        };

        _proto.bindSampler = function bindSampler(binding, sampler, index) {
          if (index === void 0) {
            index = 0;
          }

          var bindingIndex = this._layout.bindingIndices[binding];
          var info = this._layout.bindings[bindingIndex];

          if (!info) {
            return;
          }

          if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
            var descriptorIndex = this._layout.descriptorIndices[binding];

            if (this._samplers[descriptorIndex + index] !== sampler) {
              this._samplers[descriptorIndex + index] = sampler;
              this._isDirty = true;
            }
          }
        };

        _proto.bindTexture = function bindTexture(binding, texture, index) {
          if (index === void 0) {
            index = 0;
          }

          var bindingIndex = this._layout.bindingIndices[binding];
          var info = this._layout.bindings[bindingIndex];

          if (!info) {
            return;
          }

          if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
            var descriptorIndex = this._layout.descriptorIndices[binding];

            if (this._textures[descriptorIndex + index] !== texture) {
              this._textures[descriptorIndex + index] = texture;
              this._isDirty = true;
            }
          }
        };

        _proto.getBuffer = function getBuffer(binding, index) {
          if (index === void 0) {
            index = 0;
          }

          var descriptorIndex = this._layout.descriptorIndices[binding];
          return this._buffers[descriptorIndex + index];
        };

        _proto.getSampler = function getSampler(binding, index) {
          if (index === void 0) {
            index = 0;
          }

          var descriptorIndex = this._layout.descriptorIndices[binding];
          return this._samplers[descriptorIndex + index];
        };

        _proto.getTexture = function getTexture(binding, index) {
          if (index === void 0) {
            index = 0;
          }

          var descriptorIndex = this._layout.descriptorIndices[binding];
          return this._textures[descriptorIndex + index];
        };

        _createClass(DescriptorSet, [{
          key: "layout",
          get: function get() {
            return this._layout;
          }
        }]);

        return DescriptorSet;
      }(GFXObject);

      var DescriptorSetLayout = function (_GFXObject) {
        _inheritsLoose(DescriptorSetLayout, _GFXObject);

        function DescriptorSetLayout() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.DESCRIPTOR_SET_LAYOUT) || this;
          _this._bindings = [];
          _this._bindingIndices = [];
          _this._descriptorIndices = [];
          return _this;
        }

        _createClass(DescriptorSetLayout, [{
          key: "bindings",
          get: function get() {
            return this._bindings;
          }
        }, {
          key: "bindingIndices",
          get: function get() {
            return this._bindingIndices;
          }
        }, {
          key: "descriptorIndices",
          get: function get() {
            return this._descriptorIndices;
          }
        }]);

        return DescriptorSetLayout;
      }(GFXObject);

      var PipelineLayout = function (_GFXObject) {
        _inheritsLoose(PipelineLayout, _GFXObject);

        function PipelineLayout() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.PIPELINE_LAYOUT) || this;
          _this._setLayouts = [];
          return _this;
        }

        _createClass(PipelineLayout, [{
          key: "setLayouts",
          get: function get() {
            return this._setLayouts;
          }
        }]);

        return PipelineLayout;
      }(GFXObject);

      var RasterizerState = function () {
        function RasterizerState(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth) {
          if (isDiscard === void 0) {
            isDiscard = false;
          }

          if (polygonMode === void 0) {
            polygonMode = PolygonMode.FILL;
          }

          if (shadeModel === void 0) {
            shadeModel = ShadeModel.GOURAND;
          }

          if (cullMode === void 0) {
            cullMode = CullMode.BACK;
          }

          if (isFrontFaceCCW === void 0) {
            isFrontFaceCCW = true;
          }

          if (depthBiasEnabled === void 0) {
            depthBiasEnabled = false;
          }

          if (depthBias === void 0) {
            depthBias = 0;
          }

          if (depthBiasClamp === void 0) {
            depthBiasClamp = 0.0;
          }

          if (depthBiasSlop === void 0) {
            depthBiasSlop = 0.0;
          }

          if (isDepthClip === void 0) {
            isDepthClip = true;
          }

          if (isMultisample === void 0) {
            isMultisample = false;
          }

          if (lineWidth === void 0) {
            lineWidth = 1.0;
          }

          this.isDiscard = isDiscard;
          this.polygonMode = polygonMode;
          this.shadeModel = shadeModel;
          this.cullMode = cullMode;
          this.isFrontFaceCCW = isFrontFaceCCW;
          this.depthBiasEnabled = depthBiasEnabled;
          this.depthBias = depthBias;
          this.depthBiasClamp = depthBiasClamp;
          this.depthBiasSlop = depthBiasSlop;
          this.isDepthClip = isDepthClip;
          this.isMultisample = isMultisample;
          this.lineWidth = lineWidth;
        }

        var _proto = RasterizerState.prototype;

        _proto.reset = function reset() {
          this.isDiscard = false;
          this.polygonMode = PolygonMode.FILL;
          this.shadeModel = ShadeModel.GOURAND;
          this.cullMode = CullMode.BACK;
          this.isFrontFaceCCW = true;
          this.depthBiasEnabled = false;
          this.depthBias = 0;
          this.depthBiasClamp = 0.0;
          this.depthBiasSlop = 0.0;
          this.isDepthClip = true;
          this.isMultisample = false;
          this.lineWidth = 1.0;
        };

        _proto.assign = function assign(rs) {
          Object.assign(this, rs);
        };

        _proto.destroy = function destroy() {};

        _createClass(RasterizerState, [{
          key: "native",
          get: function get() {
            return this;
          }
        }]);

        return RasterizerState;
      }();
      var DepthStencilState = function () {
        function DepthStencilState(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack) {
          if (depthTest === void 0) {
            depthTest = true;
          }

          if (depthWrite === void 0) {
            depthWrite = true;
          }

          if (depthFunc === void 0) {
            depthFunc = ComparisonFunc.LESS;
          }

          if (stencilTestFront === void 0) {
            stencilTestFront = false;
          }

          if (stencilFuncFront === void 0) {
            stencilFuncFront = ComparisonFunc.ALWAYS;
          }

          if (stencilReadMaskFront === void 0) {
            stencilReadMaskFront = 0xffff;
          }

          if (stencilWriteMaskFront === void 0) {
            stencilWriteMaskFront = 0xffff;
          }

          if (stencilFailOpFront === void 0) {
            stencilFailOpFront = StencilOp.KEEP;
          }

          if (stencilZFailOpFront === void 0) {
            stencilZFailOpFront = StencilOp.KEEP;
          }

          if (stencilPassOpFront === void 0) {
            stencilPassOpFront = StencilOp.KEEP;
          }

          if (stencilRefFront === void 0) {
            stencilRefFront = 1;
          }

          if (stencilTestBack === void 0) {
            stencilTestBack = false;
          }

          if (stencilFuncBack === void 0) {
            stencilFuncBack = ComparisonFunc.ALWAYS;
          }

          if (stencilReadMaskBack === void 0) {
            stencilReadMaskBack = 0xffff;
          }

          if (stencilWriteMaskBack === void 0) {
            stencilWriteMaskBack = 0xffff;
          }

          if (stencilFailOpBack === void 0) {
            stencilFailOpBack = StencilOp.KEEP;
          }

          if (stencilZFailOpBack === void 0) {
            stencilZFailOpBack = StencilOp.KEEP;
          }

          if (stencilPassOpBack === void 0) {
            stencilPassOpBack = StencilOp.KEEP;
          }

          if (stencilRefBack === void 0) {
            stencilRefBack = 1;
          }

          this.depthTest = depthTest;
          this.depthWrite = depthWrite;
          this.depthFunc = depthFunc;
          this.stencilTestFront = stencilTestFront;
          this.stencilFuncFront = stencilFuncFront;
          this.stencilReadMaskFront = stencilReadMaskFront;
          this.stencilWriteMaskFront = stencilWriteMaskFront;
          this.stencilFailOpFront = stencilFailOpFront;
          this.stencilZFailOpFront = stencilZFailOpFront;
          this.stencilPassOpFront = stencilPassOpFront;
          this.stencilRefFront = stencilRefFront;
          this.stencilTestBack = stencilTestBack;
          this.stencilFuncBack = stencilFuncBack;
          this.stencilReadMaskBack = stencilReadMaskBack;
          this.stencilWriteMaskBack = stencilWriteMaskBack;
          this.stencilFailOpBack = stencilFailOpBack;
          this.stencilZFailOpBack = stencilZFailOpBack;
          this.stencilPassOpBack = stencilPassOpBack;
          this.stencilRefBack = stencilRefBack;
        }

        var _proto2 = DepthStencilState.prototype;

        _proto2.reset = function reset() {
          this.depthTest = true;
          this.depthWrite = true;
          this.depthFunc = ComparisonFunc.LESS;
          this.stencilTestFront = false;
          this.stencilFuncFront = ComparisonFunc.ALWAYS;
          this.stencilReadMaskFront = 0xffff;
          this.stencilWriteMaskFront = 0xffff;
          this.stencilFailOpFront = StencilOp.KEEP;
          this.stencilZFailOpFront = StencilOp.KEEP;
          this.stencilPassOpFront = StencilOp.KEEP;
          this.stencilRefFront = 1;
          this.stencilTestBack = false;
          this.stencilFuncBack = ComparisonFunc.ALWAYS;
          this.stencilReadMaskBack = 0xffff;
          this.stencilWriteMaskBack = 0xffff;
          this.stencilFailOpBack = StencilOp.KEEP;
          this.stencilZFailOpBack = StencilOp.KEEP;
          this.stencilPassOpBack = StencilOp.KEEP;
          this.stencilRefBack = 1;
        };

        _proto2.assign = function assign(dss) {
          Object.assign(this, dss);
        };

        _proto2.destroy = function destroy() {};

        _createClass(DepthStencilState, [{
          key: "native",
          get: function get() {
            return this;
          }
        }]);

        return DepthStencilState;
      }();
      var BlendTarget = function () {
        function BlendTarget(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask) {
          if (blend === void 0) {
            blend = false;
          }

          if (blendSrc === void 0) {
            blendSrc = BlendFactor.ONE;
          }

          if (blendDst === void 0) {
            blendDst = BlendFactor.ZERO;
          }

          if (blendEq === void 0) {
            blendEq = BlendOp.ADD;
          }

          if (blendSrcAlpha === void 0) {
            blendSrcAlpha = BlendFactor.ONE;
          }

          if (blendDstAlpha === void 0) {
            blendDstAlpha = BlendFactor.ZERO;
          }

          if (blendAlphaEq === void 0) {
            blendAlphaEq = BlendOp.ADD;
          }

          if (blendColorMask === void 0) {
            blendColorMask = ColorMask.ALL;
          }

          this.blend = blend;
          this.blendSrc = blendSrc;
          this.blendDst = blendDst;
          this.blendEq = blendEq;
          this.blendSrcAlpha = blendSrcAlpha;
          this.blendDstAlpha = blendDstAlpha;
          this.blendAlphaEq = blendAlphaEq;
          this.blendColorMask = blendColorMask;
        }

        var _proto3 = BlendTarget.prototype;

        _proto3.reset = function reset() {
          this.blend = false;
          this.blendSrc = BlendFactor.ONE;
          this.blendDst = BlendFactor.ZERO;
          this.blendEq = BlendOp.ADD;
          this.blendSrcAlpha = BlendFactor.ONE;
          this.blendDstAlpha = BlendFactor.ZERO;
          this.blendAlphaEq = BlendOp.ADD;
          this.blendColorMask = ColorMask.ALL;
        };

        _proto3.assign = function assign(target) {
          Object.assign(this, target);
        };

        _proto3.destroy = function destroy() {};

        return BlendTarget;
      }();
      var BlendState = function () {
        function BlendState(isA2C, isIndepend, blendColor, targets) {
          if (isA2C === void 0) {
            isA2C = false;
          }

          if (isIndepend === void 0) {
            isIndepend = false;
          }

          if (blendColor === void 0) {
            blendColor = new Color$1();
          }

          if (targets === void 0) {
            targets = [new BlendTarget()];
          }

          this.isA2C = isA2C;
          this.isIndepend = isIndepend;
          this.blendColor = blendColor;
          this.targets = targets;
        }

        var _proto4 = BlendState.prototype;

        _proto4.setTarget = function setTarget(index, target) {
          var tg = this.targets[index];

          if (!tg) {
            tg = this.targets[index] = new BlendTarget();
          }

          Object.assign(tg, target);
        };

        _proto4.reset = function reset() {
          this.isA2C = false;
          this.isIndepend = false;
          this.blendColor.x = 0;
          this.blendColor.y = 0;
          this.blendColor.z = 0;
          this.blendColor.w = 0;
          this.targets.length = 1;
          this.targets[0].reset();
        };

        _proto4.destroy = function destroy() {};

        _createClass(BlendState, [{
          key: "native",
          get: function get() {
            return this;
          }
        }]);

        return BlendState;
      }();
      var PipelineStateInfo = function PipelineStateInfo(shader, pipelineLayout, renderPass, inputState, rasterizerState, depthStencilState, blendState, primitive, dynamicStates, bindPoint) {
        if (shader === void 0) {
          shader = null;
        }

        if (pipelineLayout === void 0) {
          pipelineLayout = null;
        }

        if (renderPass === void 0) {
          renderPass = null;
        }

        if (inputState === void 0) {
          inputState = new InputState();
        }

        if (rasterizerState === void 0) {
          rasterizerState = new RasterizerState();
        }

        if (depthStencilState === void 0) {
          depthStencilState = new DepthStencilState();
        }

        if (blendState === void 0) {
          blendState = new BlendState();
        }

        if (primitive === void 0) {
          primitive = PrimitiveMode.TRIANGLE_LIST;
        }

        if (dynamicStates === void 0) {
          dynamicStates = DynamicStateFlagBit.NONE;
        }

        if (bindPoint === void 0) {
          bindPoint = PipelineBindPoint.GRAPHICS;
        }

        this.shader = shader;
        this.pipelineLayout = pipelineLayout;
        this.renderPass = renderPass;
        this.inputState = inputState;
        this.rasterizerState = rasterizerState;
        this.depthStencilState = depthStencilState;
        this.blendState = blendState;
        this.primitive = primitive;
        this.dynamicStates = dynamicStates;
        this.bindPoint = bindPoint;
      };
      var PipelineState = function (_GFXObject) {
        _inheritsLoose(PipelineState, _GFXObject);

        function PipelineState() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.PIPELINE_STATE) || this;
          _this._shader = null;
          _this._pipelineLayout = null;
          _this._primitive = PrimitiveMode.TRIANGLE_LIST;
          _this._is = null;
          _this._rs = new RasterizerState();
          _this._dss = new DepthStencilState();
          _this._bs = new BlendState();
          _this._dynamicStates = DynamicStateFlagBit.NONE;
          _this._renderPass = null;
          return _this;
        }

        _createClass(PipelineState, [{
          key: "shader",
          get: function get() {
            return this._shader;
          }
        }, {
          key: "pipelineLayout",
          get: function get() {
            return this._pipelineLayout;
          }
        }, {
          key: "primitive",
          get: function get() {
            return this._primitive;
          }
        }, {
          key: "rasterizerState",
          get: function get() {
            return this._rs;
          }
        }, {
          key: "depthStencilState",
          get: function get() {
            return this._dss;
          }
        }, {
          key: "blendState",
          get: function get() {
            return this._bs;
          }
        }, {
          key: "inputState",
          get: function get() {
            return this._is;
          }
        }, {
          key: "dynamicStates",
          get: function get() {
            return this._dynamicStates;
          }
        }, {
          key: "renderPass",
          get: function get() {
            return this._renderPass;
          }
        }]);

        return PipelineState;
      }(GFXObject);

      var Queue = function (_GFXObject) {
        _inheritsLoose(Queue, _GFXObject);

        function Queue() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.QUEUE) || this;
          _this._type = QueueType.GRAPHICS;
          return _this;
        }

        _createClass(Queue, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }]);

        return Queue;
      }(GFXObject);

      var RenderPass = function (_GFXObject) {
        _inheritsLoose(RenderPass, _GFXObject);

        function RenderPass() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.RENDER_PASS) || this;
          _this._colorInfos = [];
          _this._depthStencilInfo = null;
          _this._subpasses = [];
          _this._hash = 0;
          return _this;
        }

        var _proto = RenderPass.prototype;

        _proto.computeHash = function computeHash() {
          var res = '';

          if (this._subpasses.length) {
            for (var i = 0; i < this._subpasses.length; ++i) {
              var subpass = this._subpasses[i];

              if (subpass.inputs.length) {
                res += 'ia';

                for (var j = 0; j < subpass.inputs.length; ++j) {
                  var ia = this._colorInfos[subpass.inputs[j]];
                  res += "," + ia.format + "," + ia.sampleCount;
                }
              }

              if (subpass.colors.length) {
                res += 'ca';

                for (var _j = 0; _j < subpass.inputs.length; ++_j) {
                  var ca = this._colorInfos[subpass.inputs[_j]];
                  res += "," + ca.format + "," + ca.sampleCount;
                }
              }

              if (subpass.depthStencil >= 0) {
                var ds = this._colorInfos[subpass.depthStencil];
                res += "ds," + ds.format + "," + ds.sampleCount;
              }
            }
          } else {
            res += 'ca';

            for (var _i = 0; _i < this._colorInfos.length; ++_i) {
              var _ca = this._colorInfos[_i];
              res += "," + _ca.format + "," + _ca.sampleCount;
            }

            var _ds = this._depthStencilInfo;

            if (_ds) {
              res += "ds," + _ds.format + "," + _ds.sampleCount;
            }
          }

          return murmurhash2_32_gc(res, 666);
        };

        _createClass(RenderPass, [{
          key: "colorAttachments",
          get: function get() {
            return this._colorInfos;
          }
        }, {
          key: "depthStencilAttachment",
          get: function get() {
            return this._depthStencilInfo;
          }
        }, {
          key: "subPasses",
          get: function get() {
            return this._subpasses;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }]);

        return RenderPass;
      }(GFXObject);

      var Sampler = function (_GFXObject) {
        _inheritsLoose(Sampler, _GFXObject);

        function Sampler(info, hash) {
          var _this;

          _this = _GFXObject.call(this, ObjectType.SAMPLER) || this;
          _this._info = new SamplerInfo();
          _this._hash = 0;

          _this._info.copy(info);

          _this._hash = hash;
          return _this;
        }

        Sampler.computeHash = function computeHash(info) {
          var hash = info.minFilter;
          hash |= info.magFilter << 2;
          hash |= info.mipFilter << 4;
          hash |= info.addressU << 6;
          hash |= info.addressV << 8;
          hash |= info.addressW << 10;
          hash |= info.maxAnisotropy << 12;
          hash |= info.cmpFunc << 16;
          return hash;
        };

        Sampler.unpackFromHash = function unpackFromHash(hash) {
          var info = new SamplerInfo();
          info.minFilter = (hash & (1 << 2) - 1) >> 0;
          info.magFilter = (hash & (1 << 2) - 1) >> 2;
          info.mipFilter = (hash & (1 << 2) - 1) >> 4;
          info.addressU = (hash & (1 << 2) - 1) >> 6;
          info.addressV = (hash & (1 << 2) - 1) >> 8;
          info.addressW = (hash & (1 << 2) - 1) >> 10;
          info.maxAnisotropy = (hash & (1 << 4) - 1) >> 12;
          info.cmpFunc = (hash & (1 << 3) - 1) >> 16;
          return info;
        };

        _createClass(Sampler, [{
          key: "info",
          get: function get() {
            return this._info;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }]);

        return Sampler;
      }(GFXObject);

      var Shader = function (_GFXObject) {
        _inheritsLoose(Shader, _GFXObject);

        function Shader() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.SHADER) || this;
          _this._name = '';
          _this._stages = [];
          _this._attributes = [];
          _this._blocks = [];
          _this._samplers = [];
          return _this;
        }

        _createClass(Shader, [{
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "blocks",
          get: function get() {
            return this._blocks;
          }
        }, {
          key: "samplers",
          get: function get() {
            return this._samplers;
          }
        }]);

        return Shader;
      }(GFXObject);

      var Texture = function (_GFXObject) {
        _inheritsLoose(Texture, _GFXObject);

        function Texture() {
          var _this;

          _this = _GFXObject.call(this, ObjectType.TEXTURE) || this;
          _this._info = new TextureInfo();
          _this._viewInfo = new TextureViewInfo();
          _this._isPowerOf2 = false;
          _this._isTextureView = false;
          _this._size = 0;
          return _this;
        }

        Texture.getLevelCount = function getLevelCount(width, height) {
          return Math.floor(Math.log2(Math.max(width, height)));
        };

        _createClass(Texture, [{
          key: "type",
          get: function get() {
            return this._info.type;
          }
        }, {
          key: "usage",
          get: function get() {
            return this._info.usage;
          }
        }, {
          key: "format",
          get: function get() {
            return this._info.format;
          }
        }, {
          key: "width",
          get: function get() {
            return this._info.width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._info.height;
          }
        }, {
          key: "depth",
          get: function get() {
            return this._info.depth;
          }
        }, {
          key: "layerCount",
          get: function get() {
            return this._info.layerCount;
          }
        }, {
          key: "levelCount",
          get: function get() {
            return this._info.levelCount;
          }
        }, {
          key: "samples",
          get: function get() {
            return this._info.samples;
          }
        }, {
          key: "flags",
          get: function get() {
            return this._info.flags;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          }
        }, {
          key: "info",
          get: function get() {
            return this._info;
          }
        }, {
          key: "viewInfo",
          get: function get() {
            return this._viewInfo;
          }
        }, {
          key: "isTextureView",
          get: function get() {
            return this._isTextureView;
          }
        }]);

        return Texture;
      }(GFXObject);

      var GeneralBarrier = function (_GFXObject) {
        _inheritsLoose(GeneralBarrier, _GFXObject);

        function GeneralBarrier(info, hash) {
          var _this;

          _this = _GFXObject.call(this, ObjectType.GLOBAL_BARRIER) || this;
          _this._info = new GeneralBarrierInfo();
          _this._hash = 0;

          _this._info.copy(info);

          _this._hash = hash;
          return _this;
        }

        GeneralBarrier.computeHash = function computeHash(info) {
          return murmurhash2_32_gc(info.prevAccesses + " " + info.nextAccesses, 666);
        };

        _createClass(GeneralBarrier, [{
          key: "info",
          get: function get() {
            return this._info;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }]);

        return GeneralBarrier;
      }(GFXObject);

      var TextureBarrier = function (_GFXObject) {
        _inheritsLoose(TextureBarrier, _GFXObject);

        function TextureBarrier(info, hash) {
          var _this;

          _this = _GFXObject.call(this, ObjectType.TEXTURE_BARRIER) || this;
          _this._info = new TextureBarrierInfo();
          _this._hash = 0;

          _this._info.copy(info);

          _this._hash = hash;
          return _this;
        }

        TextureBarrier.computeHash = function computeHash(info) {
          var res = info.prevAccesses + " " + info.nextAccesses;
          res += info.discardContents;
          res += info.srcQueue ? info.srcQueue.type : 0;
          res += info.dstQueue ? info.dstQueue.type : 0;
          return murmurhash2_32_gc(res, 666);
        };

        _createClass(TextureBarrier, [{
          key: "info",
          get: function get() {
            return this._info;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }]);

        return TextureBarrier;
      }(GFXObject);

      var polyfills = {
        Device: Device,
        Swapchain: Swapchain,
        Buffer: Buffer,
        Texture: Texture,
        Sampler: Sampler,
        Shader: Shader,
        InputAssembler: InputAssembler,
        RenderPass: RenderPass,
        Framebuffer: Framebuffer,
        DescriptorSet: DescriptorSet,
        DescriptorSetLayout: DescriptorSetLayout,
        PipelineLayout: PipelineLayout,
        PipelineState: PipelineState,
        CommandBuffer: CommandBuffer,
        Queue: Queue,
        GeneralBarrier: GeneralBarrier,
        TextureBarrier: TextureBarrier,
        RasterizerState: RasterizerState,
        BlendState: BlendState,
        BlendTarget: BlendTarget,
        DepthStencilState: DepthStencilState,
        PipelineStateInfo: PipelineStateInfo
      };
      Object.assign(polyfills, defines);
      legacyCC.gfx = polyfills;

      var polyfills$1 = {
        GFXDevice: true,
        GFXBuffer: true,
        GFXTexture: true,
        GFXSampler: true,
        GFXShader: true,
        GFXInputAssembler: true,
        GFXRenderPass: true,
        GFXFramebuffer: true,
        GFXPipelineState: true,
        GFXCommandBuffer: true,
        GFXQueue: true,
        GFXObjectType: true,
        GFXObject: false,
        GFXAttributeName: true,
        GFXType: true,
        GFXFormat: true,
        GFXBufferUsageBit: true,
        GFXMemoryUsageBit: true,
        GFXBufferFlagBit: true,
        GFXBufferAccessBit: 'MemoryAccessBit',
        GFXPrimitiveMode: true,
        GFXPolygonMode: true,
        GFXShadeModel: true,
        GFXCullMode: true,
        GFXComparisonFunc: true,
        GFXStencilOp: true,
        GFXBlendOp: true,
        GFXBlendFactor: true,
        GFXColorMask: true,
        GFXFilter: true,
        GFXAddress: true,
        GFXTextureType: true,
        GFXTextureUsageBit: true,
        GFXSampleCount: true,
        GFXTextureFlagBit: true,
        GFXShaderStageFlagBit: true,
        GFXDescriptorType: true,
        GFXCommandBufferType: true,
        GFXLoadOp: true,
        GFXStoreOp: true,
        GFXPipelineBindPoint: true,
        GFXDynamicStateFlagBit: true,
        GFXStencilFace: true,
        GFXQueueType: true,
        GFXRect: true,
        GFXViewport: true,
        GFXColor: true,
        GFXClearFlag: true,
        GFXOffset: true,
        GFXExtent: true,
        GFXTextureSubres: 'TextureSubresLayers',
        GFXTextureCopy: true,
        GFXBufferTextureCopy: true,
        GFXFormatType: true,
        GFXFormatInfo: true,
        GFXMemoryStatus: true,
        GFXFormatInfos: true,
        GFXFormatSize: true,
        GFXFormatSurfaceSize: true,
        GFXGetTypeSize: true,
        getTypedArrayConstructor: false
      };

      for (var name in polyfills$1) {
        var newName = polyfills$1[name];

        if (newName === true) {
          newName = name.slice(3);
        } else if (newName === false) {
          newName = name;
        }

        replaceProperty(legacyCC, 'cc', [{
          name: name,
          newName: newName,
          target: legacyCC.gfx,
          targetName: 'cc.gfx'
        }]);
      }

      removeProperty(legacyCC, 'cc', [{
        name: 'GFX_MAX_VERTEX_ATTRIBUTES'
      }, {
        name: 'GFX_MAX_TEXTURE_UNITS'
      }, {
        name: 'GFX_MAX_ATTACHMENTS'
      }, {
        name: 'GFX_MAX_BUFFER_BINDINGS'
      }, {
        name: 'GFXTextureLayout'
      }]);

      removeProperty(Feature, 'Feature', [{
        name: 'COLOR_FLOAT',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R32F) & FormatFeatureBit.RENDER_TARGET;'
      }, {
        name: 'COLOR_HALF_FLOAT',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R16F) & FormatFeatureBit.RENDER_TARGET;'
      }, {
        name: 'TEXTURE_FLOAT',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = (device.getFormatFeatures(Format.R32F) & (FormatFeatureBit.RENDER_TARGET' + ' | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);'
      }, {
        name: 'TEXTURE_HALF_FLOAT',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = (device.getFormatFeatures(Format.R16F) & (FormatFeatureBit.RENDER_TARGET' + ' | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);'
      }, {
        name: 'TEXTURE_FLOAT_LINEAR',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R32F) & FormatFeatureBit.LINEAR_FILTER;'
      }, {
        name: 'TEXTURE_HALF_FLOAT_LINEAR',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R16F) & FormatFeatureBit.LINEAR_FILTER;'
      }, {
        name: 'FORMAT_R11G11B10F',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R11G11B10F) !== FormatFeatureBit.NONE;'
      }, {
        name: 'FORMAT_SRGB',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.SRGB8) !== FormatFeatureBit.NONE;'
      }, {
        name: 'FORMAT_ETC1',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.ETC_RGB8) !== FormatFeatureBit.NONE;'
      }, {
        name: 'FORMAT_ETC2',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.ETC2_RGB8) !== FormatFeatureBit.NONE;'
      }, {
        name: 'FORMAT_DXT',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.BC1) !== FormatFeatureBit.NONE;'
      }, {
        name: 'FORMAT_PVRTC',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.PVRTC_RGB2) !== FormatFeatureBit.NONE;'
      }, {
        name: 'FORMAT_ASTC',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.ASTC_RGBA_4x4) !== FormatFeatureBit.NONE;'
      }, {
        name: 'FORMAT_RGB8',
        suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.RGB8) !== FormatFeatureBit.NONE;'
      }]);
      removeProperty(ColorAttachment.prototype, 'ColorAttachment', [{
        name: 'beginAccesses',
        suggest: 'Please assign to ColorAttachment.barrier instead'
      }, {
        name: 'endAccesses',
        suggest: 'Please assign to ColorAttachment.barrier instead'
      }]);
      removeProperty(DepthStencilAttachment.prototype, 'DepthStencilAttachment', [{
        name: 'beginAccesses',
        suggest: 'Please assign to DepthStencilAttachment.barrier instead'
      }, {
        name: 'endAccesses',
        suggest: 'Please assign to DepthStencilAttachment.barrier instead'
      }]);
      replaceProperty(Device.prototype, 'Device', [{
        name: 'getGlobalBarrier',
        newName: 'getGeneralBarrier'
      }]);

      var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DescriptorSet: DescriptorSet,
        Buffer: Buffer,
        CommandBuffer: CommandBuffer,
        get ObjectType () { return ObjectType; },
        get Status () { return Status; },
        get API () { return API; },
        get SurfaceTransform () { return SurfaceTransform; },
        get Feature () { return Feature; },
        get Format () { return Format; },
        get FormatType () { return FormatType; },
        get Type () { return Type; },
        get BufferUsageBit () { return BufferUsageBit; },
        get BufferFlagBit () { return BufferFlagBit; },
        get MemoryAccessBit () { return MemoryAccessBit; },
        get MemoryUsageBit () { return MemoryUsageBit; },
        get TextureType () { return TextureType; },
        get TextureUsageBit () { return TextureUsageBit; },
        get TextureFlagBit () { return TextureFlagBit; },
        get FormatFeatureBit () { return FormatFeatureBit; },
        get SampleCount () { return SampleCount; },
        get VsyncMode () { return VsyncMode; },
        get Filter () { return Filter; },
        get Address () { return Address; },
        get ComparisonFunc () { return ComparisonFunc; },
        get StencilOp () { return StencilOp; },
        get BlendFactor () { return BlendFactor; },
        get BlendOp () { return BlendOp; },
        get ColorMask () { return ColorMask; },
        get ShaderStageFlagBit () { return ShaderStageFlagBit; },
        get LoadOp () { return LoadOp; },
        get StoreOp () { return StoreOp; },
        get AccessFlagBit () { return AccessFlagBit; },
        get ResolveMode () { return ResolveMode; },
        get PipelineBindPoint () { return PipelineBindPoint; },
        get PrimitiveMode () { return PrimitiveMode; },
        get PolygonMode () { return PolygonMode; },
        get ShadeModel () { return ShadeModel; },
        get CullMode () { return CullMode; },
        get DynamicStateFlagBit () { return DynamicStateFlagBit; },
        get StencilFace () { return StencilFace; },
        get DescriptorType () { return DescriptorType; },
        get QueueType () { return QueueType; },
        get QueryType () { return QueryType; },
        get CommandBufferType () { return CommandBufferType; },
        get ClearFlagBit () { return ClearFlagBit; },
        Size: Size$1,
        DeviceCaps: DeviceCaps,
        Offset: Offset,
        Rect: Rect$1,
        Extent: Extent,
        TextureSubresLayers: TextureSubresLayers,
        TextureSubresRange: TextureSubresRange,
        TextureCopy: TextureCopy,
        TextureBlit: TextureBlit,
        BufferTextureCopy: BufferTextureCopy,
        Viewport: Viewport,
        Color: Color$1,
        BindingMappingInfo: BindingMappingInfo,
        SwapchainInfo: SwapchainInfo,
        DeviceInfo: DeviceInfo,
        BufferInfo: BufferInfo,
        BufferViewInfo: BufferViewInfo,
        DrawInfo: DrawInfo,
        DispatchInfo: DispatchInfo,
        IndirectBuffer: IndirectBuffer,
        TextureInfo: TextureInfo,
        TextureViewInfo: TextureViewInfo,
        SamplerInfo: SamplerInfo,
        Uniform: Uniform,
        UniformBlock: UniformBlock,
        UniformSamplerTexture: UniformSamplerTexture,
        UniformSampler: UniformSampler,
        UniformTexture: UniformTexture,
        UniformStorageImage: UniformStorageImage,
        UniformStorageBuffer: UniformStorageBuffer,
        UniformInputAttachment: UniformInputAttachment,
        ShaderStage: ShaderStage,
        Attribute: Attribute,
        ShaderInfo: ShaderInfo,
        InputAssemblerInfo: InputAssemblerInfo,
        ColorAttachment: ColorAttachment,
        DepthStencilAttachment: DepthStencilAttachment,
        SubpassInfo: SubpassInfo,
        SubpassDependency: SubpassDependency,
        RenderPassInfo: RenderPassInfo,
        GeneralBarrierInfo: GeneralBarrierInfo,
        TextureBarrierInfo: TextureBarrierInfo,
        FramebufferInfo: FramebufferInfo,
        DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
        DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
        DescriptorSetInfo: DescriptorSetInfo,
        PipelineLayoutInfo: PipelineLayoutInfo,
        InputState: InputState,
        CommandBufferInfo: CommandBufferInfo,
        QueueInfo: QueueInfo,
        QueryPoolInfo: QueryPoolInfo,
        FormatInfo: FormatInfo,
        MemoryStatus: MemoryStatus,
        DynamicStencilStates: DynamicStencilStates,
        DynamicStates: DynamicStates,
        GFXObject: GFXObject,
        get AttributeName () { return AttributeName; },
        FormatInfos: FormatInfos,
        DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
        DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
        DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
        DRAW_INFO_SIZE: DRAW_INFO_SIZE,
        IsPowerOf2: IsPowerOf2,
        FormatSize: FormatSize,
        FormatSurfaceSize: FormatSurfaceSize,
        GetTypeSize: GetTypeSize,
        getTypedArrayConstructor: getTypedArrayConstructor,
        Device: Device,
        Swapchain: Swapchain,
        Framebuffer: Framebuffer,
        InputAssembler: InputAssembler,
        DescriptorSetLayout: DescriptorSetLayout,
        PipelineLayout: PipelineLayout,
        RasterizerState: RasterizerState,
        DepthStencilState: DepthStencilState,
        BlendTarget: BlendTarget,
        BlendState: BlendState,
        PipelineStateInfo: PipelineStateInfo,
        PipelineState: PipelineState,
        Queue: Queue,
        RenderPass: RenderPass,
        Sampler: Sampler,
        Shader: Shader,
        Texture: Texture,
        GeneralBarrier: GeneralBarrier,
        TextureBarrier: TextureBarrier
      });
      exports('gfx', index);

      var ERaycastMode;

      (function (ERaycastMode) {
        ERaycastMode[ERaycastMode["ALL"] = 0] = "ALL";
        ERaycastMode[ERaycastMode["CLOSEST"] = 1] = "CLOSEST";
        ERaycastMode[ERaycastMode["ANY"] = 2] = "ANY";
      })(ERaycastMode || (ERaycastMode = {}));

      var rayPlane = function () {
        var pt = new Vec3(0, 0, 0);
        return function (ray, plane) {
          var denom = Vec3.dot(ray.d, plane.n);

          if (Math.abs(denom) < Number.EPSILON) {
            return 0;
          }

          Vec3.multiplyScalar(pt, plane.n, plane.d);
          var t = Vec3.dot(Vec3.subtract(pt, pt, ray.o), plane.n) / denom;

          if (t < 0) {
            return 0;
          }

          return t;
        };
      }();

      var rayTriangle = function () {
        var ab = new Vec3(0, 0, 0);
        var ac = new Vec3(0, 0, 0);
        var pvec = new Vec3(0, 0, 0);
        var tvec = new Vec3(0, 0, 0);
        var qvec = new Vec3(0, 0, 0);
        return function (ray, triangle, doubleSided) {
          Vec3.subtract(ab, triangle.b, triangle.a);
          Vec3.subtract(ac, triangle.c, triangle.a);
          Vec3.cross(pvec, ray.d, ac);
          var det = Vec3.dot(ab, pvec);

          if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) {
            return 0;
          }

          var inv_det = 1 / det;
          Vec3.subtract(tvec, ray.o, triangle.a);
          var u = Vec3.dot(tvec, pvec) * inv_det;

          if (u < 0 || u > 1) {
            return 0;
          }

          Vec3.cross(qvec, tvec, ab);
          var v = Vec3.dot(ray.d, qvec) * inv_det;

          if (v < 0 || u + v > 1) {
            return 0;
          }

          var t = Vec3.dot(ac, qvec) * inv_det;
          return t < 0 ? 0 : t;
        };
      }();

      var raySphere = function () {
        var e = new Vec3(0, 0, 0);
        return function (ray, sphere) {
          var r = sphere.radius;
          var c = sphere.center;
          var o = ray.o;
          var d = ray.d;
          var rSq = r * r;
          Vec3.subtract(e, c, o);
          var eSq = e.lengthSqr();
          var aLength = Vec3.dot(e, d);
          var fSq = rSq - (eSq - aLength * aLength);

          if (fSq < 0) {
            return 0;
          }

          var f = Math.sqrt(fSq);
          var t = eSq < rSq ? aLength + f : aLength - f;

          if (t < 0) {
            return 0;
          }

          return t;
        };
      }();

      var rayAABB = function () {
        var min = new Vec3();
        var max = new Vec3();
        return function (ray, aabb) {
          Vec3.subtract(min, aabb.center, aabb.halfExtents);
          Vec3.add(max, aabb.center, aabb.halfExtents);
          return rayAABB2(ray, min, max);
        };
      }();

      function rayAABB2(ray, min, max) {
        var o = ray.o;
        var d = ray.d;
        var ix = 1 / d.x;
        var iy = 1 / d.y;
        var iz = 1 / d.z;
        var t1 = (min.x - o.x) * ix;
        var t2 = (max.x - o.x) * ix;
        var t3 = (min.y - o.y) * iy;
        var t4 = (max.y - o.y) * iy;
        var t5 = (min.z - o.z) * iz;
        var t6 = (max.z - o.z) * iz;
        var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

        if (tmax < 0 || tmin > tmax) {
          return 0;
        }

        return tmin > 0 ? tmin : tmax;
      }

      var rayOBB = function () {
        var center = new Vec3();
        var o = new Vec3();
        var d = new Vec3();
        var X = new Vec3();
        var Y = new Vec3();
        var Z = new Vec3();
        var p = new Vec3();
        var size = new Array(3);
        var f = new Array(3);
        var e = new Array(3);
        var t = new Array(6);
        return function (ray, obb) {
          size[0] = obb.halfExtents.x;
          size[1] = obb.halfExtents.y;
          size[2] = obb.halfExtents.z;
          center = obb.center;
          o = ray.o;
          d = ray.d;
          Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
          Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
          Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
          Vec3.subtract(p, center, o);
          f[0] = Vec3.dot(X, d);
          f[1] = Vec3.dot(Y, d);
          f[2] = Vec3.dot(Z, d);
          e[0] = Vec3.dot(X, p);
          e[1] = Vec3.dot(Y, p);
          e[2] = Vec3.dot(Z, p);

          for (var i = 0; i < 3; ++i) {
            if (f[i] === 0) {
              if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) {
                return 0;
              }

              f[i] = 0.0000001;
            }

            t[i * 2 + 0] = (e[i] + size[i]) / f[i];
            t[i * 2 + 1] = (e[i] - size[i]) / f[i];
          }

          var tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5]));
          var tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));

          if (tmax < 0 || tmin > tmax) {
            return 0;
          }

          return tmin > 0 ? tmin : tmax;
        };
      }();

      var rayCapsule = function () {
        var v3_0 = new Vec3();
        var v3_1 = new Vec3();
        var v3_2 = new Vec3();
        var v3_3 = new Vec3();
        var v3_4 = new Vec3();
        var v3_5 = new Vec3();
        var v3_6 = new Vec3();
        var sphere_0 = new Sphere();
        return function (ray, capsule) {
          var radiusSqr = capsule.radius * capsule.radius;
          var vRayNorm = Vec3.normalize(v3_0, ray.d);
          var A = capsule.ellipseCenter0;
          var B = capsule.ellipseCenter1;
          var BA = Vec3.subtract(v3_1, B, A);

          if (BA.equals(Vec3.ZERO)) {
            sphere_0.radius = capsule.radius;
            sphere_0.center.set(capsule.ellipseCenter0);
            return intersect.raySphere(ray, sphere_0);
          }

          var O = ray.o;
          var OA = Vec3.subtract(v3_2, O, A);
          var VxBA = Vec3.cross(v3_3, vRayNorm, BA);
          var a = VxBA.lengthSqr();

          if (a === 0) {
            sphere_0.radius = capsule.radius;
            var BO = Vec3.subtract(v3_4, B, O);

            if (OA.lengthSqr() < BO.lengthSqr()) {
              sphere_0.center.set(capsule.ellipseCenter0);
            } else {
              sphere_0.center.set(capsule.ellipseCenter1);
            }

            return intersect.raySphere(ray, sphere_0);
          }

          var OAxBA = Vec3.cross(v3_4, OA, BA);
          var ab2 = BA.lengthSqr();
          var b = 2 * Vec3.dot(VxBA, OAxBA);
          var c = OAxBA.lengthSqr() - radiusSqr * ab2;
          var d = b * b - 4 * a * c;

          if (d < 0) {
            return 0;
          }

          var t = (-b - Math.sqrt(d)) / (2 * a);

          if (t < 0) {
            sphere_0.radius = capsule.radius;

            var _BO = Vec3.subtract(v3_5, B, O);

            if (OA.lengthSqr() < _BO.lengthSqr()) {
              sphere_0.center.set(capsule.ellipseCenter0);
            } else {
              sphere_0.center.set(capsule.ellipseCenter1);
            }

            return intersect.raySphere(ray, sphere_0);
          } else {
            var iPos = Vec3.scaleAndAdd(v3_5, ray.o, vRayNorm, t);
            var iPosLen = Vec3.subtract(v3_6, iPos, A);
            var tLimit = Vec3.dot(iPosLen, BA) / ab2;

            if (tLimit >= 0 && tLimit <= 1) {
              return t;
            } else if (tLimit < 0) {
              sphere_0.radius = capsule.radius;
              sphere_0.center.set(capsule.ellipseCenter0);
              return intersect.raySphere(ray, sphere_0);
            } else if (tLimit > 1) {
              sphere_0.radius = capsule.radius;
              sphere_0.center.set(capsule.ellipseCenter1);
              return intersect.raySphere(ray, sphere_0);
            } else {
              return 0;
            }
          }
        };
      }();

      var raySubMesh = function () {
        var tri = Triangle.create();
        var deOpt = {
          distance: Infinity,
          doubleSided: false,
          mode: ERaycastMode.ANY
        };
        var minDis = 0;

        var fillResult = function fillResult(m, d, i0, i1, i2, r) {
          if (m === ERaycastMode.CLOSEST) {
            if (minDis > d || minDis === 0) {
              minDis = d;

              if (r) {
                if (r.length === 0) {
                  r.push({
                    distance: d,
                    vertexIndex0: i0 / 3,
                    vertexIndex1: i1 / 3,
                    vertexIndex2: i2 / 3
                  });
                } else {
                  r[0].distance = d;
                  r[0].vertexIndex0 = i0 / 3;
                  r[0].vertexIndex1 = i1 / 3;
                  r[0].vertexIndex2 = i2 / 3;
                }
              }
            }
          } else {
            minDis = d;
            if (r) r.push({
              distance: d,
              vertexIndex0: i0 / 3,
              vertexIndex1: i1 / 3,
              vertexIndex2: i2 / 3
            });
          }
        };

        var narrowphase = function narrowphase(vb, ib, pm, ray, opt) {
          if (pm === PrimitiveMode.TRIANGLE_LIST) {
            var cnt = ib.length;

            for (var j = 0; j < cnt; j += 3) {
              var i0 = ib[j] * 3;
              var i1 = ib[j + 1] * 3;
              var i2 = ib[j + 2] * 3;
              Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
              Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
              Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
              var dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
              if (dist === 0 || dist > opt.distance) continue;
              fillResult(opt.mode, dist, i0, i1, i2, opt.result);
              if (opt.mode === ERaycastMode.ANY) return dist;
            }
          } else if (pm === PrimitiveMode.TRIANGLE_STRIP) {
            var _cnt = ib.length - 2;

            var rev = 0;

            for (var _j = 0; _j < _cnt; _j += 1) {
              var _i = ib[_j - rev] * 3;

              var _i2 = ib[_j + rev + 1] * 3;

              var _i3 = ib[_j + 2] * 3;

              Vec3.set(tri.a, vb[_i], vb[_i + 1], vb[_i + 2]);
              Vec3.set(tri.b, vb[_i2], vb[_i2 + 1], vb[_i2 + 2]);
              Vec3.set(tri.c, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]);
              rev = ~rev;

              var _dist = intersect.rayTriangle(ray, tri, opt.doubleSided);

              if (_dist === 0 || _dist > opt.distance) continue;
              fillResult(opt.mode, _dist, _i, _i2, _i3, opt.result);
              if (opt.mode === ERaycastMode.ANY) return _dist;
            }
          } else if (pm === PrimitiveMode.TRIANGLE_FAN) {
            var _cnt2 = ib.length - 1;

            var _i4 = ib[0] * 3;

            Vec3.set(tri.a, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);

            for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
              var _i5 = ib[_j2] * 3;

              var _i6 = ib[_j2 + 1] * 3;

              Vec3.set(tri.b, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]);
              Vec3.set(tri.c, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);

              var _dist2 = intersect.rayTriangle(ray, tri, opt.doubleSided);

              if (_dist2 === 0 || _dist2 > opt.distance) continue;
              fillResult(opt.mode, _dist2, _i4, _i5, _i6, opt.result);
              if (opt.mode === ERaycastMode.ANY) return _dist2;
            }
          }

          return minDis;
        };

        return function (ray, submesh, options) {
          minDis = 0;
          if (submesh.geometricInfo.positions.length === 0) return minDis;
          var opt = options === undefined ? deOpt : options;
          var min = submesh.geometricInfo.boundingBox.min;
          var max = submesh.geometricInfo.boundingBox.max;

          if (rayAABB2(ray, min, max)) {
            var pm = submesh.primitiveMode;
            var _submesh$geometricInf = submesh.geometricInfo,
                vb = _submesh$geometricInf.positions,
                ib = _submesh$geometricInf.indices;
            narrowphase(vb, ib, pm, ray, opt);
          }

          return minDis;
        };
      }();

      var rayMesh = function () {
        var minDis = 0;
        var deOpt = {
          distance: Infinity,
          doubleSided: false,
          mode: ERaycastMode.ANY
        };
        return function (ray, mesh, options) {
          minDis = 0;
          var opt = options === undefined ? deOpt : options;
          var length = mesh.renderingSubMeshes.length;
          var min = mesh.struct.minPosition;
          var max = mesh.struct.maxPosition;
          if (min && max && !rayAABB2(ray, min, max)) return minDis;

          for (var i = 0; i < length; i++) {
            var sm = mesh.renderingSubMeshes[i];
            var dis = raySubMesh(ray, sm, opt);

            if (dis) {
              if (opt.mode === ERaycastMode.CLOSEST) {
                if (minDis === 0 || minDis > dis) {
                  minDis = dis;
                  if (opt.subIndices) opt.subIndices[0] = i;
                }
              } else {
                minDis = dis;
                if (opt.subIndices) opt.subIndices.push(i);

                if (opt.mode === ERaycastMode.ANY) {
                  return dis;
                }
              }
            }
          }

          if (minDis && opt.mode === ERaycastMode.CLOSEST) {
            if (opt.result) {
              opt.result[0].distance = minDis;
              opt.result.length = 1;
            }

            if (opt.subIndices) opt.subIndices.length = 1;
          }

          return minDis;
        };
      }();

      var rayModel = function () {
        var minDis = 0;
        var deOpt = {
          distance: Infinity,
          doubleSided: false,
          mode: ERaycastMode.ANY
        };
        var modelRay = new Ray();
        var m4 = new Mat4();
        return function (r, model, options) {
          minDis = 0;
          var opt = options === undefined ? deOpt : options;
          var wb = model.worldBounds;
          if (wb && !rayAABB(r, wb)) return minDis;
          Ray.copy(modelRay, r);

          if (model.node) {
            Mat4.invert(m4, model.node.getWorldMatrix(m4));
            Vec3.transformMat4(modelRay.o, r.o, m4);
            Vec3.transformMat4Normal(modelRay.d, r.d, m4);
          }

          var subModels = model.subModels;

          for (var i = 0; i < subModels.length; i++) {
            var subMesh = subModels[i].subMesh;
            var dis = raySubMesh(modelRay, subMesh, opt);

            if (dis) {
              if (opt.mode === ERaycastMode.CLOSEST) {
                if (minDis === 0 || minDis > dis) {
                  minDis = dis;
                  if (opt.subIndices) opt.subIndices[0] = i;
                }
              } else {
                minDis = dis;
                if (opt.subIndices) opt.subIndices.push(i);

                if (opt.mode === ERaycastMode.ANY) {
                  return dis;
                }
              }
            }
          }

          if (minDis && opt.mode === ERaycastMode.CLOSEST) {
            if (opt.result) {
              opt.result[0].distance = minDis;
              opt.result.length = 1;
            }

            if (opt.subIndices) opt.subIndices.length = 1;
          }

          return minDis;
        };
      }();

      var linePlane = function () {
        var ab = new Vec3(0, 0, 0);
        return function (line, plane) {
          Vec3.subtract(ab, line.e, line.s);
          var t = (plane.d - Vec3.dot(line.s, plane.n)) / Vec3.dot(ab, plane.n);

          if (t < 0 || t > 1) {
            return 0;
          }

          return t;
        };
      }();

      var lineTriangle = function () {
        var ab = new Vec3(0, 0, 0);
        var ac = new Vec3(0, 0, 0);
        var qp = new Vec3(0, 0, 0);
        var ap = new Vec3(0, 0, 0);
        var n = new Vec3(0, 0, 0);
        var e = new Vec3(0, 0, 0);
        return function (line, triangle, outPt) {
          Vec3.subtract(ab, triangle.b, triangle.a);
          Vec3.subtract(ac, triangle.c, triangle.a);
          Vec3.subtract(qp, line.s, line.e);
          Vec3.cross(n, ab, ac);
          var det = Vec3.dot(qp, n);

          if (det <= 0.0) {
            return 0;
          }

          Vec3.subtract(ap, line.s, triangle.a);
          var t = Vec3.dot(ap, n);

          if (t < 0 || t > det) {
            return 0;
          }

          Vec3.cross(e, qp, ap);
          var v = Vec3.dot(ac, e);

          if (v < 0 || v > det) {
            return 0;
          }

          var w = -Vec3.dot(ab, e);

          if (w < 0.0 || v + w > det) {
            return 0;
          }

          if (outPt) {
            var invDet = 1.0 / det;
            v *= invDet;
            w *= invDet;
            var u = 1.0 - v - w;
            Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
          }

          return 1;
        };
      }();

      var r_t = new Ray();

      function lineAABB(line, aabb) {
        r_t.o.set(line.s);
        Vec3.subtract(r_t.d, line.e, line.s);
        r_t.d.normalize();
        var min = rayAABB(r_t, aabb);
        var len = line.length();

        if (min <= len) {
          return min;
        } else {
          return 0;
        }
      }

      function lineOBB(line, obb) {
        r_t.o.set(line.s);
        Vec3.subtract(r_t.d, line.e, line.s);
        r_t.d.normalize();
        var min = rayOBB(r_t, obb);
        var len = line.length();

        if (min <= len) {
          return min;
        } else {
          return 0;
        }
      }

      function lineSphere(line, sphere) {
        r_t.o.set(line.s);
        Vec3.subtract(r_t.d, line.e, line.s);
        r_t.d.normalize();
        var min = raySphere(r_t, sphere);
        var len = line.length();

        if (min <= len) {
          return min;
        } else {
          return 0;
        }
      }

      var aabbWithAABB = function () {
        var aMin = new Vec3();
        var aMax = new Vec3();
        var bMin = new Vec3();
        var bMax = new Vec3();
        return function (aabb1, aabb2) {
          Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
          Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
          Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
          Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
          return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
        };
      }();

      function getAABBVertices(min, max, out) {
        Vec3.set(out[0], min.x, max.y, max.z);
        Vec3.set(out[1], min.x, max.y, min.z);
        Vec3.set(out[2], min.x, min.y, max.z);
        Vec3.set(out[3], min.x, min.y, min.z);
        Vec3.set(out[4], max.x, max.y, max.z);
        Vec3.set(out[5], max.x, max.y, min.z);
        Vec3.set(out[6], max.x, min.y, max.z);
        Vec3.set(out[7], max.x, min.y, min.z);
      }

      function getOBBVertices(c, e, a1, a2, a3, out) {
        Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z);
        Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z);
        Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z);
        Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z);
        Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z);
        Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z);
        Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z);
        Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
      }

      function getInterval(vertices, axis) {
        var min = Vec3.dot(axis, vertices[0]);
        var max = min;

        for (var i = 1; i < 8; ++i) {
          var projection = Vec3.dot(axis, vertices[i]);
          min = projection < min ? projection : min;
          max = projection > max ? projection : max;
        }

        return [min, max];
      }

      var aabbWithOBB = function () {
        var test = new Array(15);

        for (var i = 0; i < 15; i++) {
          test[i] = new Vec3(0, 0, 0);
        }

        var vertices = new Array(8);
        var vertices2 = new Array(8);

        for (var _i7 = 0; _i7 < 8; _i7++) {
          vertices[_i7] = new Vec3(0, 0, 0);
          vertices2[_i7] = new Vec3(0, 0, 0);
        }

        var min = new Vec3();
        var max = new Vec3();
        return function (aabb, obb) {
          Vec3.set(test[0], 1, 0, 0);
          Vec3.set(test[1], 0, 1, 0);
          Vec3.set(test[2], 0, 0, 1);
          Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
          Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
          Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

          for (var _i8 = 0; _i8 < 3; ++_i8) {
            Vec3.cross(test[6 + _i8 * 3 + 0], test[_i8], test[3]);
            Vec3.cross(test[6 + _i8 * 3 + 1], test[_i8], test[4]);
            Vec3.cross(test[6 + _i8 * 3 + 1], test[_i8], test[5]);
          }

          Vec3.subtract(min, aabb.center, aabb.halfExtents);
          Vec3.add(max, aabb.center, aabb.halfExtents);
          getAABBVertices(min, max, vertices);
          getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);

          for (var j = 0; j < 15; ++j) {
            var a = getInterval(vertices, test[j]);
            var b = getInterval(vertices2, test[j]);

            if (b[0] > a[1] || a[0] > b[1]) {
              return 0;
            }
          }

          return 1;
        };
      }();

      var aabbPlane = function aabbPlane(aabb, plane) {
        var r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z);
        var dot = Vec3.dot(plane.n, aabb.center);

        if (dot + r < plane.d) {
          return -1;
        } else if (dot - r > plane.d) {
          return 0;
        }

        return 1;
      };

      var aabbFrustum = function aabbFrustum(aabb, frustum) {
        for (var i = 0; i < frustum.planes.length; i++) {
          if (aabbPlane(aabb, frustum.planes[i]) === -1) {
            return 0;
          }
        }

        return 1;
      };

      var aabbFrustumAccurate = function () {
        var tmp = new Array(8);
        var out1 = 0;
        var out2 = 0;

        for (var i = 0; i < tmp.length; i++) {
          tmp[i] = new Vec3(0, 0, 0);
        }

        return function (aabb, frustum) {
          var result = 0;
          var intersects = false;

          for (var _i9 = 0; _i9 < frustum.planes.length; _i9++) {
            result = aabbPlane(aabb, frustum.planes[_i9]);
            if (result === -1) return 0;else if (result === 1) {
                intersects = true;
              }
          }

          if (!intersects) {
            return 1;
          }

          for (var _i10 = 0; _i10 < frustum.vertices.length; _i10++) {
            Vec3.subtract(tmp[_i10], frustum.vertices[_i10], aabb.center);
          }

          out1 = 0, out2 = 0;

          for (var _i11 = 0; _i11 < frustum.vertices.length; _i11++) {
            if (tmp[_i11].x > aabb.halfExtents.x) {
              out1++;
            } else if (tmp[_i11].x < -aabb.halfExtents.x) {
              out2++;
            }
          }

          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }

          out1 = 0;
          out2 = 0;

          for (var _i12 = 0; _i12 < frustum.vertices.length; _i12++) {
            if (tmp[_i12].y > aabb.halfExtents.y) {
              out1++;
            } else if (tmp[_i12].y < -aabb.halfExtents.y) {
              out2++;
            }
          }

          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }

          out1 = 0;
          out2 = 0;

          for (var _i13 = 0; _i13 < frustum.vertices.length; _i13++) {
            if (tmp[_i13].z > aabb.halfExtents.z) {
              out1++;
            } else if (tmp[_i13].z < -aabb.halfExtents.z) {
              out2++;
            }
          }

          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }

          return 1;
        };
      }();

      var obbPoint = function () {
        var tmp = new Vec3(0, 0, 0);
        var m3 = new Mat3();

        var lessThan = function lessThan(a, b) {
          return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
        };

        return function (obb, point) {
          Vec3.subtract(tmp, point, obb.center);
          Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation));
          return lessThan(tmp, obb.halfExtents);
        };
      }();

      var obbPlane = function () {
        var absDot = function absDot(n, x, y, z) {
          return Math.abs(n.x * x + n.y * y + n.z * z);
        };

        return function (obb, plane) {
          var r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
          var dot = Vec3.dot(plane.n, obb.center);

          if (dot + r < plane.d) {
            return -1;
          } else if (dot - r > plane.d) {
            return 0;
          }

          return 1;
        };
      }();

      var obbFrustum = function obbFrustum(obb, frustum) {
        for (var i = 0; i < frustum.planes.length; i++) {
          if (obbPlane(obb, frustum.planes[i]) === -1) {
            return 0;
          }
        }

        return 1;
      };

      var obbFrustumAccurate = function () {
        var tmp = new Array(8);
        var dist = 0;
        var out1 = 0;
        var out2 = 0;

        for (var i = 0; i < tmp.length; i++) {
          tmp[i] = new Vec3(0, 0, 0);
        }

        var dot = function dot(n, x, y, z) {
          return n.x * x + n.y * y + n.z * z;
        };

        return function (obb, frustum) {
          var result = 0;
          var intersects = false;

          for (var _i14 = 0; _i14 < frustum.planes.length; _i14++) {
            result = obbPlane(obb, frustum.planes[_i14]);
            if (result === -1) return 0;else if (result === 1) {
                intersects = true;
              }
          }

          if (!intersects) {
            return 1;
          }

          for (var _i15 = 0; _i15 < frustum.vertices.length; _i15++) {
            Vec3.subtract(tmp[_i15], frustum.vertices[_i15], obb.center);
          }

          out1 = 0, out2 = 0;

          for (var _i16 = 0; _i16 < frustum.vertices.length; _i16++) {
            dist = dot(tmp[_i16], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);

            if (dist > obb.halfExtents.x) {
              out1++;
            } else if (dist < -obb.halfExtents.x) {
              out2++;
            }
          }

          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }

          out1 = 0;
          out2 = 0;

          for (var _i17 = 0; _i17 < frustum.vertices.length; _i17++) {
            dist = dot(tmp[_i17], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);

            if (dist > obb.halfExtents.y) {
              out1++;
            } else if (dist < -obb.halfExtents.y) {
              out2++;
            }
          }

          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }

          out1 = 0;
          out2 = 0;

          for (var _i18 = 0; _i18 < frustum.vertices.length; _i18++) {
            dist = dot(tmp[_i18], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

            if (dist > obb.halfExtents.z) {
              out1++;
            } else if (dist < -obb.halfExtents.z) {
              out2++;
            }
          }

          if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
            return 0;
          }

          return 1;
        };
      }();

      var obbWithOBB = function () {
        var test = new Array(15);

        for (var i = 0; i < 15; i++) {
          test[i] = new Vec3(0, 0, 0);
        }

        var vertices = new Array(8);
        var vertices2 = new Array(8);

        for (var _i19 = 0; _i19 < 8; _i19++) {
          vertices[_i19] = new Vec3(0, 0, 0);
          vertices2[_i19] = new Vec3(0, 0, 0);
        }

        return function (obb1, obb2) {
          Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02);
          Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05);
          Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08);
          Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02);
          Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05);
          Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);

          for (var _i20 = 0; _i20 < 3; ++_i20) {
            Vec3.cross(test[6 + _i20 * 3 + 0], test[_i20], test[3]);
            Vec3.cross(test[6 + _i20 * 3 + 1], test[_i20], test[4]);
            Vec3.cross(test[6 + _i20 * 3 + 2], test[_i20], test[5]);
          }

          getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices);
          getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);

          for (var _i21 = 0; _i21 < 15; ++_i21) {
            var a = getInterval(vertices, test[_i21]);
            var b = getInterval(vertices2, test[_i21]);

            if (b[0] > a[1] || a[0] > b[1]) {
              return 0;
            }
          }

          return 1;
        };
      }();

      var obbCapsule = function () {
        var sphere_0 = new Sphere();
        var v3_0 = new Vec3();
        var v3_1 = new Vec3();
        var v3_2 = new Vec3();
        var v3_verts8 = new Array(8);

        for (var i = 0; i < 8; i++) {
          v3_verts8[i] = new Vec3();
        }

        var v3_axis8 = new Array(8);

        for (var _i22 = 0; _i22 < 8; _i22++) {
          v3_axis8[_i22] = new Vec3();
        }

        return function (obb, capsule) {
          var h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

          if (h === 0) {
            sphere_0.radius = capsule.radius;
            sphere_0.center.set(capsule.ellipseCenter0);
            return intersect.sphereOBB(sphere_0, obb);
          } else {
            v3_0.x = obb.orientation.m00;
            v3_0.y = obb.orientation.m01;
            v3_0.z = obb.orientation.m02;
            v3_1.x = obb.orientation.m03;
            v3_1.y = obb.orientation.m04;
            v3_1.z = obb.orientation.m05;
            v3_2.x = obb.orientation.m06;
            v3_2.y = obb.orientation.m07;
            v3_2.z = obb.orientation.m08;
            getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
            var axes = v3_axis8;
            var a0 = Vec3.copy(axes[0], v3_0);
            var a1 = Vec3.copy(axes[1], v3_1);
            var a2 = Vec3.copy(axes[2], v3_2);
            var C = Vec3.subtract(axes[3], capsule.center, obb.center);
            C.normalize();
            var B = Vec3.subtract(axes[4], capsule.ellipseCenter0, capsule.ellipseCenter1);
            B.normalize();
            Vec3.cross(axes[5], a0, B);
            Vec3.cross(axes[6], a1, B);
            Vec3.cross(axes[7], a2, B);

            for (var _i23 = 0; _i23 < 8; ++_i23) {
              var a = getInterval(v3_verts8, axes[_i23]);
              var d0 = Vec3.dot(axes[_i23], capsule.ellipseCenter0);
              var d1 = Vec3.dot(axes[_i23], capsule.ellipseCenter1);
              var max_d = Math.max(d0, d1);
              var min_d = Math.min(d0, d1);
              var d_min = min_d - capsule.radius;
              var d_max = max_d + capsule.radius;

              if (d_min > a[1] || a[0] > d_max) {
                return 0;
              }
            }

            return 1;
          }
        };
      }();

      var spherePlane = function spherePlane(sphere, plane) {
        var dot = Vec3.dot(plane.n, sphere.center);
        var r = sphere.radius * plane.n.length();

        if (dot + r < plane.d) {
          return -1;
        } else if (dot - r > plane.d) {
          return 0;
        }

        return 1;
      };

      var sphereFrustum = function sphereFrustum(sphere, frustum) {
        for (var i = 0; i < frustum.planes.length; i++) {
          if (spherePlane(sphere, frustum.planes[i]) === -1) {
            return 0;
          }
        }

        return 1;
      };

      var sphereFrustumAccurate = function () {
        var pt = new Vec3(0, 0, 0);
        var map = [1, -1, 1, -1, 1, -1];
        return function (sphere, frustum) {
          for (var i = 0; i < 6; i++) {
            var plane = frustum.planes[i];
            var r = sphere.radius;
            var c = sphere.center;
            var n = plane.n;
            var d = plane.d;
            var dot = Vec3.dot(n, c);
            if (dot + r < d) return 0;else if (dot - r > d) {
                continue;
              }
            Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));

            for (var j = 0; j < 6; j++) {
              if (j === i || j === i + map[i]) {
                continue;
              }

              var test = frustum.planes[j];

              if (Vec3.dot(test.n, pt) < test.d) {
                return 0;
              }
            }
          }

          return 1;
        };
      }();

      var sphereWithSphere = function sphereWithSphere(sphere0, sphere1) {
        var r = sphere0.radius + sphere1.radius;
        return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
      };

      var sphereAABB = function () {
        var pt = new Vec3();
        return function (sphere, aabb) {
          pt_point_aabb(pt, sphere.center, aabb);
          return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
        };
      }();

      var sphereOBB = function () {
        var pt = new Vec3();
        return function (sphere, obb) {
          pt_point_obb(pt, sphere.center, obb);
          return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
        };
      }();

      var sphereCapsule = function () {
        var v3_0 = new Vec3();
        var v3_1 = new Vec3();
        return function (sphere, capsule) {
          var r = sphere.radius + capsule.radius;
          var squaredR = r * r;
          var h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

          if (h === 0) {
            return Vec3.squaredDistance(sphere.center, capsule.center) < squaredR;
          } else {
            Vec3.subtract(v3_0, sphere.center, capsule.ellipseCenter0);
            Vec3.subtract(v3_1, capsule.ellipseCenter1, capsule.ellipseCenter0);
            var t = Vec3.dot(v3_0, v3_1) / h;

            if (t < 0) {
              return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter0) < squaredR;
            } else if (t > 1) {
              return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter1) < squaredR;
            } else {
              Vec3.scaleAndAdd(v3_0, capsule.ellipseCenter0, v3_1, t);
              return Vec3.squaredDistance(sphere.center, v3_0) < squaredR;
            }
          }
        };
      }();

      var capsuleWithCapsule = function () {
        var v3_0 = new Vec3();
        var v3_1 = new Vec3();
        var v3_2 = new Vec3();
        var v3_3 = new Vec3();
        var v3_4 = new Vec3();
        var v3_5 = new Vec3();
        return function capsuleWithCapsule(capsuleA, capsuleB) {
          var u = Vec3.subtract(v3_0, capsuleA.ellipseCenter1, capsuleA.ellipseCenter0);
          var v = Vec3.subtract(v3_1, capsuleB.ellipseCenter1, capsuleB.ellipseCenter0);
          var w = Vec3.subtract(v3_2, capsuleA.ellipseCenter0, capsuleB.ellipseCenter0);
          var a = Vec3.dot(u, u);
          var b = Vec3.dot(u, v);
          var c = Vec3.dot(v, v);
          var d = Vec3.dot(u, w);
          var e = Vec3.dot(v, w);
          var D = a * c - b * b;
          var sN;
          var sD = D;
          var tN;
          var tD = D;

          if (D < EPSILON) {
            sN = 0.0;
            sD = 1.0;
            tN = e;
            tD = c;
          } else {
            sN = b * e - c * d;
            tN = a * e - b * d;

            if (sN < 0.0) {
              sN = 0.0;
              tN = e;
              tD = c;
            } else if (sN > sD) {
              sN = sD;
              tN = e + b;
              tD = c;
            }
          }

          if (tN < 0.0) {
            tN = 0.0;

            if (-d < 0.0) {
              sN = 0.0;
            } else if (-d > a) {
              sN = sD;
            } else {
              sN = -d;
              sD = a;
            }
          } else if (tN > tD) {
            tN = tD;

            if (-d + b < 0.0) {
              sN = 0;
            } else if (-d + b > a) {
              sN = sD;
            } else {
              sN = -d + b;
              sD = a;
            }
          }

          var sc = Math.abs(sN) < EPSILON ? 0.0 : sN / sD;
          var tc = Math.abs(tN) < EPSILON ? 0.0 : tN / tD;
          var dP = v3_3;
          dP.set(w);
          dP.add(Vec3.multiplyScalar(v3_4, u, sc));
          dP.subtract(Vec3.multiplyScalar(v3_5, v, tc));
          var radius = capsuleA.radius + capsuleB.radius;
          return dP.lengthSqr() < radius * radius;
        };
      }();

      var intersect = {
        raySphere: raySphere,
        rayAABB: rayAABB,
        rayOBB: rayOBB,
        rayPlane: rayPlane,
        rayTriangle: rayTriangle,
        rayCapsule: rayCapsule,
        raySubMesh: raySubMesh,
        rayMesh: rayMesh,
        rayModel: rayModel,
        lineSphere: lineSphere,
        lineAABB: lineAABB,
        lineOBB: lineOBB,
        linePlane: linePlane,
        lineTriangle: lineTriangle,
        sphereWithSphere: sphereWithSphere,
        sphereAABB: sphereAABB,
        sphereOBB: sphereOBB,
        spherePlane: spherePlane,
        sphereFrustum: sphereFrustum,
        sphereFrustumAccurate: sphereFrustumAccurate,
        sphereCapsule: sphereCapsule,
        aabbWithAABB: aabbWithAABB,
        aabbWithOBB: aabbWithOBB,
        aabbPlane: aabbPlane,
        aabbFrustum: aabbFrustum,
        aabbFrustumAccurate: aabbFrustumAccurate,
        obbWithOBB: obbWithOBB,
        obbPlane: obbPlane,
        obbFrustum: obbFrustum,
        obbFrustumAccurate: obbFrustumAccurate,
        obbPoint: obbPoint,
        obbCapsule: obbCapsule,
        capsuleWithCapsule: capsuleWithCapsule,
        resolve: function resolve(g1, g2, outPt) {
          if (outPt === void 0) {
            outPt = null;
          }

          var type1 = g1._type;
          var type2 = g2._type;
          var resolver = this[type1 | type2];
          return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
        }
      };
      intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = raySphere;
      intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = rayAABB;
      intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = rayOBB;
      intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = rayPlane;
      intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = rayTriangle;
      intersect[enums.SHAPE_RAY | enums.SHAPE_CAPSULE] = rayCapsule;
      intersect[enums.SHAPE_LINE | enums.SHAPE_SPHERE] = lineSphere;
      intersect[enums.SHAPE_LINE | enums.SHAPE_AABB] = lineAABB;
      intersect[enums.SHAPE_LINE | enums.SHAPE_OBB] = lineOBB;
      intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = linePlane;
      intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = lineTriangle;
      intersect[enums.SHAPE_SPHERE] = sphereWithSphere;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphereAABB;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphereOBB;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = spherePlane;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphereFrustum;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphereFrustumAccurate;
      intersect[enums.SHAPE_SPHERE | enums.SHAPE_CAPSULE] = sphereCapsule;
      intersect[enums.SHAPE_AABB] = aabbWithAABB;
      intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabbWithOBB;
      intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabbPlane;
      intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabbFrustum;
      intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabbFrustumAccurate;
      intersect[enums.SHAPE_OBB] = obbWithOBB;
      intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obbPlane;
      intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obbFrustum;
      intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obbFrustumAccurate;
      intersect[enums.SHAPE_OBB | enums.SHAPE_CAPSULE] = obbCapsule;
      intersect[enums.SHAPE_CAPSULE] = capsuleWithCapsule;

      replaceProperty(Line.prototype, 'line', [{
        name: 'mag',
        newName: 'len'
      }, {
        name: 'magnitude',
        newName: 'len'
      }]);
      removeProperty(intersect, 'intersect', [{
        name: 'line_quad'
      }]);

      var v1 = new Vec3(0, 0, 0);
      var v2$1 = new Vec3(0, 0, 0);
      var temp_mat = legacyCC.mat4();
      var temp_vec4 = legacyCC.v4();
      var Plane = function () {
        Plane.create = function create(nx, ny, nz, d) {
          return new Plane(nx, ny, nz, d);
        };

        Plane.clone = function clone(p) {
          return new Plane(p.n.x, p.n.y, p.n.z, p.d);
        };

        Plane.copy = function copy(out, p) {
          Vec3.copy(out.n, p.n);
          out.d = p.d;
          return out;
        };

        Plane.fromPoints = function fromPoints(out, a, b, c) {
          Vec3.subtract(v1, b, a);
          Vec3.subtract(v2$1, c, a);
          Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2$1));
          out.d = Vec3.dot(out.n, a);
          return out;
        };

        Plane.set = function set(out, nx, ny, nz, d) {
          out.n.x = nx;
          out.n.y = ny;
          out.n.z = nz;
          out.d = d;
          return out;
        };

        Plane.fromNormalAndPoint = function fromNormalAndPoint(out, normal, point) {
          Vec3.copy(out.n, normal);
          out.d = Vec3.dot(normal, point);
          return out;
        };

        Plane.normalize = function normalize(out, a) {
          var len = a.n.length();
          Vec3.normalize(out.n, a.n);

          if (len > 0) {
            out.d = a.d / len;
          }

          return out;
        };

        function Plane(nx, ny, nz, d) {
          if (nx === void 0) {
            nx = 0;
          }

          if (ny === void 0) {
            ny = 1;
          }

          if (nz === void 0) {
            nz = 0;
          }

          if (d === void 0) {
            d = 0;
          }

          this.n = void 0;
          this.d = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_PLANE;
          this.n = new Vec3(nx, ny, nz);
          this.d = d;
        }

        var _proto = Plane.prototype;

        _proto.transform = function transform(mat) {
          Mat4.invert(temp_mat, mat);
          Mat4.transpose(temp_mat, temp_mat);
          Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d);
          Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat);
          Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z);
          this.d = temp_vec4.w;
        };

        _createClass(Plane, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }, {
          key: "x",
          get: function get() {
            return this.n.x;
          },
          set: function set(val) {
            this.n.x = val;
          }
        }, {
          key: "y",
          get: function get() {
            return this.n.y;
          },
          set: function set(val) {
            this.n.y = val;
          }
        }, {
          key: "z",
          get: function get() {
            return this.n.z;
          },
          set: function set(val) {
            this.n.z = val;
          }
        }, {
          key: "w",
          get: function get() {
            return this.d;
          },
          set: function set(val) {
            this.d = val;
          }
        }]);

        return Plane;
      }();

      var NativeBufferPool = function () {
        function NativeBufferPool(dataType, entryBits, stride) {
          this._arrayBuffers = [];
          this._chunkSize = void 0;
          this._chunkSize = stride * (1 << entryBits);
        }

        var _proto = NativeBufferPool.prototype;

        _proto.allocateNewChunk = function allocateNewChunk() {
          return new ArrayBuffer(this._chunkSize);
        };

        return NativeBufferPool;
      }();

      var _NodeViewDataType, _NodeViewDataMembers, _PassViewDataType, _PassViewDataMembers, _AABBViewDataType, _AABBViewDataMembers;

      var contains$2 = function contains(a, t) {
        for (var i = 0; i < a.length; ++i) {
          if (a[i] === t) return true;
        }

        return false;
      };

      var BufferDataType;

      (function (BufferDataType) {
        BufferDataType[BufferDataType["UINT32"] = 0] = "UINT32";
        BufferDataType[BufferDataType["FLOAT32"] = 1] = "FLOAT32";
        BufferDataType[BufferDataType["NEVER"] = 2] = "NEVER";
      })(BufferDataType || (BufferDataType = {}));

      var BufferPool = function () {
        function BufferPool(poolType, dataType, dataMembers, enumType, entryBits) {
          if (entryBits === void 0) {
            entryBits = 8;
          }

          this._dataType = void 0;
          this._dataMembers = void 0;
          this._elementCount = void 0;
          this._entryBits = void 0;
          this._stride = void 0;
          this._entriesPerChunk = void 0;
          this._entryMask = void 0;
          this._chunkMask = void 0;
          this._poolFlag = void 0;
          this._arrayBuffers = [];
          this._freeLists = [];
          this._uint32BufferViews = [];
          this._float32BufferViews = [];
          this._hasUint32 = false;
          this._hasFloat32 = false;
          this._nativePool = void 0;
          this._elementCount = enumType.COUNT;
          this._entryBits = entryBits;
          this._dataType = dataType;
          this._dataMembers = dataMembers;
          var bytesPerElement = 4;
          this._stride = bytesPerElement * this._elementCount;
          this._entriesPerChunk = 1 << entryBits;
          this._entryMask = this._entriesPerChunk - 1;
          this._poolFlag = 1 << 30;
          this._chunkMask = ~(this._entryMask | this._poolFlag);
          this._nativePool = new NativeBufferPool(poolType, entryBits, this._stride);
          var type = BufferDataType.NEVER;
          var hasFloat32 = false;
          var hasUint32 = false;

          for (var e in dataType) {
            hasFloat32 = this._hasFloat32;
            hasUint32 = this._hasUint32;

            if (hasUint32 && hasFloat32) {
              break;
            }

            type = dataType[e];

            if (!hasFloat32 && type === BufferDataType.FLOAT32) {
              this._hasFloat32 = true;
            } else if (!hasUint32 && type === BufferDataType.UINT32) {
              this._hasUint32 = true;
            }
          }
        }

        var _proto = BufferPool.prototype;

        _proto.alloc = function alloc() {
          var i = 0;

          for (; i < this._freeLists.length; i++) {
            var list = this._freeLists[i];

            if (list.length) {
              var j = list[list.length - 1];
              list.length--;
              return (i << this._entryBits) + j + this._poolFlag;
            }
          }

          var buffer = this._nativePool.allocateNewChunk();

          var float32BufferViews = [];
          var uint32BufferViews = [];
          var freeList = [];
          var hasFloat32 = this._hasFloat32;
          var hasUint32 = this._hasUint32;

          for (var _j = 0; _j < this._entriesPerChunk; _j++) {
            if (hasFloat32) {
              float32BufferViews.push(new Float32Array(buffer, this._stride * _j, this._elementCount));
            }

            if (hasUint32) {
              uint32BufferViews.push(new Uint32Array(buffer, this._stride * _j, this._elementCount));
            }

            if (_j) {
              freeList.push(_j);
            }
          }

          if (hasUint32) {
            this._uint32BufferViews.push(uint32BufferViews);
          }

          if (hasFloat32) {
            this._float32BufferViews.push(float32BufferViews);
          }

          this._freeLists.push(freeList);

          this._arrayBuffers.push(buffer);

          var handle = (i << this._entryBits) + this._poolFlag;
          return handle;
        };

        _proto.getBuffer = function getBuffer(handle) {
          var chunk = (this._chunkMask & handle) >> this._entryBits;
          var entry = this._entryMask & handle;
          var bufferViews = this._hasFloat32 ? this._float32BufferViews : this._uint32BufferViews;

          if ( (!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains$2(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return [];
          }

          return bufferViews[chunk][entry];
        };

        _proto.getTypedArray = function getTypedArray(handle, element) {
          var chunk = (this._chunkMask & handle) >> this._entryBits;
          var entry = this._entryMask & handle;
          var bufferViews = this._dataType[element] === BufferDataType.UINT32 ? this._uint32BufferViews : this._float32BufferViews;

          if ( (!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains$2(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return [];
          }

          var index = element;
          var view = bufferViews[chunk][entry];
          var count = this._dataMembers[element];
          return view.subarray(index, index + count);
        };

        _proto.free = function free(handle) {
          var chunk = (this._chunkMask & handle) >> this._entryBits;
          var entry = this._entryMask & handle;

          if ( (!handle || chunk < 0 || chunk >= this._freeLists.length || entry < 0 || entry >= this._entriesPerChunk || contains$2(this._freeLists[chunk], entry))) {
            console.warn('invalid buffer pool handle');
            return;
          }

          var bufferViews = this._hasUint32 ? this._uint32BufferViews : this._float32BufferViews;
          bufferViews[chunk][entry].fill(0);

          this._freeLists[chunk].push(entry);
        };

        return BufferPool;
      }();

      var PoolType;

      (function (PoolType) {
        PoolType[PoolType["NODE"] = 0] = "NODE";
        PoolType[PoolType["PASS"] = 1] = "PASS";
        PoolType[PoolType["AABB"] = 2] = "AABB";
      })(PoolType || (PoolType = {}));

      var NULL_HANDLE = 0;
      var NodeView;

      (function (NodeView) {
        NodeView[NodeView["DIRTY_FLAG"] = 0] = "DIRTY_FLAG";
        NodeView[NodeView["LAYER"] = 1] = "LAYER";
        NodeView[NodeView["WORLD_SCALE"] = 2] = "WORLD_SCALE";
        NodeView[NodeView["WORLD_POSITION"] = 5] = "WORLD_POSITION";
        NodeView[NodeView["WORLD_ROTATION"] = 8] = "WORLD_ROTATION";
        NodeView[NodeView["WORLD_MATRIX"] = 12] = "WORLD_MATRIX";
        NodeView[NodeView["LOCAL_SCALE"] = 28] = "LOCAL_SCALE";
        NodeView[NodeView["LOCAL_POSITION"] = 31] = "LOCAL_POSITION";
        NodeView[NodeView["LOCAL_ROTATION"] = 34] = "LOCAL_ROTATION";
        NodeView[NodeView["COUNT"] = 38] = "COUNT";
      })(NodeView || (NodeView = {}));

      var NodeViewDataType = (_NodeViewDataType = {}, _NodeViewDataType[NodeView.DIRTY_FLAG] = BufferDataType.UINT32, _NodeViewDataType[NodeView.LAYER] = BufferDataType.UINT32, _NodeViewDataType[NodeView.WORLD_SCALE] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.WORLD_POSITION] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.WORLD_ROTATION] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.WORLD_MATRIX] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.LOCAL_SCALE] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.LOCAL_POSITION] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.LOCAL_ROTATION] = BufferDataType.FLOAT32, _NodeViewDataType[NodeView.COUNT] = BufferDataType.NEVER, _NodeViewDataType);
      var NodeViewDataMembers = (_NodeViewDataMembers = {}, _NodeViewDataMembers[NodeView.DIRTY_FLAG] = NodeView.LAYER - NodeView.DIRTY_FLAG, _NodeViewDataMembers[NodeView.LAYER] = NodeView.WORLD_SCALE - NodeView.LAYER, _NodeViewDataMembers[NodeView.WORLD_SCALE] = NodeView.WORLD_POSITION - NodeView.WORLD_SCALE, _NodeViewDataMembers[NodeView.WORLD_POSITION] = NodeView.WORLD_ROTATION - NodeView.WORLD_POSITION, _NodeViewDataMembers[NodeView.WORLD_ROTATION] = NodeView.WORLD_MATRIX - NodeView.WORLD_ROTATION, _NodeViewDataMembers[NodeView.WORLD_MATRIX] = NodeView.LOCAL_SCALE - NodeView.WORLD_MATRIX, _NodeViewDataMembers[NodeView.LOCAL_SCALE] = NodeView.LOCAL_POSITION - NodeView.LOCAL_SCALE, _NodeViewDataMembers[NodeView.LOCAL_POSITION] = NodeView.LOCAL_ROTATION - NodeView.LOCAL_POSITION, _NodeViewDataMembers[NodeView.LOCAL_ROTATION] = NodeView.COUNT - NodeView.LOCAL_ROTATION, _NodeViewDataMembers[NodeView.COUNT] = 1, _NodeViewDataMembers);
      var NodePool = new BufferPool(PoolType.NODE, NodeViewDataType, NodeViewDataMembers, NodeView);
      var PassView;

      (function (PassView) {
        PassView[PassView["PRIORITY"] = 0] = "PRIORITY";
        PassView[PassView["STAGE"] = 1] = "STAGE";
        PassView[PassView["PHASE"] = 2] = "PHASE";
        PassView[PassView["PRIMITIVE"] = 3] = "PRIMITIVE";
        PassView[PassView["BATCHING_SCHEME"] = 4] = "BATCHING_SCHEME";
        PassView[PassView["DYNAMIC_STATE"] = 5] = "DYNAMIC_STATE";
        PassView[PassView["HASH"] = 6] = "HASH";
        PassView[PassView["COUNT"] = 7] = "COUNT";
      })(PassView || (PassView = {}));

      var PassViewDataType = (_PassViewDataType = {}, _PassViewDataType[PassView.PRIORITY] = BufferDataType.UINT32, _PassViewDataType[PassView.STAGE] = BufferDataType.UINT32, _PassViewDataType[PassView.PHASE] = BufferDataType.UINT32, _PassViewDataType[PassView.PRIMITIVE] = BufferDataType.UINT32, _PassViewDataType[PassView.BATCHING_SCHEME] = BufferDataType.UINT32, _PassViewDataType[PassView.DYNAMIC_STATE] = BufferDataType.UINT32, _PassViewDataType[PassView.HASH] = BufferDataType.UINT32, _PassViewDataType[PassView.COUNT] = BufferDataType.NEVER, _PassViewDataType);
      var PassViewDataMembers = (_PassViewDataMembers = {}, _PassViewDataMembers[PassView.PRIORITY] = PassView.STAGE - PassView.PRIORITY, _PassViewDataMembers[PassView.STAGE] = PassView.PHASE - PassView.STAGE, _PassViewDataMembers[PassView.PHASE] = PassView.PRIMITIVE - PassView.PHASE, _PassViewDataMembers[PassView.PRIMITIVE] = PassView.BATCHING_SCHEME - PassView.PRIMITIVE, _PassViewDataMembers[PassView.BATCHING_SCHEME] = PassView.DYNAMIC_STATE - PassView.BATCHING_SCHEME, _PassViewDataMembers[PassView.DYNAMIC_STATE] = PassView.HASH - PassView.DYNAMIC_STATE, _PassViewDataMembers[PassView.HASH] = PassView.COUNT - PassView.HASH, _PassViewDataMembers[PassView.COUNT] = 1, _PassViewDataMembers);
      var PassPool = new BufferPool(PoolType.PASS, PassViewDataType, PassViewDataMembers, PassView);
      var AABBView;

      (function (AABBView) {
        AABBView[AABBView["CENTER"] = 0] = "CENTER";
        AABBView[AABBView["HALFEXTENTS"] = 3] = "HALFEXTENTS";
        AABBView[AABBView["COUNT"] = 6] = "COUNT";
      })(AABBView || (AABBView = {}));

      var AABBViewDataType = (_AABBViewDataType = {}, _AABBViewDataType[AABBView.CENTER] = BufferDataType.FLOAT32, _AABBViewDataType[AABBView.HALFEXTENTS] = BufferDataType.FLOAT32, _AABBViewDataType[AABBView.COUNT] = BufferDataType.NEVER, _AABBViewDataType);
      var AABBViewDataMembers = (_AABBViewDataMembers = {}, _AABBViewDataMembers[AABBView.CENTER] = AABBView.HALFEXTENTS - AABBView.CENTER, _AABBViewDataMembers[AABBView.HALFEXTENTS] = AABBView.COUNT - AABBView.HALFEXTENTS, _AABBViewDataMembers[AABBView.COUNT] = 1, _AABBViewDataMembers);
      var AABBPool = new BufferPool(PoolType.AABB, AABBViewDataType, AABBViewDataMembers, AABBView);

      var NativeNode = null;
      var NativeScene = null;
      var NativeAABB = null;
      var NativeModel = null;
      var NativeSkinningModel = null;
      var NativeBakedAnimInfo = null;
      var NativeBakedJointInfo = null;
      var NativeBakedSkinningModel = null;
      var NativeLight = null;
      var NativeDirectionalLight = null;
      var NativeSphereLight = null;
      var NativeSpotLight = null;
      var NaitveSkybox = null;
      var NativeFog = null;
      var NativeRenderWindow = null;
      var NativeCamera = null;
      var NativePass = null;
      var NativeSubModel = null;
      var NativeDrawBatch2D = null;
      var NativeRenderScene = null;
      var NativeOctree = null;
      var NativeAmbient = null;
      var NativeShadow = null;
      var NativeRoot = null;
      var NativeJointTransform = null;
      var NativeJointInfo = null;
      var NativePipelineSharedSceneData = null;
      var NativeGeometryRenderer = null;

      var _v3_tmp$1 = new Vec3();

      var _v3_tmp2 = new Vec3();

      var _v3_tmp3 = new Vec3();

      var _v3_tmp4 = new Vec3();

      var _m3_tmp = new Mat3();

      var transform_extent_m4 = function transform_extent_m4(out, extent, m4) {
        _m3_tmp.m00 = Math.abs(m4.m00);
        _m3_tmp.m01 = Math.abs(m4.m01);
        _m3_tmp.m02 = Math.abs(m4.m02);
        _m3_tmp.m03 = Math.abs(m4.m04);
        _m3_tmp.m04 = Math.abs(m4.m05);
        _m3_tmp.m05 = Math.abs(m4.m06);
        _m3_tmp.m06 = Math.abs(m4.m08);
        _m3_tmp.m07 = Math.abs(m4.m09);
        _m3_tmp.m08 = Math.abs(m4.m10);
        Vec3.transformMat3(out, extent, _m3_tmp);
      };

      var AABB = function () {
        AABB.create = function create(px, py, pz, hw, hh, hl) {
          return new AABB(px, py, pz, hw, hh, hl);
        };

        AABB.clone = function clone(a) {
          return new AABB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
        };

        AABB.copy = function copy(out, a) {
          Vec3.copy(out.center, a.center);
          Vec3.copy(out.halfExtents, a.halfExtents);
          return out;
        };

        AABB.fromPoints = function fromPoints(out, minPos, maxPos) {
          Vec3.add(_v3_tmp$1, maxPos, minPos);
          Vec3.subtract(_v3_tmp2, maxPos, minPos);
          Vec3.multiplyScalar(out.center, _v3_tmp$1, 0.5);
          Vec3.multiplyScalar(out.halfExtents, _v3_tmp2, 0.5);
          return out;
        };

        AABB.set = function set(out, px, py, pz, hw, hh, hl) {
          out.center.set(px, py, pz);
          out.halfExtents.set(hw, hh, hl);
          return out;
        };

        AABB.merge = function merge(out, a, b) {
          Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents);
          Vec3.subtract(_v3_tmp2, b.center, b.halfExtents);
          Vec3.add(_v3_tmp3, a.center, a.halfExtents);
          Vec3.add(_v3_tmp4, b.center, b.halfExtents);
          Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4);
          Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2);
          return AABB.fromPoints(out, _v3_tmp3, _v3_tmp4);
        };

        AABB.toBoundingSphere = function toBoundingSphere(out, a) {
          out.center.set(a.center);
          out.radius = a.halfExtents.length();
          return out;
        };

        AABB.transform = function transform(out, a, matrix) {
          Vec3.transformMat4(out.center, a.center, matrix);
          transform_extent_m4(out.halfExtents, a.halfExtents, matrix);
          return out;
        };

        function AABB(px, py, pz, hw, hh, hl) {
          if (px === void 0) {
            px = 0;
          }

          if (py === void 0) {
            py = 0;
          }

          if (pz === void 0) {
            pz = 0;
          }

          if (hw === void 0) {
            hw = 1;
          }

          if (hh === void 0) {
            hh = 1;
          }

          if (hl === void 0) {
            hl = 1;
          }

          this.center = void 0;
          this.halfExtents = void 0;
          this._type = void 0;
          this._aabbHandle = NULL_HANDLE;
          this._type = enums.SHAPE_AABB;

          this.center = new Vec3(px, py, pz);
          this.halfExtents = new Vec3(hw, hh, hl);
        }

        var _proto = AABB.prototype;

        _proto.getBoundary = function getBoundary(minPos, maxPos) {
          Vec3.subtract(minPos, this.center, this.halfExtents);
          Vec3.add(maxPos, this.center, this.halfExtents);
        };

        _proto.transform = function transform(m, pos, rot, scale, out) {
          Vec3.transformMat4(out.center, this.center, m);
          transform_extent_m4(out.halfExtents, this.halfExtents, m);
        };

        _proto.clone = function clone() {
          return AABB.clone(this);
        };

        _proto.copy = function copy(a) {
          return AABB.copy(this, a);
        };

        _proto.mergePoint = function mergePoint(point) {
          this.getBoundary(_v3_tmp$1, _v3_tmp2);

          if (point.x < _v3_tmp$1.x) {
            _v3_tmp$1.x = point.x;
          }

          if (point.y < _v3_tmp$1.y) {
            _v3_tmp$1.y = point.y;
          }

          if (point.z < _v3_tmp$1.z) {
            _v3_tmp$1.z = point.z;
          }

          if (point.x > _v3_tmp2.x) {
            _v3_tmp2.x = point.x;
          }

          if (point.y > _v3_tmp2.y) {
            _v3_tmp2.y = point.y;
          }

          if (point.z > _v3_tmp2.z) {
            _v3_tmp2.z = point.z;
          }

          Vec3.add(_v3_tmp3, _v3_tmp$1, _v3_tmp2);
          this.center.set(Vec3.multiplyScalar(_v3_tmp3, _v3_tmp3, 0.5));
          this.halfExtents.set(_v3_tmp2.x - _v3_tmp3.x, _v3_tmp2.y - _v3_tmp3.y, _v3_tmp2.z - _v3_tmp3.z);
        };

        _proto.mergePoints = function mergePoints(points) {
          if (points.length < 1) {
            return;
          }

          for (var i = 0; i < points.length; i++) {
            this.mergePoint(points[i]);
          }
        };

        _proto.mergeFrustum = function mergeFrustum(frustum) {
          return this.mergePoints(frustum.vertices);
        };

        _createClass(AABB, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return AABB;
      }();

      var _v3_tmp$2 = new Vec3();

      var _v3_tmp2$1 = new Vec3();

      var _m3_tmp$1 = new Mat3();

      var transform_extent_m3 = function transform_extent_m3(out, extent, m3) {
        _m3_tmp$1.m00 = Math.abs(m3.m00);
        _m3_tmp$1.m01 = Math.abs(m3.m01);
        _m3_tmp$1.m02 = Math.abs(m3.m02);
        _m3_tmp$1.m03 = Math.abs(m3.m03);
        _m3_tmp$1.m04 = Math.abs(m3.m04);
        _m3_tmp$1.m05 = Math.abs(m3.m05);
        _m3_tmp$1.m06 = Math.abs(m3.m06);
        _m3_tmp$1.m07 = Math.abs(m3.m07);
        _m3_tmp$1.m08 = Math.abs(m3.m08);
        Vec3.transformMat3(out, extent, _m3_tmp$1);
      };

      var OBB = function () {
        OBB.create = function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
          return new OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        };

        OBB.clone = function clone(a) {
          return new OBB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
        };

        OBB.copy = function copy(out, a) {
          Vec3.copy(out.center, a.center);
          Vec3.copy(out.halfExtents, a.halfExtents);
          Mat3.copy(out.orientation, a.orientation);
          return out;
        };

        OBB.fromPoints = function fromPoints(out, minPos, maxPos) {
          Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), 0.5);
          Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2$1, maxPos, minPos), 0.5);
          Mat3.identity(out.orientation);
          return out;
        };

        OBB.set = function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
          Vec3.set(out.center, cx, cy, cz);
          Vec3.set(out.halfExtents, hw, hh, hl);
          Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
          return out;
        };

        function OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
          if (cx === void 0) {
            cx = 0;
          }

          if (cy === void 0) {
            cy = 0;
          }

          if (cz === void 0) {
            cz = 0;
          }

          if (hw === void 0) {
            hw = 1;
          }

          if (hh === void 0) {
            hh = 1;
          }

          if (hl === void 0) {
            hl = 1;
          }

          if (ox_1 === void 0) {
            ox_1 = 1;
          }

          if (ox_2 === void 0) {
            ox_2 = 0;
          }

          if (ox_3 === void 0) {
            ox_3 = 0;
          }

          if (oy_1 === void 0) {
            oy_1 = 0;
          }

          if (oy_2 === void 0) {
            oy_2 = 1;
          }

          if (oy_3 === void 0) {
            oy_3 = 0;
          }

          if (oz_1 === void 0) {
            oz_1 = 0;
          }

          if (oz_2 === void 0) {
            oz_2 = 0;
          }

          if (oz_3 === void 0) {
            oz_3 = 1;
          }

          this.center = void 0;
          this.halfExtents = void 0;
          this.orientation = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_OBB;
          this.center = new Vec3(cx, cy, cz);
          this.halfExtents = new Vec3(hw, hh, hl);
          this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        }

        var _proto = OBB.prototype;

        _proto.getBoundary = function getBoundary(minPos, maxPos) {
          transform_extent_m3(_v3_tmp$2, this.halfExtents, this.orientation);
          Vec3.subtract(minPos, this.center, _v3_tmp$2);
          Vec3.add(maxPos, this.center, _v3_tmp$2);
        };

        _proto.transform = function transform(m, pos, rot, scale, out) {
          Vec3.transformMat4(out.center, this.center, m);
          Mat3.fromQuat(out.orientation, rot);
          Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        };

        _proto.translateAndRotate = function translateAndRotate(m, rot, out) {
          Vec3.transformMat4(out.center, this.center, m);
          Mat3.fromQuat(out.orientation, rot);
        };

        _proto.setScale = function setScale(scale, out) {
          Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        };

        _createClass(OBB, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }]);

        return OBB;
      }();

      var Capsule = function () {
        function Capsule(radius, halfHeight, axis) {
          if (radius === void 0) {
            radius = 0.5;
          }

          if (halfHeight === void 0) {
            halfHeight = 0.5;
          }

          if (axis === void 0) {
            axis = 1;
          }

          this._type = void 0;
          this.radius = void 0;
          this.halfHeight = void 0;
          this.axis = void 0;
          this.center = void 0;
          this.rotation = void 0;
          this.ellipseCenter0 = void 0;
          this.ellipseCenter1 = void 0;
          this._type = enums.SHAPE_CAPSULE;
          this.radius = radius;
          this.halfHeight = halfHeight;
          this.axis = axis;
          this.center = new Vec3();
          this.rotation = new Quat();
          this.ellipseCenter0 = new Vec3(0, halfHeight, 0);
          this.ellipseCenter1 = new Vec3(0, -halfHeight, 0);
          this.updateCache();
        }

        var _proto = Capsule.prototype;

        _proto.transform = function transform(m, pos, rot, scale, out) {
          var ws = scale;
          var s = absMaxComponent(ws);
          out.radius = this.radius * Math.abs(s);
          var halfTotalWorldHeight = (this.halfHeight + this.radius) * Math.abs(ws.y);
          var halfWorldHeight = halfTotalWorldHeight - out.radius;
          if (halfWorldHeight < 0) halfWorldHeight = 0;
          out.halfHeight = halfWorldHeight;
          Vec3.transformMat4(out.center, this.center, m);
          Quat.multiply(out.rotation, this.rotation, rot);
          out.updateCache();
        };

        _proto.updateCache = function updateCache() {
          this.updateLocalCenter();
          Vec3.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation);
          Vec3.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation);
          this.ellipseCenter0.add(this.center);
          this.ellipseCenter1.add(this.center);
        };

        _proto.updateLocalCenter = function updateLocalCenter() {
          var halfHeight = this.halfHeight;
          var axis = this.axis;

          switch (axis) {
            case 0:
              this.ellipseCenter0.set(halfHeight, 0, 0);
              this.ellipseCenter1.set(-halfHeight, 0, 0);
              break;

            case 1:
              this.ellipseCenter0.set(0, halfHeight, 0);
              this.ellipseCenter1.set(0, -halfHeight, 0);
              break;

            case 2:
              this.ellipseCenter0.set(0, 0, halfHeight);
              this.ellipseCenter1.set(0, 0, -halfHeight);
              break;
          }
        };

        _createClass(Capsule, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }]);

        return Capsule;
      }();

      var _v = new Array(8);

      _v[0] = new Vec3(1, 1, 1);
      _v[1] = new Vec3(-1, 1, 1);
      _v[2] = new Vec3(-1, -1, 1);
      _v[3] = new Vec3(1, -1, 1);
      _v[4] = new Vec3(1, 1, -1);
      _v[5] = new Vec3(-1, 1, -1);
      _v[6] = new Vec3(-1, -1, -1);
      _v[7] = new Vec3(1, -1, -1);

      var _nearTemp = new Vec3();

      var _farTemp = new Vec3();

      var _temp_v3 = new Vec3();

      var Frustum = function () {
        Frustum.createFromAABB = function createFromAABB(out, aabb) {
          var vec3_min = new Vec3();
          var vec3_max = new Vec3();
          Vec3.subtract(vec3_min, aabb.center, aabb.halfExtents);
          Vec3.add(vec3_max, aabb.center, aabb.halfExtents);
          out.vertices[0].set(vec3_min.x, vec3_max.y, vec3_min.z);
          out.vertices[1].set(vec3_max.x, vec3_max.y, vec3_min.z);
          out.vertices[2].set(vec3_max.x, vec3_min.y, vec3_min.z);
          out.vertices[3].set(vec3_min.x, vec3_min.y, vec3_min.z);
          out.vertices[4].set(vec3_min.x, vec3_max.y, vec3_max.z);
          out.vertices[5].set(vec3_max.x, vec3_max.y, vec3_max.z);
          out.vertices[6].set(vec3_max.x, vec3_min.y, vec3_max.z);
          out.vertices[7].set(vec3_min.x, vec3_min.y, vec3_max.z);

          if (out._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
            return out;
          }

          out.updatePlanes();
          return out;
        };

        Frustum.split = function split(out, camera, m, start, end) {
          var h = Math.tan(camera.fov * 0.5);
          var w = h * camera.aspect;

          _nearTemp.set(start * w, start * h, start);

          _farTemp.set(end * w, end * h, end);

          var vertexes = out.vertices;

          _temp_v3.set(_nearTemp.x, _nearTemp.y, _nearTemp.z);

          Vec3.transformMat4(vertexes[0], _temp_v3, m);

          _temp_v3.set(-_nearTemp.x, _nearTemp.y, _nearTemp.z);

          Vec3.transformMat4(vertexes[1], _temp_v3, m);

          _temp_v3.set(-_nearTemp.x, -_nearTemp.y, _nearTemp.z);

          Vec3.transformMat4(vertexes[2], _temp_v3, m);

          _temp_v3.set(_nearTemp.x, -_nearTemp.y, _nearTemp.z);

          Vec3.transformMat4(vertexes[3], _temp_v3, m);

          _temp_v3.set(_farTemp.x, _farTemp.y, _farTemp.z);

          Vec3.transformMat4(vertexes[4], _temp_v3, m);

          _temp_v3.set(-_farTemp.x, _farTemp.y, _farTemp.z);

          Vec3.transformMat4(vertexes[5], _temp_v3, m);

          _temp_v3.set(-_farTemp.x, -_farTemp.y, _farTemp.z);

          Vec3.transformMat4(vertexes[6], _temp_v3, m);

          _temp_v3.set(_farTemp.x, -_farTemp.y, _farTemp.z);

          Vec3.transformMat4(vertexes[7], _temp_v3, m);
          out.updatePlanes();
          return out;
        };

        Frustum.create = function create() {
          return new Frustum();
        };

        Frustum.clone = function clone(f) {
          return Frustum.copy(new Frustum(), f);
        };

        Frustum.copy = function copy(out, f) {
          out._type = f._type;

          for (var i = 0; i < 6; ++i) {
            Plane.copy(out.planes[i], f.planes[i]);
          }

          for (var _i = 0; _i < 8; ++_i) {
            Vec3.copy(out.vertices[_i], f.vertices[_i]);
          }

          return out;
        };

        function Frustum() {
          this.planes = void 0;
          this.vertices = void 0;
          this._type = void 0;
          this._type = enums.SHAPE_FRUSTUM;
          this.planes = new Array(6);

          for (var i = 0; i < 6; ++i) {
            this.planes[i] = Plane.create(0, 0, 0, 0);
          }

          this.vertices = new Array(8);

          for (var _i2 = 0; _i2 < 8; ++_i2) {
            this.vertices[_i2] = new Vec3();
          }
        }

        var _proto = Frustum.prototype;

        _proto.update = function update(m, inv) {
          Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08);
          this.planes[0].d = -(m.m15 + m.m12);
          Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08);
          this.planes[1].d = -(m.m15 - m.m12);
          Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09);
          this.planes[2].d = -(m.m15 + m.m13);
          Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09);
          this.planes[3].d = -(m.m15 - m.m13);
          Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10);
          this.planes[4].d = -(m.m15 + m.m14);
          Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10);
          this.planes[5].d = -(m.m15 - m.m14);

          if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
            return;
          }

          for (var i = 0; i < 6; i++) {
            var pl = this.planes[i];
            var invDist = 1 / pl.n.length();
            Vec3.multiplyScalar(pl.n, pl.n, invDist);
            pl.d *= invDist;
          }

          for (var _i3 = 0; _i3 < 8; _i3++) {
            Vec3.transformMat4(this.vertices[_i3], _v[_i3], inv);
          }
        };

        _proto.transform = function transform(mat) {
          if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
            return;
          }

          for (var i = 0; i < 8; i++) {
            Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
          }

          this.updatePlanes();
        };

        _proto.updatePlanes = function updatePlanes() {
          Plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[6], this.vertices[5]);
          Plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[4], this.vertices[7]);
          Plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[3], this.vertices[7]);
          Plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[5], this.vertices[4]);
          Plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[0], this.vertices[3]);
          Plane.fromPoints(this.planes[5], this.vertices[7], this.vertices[5], this.vertices[6]);
        };

        _createClass(Frustum, [{
          key: "accurate",
          set: function set(b) {
            this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          }
        }]);

        return Frustum;
      }();

      Frustum.createOrtho = function () {
        return function (out, width, height, near, far, transform) {
          var halfWidth = width / 2;
          var halfHeight = height / 2;
          Vec3.set(_temp_v3, halfWidth, halfHeight, -near);
          Vec3.transformMat4(out.vertices[0], _temp_v3, transform);
          Vec3.set(_temp_v3, -halfWidth, halfHeight, -near);
          Vec3.transformMat4(out.vertices[1], _temp_v3, transform);
          Vec3.set(_temp_v3, -halfWidth, -halfHeight, -near);
          Vec3.transformMat4(out.vertices[2], _temp_v3, transform);
          Vec3.set(_temp_v3, halfWidth, -halfHeight, -near);
          Vec3.transformMat4(out.vertices[3], _temp_v3, transform);
          Vec3.set(_temp_v3, halfWidth, halfHeight, -far);
          Vec3.transformMat4(out.vertices[4], _temp_v3, transform);
          Vec3.set(_temp_v3, -halfWidth, halfHeight, -far);
          Vec3.transformMat4(out.vertices[5], _temp_v3, transform);
          Vec3.set(_temp_v3, -halfWidth, -halfHeight, -far);
          Vec3.transformMat4(out.vertices[6], _temp_v3, transform);
          Vec3.set(_temp_v3, halfWidth, -halfHeight, -far);
          Vec3.transformMat4(out.vertices[7], _temp_v3, transform);
          Plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]);
          Plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]);
          Plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]);
          Plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]);
          Plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]);
          Plane.fromPoints(out.planes[5], out.vertices[7], out.vertices[5], out.vertices[6]);
        };
      }();

      var WrapModeMask;

      (function (WrapModeMask) {
        WrapModeMask[WrapModeMask["Default"] = 0] = "Default";
        WrapModeMask[WrapModeMask["Normal"] = 1] = "Normal";
        WrapModeMask[WrapModeMask["Loop"] = 2] = "Loop";
        WrapModeMask[WrapModeMask["ShouldWrap"] = 4] = "ShouldWrap";
        WrapModeMask[WrapModeMask["Clamp"] = 8] = "Clamp";
        WrapModeMask[WrapModeMask["PingPong"] = 22] = "PingPong";
        WrapModeMask[WrapModeMask["Reverse"] = 36] = "Reverse";
      })(WrapModeMask || (WrapModeMask = {}));

      var WrapMode;

      (function (WrapMode) {
        WrapMode[WrapMode["Default"] = WrapModeMask.Default] = "Default";
        WrapMode[WrapMode["Normal"] = WrapModeMask.Normal] = "Normal";
        WrapMode[WrapMode["Reverse"] = WrapModeMask.Reverse] = "Reverse";
        WrapMode[WrapMode["Loop"] = WrapModeMask.Loop] = "Loop";
        WrapMode[WrapMode["LoopReverse"] = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse";
        WrapMode[WrapMode["PingPong"] = WrapModeMask.PingPong] = "PingPong";
        WrapMode[WrapMode["PingPongReverse"] = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
      })(WrapMode || (WrapMode = {}));

      ccenum(WrapMode);

      function binarySearchEpsilon(array, value, EPSILON) {
        if (EPSILON === void 0) {
          EPSILON = 1e-6;
        }

        var low = 0;
        var high = array.length - 1;
        var middle = high >>> 1;

        for (; low <= high; middle = low + high >>> 1) {
          var test = array[middle];

          if (test > value + EPSILON) {
            high = middle - 1;
          } else if (test < value - EPSILON) {
            low = middle + 1;
          } else {
            return middle;
          }
        }

        return ~low;
      }

      var _Symbol$iterator;
      _Symbol$iterator = Symbol.iterator;
      var KeyframeCurve = function () {
        function KeyframeCurve() {
          this._times = [];
          this._values = [];
        }

        var _proto = KeyframeCurve.prototype;

        _proto[_Symbol$iterator] = function () {
          var _this = this;

          var index = 0;
          return {
            next: function next() {
              if (index >= _this._times.length) {
                return {
                  done: true,
                  value: undefined
                };
              } else {
                var value = [_this._times[index], _this._values[index]];
                ++index;
                return {
                  done: false,
                  value: value
                };
              }
            }
          };
        };

        _proto.keyframes = function keyframes() {
          return this;
        };

        _proto.times = function times() {
          return this._times;
        };

        _proto.values = function values() {
          return this._values;
        };

        _proto.getKeyframeTime = function getKeyframeTime(index) {
          return this._times[index];
        };

        _proto.getKeyframeValue = function getKeyframeValue(index) {
          return this._values[index];
        };

        _proto.addKeyFrame = function addKeyFrame(time, keyframeValue) {
          return this._insertNewKeyframe(time, keyframeValue);
        };

        _proto.removeKeyframe = function removeKeyframe(index) {
          this._times.splice(index, 1);

          this._values.splice(index, 1);
        };

        _proto.indexOfKeyframe = function indexOfKeyframe(time) {
          return binarySearchEpsilon(this._times, time);
        };

        _proto.updateTime = function updateTime(index, time) {
          var value = this._values[index];
          this.removeKeyframe(index);

          this._insertNewKeyframe(time, value);
        };

        _proto.assignSorted = function assignSorted(times, values) {
          if (values !== undefined) {
            assertIsTrue(Array.isArray(times));
            this.setKeyframes(times.slice(), values.slice());
          } else {
            var _keyframes = Array.from(times);

            this.setKeyframes(_keyframes.map(function (_ref) {
              var time = _ref[0];
              return time;
            }), _keyframes.map(function (_ref2) {
              var value = _ref2[1];
              return value;
            }));
          }
        };

        _proto.clear = function clear() {
          this._times.length = 0;
          this._values.length = 0;
        };

        _proto.searchKeyframe = function searchKeyframe(time) {
          return binarySearchEpsilon(this._times, time);
        };

        _proto.setKeyframes = function setKeyframes(times, values) {
          assertIsTrue(times.length === values.length);
          assertIsTrue(isSorted(times));
          this._times = times;
          this._values = values;
        };

        _proto._insertNewKeyframe = function _insertNewKeyframe(time, value) {
          var times = this._times;
          var values = this._values;
          var nFrames = times.length;
          var index = binarySearchEpsilon(times, time);

          if (index >= 0) {
            return index;
          }

          var iNext = ~index;

          if (iNext === 0) {
            times.unshift(time);
            values.unshift(value);
          } else if (iNext === nFrames) {
            times.push(time);
            values.push(value);
          } else {
            assertIsTrue(nFrames > 1);
            times.splice(iNext - 1, 0, time);
            values.splice(iNext - 1, 0, value);
          }

          return iNext;
        };

        _createClass(KeyframeCurve, [{
          key: "keyFramesCount",
          get: function get() {
            return this._times.length;
          }
        }, {
          key: "rangeMin",
          get: function get() {
            return this._times[0];
          }
        }, {
          key: "rangeMax",
          get: function get() {
            return this._times[this._values.length - 1];
          }
        }]);

        return KeyframeCurve;
      }();
      CCClass.fastDefine('cc.KeyframeCurve', KeyframeCurve, {
        _times: [],
        _values: []
      });

      function isSorted(values) {
        return values.every(function (value, index, array) {
          return index === 0 || value > array[index - 1] || approx(value, array[index - 1], 1e-6);
        });
      }

      var RealInterpolationMode;

      (function (RealInterpolationMode) {
        RealInterpolationMode[RealInterpolationMode["LINEAR"] = 0] = "LINEAR";
        RealInterpolationMode[RealInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
        RealInterpolationMode[RealInterpolationMode["CUBIC"] = 2] = "CUBIC";
      })(RealInterpolationMode || (RealInterpolationMode = exports('RealInterpolationMode', {})));

      var ExtrapolationMode;

      (function (ExtrapolationMode) {
        ExtrapolationMode[ExtrapolationMode["LINEAR"] = 0] = "LINEAR";
        ExtrapolationMode[ExtrapolationMode["CLAMP"] = 1] = "CLAMP";
        ExtrapolationMode[ExtrapolationMode["LOOP"] = 2] = "LOOP";
        ExtrapolationMode[ExtrapolationMode["PING_PONG"] = 3] = "PING_PONG";
      })(ExtrapolationMode || (ExtrapolationMode = exports('ExtrapolationMode', {})));

      var TangentWeightMode;

      (function (TangentWeightMode) {
        TangentWeightMode[TangentWeightMode["NONE"] = 0] = "NONE";
        TangentWeightMode[TangentWeightMode["LEFT"] = 1] = "LEFT";
        TangentWeightMode[TangentWeightMode["RIGHT"] = 2] = "RIGHT";
        TangentWeightMode[TangentWeightMode["BOTH"] = 3] = "BOTH";
      })(TangentWeightMode || (TangentWeightMode = exports('TangentWeightMode', {})));

      function solveCubic(coeff0, coeff1, coeff2, coeff3, solutions) {
        var a = coeff2 / coeff3;
        var b = coeff1 / coeff3;
        var c = coeff0 / coeff3;
        var sqrA = a * a;
        var p = 1.0 / 3.0 * (-1.0 / 3 * sqrA + b);
        var q = 1.0 / 2.0 * (2.0 / 27.0 * a * sqrA - 1.0 / 3 * a * b + c);
        var cubicP = p * p * p;
        var d = q * q + cubicP;
        var nSolutions = 0;

        if (isZero(d)) {
          if (isZero(q)) {
            solutions[0] = 0;
            return 1;
          } else {
            var u = Math.cbrt(-q);
            solutions[0] = 2 * u;
            solutions[1] = -u;
            return 2;
          }
        } else if (d < 0) {
          var phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cubicP));
          var t = 2 * Math.sqrt(-p);
          solutions[0] = t * Math.cos(phi);
          solutions[1] = -t * Math.cos(phi + Math.PI / 3);
          solutions[2] = -t * Math.cos(phi - Math.PI / 3);
          nSolutions = 3;
        } else {
          var sqrtD = Math.sqrt(d);

          var _u = Math.cbrt(sqrtD - q);

          var v = -Math.cbrt(sqrtD + q);
          solutions[0] = _u + v;
          nSolutions = 1;
        }

        var sub = 1.0 / 3 * a;

        for (var i = 0; i < nSolutions; ++i) {
          solutions[i] -= sub;
        }

        return nSolutions;
      }
      var EQN_EPS = 1e-9;

      function isZero(x) {
        return x > -EQN_EPS && x < EQN_EPS;
      }

      var emptyDecorator = function emptyDecorator() {};
      var emptyDecoratorFn = function emptyDecoratorFn() {
        return emptyDecorator;
      };
      var emptySmartClassDecorator = makeSmartClassDecorator(function () {});
      function makeSmartClassDecorator(decorate) {
        return proxyFn;

        function proxyFn(target) {
          if (typeof target === 'function') {
            return decorate(target);
          } else {
            return function (constructor) {
              return decorate(constructor, target);
            };
          }
        }
      }

      function writeEditorClassProperty(constructor, propertyName, value) {
        var cache = getClassCache(constructor);

        if (cache) {
          var proto = getSubDict(cache, 'proto');
          getSubDict(proto, 'editor')[propertyName] = value;
        }
      }

      function makeEditorClassDecoratorFn(propertyName) {
        return function (value) {
          return function (constructor) {
            writeEditorClassProperty(constructor, propertyName, value);
          };
        };
      }
      var CACHE_KEY = '__ccclassCache__';
      function getClassCache(ctor, decoratorName) {

        return getSubDict(ctor, CACHE_KEY);
      }
      function getSubDict(obj, key) {
        return obj[key] || (obj[key] = {});
      }

      var ccclass = makeSmartClassDecorator(function (constructor, name) {
        var base = js.getSuper(constructor);

        if (base === Object) {
          base = null;
        }

        var proto = {
          name: name,
          "extends": base,
          ctor: constructor
        };
        var cache = constructor[CACHE_KEY];

        if (cache) {
          var decoratedProto = cache.proto;

          if (decoratedProto) {
            js.mixin(proto, decoratedProto);
          }

          constructor[CACHE_KEY] = undefined;
        }

        var res = CCClass(proto);

        return res;
      });

      var requireComponent = makeEditorClassDecoratorFn('requireComponent');
      var executionOrder = makeEditorClassDecoratorFn('executionOrder');
      var disallowMultiple =  emptySmartClassDecorator;
      var allowReplicated = function allowReplicated(ctor) {
        CCClass.Attr.setClassAttr(ctor, 'replicated', 'visible', true);
      };

      function property(target, propertyKey, descriptor) {
        var options = null;

        function normalized(target, propertyKey, descriptor) {
          var classStash = getOrCreateClassStash(target);
          var propertyStash = getOrCreateEmptyPropertyStash(target, propertyKey);
          var classConstructor = target.constructor;
          mergePropertyOptions(classStash, propertyStash, classConstructor, propertyKey, options, descriptor);
        }

        if (target === undefined) {
          return property({
            type: undefined
          });
        } else if (typeof propertyKey === 'undefined') {
          options = target;
          return normalized;
        } else {
          normalized(target, propertyKey, descriptor);
          return undefined;
        }
      }

      function getDefaultFromInitializer(initializer) {
        var value;

        try {
          value = initializer();
        } catch (e) {
          return initializer;
        }

        if (typeof value !== 'object' || value === null) {
          return value;
        } else {
          return initializer;
        }
      }

      function extractActualDefaultValues(classConstructor) {
        var dummyObj;

        try {
          dummyObj = new classConstructor();
        } catch (e) {

          return {};
        }

        return dummyObj;
      }

      function getOrCreateClassStash(target) {
        var cache = getClassCache(target.constructor);
        return cache;
      }

      function getOrCreateEmptyPropertyStash(target, propertyKey) {
        var _ref, _properties$_ref;

        var classStash = getClassCache(target.constructor);
        var ccclassProto = getSubDict(classStash, 'proto');
        var properties = getSubDict(ccclassProto, 'properties');
        var propertyStash = (_properties$_ref = properties[_ref = propertyKey]) !== null && _properties$_ref !== void 0 ? _properties$_ref : properties[_ref] = {};
        return propertyStash;
      }

      function getOrCreatePropertyStash(target, propertyKey, descriptor) {
        var _ref2, _properties$_ref2;

        var classStash = getClassCache(target.constructor);
        var ccclassProto = getSubDict(classStash, 'proto');
        var properties = getSubDict(ccclassProto, 'properties');
        var propertyStash = (_properties$_ref2 = properties[_ref2 = propertyKey]) !== null && _properties$_ref2 !== void 0 ? _properties$_ref2 : properties[_ref2] = {};
        propertyStash.__internalFlags |= PropertyStashInternalFlag.STANDALONE;

        if (descriptor && (descriptor.get || descriptor.set)) {
          if (descriptor.get) {
            propertyStash.get = descriptor.get;
          }

          if (descriptor.set) {
            propertyStash.set = descriptor.set;
          }
        } else {
          setDefaultValue(classStash, propertyStash, target.constructor, propertyKey, descriptor);
        }

        return propertyStash;
      }

      function mergePropertyOptions(cache, propertyStash, ctor, propertyKey, options, descriptor) {
        var fullOptions;
        var isGetset = descriptor && (descriptor.get || descriptor.set);

        if (options) {
          fullOptions = getFullFormOfProperty(options, isGetset);
        }

        var propertyRecord = js.mixin(propertyStash, fullOptions || options || {});

        if (isGetset) {

          if (descriptor.get) {
            propertyRecord.get = descriptor.get;
          }

          if (descriptor.set) {
            propertyRecord.set = descriptor.set;
          }
        } else {

          setDefaultValue(cache, propertyRecord, ctor, propertyKey, descriptor);
        }
      }

      function setDefaultValue(classStash, propertyStash, classConstructor, propertyKey, descriptor) {
        if (descriptor) {
          if (descriptor.initializer) {
            propertyStash["default"] = getDefaultFromInitializer(descriptor.initializer);
          }
        } else {
          var actualDefaultValues = classStash["default"] || (classStash["default"] = extractActualDefaultValues(classConstructor));

          if (actualDefaultValues.hasOwnProperty(propertyKey)) {
            propertyStash["default"] = actualDefaultValues[propertyKey];
          }
        }
      }

      var sMetadataTag = Symbol('cc:SerializationMetadata');
      function getSerializationMetadata(constructor) {
        return constructor[sMetadataTag];
      }
      function getOrCreateSerializationMetadata(constructor) {
        var _ref, _ref$sMetadataTag;

        return (_ref$sMetadataTag = (_ref = constructor)[sMetadataTag]) !== null && _ref$sMetadataTag !== void 0 ? _ref$sMetadataTag : _ref[sMetadataTag] = {};
      }

      var serializable = function serializable(target, propertyKey, descriptor) {
        var propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptor);
        setImplicitSerializable(propertyStash);
      };
      function formerlySerializedAs(name) {
        return function (target, propertyKey, descriptor) {
          var propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptor);
          propertyStash.formerlySerializedAs = name;
          setImplicitSerializable(propertyStash);
        };
      }
      var editorOnly = function editorOnly(target, propertyKey, descriptor) {
        var propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptor);
        propertyStash.editorOnly = true;
        setImplicitSerializable(propertyStash);
      };

      function setImplicitSerializable(propertyStash) {
        propertyStash.__internalFlags |= PropertyStashInternalFlag.IMPLICIT_SERIALIZABLE;
      }

      var uniquelyReferenced =  emptyDecorator ;

      var executeInEditMode =  emptySmartClassDecorator;
      var menu =  emptyDecoratorFn;
      var playOnFocus =  emptySmartClassDecorator;
      var inspector =  emptyDecoratorFn;
      var icon =  emptyDecoratorFn;
      var help =  emptyDecoratorFn;
      var editable =  emptyDecorator ;
      var visible =  emptyDecoratorFn ;
      var readOnly =  emptyDecorator ;
      var displayName =  emptyDecoratorFn ;
      var tooltip =  emptyDecoratorFn ;
      var range =  emptyDecoratorFn ;
      var rangeMin =  emptyDecoratorFn ;
      var rangeMax =  emptyDecoratorFn ;
      var rangeStep =  emptyDecoratorFn ;
      var slide =  emptyDecorator ;
      var displayOrder =  emptyDecoratorFn ;
      var multiline =  emptyDecorator ;
      var disallowAnimation =  emptyDecorator ;

      var integer = type(CCInteger);

      var _float = type(CCFloat);

      var _boolean = type(CCBoolean);
      var string = type(CCString);
      function type(type) {
        return property({
          type: type
        });
      }

      var override = function override(target, propertyKey, descriptor) {
        var propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptor);
        propertyStash.override = true;
      };

      var editorExtrasTag = exports('editorExtrasTag', '__editorExtras__');

      var Empty = function Empty() {};

      var EditorExtendable = editorExtendableInternal();
      assertIsTrue(editorExtrasTag === '__editorExtras__', 'editorExtrasTag needs to be updated.');

      function editorExtendableInternal(Base, className) {
        {
          return Base !== null && Base !== void 0 ? Base : Empty;
        }
      }

      var _decorator = /*#__PURE__*/Object.freeze({
        __proto__: null,
        uniquelyReferenced: uniquelyReferenced,
        ccclass: ccclass,
        property: property,
        requireComponent: requireComponent,
        executionOrder: executionOrder,
        disallowMultiple: disallowMultiple,
        allowReplicated: allowReplicated,
        executeInEditMode: executeInEditMode,
        menu: menu,
        playOnFocus: playOnFocus,
        inspector: inspector,
        icon: icon,
        help: help,
        type: type,
        integer: integer,
        float: _float,
        boolean: _boolean,
        string: string
      });
      exports('_decorator', _decorator);

      var _CCClass$fastDefine;
      var Destroyed = 1 << 0;
      var ToDestroy = 1 << 2;
      var DontSave = 1 << 3;
      var EditorOnly = 1 << 4;
      var Dirty = 1 << 5;
      var DontDestroy = 1 << 6;
      var Destroying = 1 << 7;
      var Deactivating = 1 << 8;
      var LockedInEditor = 1 << 9;
      var HideInHierarchy = 1 << 10;
      var IsOnEnableCalled = 1 << 11;
      var IsEditorOnEnableCalled = 1 << 12;
      var IsPreloadStarted = 1 << 13;
      var IsOnLoadCalled = 1 << 14;
      var IsOnLoadStarted = 1 << 15;
      var IsStartCalled = 1 << 16;
      var IsRotationLocked = 1 << 17;
      var IsScaleLocked = 1 << 18;
      var IsAnchorLocked = 1 << 19;
      var IsSizeLocked = 1 << 20;
      var IsPositionLocked = 1 << 21;
      var IsReplicated = 1 << 22;
      var PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | Deactivating | IsPreloadStarted | IsOnLoadStarted | IsOnLoadCalled | IsStartCalled | IsOnEnableCalled | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
      var AllHideMasks = DontSave | EditorOnly | LockedInEditor | HideInHierarchy;
      var objectsToDestroy = [];

      function compileDestruct(obj, ctor) {
        var shouldSkipId = obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component;
        var idToSkip = shouldSkipId ? '_id' : null;
        var key;
        var propsToReset = {};

        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (key === idToSkip) {
              continue;
            }

            switch (typeof obj[key]) {
              case 'string':
                propsToReset[key] = '';
                break;

              case 'object':
              case 'function':
                propsToReset[key] = null;
                break;
            }
          }
        }

        if (CCClass._isCCClass(ctor)) {
          var attrs = legacyCC.Class.Attr.getClassAttrs(ctor);
          var propList = ctor.__props__;

          for (var i = 0; i < propList.length; i++) {
            key = propList[i];
            var attrKey = key + legacyCC.Class.Attr.DELIMETER + "default";

            if (attrKey in attrs) {
              if (shouldSkipId && key === '_id') {
                continue;
              }

              switch (typeof attrs[attrKey]) {
                case 'string':
                  propsToReset[key] = '';
                  break;

                case 'object':
                case 'function':
                  propsToReset[key] = null;
                  break;

                case 'undefined':
                  propsToReset[key] = undefined;
                  break;
              }
            }
          }
        }

        {
          var func = '';

          for (key in propsToReset) {
            var statement = void 0;

            if (CCClass.IDENTIFIER_RE.test(key)) {
              statement = "o." + key + "=";
            } else {
              statement = "o[" + CCClass.escapeForJS(key) + "]=";
            }

            var val = propsToReset[key];

            if (val === '') {
              val = '""';
            }

            func += statement + val + ";\n";
          }

          return Function('o', func);
        }
      }

      var CCObject = exports('CCObject', function () {
        CCObject._deferredDestroy = function _deferredDestroy() {
          var deleteCount = objectsToDestroy.length;

          for (var i = 0; i < deleteCount; ++i) {
            var obj = objectsToDestroy[i];

            if (!(obj._objFlags & Destroyed)) {
              obj._destroyImmediate();
            }
          }

          if (deleteCount === objectsToDestroy.length) {
            objectsToDestroy.length = 0;
          } else {
            objectsToDestroy.splice(0, deleteCount);
          }
        };

        function CCObject(name) {
          if (name === void 0) {
            name = '';
          }

          this._objFlags = void 0;
          this._name = void 0;
          this._name = name;
          this._objFlags = 0;
        }

        var _proto = CCObject.prototype;

        _proto.destroy = function destroy() {
          if (this._objFlags & Destroyed) {
            warnID(5000);
            return false;
          }

          if (this._objFlags & ToDestroy) {
            return false;
          }

          this._objFlags |= ToDestroy;
          objectsToDestroy.push(this);

          return true;
        };

        _proto._destruct = function _destruct() {
          var ctor = this.constructor;
          var destruct = ctor.__destruct__;

          if (!destruct) {
            destruct = compileDestruct(this, ctor);
            value(ctor, '__destruct__', destruct, true);
          }

          destruct(this);
        };

        _proto._destroyImmediate = function _destroyImmediate() {
          if (this._objFlags & Destroyed) {
            errorID(5000);
            return;
          }

          if (this._onPreDestroy) {
            this._onPreDestroy();
          }

          {
            this._destruct();
          }

          this._objFlags |= Destroyed;
        };

        _createClass(CCObject, [{
          key: "name",
          get: function get() {
            return this._name;
          },
          set: function set(value) {
            this._name = value;
          }
        }, {
          key: "hideFlags",
          get: function get() {
            return this._objFlags & CCObject.Flags.AllHideMasks;
          },
          set: function set(hideFlags) {
            var flags = hideFlags & CCObject.Flags.AllHideMasks;
            this._objFlags = this._objFlags & ~CCObject.Flags.AllHideMasks | flags;
          }
        }, {
          key: "replicated",
          get: function get() {
            return !!(this._objFlags & IsReplicated);
          },
          set: function set(value) {
            if (value) {
              this._objFlags |= IsReplicated;
            } else {
              this._objFlags &= ~IsReplicated;
            }
          }
        }, {
          key: "isValid",
          get: function get() {
            return !(this._objFlags & Destroyed);
          }
        }]);

        return CCObject;
      }());

      var prototype = CCObject.prototype;

      prototype._deserialize = null;
      prototype._onPreDestroy = null;
      CCClass.fastDefine('cc.Object', CCObject, (_CCClass$fastDefine = {
        _name: '',
        _objFlags: 0
      }, _CCClass$fastDefine[editorExtrasTag] = {}, _CCClass$fastDefine));
      CCClass.Attr.setClassAttr(CCObject, editorExtrasTag, 'editorOnly', true);
      CCClass.Attr.setClassAttr(CCObject, 'replicated', 'visible', false);
      value(CCObject, 'Flags', {
        Destroyed: Destroyed,
        DontSave: DontSave,
        EditorOnly: EditorOnly,
        Dirty: Dirty,
        DontDestroy: DontDestroy,
        PersistentMask: PersistentMask,
        Destroying: Destroying,
        Deactivating: Deactivating,
        LockedInEditor: LockedInEditor,
        HideInHierarchy: HideInHierarchy,
        AllHideMasks: AllHideMasks,
        IsPreloadStarted: IsPreloadStarted,
        IsOnLoadStarted: IsOnLoadStarted,
        IsOnLoadCalled: IsOnLoadCalled,
        IsOnEnableCalled: IsOnEnableCalled,
        IsStartCalled: IsStartCalled,
        IsEditorOnEnableCalled: IsEditorOnEnableCalled,
        IsPositionLocked: IsPositionLocked,
        IsRotationLocked: IsRotationLocked,
        IsScaleLocked: IsScaleLocked,
        IsAnchorLocked: IsAnchorLocked,
        IsSizeLocked: IsSizeLocked
      });
      function isValid(value, strictMode) {
        if (typeof value === 'object') {
          return !!value && !(value._objFlags & (strictMode ? Destroyed | ToDestroy : Destroyed));
        } else {
          return typeof value !== 'undefined';
        }
      }
      legacyCC.isValid = isValid;

      legacyCC.Object = CCObject;

      var Cache = function () {
        function Cache(map) {
          this._map = null;
          this._count = 0;

          if (map) {
            this._map = map;
            this._count = Object.keys(map).length;
          } else {
            this._map = js.createMap(true);
            this._count = 0;
          }
        }

        var _proto = Cache.prototype;

        _proto.add = function add(key, val) {
          if (!(key in this._map)) {
            this._count++;
          }

          return this._map[key] = val;
        };

        _proto.get = function get(key) {
          return this._map[key];
        };

        _proto.has = function has(key) {
          return key in this._map;
        };

        _proto.remove = function remove(key) {
          var out = this._map[key];

          if (key in this._map) {
            delete this._map[key];
            this._count--;
          }

          return out;
        };

        _proto.clear = function clear() {
          if (this._count !== 0) {
            this._map = js.createMap(true);
            this._count = 0;
          }
        };

        _proto.forEach = function forEach(func) {
          for (var _key in this._map) {
            func(this._map[_key], _key);
          }
        };

        _proto.find = function find(predicate) {
          for (var _key2 in this._map) {
            if (predicate(this._map[_key2], _key2)) {
              return this._map[_key2];
            }
          }

          return null;
        };

        _proto.destroy = function destroy() {
          this._map = null;
        };

        _createClass(Cache, [{
          key: "count",
          get: function get() {
            return this._count;
          }
        }]);

        return Cache;
      }();

      var Pipeline = function () {
        function Pipeline(name, funcs) {
          this.id = Pipeline._pipelineId++;
          this.name = '';
          this.pipes = [];
          this.name = name;

          for (var i = 0, l = funcs.length; i < l; i++) {
            this.pipes.push(funcs[i]);
          }
        }

        var _proto = Pipeline.prototype;

        _proto.insert = function insert(func, index) {
          if (index > this.pipes.length) {
            warnID(4921);
            return this;
          }

          this.pipes.splice(index, 0, func);
          return this;
        };

        _proto.append = function append(func) {
          this.pipes.push(func);
          return this;
        };

        _proto.remove = function remove(index) {
          this.pipes.splice(index, 1);
          return this;
        };

        _proto.sync = function sync(task) {
          var pipes = this.pipes;

          if (pipes.length === 0) {
            return null;
          }

          task.isFinish = false;

          for (var i = 0, l = pipes.length; i < l;) {
            var pipe = pipes[i];
            var result = pipe(task);

            if (result) {
              task.isFinish = true;
              return result;
            }

            i++;

            if (i !== l) {
              task.input = task.output;
              task.output = null;
            }
          }

          task.isFinish = true;
          return task.output;
        };

        _proto.async = function async(task) {
          var pipes = this.pipes;

          if (pipes.length === 0) {
            return;
          }

          task.isFinish = false;

          this._flow(0, task);
        };

        _proto._flow = function _flow(index, task) {
          var _this = this;

          var pipe = this.pipes[index];
          pipe(task, function (result) {
            if (result) {
              task.isFinish = true;
              task.dispatch('complete', result);
            } else {
              index++;

              if (index < _this.pipes.length) {
                task.input = task.output;
                task.output = null;

                _this._flow(index, task);
              } else {
                task.isFinish = true;
                task.dispatch('complete', result, task.output);
              }
            }
          });
        };

        return Pipeline;
      }();
      Pipeline._pipelineId = 0;

      var WeakCache = function () {
        function WeakCache(map) {
          this._weakMap = {};
          if (typeof window.WeakRef === 'undefined') throw new Error('this platform does not support WeakRef!');

          if (map) {
            for (var _key in map) {
              this._weakMap[_key] = new WeakRef(map[_key]);
            }
          }
        }

        var _proto = WeakCache.prototype;

        _proto.add = function add(key, val) {
          this._weakMap[key] = new WeakRef(val);
          return val;
        };

        _proto.has = function has(key) {
          return key in this._weakMap && !!this._weakMap[key].deref();
        };

        _proto.get = function get(key) {
          return this._weakMap[key] && this._weakMap[key].deref();
        };

        _proto.remove = function remove(key) {
          var out = this._weakMap[key];
          delete this._weakMap[key];
          return out && out.deref();
        };

        _proto.clear = function clear() {
          this._weakMap = js.createMap(true);
        };

        _proto.forEach = function forEach(func) {
          for (var _key2 in this._weakMap) {
            var _val = this.get(_key2);

            if (_val) {
              func(_val, _key2);
            }
          }
        };

        _proto.find = function find(predicate) {
          for (var _key3 in this._weakMap) {
            var _val2 = this.get(_key3);

            if (_val2 && predicate(_val2, _key3)) {
              return this._weakMap[_key3].deref();
            }
          }

          return null;
        };

        _proto.destroy = function destroy() {
          this._weakMap = {};
        };

        _createClass(WeakCache, [{
          key: "count",
          get: function get() {
            return Object.values(this._weakMap).filter(function (weakRef) {
              return weakRef.deref();
            }).length;
          }
        }]);

        return WeakCache;
      }();

      var assets =  new Cache();
      var files = new Cache();
      var parsed = new Cache();
      var bundles = new Cache();
      var pipeline = new Pipeline('normal load', []);
      var fetchPipeline = new Pipeline('fetch', []);
      var transformPipeline = new Pipeline('transform url', []);
      var references =  null;
      var RequestType;

      (function (RequestType) {
        RequestType["UUID"] = "uuid";
        RequestType["PATH"] = "path";
        RequestType["DIR"] = "dir";
        RequestType["URL"] = "url";
        RequestType["SCENE"] = "scene";
      })(RequestType || (RequestType = {}));

      var presets = {
        "default": {
          priority: 0
        },
        preload: {
          maxConcurrency: 6,
          maxRequestsPerFrame: 2,
          priority: -1
        },
        scene: {
          maxConcurrency: 20,
          maxRequestsPerFrame: 20,
          priority: 1
        },
        bundle: {
          maxConcurrency: 20,
          maxRequestsPerFrame: 20,
          priority: 2
        },
        remote: {
          maxRetryCount: 4
        }
      };
      var BuiltinBundleName;

      (function (BuiltinBundleName) {
        BuiltinBundleName["RESOURCES"] = "resources";
        BuiltinBundleName["MAIN"] = "main";
        BuiltinBundleName["START_SCENE"] = "start-scene";
      })(BuiltinBundleName || (BuiltinBundleName = {}));

      var Task = function () {
        Task.create = function create(options) {
          var out;

          if (Task._deadPool.length !== 0) {
            out = Task._deadPool.pop();
            out.set(options);
          } else {
            out = new Task(options);
          }

          return out;
        };

        function Task(options) {
          this.id = Task._taskId++;
          this.onComplete = null;
          this.onProgress = null;
          this.onError = null;
          this.source = null;
          this.output = null;
          this.input = null;
          this.progress = null;
          this.options = null;
          this.isFinish = true;
          this.set(options);
        }

        var _proto = Task.prototype;

        _proto.set = function set(options) {
          if (options === void 0) {
            options = Object.create(null);
          }

          this.onComplete = options.onComplete || null;
          this.onProgress = options.onProgress || null;
          this.onError = options.onError || null;
          this.source = this.input = options.input;
          this.output = null;
          this.progress = options.progress;
          this.options = options.options || Object.create(null);
        };

        _proto.dispatch = function dispatch(event, param1, param2, param3, param4) {
          switch (event) {
            case 'complete':
              if (this.onComplete) {
                this.onComplete(param1, param2);
              }

              break;

            case 'progress':
              if (this.onProgress) {
                this.onProgress(param1, param2, param3, param4);
              }

              break;

            case 'error':
              if (this.onError) {
                this.onError(param1, param2, param3, param4);
              }

              break;

            default:
              {
                var str = "on" + event[0].toUpperCase() + event.substr(1);

                if (typeof this[str] === 'function') {
                  this[str](param1, param2, param3, param4);
                }

                break;
              }
          }
        };

        _proto.recycle = function recycle() {
          if (Task._deadPool.length === Task.MAX_DEAD_NUM) {
            return;
          }

          this.onComplete = null;
          this.onProgress = null;
          this.onError = null;
          this.source = this.output = this.input = null;
          this.progress = null;
          this.options = null;

          Task._deadPool.push(this);
        };

        return Task;
      }();

      Task.MAX_DEAD_NUM = 500;
      Task._taskId = 0;
      Task._deadPool = [];

      var HexChars = '0123456789abcdef'.split('');
      var _t = ['', '', '', ''];

      var UuidTemplate = _t.concat(_t, '-', _t, '-', _t, '-', _t, '-', _t, _t, _t);

      var Indices = UuidTemplate.map(function (x, i) {
        return x === '-' ? NaN : i;
      }).filter(isFinite);
      function decodeUuid(base64) {
        var strs = base64.split('@');
        var uuid = strs[0];

        if (uuid.length !== 22) {
          return base64;
        }

        UuidTemplate[0] = base64[0];
        UuidTemplate[1] = base64[1];

        for (var i = 2, j = 2; i < 22; i += 2) {
          var lhs = BASE64_VALUES[base64.charCodeAt(i)];
          var rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
          UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
          UuidTemplate[Indices[j++]] = HexChars[(lhs & 3) << 2 | rhs >> 4];
          UuidTemplate[Indices[j++]] = HexChars[rhs & 0xF];
        }

        return base64.replace(uuid, UuidTemplate.join(''));
      }

      var _uuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
      function getUuidFromURL(url) {
        var matches = _uuidRegex.exec(url);

        if (matches) {
          return matches[1];
        }

        return '';
      }
      function getUrlWithUuid(uuid, options) {
        options = options || Object.create(null);
        options.__isNative__ = options.isNative;

        if (options.nativeExt) {
          options.ext = options.nativeExt;
        }

        var bundle = bundles.find(function (b) {
          return !!b.getAssetInfo(uuid);
        });

        if (bundle) {
          options.bundle = bundle.name;
        }

        return transform(uuid, options);
      }
      function isScene(asset) {
        return !!asset && (asset instanceof legacyCC.SceneAsset || asset instanceof legacyCC.Scene);
      }
      function normalize(url) {
        if (url) {
          if (url.charCodeAt(0) === 46 && url.charCodeAt(1) === 47) {
            url = url.slice(2);
          } else if (url.charCodeAt(0) === 47) {
            url = url.slice(1);
          }
        }

        return url;
      }
      function transform(input, options) {
        var subTask = Task.create({
          input: input,
          options: options
        });
        var urls = [];

        try {
          var result = transformPipeline.sync(subTask);

          for (var _iterator = _createForOfIteratorHelperLoose(result), _step; !(_step = _iterator()).done;) {
            var requestItem = _step.value;
            var url = requestItem.url;
            requestItem.recycle();
            urls.push(url);
          }
        } catch (e) {
          for (var _iterator2 = _createForOfIteratorHelperLoose(subTask.output), _step2; !(_step2 = _iterator2()).done;) {
            var item = _step2.value;
            item.recycle();
          }

          error(e.message, e.stack);
        }

        subTask.recycle();
        return urls.length > 1 ? urls : urls[0];
      }

      var helper = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getUuidFromURL: getUuidFromURL,
        getUrlWithUuid: getUrlWithUuid,
        isScene: isScene,
        normalize: normalize,
        transform: transform,
        decodeUuid: decodeUuid
      });

      var ContainerManager = function () {
        function ContainerManager() {
          this._pools = [];
          this._lastShrinkPassed = 0;
          this.shrinkTimeSpan = 5;
        }

        var _proto = ContainerManager.prototype;

        _proto.addContainer = function addContainer(pool) {
          if (pool._poolHandle !== -1) return;
          pool._poolHandle = this._pools.length;

          this._pools.push(pool);
        };

        _proto.removeContainer = function removeContainer(pool) {
          if (pool._poolHandle === -1) return;
          this._pools[this._pools.length - 1]._poolHandle = pool._poolHandle;
          fastRemoveAt(this._pools, pool._poolHandle);
          pool._poolHandle = -1;
        };

        _proto.tryShrink = function tryShrink() {
          for (var i = 0; i < this._pools.length; i++) {
            this._pools[i].tryShrink();
          }
        };

        _proto.update = function update(dt) {
          this._lastShrinkPassed += dt;

          if (this._lastShrinkPassed > this.shrinkTimeSpan) {
            this.tryShrink();
            this._lastShrinkPassed -= this.shrinkTimeSpan;
          }
        };

        return ContainerManager;
      }();

      var containerManager = new ContainerManager();

      var ScalableContainer = function () {
        function ScalableContainer() {
          this._poolHandle = -1;
          containerManager.addContainer(this);
        }

        var _proto = ScalableContainer.prototype;

        _proto.destroy = function destroy() {
          containerManager.removeContainer(this);
        };

        return ScalableContainer;
      }();

      var Pool$1 = exports('Pool', function (_ScalableContainer) {
        _inheritsLoose(Pool, _ScalableContainer);

        function Pool(ctor, elementsPerBatch, dtor) {
          var _this;

          _this = _ScalableContainer.call(this) || this;
          _this._ctor = void 0;
          _this._elementsPerBatch = void 0;
          _this._nextAvail = void 0;
          _this._freepool = [];
          _this._dtor = void 0;
          _this._ctor = ctor;
          _this._dtor = dtor || null;
          _this._elementsPerBatch = Math.max(elementsPerBatch, 1);
          _this._nextAvail = _this._elementsPerBatch - 1;

          for (var i = 0; i < _this._elementsPerBatch; ++i) {
            _this._freepool.push(ctor());
          }

          return _this;
        }

        var _proto = Pool.prototype;

        _proto.alloc = function alloc() {
          if (this._nextAvail < 0) {
            this._freepool.length = this._elementsPerBatch;

            for (var i = 0; i < this._elementsPerBatch; i++) {
              this._freepool[i] = this._ctor();
            }

            this._nextAvail = this._elementsPerBatch - 1;
          }

          return this._freepool[this._nextAvail--];
        };

        _proto.free = function free(obj) {
          this._freepool[++this._nextAvail] = obj;
        };

        _proto.freeArray = function freeArray(objs) {
          this._freepool.length = this._nextAvail + 1;
          Array.prototype.push.apply(this._freepool, objs);
          this._nextAvail += objs.length;
        };

        _proto.tryShrink = function tryShrink() {
          if (this._nextAvail >> 1 > this._elementsPerBatch) {
            if (this._dtor) {
              for (var i = this._nextAvail >> 1; i <= this._nextAvail; i++) {
                this._dtor(this._freepool[i]);
              }
            }

            this._freepool.length = this._nextAvail >> 1;
            this._nextAvail = this._freepool.length - 1;
          }
        };

        _proto.destroy = function destroy() {
          var dtor = arguments.length > 0 ? arguments[0] : null;

          if (dtor) {
            warnID(14100);
          }

          var readDtor = dtor || this._dtor;

          if (readDtor) {
            for (var i = 0; i <= this._nextAvail; i++) {
              readDtor(this._freepool[i]);
            }
          }

          this._freepool.length = 0;
          this._nextAvail = -1;

          _ScalableContainer.prototype.destroy.call(this);
        };

        return Pool;
      }(ScalableContainer));

      var RecyclePool = exports('RecyclePool', function (_ScalableContainer) {
        _inheritsLoose(RecyclePool, _ScalableContainer);

        function RecyclePool(fn, size, dtor) {
          var _this;

          _this = _ScalableContainer.call(this) || this;
          _this._fn = void 0;
          _this._dtor = null;
          _this._count = 0;
          _this._data = void 0;
          _this._initSize = 0;
          _this._fn = fn;
          _this._dtor = dtor || null;
          _this._data = new Array(size);
          _this._initSize = size;

          for (var i = 0; i < size; ++i) {
            _this._data[i] = fn();
          }

          return _this;
        }

        var _proto = RecyclePool.prototype;

        _proto.reset = function reset() {
          this._count = 0;
        };

        _proto.resize = function resize(size) {
          if (size > this._data.length) {
            for (var i = this._data.length; i < size; ++i) {
              this._data[i] = this._fn();
            }
          }
        };

        _proto.add = function add() {
          if (this._count >= this._data.length) {
            this.resize(this._data.length << 1);
          }

          return this._data[this._count++];
        };

        _proto.destroy = function destroy() {
          if (this._dtor) {
            for (var i = 0; i < this._data.length; i++) {
              this._dtor(this._data[i]);
            }
          }

          this._data.length = 0;
          this._count = 0;

          _ScalableContainer.prototype.destroy.call(this);
        };

        _proto.tryShrink = function tryShrink() {
          if (this._data.length >> 2 > this._count) {
            var length = Math.max(this._initSize, this._data.length >> 1);

            if (this._dtor) {
              for (var i = length; i < this._data.length; i++) {
                this._dtor(this._data[i]);
              }
            }

            this._data.length = length;
          }
        };

        _proto.removeAt = function removeAt(idx) {
          if (idx >= this._count) {
            return;
          }

          var last = this._count - 1;
          var tmp = this._data[idx];
          this._data[idx] = this._data[last];
          this._data[last] = tmp;
          this._count -= 1;
        };

        _createClass(RecyclePool, [{
          key: "length",
          get: function get() {
            return this._count;
          }
        }, {
          key: "data",
          get: function get() {
            return this._data;
          }
        }]);

        return RecyclePool;
      }(ScalableContainer));

      var CachedArray = exports('CachedArray', function (_ScalableContainer) {
        _inheritsLoose(CachedArray, _ScalableContainer);

        function CachedArray(length, compareFn) {
          var _this;

          _this = _ScalableContainer.call(this) || this;
          _this.array = void 0;
          _this.length = 0;
          _this._compareFn = void 0;
          _this._initSize = 0;
          _this.array = new Array(length);
          _this._initSize = length;
          _this.length = 0;
          _this._compareFn = compareFn;
          return _this;
        }

        var _proto = CachedArray.prototype;

        _proto.push = function push(item) {
          this.array[this.length++] = item;
        };

        _proto.pop = function pop() {
          return this.array[--this.length];
        };

        _proto.get = function get(idx) {
          return this.array[idx];
        };

        _proto.clear = function clear() {
          this.length = 0;
        };

        _proto.destroy = function destroy() {
          this.length = 0;
          this.array.length = 0;

          _ScalableContainer.prototype.destroy.call(this);
        };

        _proto.tryShrink = function tryShrink() {
          if (this.array.length >> 2 > this.length) {
            this.array.length = Math.max(this._initSize, this.array.length >> 1);
          }
        };

        _proto.sort = function sort() {
          this.array.length = this.length;
          this.array.sort(this._compareFn);
        };

        _proto.concat = function concat(array) {
          for (var i = 0; i < array.length; ++i) {
            this.array[this.length++] = array[i];
          }
        };

        _proto.fastRemove = function fastRemove(idx) {
          if (idx >= this.length || idx < 0) {
            return;
          }

          var last = --this.length;
          this.array[idx] = this.array[last];
        };

        _proto.indexOf = function indexOf(val) {
          for (var i = 0, len = this.length; i < len; ++i) {
            if (this.array[i] === val) {
              return i;
            }
          }

          return -1;
        };

        return CachedArray;
      }(ScalableContainer));

      var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Pool: Pool$1,
        RecyclePool: RecyclePool,
        CachedArray: CachedArray
      });
      exports('memop', index$1);

      var fastRemoveAt$1 = array.fastRemoveAt;

      function empty() {}

      var CallbackInfo = function () {
        function CallbackInfo() {
          this.callback = empty;
          this.target = undefined;
          this.once = false;
        }

        var _proto = CallbackInfo.prototype;

        _proto.set = function set(callback, target, once) {
          this.callback = callback || empty;
          this.target = target;
          this.once = !!once;
        };

        _proto.reset = function reset() {
          this.target = undefined;
          this.callback = empty;
          this.once = false;
        };

        _proto.check = function check() {
          if (this.target instanceof CCObject && !isValid(this.target, true)) {
            return false;
          } else {
            return true;
          }
        };

        return CallbackInfo;
      }();

      var callbackInfoPool = new Pool$1(function () {
        return new CallbackInfo();
      }, 32);
      var CallbackList = function () {
        function CallbackList() {
          this.callbackInfos = [];
          this.isInvoking = false;
          this.containCanceled = false;
        }

        var _proto2 = CallbackList.prototype;

        _proto2.removeByCallback = function removeByCallback(cb) {
          for (var i = 0; i < this.callbackInfos.length; ++i) {
            var info = this.callbackInfos[i];

            if (info && info.callback === cb) {
              info.reset();
              callbackInfoPool.free(info);
              fastRemoveAt$1(this.callbackInfos, i);
              --i;
            }
          }
        };

        _proto2.removeByTarget = function removeByTarget(target) {
          for (var i = 0; i < this.callbackInfos.length; ++i) {
            var info = this.callbackInfos[i];

            if (info && info.target === target) {
              info.reset();
              callbackInfoPool.free(info);
              fastRemoveAt$1(this.callbackInfos, i);
              --i;
            }
          }
        };

        _proto2.cancel = function cancel(index) {
          var info = this.callbackInfos[index];

          if (info) {
            info.reset();

            if (this.isInvoking) {
              this.callbackInfos[index] = null;
            } else {
              fastRemoveAt$1(this.callbackInfos, index);
            }

            callbackInfoPool.free(info);
          }

          this.containCanceled = true;
        };

        _proto2.cancelAll = function cancelAll() {
          for (var i = 0; i < this.callbackInfos.length; i++) {
            var info = this.callbackInfos[i];

            if (info) {
              info.reset();
              callbackInfoPool.free(info);
              this.callbackInfos[i] = null;
            }
          }

          this.containCanceled = true;
        };

        _proto2.purgeCanceled = function purgeCanceled() {
          for (var i = this.callbackInfos.length - 1; i >= 0; --i) {
            var info = this.callbackInfos[i];

            if (!info) {
              fastRemoveAt$1(this.callbackInfos, i);
            }
          }

          this.containCanceled = false;
        };

        _proto2.clear = function clear() {
          this.cancelAll();
          this.callbackInfos.length = 0;
          this.isInvoking = false;
          this.containCanceled = false;
        };

        return CallbackList;
      }();
      var MAX_SIZE = 16;
      var callbackListPool = new Pool$1(function () {
        return new CallbackList();
      }, MAX_SIZE);
      var CallbacksInvoker = function () {
        function CallbacksInvoker() {
          this._callbackTable = createMap(true);
          this._offCallback = void 0;
        }

        var _proto3 = CallbacksInvoker.prototype;

        _proto3.on = function on(key, callback, target, once) {
          if (!this.hasEventListener(key, callback, target)) {
            var list = this._callbackTable[key];

            if (!list) {
              list = this._callbackTable[key] = callbackListPool.alloc();
            }

            var info = callbackInfoPool.alloc();
            info.set(callback, target, once);
            list.callbackInfos.push(info);
          }

          return callback;
        };

        _proto3.hasEventListener = function hasEventListener(key, callback, target) {
          var list = this._callbackTable && this._callbackTable[key];

          if (!list) {
            return false;
          }

          var infos = list.callbackInfos;

          if (!callback) {
            if (list.isInvoking) {
              for (var i = 0; i < infos.length; ++i) {
                if (infos[i]) {
                  return true;
                }
              }

              return false;
            } else {
              return infos.length > 0;
            }
          }

          for (var _i = 0; _i < infos.length; ++_i) {
            var info = infos[_i];

            if (info && info.check() && info.callback === callback && info.target === target) {
              return true;
            }
          }

          return false;
        };

        _proto3.removeAll = function removeAll(keyOrTarget) {
          var type = typeof keyOrTarget;

          if (type === 'string' || type === 'number') {
            var list = this._callbackTable && this._callbackTable[keyOrTarget];

            if (list) {
              if (list.isInvoking) {
                list.cancelAll();
              } else {
                list.clear();
                callbackListPool.free(list);
                delete this._callbackTable[keyOrTarget];
              }
            }
          } else if (keyOrTarget) {
            for (var key in this._callbackTable) {
              var _list = this._callbackTable[key];

              if (_list.isInvoking) {
                var infos = _list.callbackInfos;

                for (var i = 0; i < infos.length; ++i) {
                  var info = infos[i];

                  if (info && info.target === keyOrTarget) {
                    _list.cancel(i);
                  }
                }
              } else {
                _list.removeByTarget(keyOrTarget);
              }
            }
          }
        };

        _proto3.off = function off(key, callback, target) {
          var _this$_offCallback;

          var list = this._callbackTable && this._callbackTable[key];

          if (list) {
            var infos = list.callbackInfos;

            if (callback) {
              for (var i = 0; i < infos.length; ++i) {
                var info = infos[i];

                if (info && info.callback === callback && info.target === target) {
                  list.cancel(i);
                  break;
                }
              }
            } else {
              this.removeAll(key);
            }
          }

          (_this$_offCallback = this._offCallback) === null || _this$_offCallback === void 0 ? void 0 : _this$_offCallback.call(this);
        };

        _proto3.emit = function emit(key, arg0, arg1, arg2, arg3, arg4) {
          var list = this._callbackTable && this._callbackTable[key];

          if (list) {
            var rootInvoker = !list.isInvoking;
            list.isInvoking = true;
            var infos = list.callbackInfos;

            for (var i = 0, len = infos.length; i < len; ++i) {
              var info = infos[i];

              if (info) {
                var callback = info.callback;
                var target = info.target;

                if (info.once) {
                  this.off(key, callback, target);
                }

                if (!info.check()) {
                  this.off(key, callback, target);
                } else if (target) {
                  callback.call(target, arg0, arg1, arg2, arg3, arg4);
                } else {
                  callback(arg0, arg1, arg2, arg3, arg4);
                }
              }
            }

            if (rootInvoker) {
              list.isInvoking = false;

              if (list.containCanceled) {
                list.purgeCanceled();
              }
            }
          }
        };

        _proto3.clear = function clear() {
          for (var key in this._callbackTable) {
            var list = this._callbackTable[key];

            if (list) {
              list.clear();
              callbackListPool.free(list);
              delete this._callbackTable[key];
            }
          }
        };

        _proto3._registerOffCallback = function _registerOffCallback(cb) {
          this._offCallback = cb;
        };

        return CallbacksInvoker;
      }();

      function Eventify(base) {
        var Eventified = function (_ref) {
          _inheritsLoose(Eventified, _ref);

          function Eventified() {
            var _this;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this = _ref.call.apply(_ref, [this].concat(args)) || this;
            _this._callbackTable = createMap(true);
            return _this;
          }

          var _proto = Eventified.prototype;

          _proto.once = function once(type, callback, target) {
            return this.on(type, callback, target, true);
          };

          _proto.targetOff = function targetOff(typeOrTarget) {
            this.removeAll(typeOrTarget);
          };

          return Eventified;
        }(base);

        var callbacksInvokerPrototype = CallbacksInvoker.prototype;
        var propertyKeys = Object.getOwnPropertyNames(callbacksInvokerPrototype).concat(Object.getOwnPropertySymbols(callbacksInvokerPrototype));

        for (var iPropertyKey = 0; iPropertyKey < propertyKeys.length; ++iPropertyKey) {
          var propertyKey = propertyKeys[iPropertyKey];

          if (!(propertyKey in Eventified.prototype)) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(callbacksInvokerPrototype, propertyKey);

            if (propertyDescriptor) {
              Object.defineProperty(Eventified.prototype, propertyKey, propertyDescriptor);
            }
          }
        }

        return Eventified;
      }

      var Empty$1 = function Empty() {};

      var EventTarget = exports('EventTarget', Eventify(Empty$1));
      legacyCC.EventTarget = EventTarget;

      var BrowserType;

      (function (BrowserType) {
        BrowserType["UNKNOWN"] = "unknown";
        BrowserType["WECHAT"] = "wechat";
        BrowserType["ANDROID"] = "androidbrowser";
        BrowserType["IE"] = "ie";
        BrowserType["EDGE"] = "edge";
        BrowserType["QQ"] = "qqbrowser";
        BrowserType["MOBILE_QQ"] = "mqqbrowser";
        BrowserType["UC"] = "ucbrowser";
        BrowserType["UCBS"] = "ucbs";
        BrowserType["BROWSER_360"] = "360browser";
        BrowserType["BAIDU_APP"] = "baiduboxapp";
        BrowserType["BAIDU"] = "baidubrowser";
        BrowserType["MAXTHON"] = "maxthon";
        BrowserType["OPERA"] = "opera";
        BrowserType["OUPENG"] = "oupeng";
        BrowserType["MIUI"] = "miuibrowser";
        BrowserType["FIREFOX"] = "firefox";
        BrowserType["SAFARI"] = "safari";
        BrowserType["CHROME"] = "chrome";
        BrowserType["LIEBAO"] = "liebao";
        BrowserType["QZONE"] = "qzone";
        BrowserType["SOUGOU"] = "sogou";
        BrowserType["HUAWEI"] = "huawei";
      })(BrowserType || (BrowserType = {}));

      var Language;

      (function (Language) {
        Language["UNKNOWN"] = "unknown";
        Language["ENGLISH"] = "en";
        Language["CHINESE"] = "zh";
        Language["FRENCH"] = "fr";
        Language["ITALIAN"] = "it";
        Language["GERMAN"] = "de";
        Language["SPANISH"] = "es";
        Language["DUTCH"] = "du";
        Language["RUSSIAN"] = "ru";
        Language["KOREAN"] = "ko";
        Language["JAPANESE"] = "ja";
        Language["HUNGARIAN"] = "hu";
        Language["PORTUGUESE"] = "pt";
        Language["ARABIC"] = "ar";
        Language["NORWEGIAN"] = "no";
        Language["POLISH"] = "pl";
        Language["TURKISH"] = "tr";
        Language["UKRAINIAN"] = "uk";
        Language["ROMANIAN"] = "ro";
        Language["BULGARIAN"] = "bg";
      })(Language || (Language = {}));

      var NetworkType;

      (function (NetworkType) {
        NetworkType[NetworkType["NONE"] = 0] = "NONE";
        NetworkType[NetworkType["LAN"] = 1] = "LAN";
        NetworkType[NetworkType["WWAN"] = 2] = "WWAN";
      })(NetworkType || (NetworkType = {}));

      var OS;

      (function (OS) {
        OS["UNKNOWN"] = "Unknown";
        OS["IOS"] = "iOS";
        OS["ANDROID"] = "Android";
        OS["WINDOWS"] = "Windows";
        OS["LINUX"] = "Linux";
        OS["OSX"] = "OS X";
        OS["OHOS"] = "OHOS";
      })(OS || (OS = {}));

      var Platform;

      (function (Platform) {
        Platform["UNKNOWN"] = "UNKNOWN";
        Platform["EDITOR_PAGE"] = "EDITOR_PAGE";
        Platform["EDITOR_CORE"] = "EDITOR_CORE";
        Platform["MOBILE_BROWSER"] = "MOBILE_BROWSER";
        Platform["DESKTOP_BROWSER"] = "DESKTOP_BROWSER";
        Platform["WIN32"] = "WIN32";
        Platform["ANDROID"] = "ANDROID";
        Platform["IOS"] = "IOS";
        Platform["MACOS"] = "MACOS";
        Platform["OHOS"] = "OHOS";
        Platform["WECHAT_GAME"] = "WECHAT_GAME";
        Platform["BAIDU_MINI_GAME"] = "BAIDU_MINI_GAME";
        Platform["XIAOMI_QUICK_GAME"] = "XIAOMI_QUICK_GAME";
        Platform["ALIPAY_MINI_GAME"] = "ALIPAY_MINI_GAME";
        Platform["BYTEDANCE_MINI_GAME"] = "BYTEDANCE_MINI_GAME";
        Platform["OPPO_MINI_GAME"] = "OPPO_MINI_GAME";
        Platform["VIVO_MINI_GAME"] = "VIVO_MINI_GAME";
        Platform["HUAWEI_QUICK_GAME"] = "HUAWEI_QUICK_GAME";
        Platform["COCOSPLAY"] = "COCOSPLAY";
        Platform["LINKSURE_MINI_GAME"] = "LINKSURE_MINI_GAME";
        Platform["QTT_MINI_GAME"] = "QTT_MINI_GAME";
      })(Platform || (Platform = {}));

      var Feature$1;

      (function (Feature) {
        Feature["WEBP"] = "WEBP";
        Feature["IMAGE_BITMAP"] = "IMAGE_BITMAP";
        Feature["WEB_VIEW"] = "WEB_VIEW";
        Feature["VIDEO_PLAYER"] = "VIDEO_PLAYER";
        Feature["SAFE_AREA"] = "SAFE_AREA";
        Feature["INPUT_TOUCH"] = "INPUT_TOUCH";
        Feature["EVENT_KEYBOARD"] = "EVENT_KEYBOARD";
        Feature["EVENT_MOUSE"] = "EVENT_MOUSE";
        Feature["EVENT_TOUCH"] = "EVENT_TOUCH";
        Feature["EVENT_ACCELEROMETER"] = "EVENT_ACCELEROMETER";
      })(Feature$1 || (Feature$1 = {}));

      var SystemInfo = function (_EventTarget) {
        _inheritsLoose(SystemInfo, _EventTarget);

        function SystemInfo() {
          var _nav$getBattery, _this$_featureMap;

          var _this;

          _this = _EventTarget.call(this) || this;
          _this.networkType = void 0;
          _this.isNative = void 0;
          _this.isBrowser = void 0;
          _this.isMobile = void 0;
          _this.isLittleEndian = void 0;
          _this.platform = void 0;
          _this.language = void 0;
          _this.nativeLanguage = void 0;
          _this.os = void 0;
          _this.osVersion = void 0;
          _this.osMainVersion = void 0;
          _this.browserType = void 0;
          _this.browserVersion = void 0;
          _this._battery = void 0;
          _this._featureMap = void 0;
          var nav = window.navigator;
          var ua = nav.userAgent.toLowerCase();
          (_nav$getBattery = nav.getBattery) === null || _nav$getBattery === void 0 ? void 0 : _nav$getBattery.call(nav).then(function (battery) {
            _this._battery = battery;
          });
          _this.networkType = NetworkType.LAN;
          _this.isNative = false;
          _this.isBrowser = true;

          {
            _this.isMobile = /mobile|android|iphone|ipad/.test(ua);
            _this.platform = _this.isMobile ? Platform.MOBILE_BROWSER : Platform.DESKTOP_BROWSER;
          }

          _this.isLittleEndian = function () {
            var buffer = new ArrayBuffer(2);
            new DataView(buffer).setInt16(0, 256, true);
            return new Int16Array(buffer)[0] === 256;
          }();

          var currLanguage = nav.language;
          _this.nativeLanguage = currLanguage.toLowerCase();
          currLanguage = currLanguage || nav.browserLanguage;
          currLanguage = currLanguage ? currLanguage.split('-')[0] : Language.ENGLISH;
          _this.language = currLanguage;
          var isAndroid = false;
          var iOS = false;
          var osVersion = '';
          var osMajorVersion = 0;
          var uaResult = /android\s*(\d+(?:\.\d+)*)/i.exec(ua) || /android\s*(\d+(?:\.\d+)*)/i.exec(nav.platform);

          if (uaResult) {
            isAndroid = true;
            osVersion = uaResult[1] || '';
            osMajorVersion = parseInt(osVersion) || 0;
          }

          uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua);

          if (uaResult) {
            iOS = true;
            osVersion = uaResult[2] || '';
            osMajorVersion = parseInt(osVersion) || 0;
          } else if (/(iPhone|iPad|iPod)/.exec(nav.platform) || nav.platform === 'MacIntel' && nav.maxTouchPoints && nav.maxTouchPoints > 1) {
            iOS = true;
            osVersion = '';
            osMajorVersion = 0;
          }

          var osName = OS.UNKNOWN;

          if (nav.appVersion.indexOf('Win') !== -1) {
            osName = OS.WINDOWS;
          } else if (iOS) {
            osName = OS.IOS;
          } else if (nav.appVersion.indexOf('Mac') !== -1) {
            osName = OS.OSX;
          } else if (nav.appVersion.indexOf('X11') !== -1 && nav.appVersion.indexOf('Linux') === -1) {
            osName = OS.LINUX;
          } else if (isAndroid) {
            osName = OS.ANDROID;
          } else if (nav.appVersion.indexOf('Linux') !== -1 || ua.indexOf('ubuntu') !== -1) {
            osName = OS.LINUX;
          }

          _this.os = osName;
          _this.osVersion = osVersion;
          _this.osMainVersion = osMajorVersion;
          _this.browserType = BrowserType.UNKNOWN;
          var typeReg0 = /wechat|weixin|micromessenger/i;
          var typeReg1 = /mqqbrowser|micromessenger|qqbrowser|sogou|qzone|liebao|maxthon|ucbs|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i;
          var typeReg2 = /qq|qqbrowser|ucbrowser|ubrowser|edge|HuaweiBrowser/i;
          var typeReg3 = /chrome|safari|firefox|trident|opera|opr\/|oupeng/i;
          var browserTypes = typeReg0.exec(ua) || typeReg1.exec(ua) || typeReg2.exec(ua) || typeReg3.exec(ua);
          var browserType = browserTypes ? browserTypes[0].toLowerCase() : OS.UNKNOWN;

          if (browserType === 'safari' && isAndroid) {
            browserType = BrowserType.ANDROID;
          } else if (browserType === 'qq' && /android.*applewebkit/i.test(ua)) {
            browserType = BrowserType.ANDROID;
          }

          var typeMap = {
            micromessenger: BrowserType.WECHAT,
            wechat: BrowserType.WECHAT,
            weixin: BrowserType.WECHAT,
            trident: BrowserType.IE,
            edge: BrowserType.EDGE,
            '360 aphone': BrowserType.BROWSER_360,
            mxbrowser: BrowserType.MAXTHON,
            'opr/': BrowserType.OPERA,
            ubrowser: BrowserType.UC,
            huaweibrowser: BrowserType.HUAWEI
          };
          _this.browserType = typeMap[browserType] || browserType;
          _this.browserVersion = '';
          var versionReg1 = /(mqqbrowser|micromessenger|qqbrowser|sogou|qzone|liebao|maxthon|uc|ucbs|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui(?:.hybrid)?)(mobile)?(browser)?\/?([\d.]+)/i;
          var versionReg2 = /(qq|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i;
          var tmp = versionReg1.exec(ua);

          if (!tmp) {
            tmp = versionReg2.exec(ua);
          }

          _this.browserVersion = tmp ? tmp[4] : '';

          var _tmpCanvas1 = document.createElement('canvas');

          var supportCanvas =  !!_tmpCanvas1.getContext('2d');

          var supportWebp;

          try {
            supportWebp = TEST ? false : _tmpCanvas1.toDataURL('image/webp').startsWith('data:image/webp');
          } catch (e) {
            supportWebp = false;
          }

          var supportImageBitmap = false;

          if ( typeof createImageBitmap !== 'undefined' && typeof Blob !== 'undefined') {
            _tmpCanvas1.width = _tmpCanvas1.height = 2;
            createImageBitmap(_tmpCanvas1, {}).then(function (imageBitmap) {
              supportImageBitmap = true;
              imageBitmap === null || imageBitmap === void 0 ? void 0 : imageBitmap.close();
            })["catch"](function (err) {});
          }

          var supportTouch = document.documentElement.ontouchstart !== undefined || document.ontouchstart !== undefined;
          var supportMouse =  document.documentElement.onmouseup !== undefined;
          _this._featureMap = (_this$_featureMap = {}, _this$_featureMap[Feature$1.WEBP] = supportWebp, _this$_featureMap[Feature$1.IMAGE_BITMAP] = supportImageBitmap, _this$_featureMap[Feature$1.WEB_VIEW] = true, _this$_featureMap[Feature$1.VIDEO_PLAYER] = true, _this$_featureMap[Feature$1.SAFE_AREA] = false, _this$_featureMap[Feature$1.INPUT_TOUCH] = supportTouch, _this$_featureMap[Feature$1.EVENT_KEYBOARD] = document.documentElement.onkeyup !== undefined, _this$_featureMap[Feature$1.EVENT_MOUSE] = supportMouse, _this$_featureMap[Feature$1.EVENT_TOUCH] = supportTouch || supportMouse, _this$_featureMap[Feature$1.EVENT_ACCELEROMETER] = window.DeviceMotionEvent !== undefined || window.DeviceOrientationEvent !== undefined, _this$_featureMap);

          _this._registerEvent();

          return _this;
        }

        var _proto = SystemInfo.prototype;

        _proto._registerEvent = function _registerEvent() {
          var _this2 = this;

          var hiddenPropName;

          if (typeof document.hidden !== 'undefined') {
            hiddenPropName = 'hidden';
          } else if (typeof document.mozHidden !== 'undefined') {
            hiddenPropName = 'mozHidden';
          } else if (typeof document.msHidden !== 'undefined') {
            hiddenPropName = 'msHidden';
          } else if (typeof document.webkitHidden !== 'undefined') {
            hiddenPropName = 'webkitHidden';
          } else {
            hiddenPropName = 'hidden';
          }

          var hidden = false;

          var onHidden = function onHidden() {
            if (!hidden) {
              hidden = true;

              _this2.emit('hide');
            }
          };

          var onShown = function onShown(arg0, arg1, arg2, arg3, arg4) {
            if (hidden) {
              hidden = false;

              _this2.emit('show', arg0, arg1, arg2, arg3, arg4);
            }
          };

          if (hiddenPropName) {
            var changeList = ['visibilitychange', 'mozvisibilitychange', 'msvisibilitychange', 'webkitvisibilitychange', 'qbrowserVisibilityChange'];

            for (var i = 0; i < changeList.length; i++) {
              document.addEventListener(changeList[i], function (event) {
                var visible = document[hiddenPropName];
                visible = visible || event.hidden;

                if (visible) {
                  onHidden();
                } else {
                  onShown();
                }
              });
            }
          } else {
            window.addEventListener('blur', onHidden);
            window.addEventListener('focus', onShown);
          }

          if (window.navigator.userAgent.indexOf('MicroMessenger') > -1) {
            window.onfocus = onShown;
          }

          if ('onpageshow' in window && 'onpagehide' in window) {
            window.addEventListener('pagehide', onHidden);
            window.addEventListener('pageshow', onShown);
            document.addEventListener('pagehide', onHidden);
            document.addEventListener('pageshow', onShown);
          }
        };

        _proto.hasFeature = function hasFeature(feature) {
          return this._featureMap[feature];
        };

        _proto.getBatteryLevel = function getBatteryLevel() {
          if (this._battery) {
            return this._battery.level;
          } else {
            {
              console.warn('getBatteryLevel is not supported');
            }

            return 1;
          }
        };

        _proto.triggerGC = function triggerGC() {
          {
            console.warn('triggerGC is not supported.');
          }
        };

        _proto.openURL = function openURL(url) {
          window.open(url);
        };

        _proto.now = function now() {
          if (Date.now) {
            return Date.now();
          }

          return +new Date();
        };

        _proto.restartJSVM = function restartJSVM() {
          {
            console.warn('restartJSVM is not supported.');
          }
        };

        _proto.close = function close() {
          this.emit('close');
          window.close();
        };

        return SystemInfo;
      }(EventTarget);

      var systemInfo = new SystemInfo();

      var EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
      var DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
      var NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
      function join() {
        var result = '';

        for (var _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) {
          segments[_key] = arguments[_key];
        }

        for (var _i = 0, _segments = segments; _i < _segments.length; _i++) {
          var segment = _segments[_i];
          result = (result + (result === '' ? '' : '/') + segment).replace(/(\/|\\\\)$/, '');
        }

        return result;
      }
      function extname(path) {
        var temp = EXTNAME_RE.exec(path);
        return temp ? temp[1] : '';
      }
      function mainFileName(fileName) {
        if (fileName) {
          var idx = fileName.lastIndexOf('.');

          if (idx !== -1) {
            return fileName.substring(0, idx);
          }
        }

        return fileName;
      }
      function basename(path, extName) {
        var index = path.indexOf('?');

        if (index > 0) {
          path = path.substring(0, index);
        }

        var reg = /(\/|\\)([^\/\\]+)$/g;
        var result = reg.exec(path.replace(/(\/|\\)$/, ''));

        if (!result) {
          return path;
        }

        var baseName = result[2];

        if (extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase()) {
          return baseName.substring(0, baseName.length - extName.length);
        }

        return baseName;
      }
      function dirname(path) {
        var temp = DIRNAME_RE.exec(path);
        return temp ? temp[2] : '';
      }
      function changeExtname(path, extName) {
        extName = extName || '';
        var index = path.indexOf('?');
        var tempStr = '';

        if (index > 0) {
          tempStr = path.substring(index);
          path = path.substring(0, index);
        }

        index = path.lastIndexOf('.');

        if (index < 0) {
          return path + extName + tempStr;
        }

        return path.substring(0, index) + extName + tempStr;
      }
      function changeBasename(path, baseName, isSameExt) {
        if (baseName.indexOf('.') === 0) {
          return changeExtname(path, baseName);
        }

        var index = path.indexOf('?');
        var tempStr = '';
        var ext = isSameExt ? extname(path) : '';

        if (index > 0) {
          tempStr = path.substring(index);
          path = path.substring(0, index);
        }

        index = path.lastIndexOf('/');
        index = index <= 0 ? 0 : index + 1;
        return path.substring(0, index) + baseName + ext + tempStr;
      }
      function _normalize(url) {
        var oldUrl = url = String(url);

        do {
          oldUrl = url;
          url = url.replace(NORMALIZE_RE, '');
        } while (oldUrl.length !== url.length);

        return url;
      }
      function stripSep(path) {
        return path.replace(/[\/\\]$/, '');
      }
      function getSeperator() {
        return systemInfo.os === OS.WINDOWS ? '\\' : '/';
      }

      var path = /*#__PURE__*/Object.freeze({
        __proto__: null,
        join: join,
        extname: extname,
        mainFileName: mainFileName,
        basename: basename,
        dirname: dirname,
        changeExtname: changeExtname,
        changeBasename: changeBasename,
        _normalize: _normalize,
        stripSep: stripSep,
        getSeperator: getSeperator
      });
      exports('path', path);

      var _dec, _class, _class2, _descriptor, _temp;
      var Asset = exports('Asset', (_dec = ccclass('cc.Asset'), _dec(_class = (_class2 = (_temp = function (_Eventify) {
        _inheritsLoose(Asset, _Eventify);

        Asset.deserialize = function deserialize(data) {
          return legacyCC.deserialize(data);
        };

        function Asset() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Eventify.call.apply(_Eventify, [this].concat(args)) || this;
          _this.loaded = true;

          _initializerDefineProperty(_this, "_native", _descriptor, _assertThisInitialized(_this));

          _this._nativeUrl = '';
          _this._file = null;
          _this._ref = 0;
          Object.defineProperty(_assertThisInitialized(_this), '_uuid', {
            value: '',
            writable: true
          });

          return _this;
        }

        var _proto = Asset.prototype;

        _proto.toString = function toString() {
          return this.nativeUrl;
        };

        _proto.serialize = function serialize() {};

        _proto._setRawAsset = function _setRawAsset(filename, inLibrary) {
          if (inLibrary === void 0) {
            inLibrary = true;
          }

          if (inLibrary !== false) {
            this._native = filename || '';
          } else {
            this._native = "/" + filename;
          }
        };

        _proto.addRef = function addRef() {
          this._ref++;
          return this;
        };

        _proto.decRef = function decRef(autoRelease) {
          if (autoRelease === void 0) {
            autoRelease = true;
          }

          if (this._ref > 0) {
            this._ref--;
          }

          if (autoRelease) {
            legacyCC.assetManager._releaseManager.tryRelease(this);
          }

          return this;
        };

        _proto.onLoaded = function onLoaded() {};

        _proto.initDefault = function initDefault(uuid) {
          if (uuid) {
            this._uuid = uuid;
          }

          this.isDefault = true;
        };

        _proto.validate = function validate() {
          return true;
        };

        _proto.destroy = function destroy() {
          debug(getError(12101, this._uuid));
          return _Eventify.prototype.destroy.call(this);
        };

        _createClass(Asset, [{
          key: "nativeUrl",
          get: function get() {
            if (!this._nativeUrl) {
              if (!this._native) return '';
              var name = this._native;

              if (name.charCodeAt(0) === 47) {
                return name.slice(1);
              }

              if (name.charCodeAt(0) === 46) {
                this._nativeUrl = getUrlWithUuid(this._uuid, {
                  nativeExt: name,
                  isNative: true
                });
              } else {
                this._nativeUrl = getUrlWithUuid(this._uuid, {
                  __nativeName__: name,
                  nativeExt: extname(name),
                  isNative: true
                });
              }
            }

            return this._nativeUrl;
          }
        }, {
          key: "_nativeAsset",
          get: function get() {
            return this._file;
          },
          set: function set(obj) {
            this._file = obj;
          }
        }, {
          key: "_nativeDep",
          get: function get() {
            if (this._native) {
              return {
                __isNative__: true,
                uuid: this._uuid,
                ext: this._native
              };
            }

            return undefined;
          }
        }, {
          key: "refCount",
          get: function get() {
            return this._ref;
          }
        }]);

        return Asset;
      }(Eventify(CCObject)), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_native", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "_nativeAsset", [property], Object.getOwnPropertyDescriptor(_class2.prototype, "_nativeAsset"), _class2.prototype)), _class2)) || _class));
      Asset.prototype.createNode = null;
      legacyCC.Asset = Asset;

      var _dec$1, _class$1, _dec2, _class2$1, _dec3, _class3;
      var Script = exports('Script', (_dec$1 = ccclass('cc.Script'), _dec$1(_class$1 = function (_Asset) {
        _inheritsLoose(Script, _Asset);

        function Script() {
          return _Asset.apply(this, arguments) || this;
        }

        return Script;
      }(Asset)) || _class$1));
      legacyCC._Script = Script;
      var JavaScript = exports('JavaScript', (_dec2 = ccclass('cc.JavaScript'), _dec2(_class2$1 = function (_Script) {
        _inheritsLoose(JavaScript, _Script);

        function JavaScript() {
          return _Script.apply(this, arguments) || this;
        }

        return JavaScript;
      }(Script)) || _class2$1));
      legacyCC._JavaScript = JavaScript;
      var TypeScript = exports('TypeScript', (_dec3 = ccclass('cc.TypeScript'), _dec3(_class3 = function (_Script2) {
        _inheritsLoose(TypeScript, _Script2);

        function TypeScript() {
          return _Script2.apply(this, arguments) || this;
        }

        return TypeScript;
      }(Script)) || _class3));
      legacyCC._TypeScript = TypeScript;

      var _dec$2, _dec2$1, _dec3$1, _dec4, _class$2, _class2$2, _descriptor$1, _descriptor2, _descriptor3, _class3$1, _temp$1;
      var idGenerator = new IDGenerator('Comp');
      var IsOnLoadCalled$1 = CCObject.Flags.IsOnLoadCalled;
      var NullNode = null;
      var Component = exports('Component', (_dec$2 = ccclass('cc.Component'), _dec2$1 = displayName(), _dec3$1 = type(Script), _dec4 = tooltip(), _dec$2(_class$2 = (_class2$2 = (_temp$1 = _class3$1 = function (_CCObject) {
        _inheritsLoose(Component, _CCObject);

        function Component() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _CCObject.call.apply(_CCObject, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "node", _descriptor$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_enabled", _descriptor2, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "__prefab", _descriptor3, _assertThisInitialized(_this));

          _this._sceneGetter = null;
          _this._id = idGenerator.getNewId();
          return _this;
        }

        var _proto = Component.prototype;

        _proto._getRenderScene = function _getRenderScene() {
          if (this._sceneGetter) {
            return this._sceneGetter();
          }

          return this.node.scene.renderScene;
        };

        _proto.addComponent = function addComponent(typeOrClassName) {
          return this.node.addComponent(typeOrClassName);
        };

        _proto.getComponent = function getComponent(typeOrClassName) {
          return this.node.getComponent(typeOrClassName);
        };

        _proto.getComponents = function getComponents(typeOrClassName) {
          return this.node.getComponents(typeOrClassName);
        };

        _proto.getComponentInChildren = function getComponentInChildren(typeOrClassName) {
          return this.node.getComponentInChildren(typeOrClassName);
        };

        _proto.getComponentsInChildren = function getComponentsInChildren(typeOrClassName) {
          return this.node.getComponentsInChildren(typeOrClassName);
        };

        _proto.destroy = function destroy() {

          if (_CCObject.prototype.destroy.call(this)) {
            if (this._enabled && this.node.activeInHierarchy) {
              legacyCC.director._compScheduler.disableComp(this);
            }

            return true;
          }

          return false;
        };

        _proto._onPreDestroy = function _onPreDestroy() {
          this.unscheduleAllCallbacks();

          legacyCC.director._nodeActivator.destroyComp(this);

          this.node._removeComponent(this);
        };

        _proto._instantiate = function _instantiate(cloned) {
          if (!cloned) {
            cloned = legacyCC.instantiate._clone(this, this);
          }

          if (cloned) {
            cloned.node = NullNode;
          }

          return cloned;
        };

        _proto.schedule = function schedule(callback, interval, repeat, delay) {
          if (interval === void 0) {
            interval = 0;
          }

          if (repeat === void 0) {
            repeat = legacyCC.macro.REPEAT_FOREVER;
          }

          if (delay === void 0) {
            delay = 0;
          }

          assertID(callback, 1619);
          interval = interval || 0;
          assertID(interval >= 0, 1620);
          repeat = Number.isNaN(repeat) ? legacyCC.macro.REPEAT_FOREVER : repeat;
          delay = delay || 0;
          var scheduler = legacyCC.director.getScheduler();
          var paused = scheduler.isTargetPaused(this);
          scheduler.schedule(callback, this, interval, repeat, delay, paused);
        };

        _proto.scheduleOnce = function scheduleOnce(callback, delay) {
          if (delay === void 0) {
            delay = 0;
          }

          this.schedule(callback, 0, 0, delay);
        };

        _proto.unschedule = function unschedule(callback_fn) {
          if (!callback_fn) {
            return;
          }

          legacyCC.director.getScheduler().unschedule(callback_fn, this);
        };

        _proto.unscheduleAllCallbacks = function unscheduleAllCallbacks() {
          legacyCC.director.getScheduler().unscheduleAllForTarget(this);
        };

        _createClass(Component, [{
          key: "name",
          get: function get() {
            if (this._name) {
              return this._name;
            }

            var className = getClassName(this);
            var trimLeft = className.lastIndexOf('.');

            if (trimLeft >= 0) {
              className = className.slice(trimLeft + 1);
            }

            if (this.node) {
              return this.node.name + "<" + className + ">";
            } else {
              return className;
            }
          },
          set: function set(value) {
            this._name = value;
          }
        }, {
          key: "uuid",
          get: function get() {
            return this._id;
          }
        }, {
          key: "__scriptAsset",
          get: function get() {
            return null;
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(value) {
            if (this._enabled !== value) {
              this._enabled = value;

              if (this.node.activeInHierarchy) {
                var compScheduler = legacyCC.director._compScheduler;

                if (value) {
                  compScheduler.enableComp(this);
                } else {
                  compScheduler.disableComp(this);
                }
              }
            }
          }
        }, {
          key: "enabledInHierarchy",
          get: function get() {
            return this._enabled && this.node && this.node.activeInHierarchy;
          }
        }, {
          key: "_isOnLoadCalled",
          get: function get() {
            return this._objFlags & IsOnLoadCalled$1;
          }
        }]);

        return Component;
      }(CCObject), _class3$1.system = null, _temp$1), (_applyDecoratedDescriptor(_class2$2.prototype, "__scriptAsset", [_dec2$1, _dec3$1, _dec4, disallowAnimation], Object.getOwnPropertyDescriptor(_class2$2.prototype, "__scriptAsset"), _class2$2.prototype), _descriptor$1 = _applyDecoratedDescriptor(_class2$2.prototype, "node", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return NullNode;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2$2.prototype, "_enabled", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2$2.prototype, "__prefab", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$2)) || _class$2));
      var proto = Component.prototype;
      proto.update = null;
      proto.lateUpdate = null;
      proto.__preload = null;
      proto.onLoad = null;
      proto.start = null;
      proto.onEnable = null;
      proto.onDisable = null;
      proto.onDestroy = null;
      proto.onFocusInEditor = null;
      proto.onLostFocusInEditor = null;
      proto.resetInEditor = null;
      proto._getLocalBounds = null;
      proto.onRestore = null;
      Component._requireComponent = null;
      Component._executionOrder = 0;

      value(Component, '_registerEditorProps', function (cls, props) {
        var reqComp = props.requireComponent;

        if (reqComp) {
          if (Array.isArray(reqComp)) {
            reqComp = reqComp.filter(Boolean);
          }

          cls._requireComponent = reqComp;
        }

        var order = props.executionOrder;

        if (order && typeof order === 'number') {
          cls._executionOrder = order;
        }
      });
      legacyCC.Component = Component;

      var _dec$3, _dec2$2, _class$3, _class2$3, _descriptor$2, _temp$2;
      var MissingScript = exports('MissingScript', (_dec$3 = ccclass('cc.MissingScript'), _dec2$2 = inspector(), _dec$3(_class$3 = _dec2$2(_class$3 = (_class2$3 = (_temp$2 = function (_Component) {
        _inheritsLoose(MissingScript, _Component);

        MissingScript.safeFindClass = function safeFindClass(id) {
          var cls = _getClassById(id);

          if (cls) {
            return cls;
          }

          legacyCC.deserialize.reportMissingClass(id);
          return undefined;
        };

        function MissingScript() {
          var _this;

          _this = _Component.call(this) || this;

          _initializerDefineProperty(_this, "_$erialized", _descriptor$2, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = MissingScript.prototype;

        _proto.onLoad = function onLoad() {
          warnID(4600, this.node.name);
        };

        return MissingScript;
      }(Component), _temp$2), (_descriptor$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_$erialized", [serializable, editorOnly], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$3)) || _class$3) || _class$3));
      legacyCC._MissingScript = MissingScript;

      try {
        var props = MissingScript.__values__;

        if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
          error("The '_$erialized' prop in MissingScript is missing. Please contact jare.");
          error("    Error props: ['" + props + "']");
        }
      } catch (e) {
        error("Error when checking MissingScript 5, " + e);
      }

      var _PORTRAIT = 1;

      var _PORTRAIT_UPSIDE_DOWN = _PORTRAIT << 1;

      var _LEFT = _PORTRAIT << 2;

      var _RIGHT = _PORTRAIT << 3;

      var _LANDSCAPE = _LEFT | _RIGHT;

      var _AUTO = _PORTRAIT | _LANDSCAPE;

      var Orientation;

      (function (Orientation) {
        Orientation[Orientation["PORTRAIT"] = _PORTRAIT] = "PORTRAIT";
        Orientation[Orientation["PORTRAIT_UPSIDE_DOWN"] = _PORTRAIT_UPSIDE_DOWN] = "PORTRAIT_UPSIDE_DOWN";
        Orientation[Orientation["LANDSCAPE_LEFT"] = _LEFT] = "LANDSCAPE_LEFT";
        Orientation[Orientation["LANDSCAPE_RIGHT"] = _RIGHT] = "LANDSCAPE_RIGHT";
        Orientation[Orientation["LANDSCAPE"] = _LANDSCAPE] = "LANDSCAPE";
        Orientation[Orientation["AUTO"] = _AUTO] = "AUTO";
      })(Orientation || (Orientation = {}));

      var EVENT_TIMEOUT =  200;
      var orientationMap = {
        auto: Orientation.AUTO,
        landscape: Orientation.LANDSCAPE,
        portrait: Orientation.PORTRAIT
      };
      var WindowType;

      (function (WindowType) {
        WindowType[WindowType["Unknown"] = 0] = "Unknown";
        WindowType[WindowType["SubFrame"] = 1] = "SubFrame";
        WindowType[WindowType["BrowserWindow"] = 2] = "BrowserWindow";
        WindowType[WindowType["Fullscreen"] = 3] = "Fullscreen";
      })(WindowType || (WindowType = {}));

      var ScreenAdapter = function (_EventTarget) {
        _inheritsLoose(ScreenAdapter, _EventTarget);

        function ScreenAdapter() {
          var _this;

          _this = _EventTarget.call(this) || this;
          _this.isFrameRotated = false;
          _this.handleResizeEvent = true;
          _this._gameFrame = void 0;
          _this._gameContainer = void 0;
          _this._gameCanvas = void 0;
          _this._isProportionalToFrame = false;
          _this._cachedFrameStyle = {
            width: '0px',
            height: '0px'
          };
          _this._cachedContainerStyle = {
            width: '0px',
            height: '0px'
          };
          _this._cbToUpdateFrameBuffer = void 0;
          _this._supportFullScreen = false;
          _this._touchEventName = void 0;
          _this._onFullscreenChange = void 0;
          _this._onFullscreenError = void 0;
          _this._orientationChangeTimeoutId = -1;
          _this._cachedFrameSize = new Size(0, 0);
          _this._exactFitScreen = false;
          _this._fn = {};
          _this._fnGroup = [['requestFullscreen', 'exitFullscreen', 'fullscreenchange', 'fullscreenEnabled', 'fullscreenElement', 'fullscreenerror'], ['requestFullScreen', 'exitFullScreen', 'fullScreenchange', 'fullScreenEnabled', 'fullScreenElement', 'fullscreenerror'], ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitIsFullScreen', 'webkitCurrentFullScreenElement', 'webkitfullscreenerror'], ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozfullscreenchange', 'mozFullScreen', 'mozFullScreenElement', 'mozfullscreenerror'], ['msRequestFullscreen', 'msExitFullscreen', 'MSFullscreenChange', 'msFullscreenEnabled', 'msFullscreenElement', 'msfullscreenerror']];
          _this._resolutionScale = 1;
          _this._orientation = Orientation.AUTO;
          _this._gameFrame = document.getElementById('GameDiv');
          _this._gameContainer = document.getElementById('Cocos3dGameContainer');
          _this._gameCanvas = document.getElementById('GameCanvas');

          {
            if (!_this._gameFrame) {
              var _this$_gameCanvas, _this$_gameCanvas$par;

              _this._gameFrame = document.createElement('div');

              _this._gameFrame.setAttribute('id', 'GameDiv');

              (_this$_gameCanvas = _this._gameCanvas) === null || _this$_gameCanvas === void 0 ? void 0 : (_this$_gameCanvas$par = _this$_gameCanvas.parentNode) === null || _this$_gameCanvas$par === void 0 ? void 0 : _this$_gameCanvas$par.insertBefore(_this._gameFrame, _this._gameCanvas);

              _this._gameFrame.appendChild(_this._gameCanvas);
            }

            if (!_this._gameContainer) {
              var _this$_gameCanvas2, _this$_gameCanvas2$pa;

              _this._gameContainer = document.createElement('div');

              _this._gameContainer.setAttribute('id', 'Cocos3dGameContainer');

              (_this$_gameCanvas2 = _this._gameCanvas) === null || _this$_gameCanvas2 === void 0 ? void 0 : (_this$_gameCanvas2$pa = _this$_gameCanvas2.parentNode) === null || _this$_gameCanvas2$pa === void 0 ? void 0 : _this$_gameCanvas2$pa.insertBefore(_this._gameContainer, _this._gameCanvas);

              _this._gameContainer.appendChild(_this._gameCanvas);
            }
          }

          var fnList;
          var fnGroup = _this._fnGroup;

          for (var i = 0; i < fnGroup.length; i++) {
            fnList = fnGroup[i];

            if (typeof document[fnList[1]] !== 'undefined') {
              for (var _i = 0; _i < fnList.length; _i++) {
                _this._fn[fnGroup[0][_i]] = fnList[_i];
              }

              break;
            }
          }

          _this._supportFullScreen = _this._fn.requestFullscreen !== undefined;
          _this._touchEventName = 'ontouchstart' in window ? 'touchend' : 'mousedown';

          _this._registerEvent();

          return _this;
        }

        var _proto = ScreenAdapter.prototype;

        _proto.init = function init(options, cbToRebuildFrameBuffer) {
          this._cbToUpdateFrameBuffer = cbToRebuildFrameBuffer;
          this.orientation = orientationMap[options.configOrientation];
          this._exactFitScreen = options.exactFitScreen;

          this._resizeFrame();
        };

        _proto.requestFullScreen = function requestFullScreen() {
          var _this2 = this;

          return new Promise(function (resolve, reject) {
            if (_this2.isFullScreen) {
              resolve();
              return;
            }

            _this2._cachedFrameSize = _this2.windowSize;

            _this2._doRequestFullScreen().then(function () {
              resolve();
            })["catch"](function () {
              var fullscreenTarget = _this2._getFullscreenTarget();

              if (!fullscreenTarget) {
                reject(new Error('Cannot access fullscreen target'));
                return;
              }

              fullscreenTarget.addEventListener(_this2._touchEventName, function () {
                _this2._doRequestFullScreen().then(function () {
                  resolve();
                })["catch"](reject);
              }, {
                once: true,
                capture: true
              });
            });
          });
        };

        _proto.exitFullScreen = function exitFullScreen() {
          var _this3 = this;

          return new Promise(function (resolve, reject) {
            var requestPromise = document[_this3._fn.exitFullscreen]();

            if (window.Promise && requestPromise instanceof Promise) {
              requestPromise.then(function () {
                _this3.windowSize = _this3._cachedFrameSize;
                resolve();
              })["catch"](reject);
              return;
            }

            _this3.windowSize = _this3._cachedFrameSize;
            resolve();
          });
        };

        _proto._registerEvent = function _registerEvent() {
          var _this4 = this;

          document.addEventListener(this._fn.fullscreenerror, function () {
            var _this4$_onFullscreenE;

            (_this4$_onFullscreenE = _this4._onFullscreenError) === null || _this4$_onFullscreenE === void 0 ? void 0 : _this4$_onFullscreenE.call(_this4);
          });
          window.addEventListener('resize', function () {
            if (!_this4.handleResizeEvent) {
              return;
            }

            _this4._resizeFrame();
          });

          if (typeof window.matchMedia === 'function') {
            var updateDPRChangeListener = function updateDPRChangeListener() {
              var _window$matchMedia, _window$matchMedia$ad;

              var dpr = window.devicePixelRatio;
              (_window$matchMedia = window.matchMedia("(resolution: " + dpr + "dppx)")) === null || _window$matchMedia === void 0 ? void 0 : (_window$matchMedia$ad = _window$matchMedia.addEventListener) === null || _window$matchMedia$ad === void 0 ? void 0 : _window$matchMedia$ad.call(_window$matchMedia, 'change', function () {
                _this4.emit('window-resize');

                updateDPRChangeListener();
              }, {
                once: true
              });
            };

            updateDPRChangeListener();
          }

          window.addEventListener('orientationchange', function () {
            if (_this4._orientationChangeTimeoutId !== -1) {
              clearTimeout(_this4._orientationChangeTimeoutId);
            }

            _this4._orientationChangeTimeoutId = setTimeout(function () {
              if (!_this4.handleResizeEvent) {
                return;
              }

              _this4._updateFrameState();

              _this4._resizeFrame();

              _this4.emit('orientation-change');

              _this4._orientationChangeTimeoutId = -1;
            }, EVENT_TIMEOUT);
          });
          document.addEventListener(this._fn.fullscreenchange, function () {
            var _this4$_onFullscreenC;

            (_this4$_onFullscreenC = _this4._onFullscreenChange) === null || _this4$_onFullscreenC === void 0 ? void 0 : _this4$_onFullscreenC.call(_this4);

            _this4.emit('fullscreen-change');
          });
        };

        _proto._convertToSizeInCssPixels = function _convertToSizeInCssPixels(size) {
          var clonedSize = size.clone();
          var dpr = this.devicePixelRatio;
          clonedSize.width /= dpr;
          clonedSize.height /= dpr;
          return clonedSize;
        };

        _proto._resizeFrame = function _resizeFrame(sizeInCssPixels) {
          if (!this._gameFrame) {
            return;
          }

          this._gameFrame.style.display = 'flex';
          this._gameFrame.style['justify-content'] = 'center';
          this._gameFrame.style['align-items'] = 'center';

          if (this._windowType === WindowType.SubFrame) {
            if (!sizeInCssPixels) {
              this._updateContainer();

              return;
            }

            this._gameFrame.style.width = sizeInCssPixels.width + "px";
            this._gameFrame.style.height = sizeInCssPixels.height + "px";
          } else {
            var winWidth = window.innerWidth;
            var winHeight = window.innerHeight;

            if (this.isFrameRotated) {
              this._gameFrame.style['-webkit-transform'] = 'rotate(90deg)';
              this._gameFrame.style.transform = 'rotate(90deg)';
              this._gameFrame.style['-webkit-transform-origin'] = '0px 0px 0px';
              this._gameFrame.style.transformOrigin = '0px 0px 0px';
              this._gameFrame.style.margin = "0 0 0 " + winWidth + "px";
              this._gameFrame.style.width = winHeight + "px";
              this._gameFrame.style.height = winWidth + "px";
            } else {
              this._gameFrame.style['-webkit-transform'] = 'rotate(0deg)';
              this._gameFrame.style.transform = 'rotate(0deg)';
              this._gameFrame.style.margin = '0px auto';
              this._gameFrame.style.width = winWidth + "px";
              this._gameFrame.style.height = winHeight + "px";
            }
          }

          this._updateContainer();
        };

        _proto._getFullscreenTarget = function _getFullscreenTarget() {
          var windowType = this._windowType;

          if (windowType === WindowType.Fullscreen) {
            return document[this._fn.fullscreenElement];
          }

          if (windowType === WindowType.SubFrame) {
            return this._gameFrame;
          }

          return document.body;
        };

        _proto._doRequestFullScreen = function _doRequestFullScreen() {
          var _this5 = this;

          return new Promise(function (resolve, reject) {
            if (!_this5._supportFullScreen) {
              reject(new Error('fullscreen is not supported'));
              return;
            }

            var fullscreenTarget = _this5._getFullscreenTarget();

            if (!fullscreenTarget) {
              reject(new Error('Cannot access fullscreen target'));
              return;
            }

            _this5._onFullscreenChange = undefined;
            _this5._onFullscreenError = undefined;

            var requestPromise = fullscreenTarget[_this5._fn.requestFullscreen]();

            if (window.Promise && requestPromise instanceof Promise) {
              requestPromise.then(resolve)["catch"](reject);
            } else {
              _this5._onFullscreenChange = resolve;
              _this5._onFullscreenError = reject;
            }
          });
        };

        _proto._updateFrameState = function _updateFrameState() {
          var orientation = this.orientation;
          var width = window.innerWidth;
          var height = window.innerHeight;
          var isBrowserLandscape = width > height;
          this.isFrameRotated = systemInfo.isMobile && (isBrowserLandscape && orientation === Orientation.PORTRAIT || !isBrowserLandscape && orientation === Orientation.LANDSCAPE);
        };

        _proto._updateContainer = function _updateContainer() {
          if (!this._gameContainer) {
            warnID(9201);
            return;
          }

          if (this.isProportionalToFrame) {
            if (!this._gameFrame) {
              warnID(9201);
              return;
            }

            var designedResolution = legacyCC.view.getDesignResolutionSize();
            var frame = this._gameFrame;
            var frameW = frame.clientWidth;
            var frameH = frame.clientHeight;
            var designW = designedResolution.width;
            var designH = designedResolution.height;
            var scaleX = frameW / designW;
            var scaleY = frameH / designH;
            var containerStyle = this._gameContainer.style;
            var containerW;
            var containerH;

            if (scaleX < scaleY) {
              containerW = frameW;
              containerH = designH * scaleX;
            } else {
              containerW = designW * scaleY;
              containerH = frameH;
            }

            containerStyle.width = containerW + "px";
            containerStyle.height = containerH + "px";
          } else {
            var _containerStyle = this._gameContainer.style;
            _containerStyle.width = '100%';
            _containerStyle.height = '100%';
          }

          if (this._gameFrame && (this._cachedFrameStyle.width !== this._gameFrame.style.width || this._cachedFrameStyle.height !== this._gameFrame.style.height || this._cachedContainerStyle.width !== this._gameContainer.style.width || this._cachedContainerStyle.height !== this._gameContainer.style.height)) {
            this.emit('window-resize');
            this._cachedFrameStyle.width = this._gameFrame.style.width;
            this._cachedFrameStyle.height = this._gameFrame.style.height;
            this._cachedContainerStyle.width = this._gameContainer.style.width;
            this._cachedContainerStyle.height = this._gameContainer.style.height;
          }
        };

        _createClass(ScreenAdapter, [{
          key: "supportFullScreen",
          get: function get() {
            return this._supportFullScreen;
          }
        }, {
          key: "isFullScreen",
          get: function get() {
            if (!this._supportFullScreen) {
              return false;
            }

            return !!document[this._fn.fullscreenElement];
          }
        }, {
          key: "devicePixelRatio",
          get: function get() {
            var _window$devicePixelRa;

            return Math.min((_window$devicePixelRa = window.devicePixelRatio) !== null && _window$devicePixelRa !== void 0 ? _window$devicePixelRa : 1, 2);
          }
        }, {
          key: "windowSize",
          get: function get() {
            var result = this._windowSizeInCssPixels;
            var dpr = this.devicePixelRatio;
            result.width *= dpr;
            result.height *= dpr;
            return result;
          },
          set: function set(size) {
            if (this._windowType !== WindowType.SubFrame) {
              warnID(9202);
              return;
            }

            this._resizeFrame(this._convertToSizeInCssPixels(size));
          }
        }, {
          key: "resolution",
          get: function get() {
            var windowSize = this.windowSize;
            var resolutionScale = this.resolutionScale;
            return new Size(windowSize.width * resolutionScale, windowSize.height * resolutionScale);
          }
        }, {
          key: "resolutionScale",
          get: function get() {
            return this._resolutionScale;
          },
          set: function set(v) {
            var _this$_cbToUpdateFram;

            if (v === this._resolutionScale) {
              return;
            }

            this._resolutionScale = v;
            (_this$_cbToUpdateFram = this._cbToUpdateFrameBuffer) === null || _this$_cbToUpdateFram === void 0 ? void 0 : _this$_cbToUpdateFram.call(this);
          }
        }, {
          key: "orientation",
          get: function get() {
            return this._orientation;
          },
          set: function set(value) {
            if (this._orientation === value) {
              return;
            }

            this._orientation = value;

            this._updateFrameState();
          }
        }, {
          key: "safeAreaEdge",
          get: function get() {
            return {
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            };
          }
        }, {
          key: "isProportionalToFrame",
          get: function get() {
            return this._isProportionalToFrame;
          },
          set: function set(v) {
            if (this._isProportionalToFrame === v) {
              return;
            }

            this._isProportionalToFrame = v;

            this._updateContainer();
          }
        }, {
          key: "_windowSizeInCssPixels",
          get: function get() {

            if (this.isProportionalToFrame) {
              if (!this._gameContainer) {
                warnID(9201);
                return new Size(0, 0);
              }

              return new Size(this._gameContainer.clientWidth, this._gameContainer.clientHeight);
            }

            var fullscreenTarget;
            var width;
            var height;

            switch (this._windowType) {
              case WindowType.SubFrame:
                if (!this._gameFrame) {
                  warnID(9201);
                  return new Size(0, 0);
                }

                return new Size(this._gameFrame.clientWidth, this._gameFrame.clientHeight);

              case WindowType.Fullscreen:
                fullscreenTarget = this._getFullscreenTarget();
                width = this.isFrameRotated ? fullscreenTarget.clientHeight : fullscreenTarget.clientWidth;
                height = this.isFrameRotated ? fullscreenTarget.clientWidth : fullscreenTarget.clientHeight;
                return new Size(width, height);

              case WindowType.BrowserWindow:
                width = this.isFrameRotated ? window.innerHeight : window.innerWidth;
                height = this.isFrameRotated ? window.innerWidth : window.innerHeight;
                return new Size(width, height);

              case WindowType.Unknown:
              default:
                return new Size(0, 0);
            }
          }
        }, {
          key: "_windowType",
          get: function get() {
            if (this.isFullScreen) {
              return WindowType.Fullscreen;
            }

            if (!this._gameFrame) {
              warnID(9201);
              return WindowType.Unknown;
            }

            if (this._exactFitScreen) {
              return WindowType.BrowserWindow;
            }

            return WindowType.SubFrame;
          }
        }]);

        return ScreenAdapter;
      }(EventTarget);

      var screenAdapter = new ScreenAdapter();

      var Screen = function () {
        function Screen() {}

        var _proto = Screen.prototype;

        _proto._init = function _init(options) {
          screenAdapter.init(options, function () {
            var _director$root;

            var director = legacyCC.director;

            if (!((_director$root = director.root) === null || _director$root === void 0 ? void 0 : _director$root.pipeline)) {
              warnID(1220);
              return;
            }

            director.root.pipeline.pipelineSceneData.shadingScale = screenAdapter.resolutionScale;
          });
        };

        _proto.fullScreen = function fullScreen() {
          return screenAdapter.isFullScreen;
        };

        _proto.requestFullScreen = function requestFullScreen(element, onFullScreenChange, onFullScreenError) {
          if (arguments.length > 0) {
            warnID(1400, 'screen.requestFullScreen(element, onFullScreenChange?, onFullScreenError?)', 'screen.requestFullScreen(): Promise');
          }

          return screenAdapter.requestFullScreen().then(function () {
            onFullScreenChange === null || onFullScreenChange === void 0 ? void 0 : onFullScreenChange();
          })["catch"](function (err) {
            console.error(err);
            onFullScreenError === null || onFullScreenError === void 0 ? void 0 : onFullScreenError();
          });
        };

        _proto.exitFullScreen = function exitFullScreen() {
          return screenAdapter.exitFullScreen();
        };

        _proto.autoFullScreen = function autoFullScreen(element, onFullScreenChange) {
          var _this$requestFullScre;

          (_this$requestFullScre = this.requestFullScreen(element, onFullScreenChange)) === null || _this$requestFullScre === void 0 ? void 0 : _this$requestFullScre["catch"](function (e) {});
        };

        _proto.disableAutoFullScreen = function disableAutoFullScreen(element) {};

        _createClass(Screen, [{
          key: "devicePixelRatio",
          get: function get() {
            return screenAdapter.devicePixelRatio;
          }
        }, {
          key: "windowSize",
          get: function get() {
            return screenAdapter.windowSize;
          },
          set: function set(size) {
            screenAdapter.windowSize = size;
          }
        }, {
          key: "resolution",
          get: function get() {
            return screenAdapter.resolution;
          }
        }, {
          key: "supportsFullScreen",
          get: function get() {
            return screenAdapter.supportFullScreen;
          }
        }]);

        return Screen;
      }();

      var screen = exports('screen', new Screen());
      legacyCC.screen = screen;

      var sys = exports('sys', {
        Feature: Feature$1,
        hasFeature: function hasFeature(feature) {
          return systemInfo.hasFeature(feature);
        },
        NetworkType: NetworkType,
        Language: Language,
        OS: OS,
        Platform: Platform,
        BrowserType: BrowserType,
        isNative: systemInfo.isNative,
        isBrowser: systemInfo.isBrowser,
        isMobile: systemInfo.isMobile,
        isLittleEndian: systemInfo.isLittleEndian,
        platform: systemInfo.platform,
        language: systemInfo.language,
        languageCode: systemInfo.nativeLanguage,
        os: systemInfo.os,
        osVersion: systemInfo.osVersion,
        osMainVersion: systemInfo.osMainVersion,
        browserType: systemInfo.browserType,
        browserVersion: systemInfo.browserVersion,
        windowPixelResolution: screen.windowSize,
        capabilities: {
          canvas: true,
          opengl: true,
          webp: systemInfo.hasFeature(Feature$1.WEBP),
          imageBitmap: systemInfo.hasFeature(Feature$1.IMAGE_BITMAP),
          touches: systemInfo.hasFeature(Feature$1.INPUT_TOUCH),
          mouse: systemInfo.hasFeature(Feature$1.EVENT_MOUSE),
          keyboard: systemInfo.hasFeature(Feature$1.EVENT_KEYBOARD),
          accelerometer: systemInfo.hasFeature(Feature$1.EVENT_ACCELEROMETER)
        },
        localStorage: {},
        getNetworkType: function getNetworkType() {
          return systemInfo.networkType;
        },
        getBatteryLevel: function getBatteryLevel() {
          return systemInfo.getBatteryLevel();
        },
        garbageCollect: function garbageCollect() {
          systemInfo.triggerGC();
        },
        isObjectValid: function isObjectValid(obj) {
          if (obj === null || obj === undefined) {
            return false;
          }

          return true;
        },
        dump: function dump() {
          var str = '';
          str += "isMobile : " + this.isMobile + "\r\n";
          str += "language : " + this.language + "\r\n";
          str += "browserType : " + this.browserType + "\r\n";
          str += "browserVersion : " + this.browserVersion + "\r\n";
          str += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
          str += "os : " + this.os + "\r\n";
          str += "osVersion : " + this.osVersion + "\r\n";
          str += "platform : " + this.platform + "\r\n";
          str += "Using " + (legacyCC.game.renderType === legacyCC.game.RENDER_TYPE_WEBGL ? 'WEBGL' : 'CANVAS') + " renderer.\r\n";
          log(str);
        },
        openURL: function openURL(url) {
          systemInfo.openURL(url);
        },
        now: function now() {
          return systemInfo.now();
        },
        restartVM: function restartVM() {
          systemInfo.restartJSVM();
        },
        getSafeAreaRect: function getSafeAreaRect() {
          var locView = legacyCC.view;
          var edge = screenAdapter.safeAreaEdge;
          var windowSize = screenAdapter.windowSize;
          var leftBottom = new Vec2(edge.left, edge.bottom);
          var rightTop = new Vec2(windowSize.width - edge.right, windowSize.height - edge.top);

          locView._convertToUISpace(leftBottom);

          locView._convertToUISpace(rightTop);

          var x = leftBottom.x;
          var y = leftBottom.y;
          var width = rightTop.x - leftBottom.x;
          var height = rightTop.y - leftBottom.y;
          return new Rect(x, y, width, height);
        }
      });

      (function initSys() {
        try {
          var localStorage = sys.localStorage = window.localStorage;
          localStorage.setItem('storage', '');
          localStorage.removeItem('storage');
          localStorage = null;
        } catch (e) {
          var warn = function warn() {
            warnID(5200);
          };

          sys.localStorage = {
            getItem: warn,
            setItem: warn,
            clear: warn,
            removeItem: warn
          };
        }

        {
          sys.__isWebIOS14OrIPadOS14Env = (sys.os === OS.IOS || sys.os === OS.OSX) && systemInfo.isBrowser && /(OS 14)|(Version\/14)/.test(window.navigator.userAgent);
        }
      })();

      legacyCC.sys = sys;

      var serializeTag = exports('serializeTag', Symbol('[[Serialize]]'));
      var deserializeTag = exports('deserializeTag', Symbol('[[Deserialize]]'));

      var VERSION = 1;
      var MAGIC = 0x4E4F4343;
      var CHUNK_ALIGN_AS = 8;
      var CCON = function () {
        function CCON(document, chunks) {
          this._document = void 0;
          this._chunks = void 0;
          this._document = document;
          this._chunks = chunks;
        }

        _createClass(CCON, [{
          key: "document",
          get: function get() {
            return this._document;
          }
        }, {
          key: "chunks",
          get: function get() {
            return this._chunks;
          }
        }]);

        return CCON;
      }();
      function parseCCONJson(json) {
        var cconPreface = json;
        return {
          chunks: cconPreface.chunks,
          document: cconPreface.document
        };
      }
      function decodeCCONBinary(bytes) {
        if (bytes.length < 16) {
          throw new InvalidCCONError(getError(13102));
        }

        var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var magic = dataView.getUint32(0, true);

        if (magic !== MAGIC) {
          throw new InvalidCCONError(getError(13100));
        }

        var version = dataView.getUint32(4, true);

        if (version !== VERSION) {
          throw new InvalidCCONError(getError(13101, version));
        }

        var dataByteLength = dataView.getUint32(8, true);

        if (dataByteLength !== dataView.byteLength) {
          throw new InvalidCCONError(getError(13102));
        }

        var chunksStart = 12;
        var jsonDataLength = dataView.getUint32(chunksStart, true);
        chunksStart += 4;
        var jsonData = new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, jsonDataLength);
        chunksStart += jsonDataLength;
        var jsonString = decodeJson(jsonData);
        var json;

        try {
          json = JSON.parse(jsonString);
        } catch (err) {
          throw new InvalidCCONError(err);
        }

        var chunks = [];

        while (chunksStart < dataView.byteLength) {
          if (chunksStart % CHUNK_ALIGN_AS !== 0) {
            var padding = CHUNK_ALIGN_AS - chunksStart % CHUNK_ALIGN_AS;
            chunksStart += padding;
          }

          var chunkDataLength = dataView.getUint32(chunksStart, true);
          chunksStart += 4;
          chunks.push(new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, chunkDataLength));
          chunksStart += chunkDataLength;
        }

        if (chunksStart !== dataView.byteLength) {
          throw new InvalidCCONError(getError(13102));
        }

        return new CCON(json, chunks);
      }

      function decodeJson(data) {
        if (typeof TextDecoder !== 'undefined') {
          return new TextDecoder().decode(data);
        } else if ('Buffer' in globalThis) {
          var _ref2 = globalThis,
              _Buffer2 = _ref2.Buffer;
          return _Buffer2.from(data.buffer, data.byteOffset, data.byteLength).toString();
        } else {
          throw new Error(getError(13104));
        }
      }

      var InvalidCCONError = function (_Error) {
        _inheritsLoose(InvalidCCONError, _Error);

        function InvalidCCONError() {
          return _Error.apply(this, arguments) || this;
        }

        return InvalidCCONError;
      }(_wrapNativeSuper(Error));
      var BufferBuilder = function () {
        function BufferBuilder() {
          this._viewOrPaddings = [];
          this._length = 0;
        }

        var _proto = BufferBuilder.prototype;

        _proto.alignAs = function alignAs(align) {
          if (align !== 0) {
            var remainder = this._length % align;

            if (remainder !== 0) {
              var padding = align - remainder;

              this._viewOrPaddings.push(padding);

              this._length += padding;
              return padding;
            }
          }

          return 0;
        };

        _proto.append = function append(view) {
          var result = this._length;

          this._viewOrPaddings.push(view);

          this._length += view.byteLength;
          return result;
        };

        _proto.get = function get() {
          var result = new Uint8Array(this._length);
          var counter = 0;

          this._viewOrPaddings.forEach(function (viewOrPadding) {
            if (typeof viewOrPadding === 'number') {
              counter += viewOrPadding;
            } else {
              result.set(new Uint8Array(viewOrPadding.buffer, viewOrPadding.byteOffset, viewOrPadding.byteLength), counter);
              counter += viewOrPadding.byteLength;
            }
          });

          return result;
        };

        _createClass(BufferBuilder, [{
          key: "byteLength",
          get: function get() {
            return this._length;
          }
        }]);

        return BufferBuilder;
      }();
      legacyCC.internal.parseCCONJson = parseCCONJson;
      legacyCC.internal.decodeCCONBinary = decodeCCONBinary;
      legacyCC.internal.CCON = CCON;

      function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue) {
        if (defaultValue instanceof legacyCC.ValueType) {
          if (!assumeHavePropIfIsValue) {
            sources.push('if(prop){');
          }

          var ctorCode = getClassName(defaultValue);
          sources.push("s._deserializeFastDefinedObject(o" + accessorToSet + ",prop," + ctorCode + ");");

          if (!assumeHavePropIfIsValue) {
            sources.push("}else o" + accessorToSet + "=null;");
          }
        } else {
          sources.push("\nif (prop) {\n    s._deserializeAndAssignField(o, prop, " + propNameLiteralToSet + ");\n} else {\n    o" + accessorToSet + "=null;\n}\n");
        }
      }

      var compileDeserialize =  compileDeserializeJIT ;
      var DELIMITER = DELIMETER;
      var POSTFIX_TYPE = DELIMITER + "type";
      var POSTFIX_DEFAULT = DELIMITER + "default";
      var POSTFIX_FORMERLY_SERIALIZED_AS = DELIMITER + "formerlySerializedAs";

      function compileDeserializeJIT(self, klass) {
        var attrs = getClassAttrs(klass);
        var props = klass.__values__;
        var sources = ['var prop;'];
        var fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass));

        for (var p = 0; p < props.length; p++) {
          var propName = props[p];

          var accessorToSet = void 0;
          var propNameLiteralToSet = void 0;

          if (CCClass.IDENTIFIER_RE.test(propName)) {
            propNameLiteralToSet = "\"" + propName + "\"";
            accessorToSet = "." + propName;
          } else {
            propNameLiteralToSet = CCClass.escapeForJS(propName);
            accessorToSet = "[" + propNameLiteralToSet + "]";
          }

          var accessorToGet = accessorToSet;

          if (attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS]) {
            var propNameToRead = attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS];

            if (CCClass.IDENTIFIER_RE.test(propNameToRead)) {
              accessorToGet = "." + propNameToRead;
            } else {
              accessorToGet = "[" + CCClass.escapeForJS(propNameToRead) + "]";
            }
          }

          sources.push("prop=d" + accessorToGet + ";");
          sources.push("if(typeof " + ( 'prop') + "!==\"undefined\"){");
          var defaultValue = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);

          if (fastMode) {
            var isPrimitiveType = void 0;
            var userType = attrs[propName + POSTFIX_TYPE];

            if (defaultValue === undefined && userType) {
              isPrimitiveType = userType instanceof PrimitiveType;
            } else {
              var defaultType = typeof defaultValue;
              isPrimitiveType = defaultType === 'string' || defaultType === 'number' || defaultType === 'boolean';
            }

            if (isPrimitiveType) {
              sources.push("o" + accessorToSet + "=prop;");
            } else {
              compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true);
            }
          } else {
            sources.push("" + ("if(typeof " + ( 'prop') + "!==\"object\"){" + 'o') + accessorToSet + "=prop;" + "}else{");
            compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false);
            sources.push('}');
          }

          sources.push('}');
        }

        if (legacyCC.js.isChildClassOf(klass, legacyCC._BaseNode) || legacyCC.js.isChildClassOf(klass, legacyCC.Component)) {
          {
            sources.push('d._id&&(o._id=d._id);');
          }
        }

        if (props[props.length - 1] === '_$erialized') {
          sources.push('o._$erialized=JSON.parse(JSON.stringify(d));');
          sources.push('s._fillPlainObject(o._$erialized,d);');
        }

        return Function('s', 'o', 'd', 'k', sources.join(''));
      }

      var DeserializerPool = function (_js$Pool) {
        _inheritsLoose(DeserializerPool, _js$Pool);

        function DeserializerPool() {
          return _js$Pool.call(this, function (deserializer) {
            deserializer.clear();
          }, 1) || this;
        }

        var _proto = DeserializerPool.prototype;

        _proto.get = function get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
          var cache = this._get();

          if (cache) {
            cache.reset(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
            return cache;
          } else {
            return new _Deserializer(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
          }
        };

        return DeserializerPool;
      }(Pool);

      var _Deserializer = function () {
        function _Deserializer(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
          this.deserializedList = void 0;
          this.deserializedData = void 0;
          this._ignoreEditorOnly = void 0;
          this.result = result;
          this.customEnv = customEnv;
          this.deserializedList = [];
          this.deserializedData = null;
          this._classFinder = classFinder;
          this._reportMissingClass = reportMissingClass;
          this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
        }

        var _proto2 = _Deserializer.prototype;

        _proto2.reset = function reset(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
          this.result = result;
          this.customEnv = customEnv;
          this._classFinder = classFinder;
          this._reportMissingClass = reportMissingClass;
          this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
        };

        _proto2.clear = function clear() {
          this.result = null;
          this.customEnv = null;
          this.deserializedList.length = 0;
          this.deserializedData = null;
          this._classFinder = null;
          this._reportMissingClass = null;
          this._onDereferenced = null;
        };

        _proto2.deserialize = function deserialize(serializedData) {
          var fromCCON = false;
          var jsonObj;

          if (serializedData instanceof CCON) {
            fromCCON = true;
            jsonObj = serializedData.document;

            if (serializedData.chunks.length > 0) {
              assertIsTrue(serializedData.chunks.length === 1);
              this._mainBinChunk = serializedData.chunks[0];
            }
          } else {
            jsonObj = serializedData;
          }

          this._serializedData = jsonObj;
          this._context = {
            fromCCON: fromCCON
          };
          var serializedRootObject = Array.isArray(jsonObj) ? jsonObj[0] : jsonObj;

          {
            this.deserializedData = this._deserializeObject(serializedRootObject, 0);
          }

          this._serializedData = undefined;
          this._mainBinChunk = undefined;
          this._context = undefined;
          return this.deserializedData;
        };

        _proto2._deserializeObject = function _deserializeObject(serialized, globalIndex, owner, propName) {
          switch (serialized.__type__) {
            case 'TypedArray':
              return this._deserializeTypedArrayView(serialized);

            case 'TypedArrayRef':
              return this._deserializeTypedArrayViewRef(serialized);

            default:
              if (serialized.__type__) {
                return this._deserializeTypeTaggedObject(serialized, globalIndex, owner, propName);
              } else if (!Array.isArray(serialized)) {
                return this._deserializePlainObject(serialized);
              } else {
                return this._deserializeArray(serialized);
              }

          }
        };

        _proto2._deserializeTypedArrayView = function _deserializeTypedArrayView(value) {
          return globalThis[value.ctor].from(value.array);
        };

        _proto2._deserializeTypedArrayViewRef = function _deserializeTypedArrayViewRef(value) {
          var offset = value.offset,
              length = value.length,
              constructorName = value.ctor;
          var obj = new globalThis[constructorName](this._mainBinChunk.buffer, this._mainBinChunk.byteOffset + offset, length);
          return obj;
        };

        _proto2._deserializeArray = function _deserializeArray(value) {
          var obj = new Array(value.length);
          var prop;

          for (var i = 0; i < value.length; i++) {
            prop = value[i];

            if (typeof prop === 'object' && prop) {
              var isAssetType = this._deserializeAndAssignField(obj, prop, "" + i);

              if (isAssetType) {
                obj[i] = null;
              }
            } else {
              obj[i] = prop;
            }
          }

          return obj;
        };

        _proto2._deserializePlainObject = function _deserializePlainObject(value) {
          var obj = {};

          this._fillPlainObject(obj, value);

          return obj;
        };

        _proto2._deserializeTypeTaggedObject = function _deserializeTypeTaggedObject(value, globalIndex, owner, propName) {
          var _this = this;

          var type = value.__type__;

          var klass = this._classFinder(type, value, owner, propName);

          if (!klass) {
            var notReported = this._classFinder === _getClassById;

            if (notReported) {
              this._reportMissingClass(type);
            }

            return null;
          }

          var createObject = function createObject(constructor) {
            var obj = new constructor();

            if (globalIndex >= 0) {
              _this.deserializedList[globalIndex] = obj;
            }

            return obj;
          };

          {
            var obj = createObject(klass);

            this._deserializeInto(value, obj, klass);

            return obj;
          }
        };

        _proto2._deserializeInto = function _deserializeInto(value, object, constructor, skipCustomized) {
          if (skipCustomized === void 0) {
            skipCustomized = false;
          }

          if (!skipCustomized && object[deserializeTag]) {
            this._runCustomizedDeserialize(value, object, constructor);

            return;
          }

          if (object._deserialize) {
            object._deserialize(value.content, this);

            return;
          }

          if (legacyCC.Class._isCCClass(constructor)) {
            this._deserializeFireClass(object, value, constructor);
          } else {
            this._deserializeFastDefinedObject(object, value, constructor);
          }
        };

        _proto2._runCustomizedDeserialize = function _runCustomizedDeserialize(value, object, constructor) {
          var _this2 = this;

          var serializationInput = {
            readProperty: function readProperty(name) {
              var serializedField = value[name];

              if (typeof serializedField !== 'object' || !serializedField) {
                return serializedField;
              } else {
                return _this2._deserializeObjectField(serializedField);
              }
            },
            readThis: function readThis() {
              _this2._deserializeInto(value, object, constructor, true);
            },
            readSuper: function readSuper() {
              var superConstructor = getSuper(constructor);

              if (superConstructor) {
                _this2._deserializeInto(value, object, superConstructor);
              }
            }
          };
          object[deserializeTag](serializationInput, this._context);
        };

        _proto2._deserializeFireClass = function _deserializeFireClass(obj, serialized, klass) {
          var deserialize;

          if (klass.hasOwnProperty('__deserialize__')) {
            deserialize = klass.__deserialize__;
          } else {
            deserialize = compileDeserialize(this, klass);

            try {
              if (klass === MissingScript) {
                var props = klass.__values__;

                if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
                  error("The '_$erialized' prop of MissingScript is missing. Will force the raw data to be save.");
                  error("    Error props: ['" + props + "']. Please contact jare.");
                }

                var rawDeserialize = deserialize;

                deserialize = function deserialize(deserializer, object, deserialized, constructor) {
                  rawDeserialize(deserializer, object, deserialized, constructor);

                  if (!object._$erialized) {
                    error("Unable to stash previously serialized data. " + JSON.stringify(deserialized));
                  }
                };
              }
            } catch (e) {
              error("Error when checking MissingScript 6, " + e);
            }

            value(klass, '__deserialize__', deserialize, true);
          }

          deserialize(this, obj, serialized, klass);
        };

        _proto2._deserializeAndAssignField = function _deserializeAndAssignField(obj, serializedField, propName) {
          var id = serializedField.__id__;

          if (typeof id === 'number') {
            var field = this.deserializedList[id];

            if (field) {
              obj[propName] = field;
            } else {
              var _this$_onDereferenced;

              var source = this._serializedData[id];

              {
                obj[propName] = this._deserializeObject(source, id, undefined, propName);
              }

              (_this$_onDereferenced = this._onDereferenced) === null || _this$_onDereferenced === void 0 ? void 0 : _this$_onDereferenced.call(this, this.deserializedList, id, obj, propName);
            }
          } else {
            var uuid = serializedField.__uuid__;

            if (uuid) {
              var expectedType = serializedField.__expectedType__;
              this.result.push(obj, propName, uuid, expectedType);
            } else {
              obj[propName] = this._deserializeObject(serializedField, -1);
            }
          }

          return false;
        };

        _proto2._deserializeObjectField = function _deserializeObjectField(serializedField) {
          var id = serializedField.__id__;

          if (typeof id === 'number') {
            var field = this.deserializedList[id];

            if (field) {
              return field;
            } else {
              var source = this._serializedData[id];

              var _field = this._deserializeObject(source, id, undefined, undefined);

              return _field;
            }
          } else {
            var uuid = serializedField.__uuid__;

            if (uuid) {
              var _expectedType = serializedField.__expectedType__;
              throw new Error("Asset reference field serialization is currently not supported in custom serialization.");
            } else {
              return this._deserializeObject(serializedField, -1);
            }
          }
        };

        _proto2._fillPlainObject = function _fillPlainObject(instance, serialized) {
          for (var propName in serialized) {
            if (!serialized.hasOwnProperty(propName)) {
              continue;
            }

            var prop = serialized[propName];

            if (typeof prop !== 'object') {
              if (propName !== '__type__') {
                  instance[propName] = prop;
                }
            } else if (prop) {
              var isAssetType = this._deserializeAndAssignField(instance, prop, propName);

              if (isAssetType) {
                instance[propName] = null;
              }
            } else {
              instance[propName] = null;
            }
          }
        };

        _proto2._deserializeFastDefinedObject = function _deserializeFastDefinedObject(instance, serialized, klass) {
          if (klass === legacyCC.Vec2) {
            instance.x = serialized.x || 0;
            instance.y = serialized.y || 0;
            return;
          } else if (klass === legacyCC.Vec3) {
            instance.x = serialized.x || 0;
            instance.y = serialized.y || 0;
            instance.z = serialized.z || 0;
            return;
          } else if (klass === legacyCC.Color) {
            instance.r = serialized.r || 0;
            instance.g = serialized.g || 0;
            instance.b = serialized.b || 0;
            var a = serialized.a;
            instance.a = a === undefined ? 255 : a;
            return;
          } else if (klass === legacyCC.Size) {
            instance.width = serialized.width || 0;
            instance.height = serialized.height || 0;
            return;
          }

          var attrs = getClassAttrs(klass);
          var props = klass.__values__;

          if ( !props) {
            error("Unable to deserialize " + getClassName(klass) + ". " + 'For non-CCClass types, they can only be marked as serializable by `CCClass.fastDefine`.');
          }

          for (var i = 0; i < props.length; i++) {
            var propName = props[i];
            var value = serialized[propName];
            var exists = value !== undefined || serialized.hasOwnProperty(propName);

            if (!exists) {
              value = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
            }

            if (typeof value !== 'object') {
              instance[propName] = value;
            } else if (value) {
              this._deserializeAndAssignField(instance, value, propName);
            } else {
              instance[propName] = null;
            }
          }
        };

        return _Deserializer;
      }();

      _Deserializer.pool = new DeserializerPool();
      function deserializeDynamic(data, details, options) {
        var _options$reportMissin;

        options = options || {};
        var classFinder = options.classFinder || _getClassById;
        var createAssetRefs = options.createAssetRefs || sys.platform === Platform.EDITOR_CORE;
        var customEnv = options.customEnv;
        var ignoreEditorOnly = options.ignoreEditorOnly;
        var reportMissingClass = (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : legacyCC.deserialize.reportMissingClass;
        details.init();

        var deserializer = _Deserializer.pool.get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);

        legacyCC.game._isCloning = true;
        var res = deserializer.deserialize(data);
        legacyCC.game._isCloning = false;

        _Deserializer.pool.put(deserializer);

        if (createAssetRefs) {
          details.assignAssetsBy(EditorExtends.serialize.asAsset);
        }

        return res;
      }

      function reportMissingClass(id) {
        {
          errorID(5302, id);
        }
      }

      var SUPPORT_MIN_FORMAT_VERSION = 1;
      var EMPTY_PLACEHOLDER = 0;
      var BuiltinValueTypes = [Vec2, Vec3, Vec4, Quat, Color, Size, Rect, Mat4];

      function BuiltinValueTypeParsers_xyzw(obj, data) {
        obj.x = data[1];
        obj.y = data[2];
        obj.z = data[3];
        obj.w = data[4];
      }

      var BuiltinValueTypeSetters = [function (obj, data) {
        obj.x = data[1];
        obj.y = data[2];
      }, function (obj, data) {
        obj.x = data[1];
        obj.y = data[2];
        obj.z = data[3];
      }, BuiltinValueTypeParsers_xyzw, BuiltinValueTypeParsers_xyzw, function (obj, data) {
        obj._val = data[1];
      }, function (obj, data) {
        obj.width = data[1];
        obj.height = data[2];
      }, function (obj, data) {
        obj.x = data[1];
        obj.y = data[2];
        obj.width = data[3];
        obj.height = data[4];
      }, function (obj, data) {
        Mat4.fromArray(obj, data, 1);
      }];

      var DataTypeID = {
        SimpleType: 0,
        InstanceRef: 1,
        Array_InstanceRef: 2,
        Array_AssetRefByInnerObj: 3,
        Class: 4,
        ValueTypeCreated: 5,
        AssetRefByInnerObj: 6,
        TRS: 7,
        ValueType: 8,
        Array_Class: 9,
        CustomizedClass: 10,
        Dict: 11,
        Array: 12,
        ARRAY_LENGTH: 13
      };
      var CLASS_TYPE = 0;
      var CLASS_KEYS = 1;
      var CLASS_PROP_TYPE_OFFSET = 2;
      var MASK_CLASS = 0;
      var OBJ_DATA_MASK = 0;
      var CUSTOM_OBJ_DATA_CLASS = 0;
      var CUSTOM_OBJ_DATA_CONTENT = 1;
      var VALUETYPE_SETTER = 0;
      var DICT_JSON_LAYOUT = 0;
      var ARRAY_ITEM_VALUES = 0;
      var Refs = {
        EACH_RECORD_LENGTH: 3,
        OWNER_OFFSET: 0,
        KEY_OFFSET: 1,
        TARGET_OFFSET: 2
      };
      var File = {
        Version: 0,
        Context: 0,
        SharedUuids: 1,
        SharedStrings: 2,
        SharedClasses: 3,
        SharedMasks: 4,
        Instances: 5,
        InstanceTypes: 6,
        Refs: 7,
        DependObjs: 8,
        DependKeys: 9,
        DependUuidIndices: 10,
        ARRAY_LENGTH: 11
      };
      var PACKED_SECTIONS = File.Instances;
      var Details = exports('Details', function () {
        function Details() {
          this.uuidObjList = null;
          this.uuidPropList = null;
          this.uuidList = null;
          this.uuidTypeList = [];
        }

        var _proto = Details.prototype;

        _proto.init = function init(data) {
          if ( data) {
            this.uuidObjList = data[File.DependObjs];
            this.uuidPropList = data[File.DependKeys];
            this.uuidList = data[File.DependUuidIndices];
          } else {
            var used = this.uuidList;

            if (!used) {
              this.uuidList = [];
              this.uuidObjList = [];
              this.uuidPropList = [];
              this.uuidTypeList = [];
            }
          }
        };

        _proto.reset = function reset() {
          {
            var used = this.uuidList;

            if (used) {
              this.uuidList.length = 0;
              this.uuidObjList.length = 0;
              this.uuidPropList.length = 0;
              this.uuidTypeList.length = 0;
            }
          }
        };

        _proto.push = function push(obj, propName, uuid, type) {
          this.uuidObjList.push(obj);
          this.uuidPropList.push(propName);
          this.uuidList.push(uuid);
          this.uuidTypeList.push(type || '');
        };

        return Details;
      }());
      Details.pool = new Pool(function (obj) {
        obj.reset();
      }, 5);

      Details.pool.get = function () {
        return this._get() || new Details();
      };

      function dereference(refs, instances, strings) {
        var dataLength = refs.length - 1;
        var i = 0;
        var instanceOffset = refs[dataLength] * Refs.EACH_RECORD_LENGTH;

        for (; i < instanceOffset; i += Refs.EACH_RECORD_LENGTH) {
          var _owner = refs[i];
          var target = instances[refs[i + Refs.TARGET_OFFSET]];
          var keyIndex = refs[i + Refs.KEY_OFFSET];

          if (keyIndex >= 0) {
            _owner[strings[keyIndex]] = target;
          } else {
            _owner[~keyIndex] = target;
          }
        }

        for (; i < dataLength; i += Refs.EACH_RECORD_LENGTH) {
          var _owner2 = instances[refs[i]];
          var _target = instances[refs[i + Refs.TARGET_OFFSET]];
          var _keyIndex = refs[i + Refs.KEY_OFFSET];

          if (_keyIndex >= 0) {
            _owner2[strings[_keyIndex]] = _target;
          } else {
            _owner2[~_keyIndex] = _target;
          }
        }
      }

      function deserializeCCObject(data, objectData) {
        var mask = data[File.SharedMasks][objectData[OBJ_DATA_MASK]];
        var clazz = mask[MASK_CLASS];
        var ctor = clazz[CLASS_TYPE];
        var obj = new ctor();
        var keys = clazz[CLASS_KEYS];
        var classTypeOffset = clazz[CLASS_PROP_TYPE_OFFSET];
        var maskTypeOffset = mask[mask.length - 1];
        var i = MASK_CLASS + 1;

        for (; i < maskTypeOffset; ++i) {
          var _key = keys[mask[i]];
          obj[_key] = objectData[i];
        }

        for (; i < objectData.length; ++i) {
          var _key2 = keys[mask[i]];
          var _type2 = clazz[mask[i] + classTypeOffset];
          var op = ASSIGNMENTS[_type2];
          op(data, obj, _key2, objectData[i]);
        }

        return obj;
      }

      function deserializeCustomCCObject(data, ctor, value) {
        var obj = new ctor();

        if (obj._deserialize) {
          obj._deserialize(value, data[File.Context]);
        } else {
          errorID(5303, getClassName(ctor));
        }

        return obj;
      }

      function assignSimple(data, owner, key, value) {
        owner[key] = value;
      }

      function assignInstanceRef(data, owner, key, value) {
        if (value >= 0) {
          owner[key] = data[File.Instances][value];
        } else {
          data[File.Refs][~value * Refs.EACH_RECORD_LENGTH] = owner;
        }
      }

      function genArrayParser(parser) {
        return function (data, owner, key, value) {
          owner[key] = value;

          for (var i = 0; i < value.length; ++i) {
            parser(data, value, i, value[i]);
          }
        };
      }

      function parseAssetRefByInnerObj(data, owner, key, value) {
        owner[key] = null;
        data[File.DependObjs][value] = owner;
      }

      function parseClass(data, owner, key, value) {
        owner[key] = deserializeCCObject(data, value);
      }

      function parseCustomClass(data, owner, key, value) {
        var ctor = data[File.SharedClasses][value[CUSTOM_OBJ_DATA_CLASS]];
        owner[key] = deserializeCustomCCObject(data, ctor, value[CUSTOM_OBJ_DATA_CONTENT]);
      }

      function parseValueTypeCreated(data, owner, key, value) {
        BuiltinValueTypeSetters[value[VALUETYPE_SETTER]](owner[key], value);
      }

      function parseValueType(data, owner, key, value) {
        var val = new BuiltinValueTypes[value[VALUETYPE_SETTER]]();
        BuiltinValueTypeSetters[value[VALUETYPE_SETTER]](val, value);
        owner[key] = val;
      }

      function parseTRS(data, owner, key, value) {
        var typedArray = owner[key];
        typedArray.set(value);
      }

      function parseDict(data, owner, key, value) {
        var dict = value[DICT_JSON_LAYOUT];
        owner[key] = dict;

        for (var i = DICT_JSON_LAYOUT + 1; i < value.length; i += 3) {
          var subKey = value[i];
          var subType = value[i + 1];
          var subValue = value[i + 2];
          var op = ASSIGNMENTS[subType];
          op(data, dict, subKey, subValue);
        }
      }

      function parseArray(data, owner, key, value) {
        var array = value[ARRAY_ITEM_VALUES];
        owner[key] = array;

        for (var i = 0; i < array.length; ++i) {
          var subValue = array[i];
          var _type3 = value[i + 1];

          if (_type3 !== DataTypeID.SimpleType) {
            var op = ASSIGNMENTS[_type3];
            op(data, array, i, subValue);
          }
        }
      }

      var ASSIGNMENTS = new Array(DataTypeID.ARRAY_LENGTH);
      ASSIGNMENTS[DataTypeID.SimpleType] = assignSimple;
      ASSIGNMENTS[DataTypeID.InstanceRef] = assignInstanceRef;
      ASSIGNMENTS[DataTypeID.Array_InstanceRef] = genArrayParser(assignInstanceRef);
      ASSIGNMENTS[DataTypeID.Array_AssetRefByInnerObj] = genArrayParser(parseAssetRefByInnerObj);
      ASSIGNMENTS[DataTypeID.Class] = parseClass;
      ASSIGNMENTS[DataTypeID.ValueTypeCreated] = parseValueTypeCreated;
      ASSIGNMENTS[DataTypeID.AssetRefByInnerObj] = parseAssetRefByInnerObj;
      ASSIGNMENTS[DataTypeID.TRS] = parseTRS;
      ASSIGNMENTS[DataTypeID.ValueType] = parseValueType;
      ASSIGNMENTS[DataTypeID.Array_Class] = genArrayParser(parseClass);
      ASSIGNMENTS[DataTypeID.CustomizedClass] = parseCustomClass;
      ASSIGNMENTS[DataTypeID.Dict] = parseDict;
      ASSIGNMENTS[DataTypeID.Array] = parseArray;

      function parseInstances(data) {
        var instances = data[File.Instances];
        var instanceTypes = data[File.InstanceTypes];
        var instanceTypesLen = instanceTypes === EMPTY_PLACEHOLDER ? 0 : instanceTypes.length;
        var rootIndex = instances[instances.length - 1];
        var normalObjectCount = instances.length - instanceTypesLen;

        if (typeof rootIndex !== 'number') {
          rootIndex = 0;
        } else {
          if (rootIndex < 0) {
            rootIndex = ~rootIndex;
          }

          --normalObjectCount;
        }

        var insIndex = 0;

        for (; insIndex < normalObjectCount; ++insIndex) {
          instances[insIndex] = deserializeCCObject(data, instances[insIndex]);
        }

        var classes = data[File.SharedClasses];

        for (var typeIndex = 0; typeIndex < instanceTypesLen; ++typeIndex, ++insIndex) {
          var _type4 = instanceTypes[typeIndex];
          var eachData = instances[insIndex];

          if (_type4 >= 0) {
            var ctor = classes[_type4];
            instances[insIndex] = deserializeCustomCCObject(data, ctor, eachData);
          } else {
            _type4 = ~_type4;
            var op = ASSIGNMENTS[_type4];
            op(data, instances, insIndex, eachData);
          }
        }

        return rootIndex;
      }

      function getMissingClass(hasCustomFinder, type, reportMissingClass) {
        if (!hasCustomFinder) {
          reportMissingClass(type);
        }

        return Object;
      }

      function doLookupClass(classFinder, type, container, index, silent, hasCustomFinder, reportMissingClass) {
        var klass = classFinder(type);

        if (!klass) {
          if (silent) {
            container[index] = function (c, i, t) {
              return function proxy() {
                var actualClass = classFinder(t) || getMissingClass(hasCustomFinder, t, reportMissingClass);
                c[i] = actualClass;
                return new actualClass();
              };
            }(container, index, type);

            return;
          } else {
            klass = getMissingClass(hasCustomFinder, type, reportMissingClass);
          }
        }

        container[index] = klass;
      }

      function lookupClasses(data, silent, customFinder, reportMissingClass) {
        var classFinder = customFinder || _getClassById;
        var classes = data[File.SharedClasses];

        for (var i = 0; i < classes.length; ++i) {
          var klassLayout = classes[i];

          if (typeof klassLayout !== 'string') {
            {
              if (typeof klassLayout[CLASS_TYPE] === 'function') {
                throw new Error('Can not deserialize the same JSON data again.');
              }
            }

            var _type5 = klassLayout[CLASS_TYPE];
            doLookupClass(classFinder, _type5, klassLayout, CLASS_TYPE, silent, customFinder, reportMissingClass);
          } else {
            doLookupClass(classFinder, klassLayout, classes, i, silent, customFinder, reportMissingClass);
          }
        }
      }

      function cacheMasks(data) {
        var masks = data[File.SharedMasks];

        if (masks) {
          var classes = data[File.SharedClasses];

          for (var i = 0; i < masks.length; ++i) {
            var mask = masks[i];
            mask[MASK_CLASS] = classes[mask[MASK_CLASS]];
          }
        }
      }

      function parseResult(data) {
        var instances = data[File.Instances];
        var sharedStrings = data[File.SharedStrings];
        var dependSharedUuids = data[File.SharedUuids];
        var dependObjs = data[File.DependObjs];
        var dependKeys = data[File.DependKeys];
        var dependUuids = data[File.DependUuidIndices];

        for (var i = 0; i < dependObjs.length; ++i) {
          var _obj2 = dependObjs[i];

          if (typeof _obj2 === 'number') {
            dependObjs[i] = instances[_obj2];
          }

          var _key3 = dependKeys[i];

          if (typeof _key3 === 'number') {
            if (_key3 >= 0) {
              _key3 = sharedStrings[_key3];
            } else {
              _key3 = ~_key3;
            }

            dependKeys[i] = _key3;
          }

          var _uuid2 = dependUuids[i];

          if (typeof _uuid2 === 'number') {
            dependUuids[i] = dependSharedUuids[_uuid2];
          }
        }
      }

      function isCompiledJson(json) {
        if (Array.isArray(json)) {
          var version = json[0];
          return typeof version === 'number' || version instanceof FileInfo;
        } else {
          return false;
        }
      }
      function deserialize(data, details, options) {
        if (typeof data === 'string') {
          data = JSON.parse(data);
        }

        var borrowDetails = !details;
        details = details || Details.pool.get();
        var res;

        if ( !isCompiledJson(data)) {
          res = deserializeDynamic(data, details, options);
        } else {
          details.init(data);
          options = options || {};
          var version = data[File.Version];
          var preprocessed = false;

          if (typeof version === 'object') {
            preprocessed = version.preprocessed;
            version = version.version;
          }

          if (version < SUPPORT_MIN_FORMAT_VERSION) {
            throw new Error(getError(5304, version));
          }

          options._version = version;
          options.result = details;
          data[File.Context] = options;

          if (!preprocessed) {
            var _options$reportMissin;

            lookupClasses(data, false, options.classFinder, (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : deserialize.reportMissingClass);
            cacheMasks(data);
          }

          legacyCC.game._isCloning = true;
          var instances = data[File.Instances];
          var rootIndex = parseInstances(data);
          legacyCC.game._isCloning = false;

          if (data[File.Refs]) {
            dereference(data[File.Refs], instances, data[File.SharedStrings]);
          }

          parseResult(data);
          res = instances[rootIndex];
        }

        if (borrowDetails) {
          Details.pool.put(details);
        }

        return res;
      }
      deserialize.Details = Details;
      deserialize.reportMissingClass = reportMissingClass;

      var FileInfo = function FileInfo(version) {
        this.preprocessed = true;
        this.version = version;
      };

      function unpackJSONs(data, classFinder, reportMissingClass) {
        if (data[File.Version] < SUPPORT_MIN_FORMAT_VERSION) {
          throw new Error(getError(5304, data[File.Version]));
        }

        lookupClasses(data, true, classFinder, reportMissingClass !== null && reportMissingClass !== void 0 ? reportMissingClass : deserialize.reportMissingClass);
        cacheMasks(data);
        var version = new FileInfo(data[File.Version]);
        var sharedUuids = data[File.SharedUuids];
        var sharedStrings = data[File.SharedStrings];
        var sharedClasses = data[File.SharedClasses];
        var sharedMasks = data[File.SharedMasks];
        var sections = data[PACKED_SECTIONS];

        for (var i = 0; i < sections.length; ++i) {
          sections[i].unshift(version, sharedUuids, sharedStrings, sharedClasses, sharedMasks);
        }

        return sections;
      }
      function packCustomObjData(type, data, hasNativeDep) {
        return [SUPPORT_MIN_FORMAT_VERSION, EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER, [type], EMPTY_PLACEHOLDER, hasNativeDep ? [data, ~0] : [data], [0], EMPTY_PLACEHOLDER, [], [], []];
      }
      function hasNativeDep(data) {
        var instances = data[File.Instances];
        var rootInfo = instances[instances.length - 1];

        if (typeof rootInfo !== 'number') {
          return false;
        } else {
          return rootInfo < 0;
        }
      }

      function getDependUuidList(json) {
        var sharedUuids = json[File.SharedUuids];
        return json[File.DependUuidIndices].map(function (index) {
          return sharedUuids[index];
        });
      }

      function parseUuidDependencies(serialized) {
        {
          return getDependUuidList(serialized);
        }
      }

      legacyCC.deserialize = deserialize;

      var Destroyed$1 = CCObject.Flags.Destroyed;
      var PersistentMask$1 = CCObject.Flags.PersistentMask;
      var objsToClearTmpVar = [];
      function instantiate(original, internalForce) {

        var clone;

        if (original instanceof CCObject) {
          if (original._instantiate) {
            legacyCC.game._isCloning = true;
            clone = original._instantiate(null, true);
            legacyCC.game._isCloning = false;
            return clone;
          } else if (original instanceof legacyCC.Asset) {
            throw new TypeError(getError(6903));
          }
        }

        legacyCC.game._isCloning = true;
        clone = doInstantiate(original);
        legacyCC.game._isCloning = false;
        return clone;
      }

      function doInstantiate(obj, parent) {

        var clone;

        if (obj._iN$t) {
          clone = obj._iN$t;
        } else if (obj.constructor) {
          var klass = obj.constructor;
          clone = new klass();
        } else {
          clone = Object.create(null);
        }

        enumerateObject(obj, clone, parent);

        for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
          objsToClearTmpVar[i]._iN$t = null;
        }

        objsToClearTmpVar.length = 0;
        return clone;
      }

      function enumerateCCClass(klass, obj, clone, parent) {
        var props = klass.__values__;

        for (var p = 0; p < props.length; p++) {
          var key = props[p];
          var value = obj[key];

          if (typeof value === 'object' && value) {
            var initValue = clone[key];

            if (initValue instanceof ValueType && initValue.constructor === value.constructor) {
              initValue.set(value);
            } else {
              clone[key] = value._iN$t || instantiateObj(value, parent);
            }
          } else {
            clone[key] = value;
          }
        }
      }

      function enumerateObject(obj, clone, parent) {
        js.value(obj, '_iN$t', clone, true);
        objsToClearTmpVar.push(obj);
        var klass = obj.constructor;

        if (isCCClassOrFastDefined(klass)) {
          enumerateCCClass(klass, obj, clone, parent);
        } else {
          for (var key in obj) {
            if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__' && key !== '__prefab') {
              continue;
            }

            var value = obj[key];

            if (typeof value === 'object' && value) {
              if (value === clone) {
                continue;
              }

              clone[key] = value._iN$t || instantiateObj(value, parent);
            } else {
              clone[key] = value;
            }
          }
        }

        if (obj instanceof CCObject) {
          clone._objFlags &= PersistentMask$1;
        }
      }

      function instantiateObj(obj, parent) {
        if (obj instanceof ValueType) {
          return obj.clone();
        }

        if (obj instanceof legacyCC.Asset) {
          return obj;
        }

        var clone;

        if (ArrayBuffer.isView(obj)) {
          var len = obj.length;
          clone = new obj.constructor(len);
          obj._iN$t = clone;
          objsToClearTmpVar.push(obj);

          for (var i = 0; i < len; ++i) {
            clone[i] = obj[i];
          }

          return clone;
        }

        if (Array.isArray(obj)) {
          var _len = obj.length;
          clone = new Array(_len);
          obj._iN$t = clone;
          objsToClearTmpVar.push(obj);

          for (var _i = 0; _i < _len; ++_i) {
            var value = obj[_i];

            if (typeof value === 'object' && value) {
              clone[_i] = value._iN$t || instantiateObj(value, parent);
            } else {
              clone[_i] = value;
            }
          }

          return clone;
        } else if (obj._objFlags & Destroyed$1) {
          return null;
        }

        var ctor = obj.constructor;

        if (isCCClassOrFastDefined(ctor)) {
          if (parent) {
            if (parent instanceof legacyCC.Component) {
              if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
                return obj;
              }
            } else if (parent instanceof legacyCC._BaseNode) {
              if (obj instanceof legacyCC._BaseNode) {
                if (!obj.isChildOf(parent)) {
                  return obj;
                }
              } else if (obj instanceof legacyCC.Component) {
                if (obj.node && !obj.node.isChildOf(parent)) {
                  return obj;
                }
              }
            }
          }

          clone = new ctor();
        } else if (ctor === Object) {
          clone = {};
        } else if (!ctor) {
          clone = Object.create(null);
        } else {
          return obj;
        }

        enumerateObject(obj, clone, parent);
        return clone;
      }

      instantiate._clone = doInstantiate;
      legacyCC.instantiate = instantiate;

      var _dec$4, _class$4, _class2$4, _descriptor$3, _descriptor2$1, _descriptor3$1, _descriptor4, _class3$2, _temp$3, _BuiltinElementTypeTr;
      var StorageUnit;

      (function (StorageUnit) {
        StorageUnit[StorageUnit["Uint8"] = 0] = "Uint8";
        StorageUnit[StorageUnit["Uint16"] = 1] = "Uint16";
        StorageUnit[StorageUnit["Uint32"] = 2] = "Uint32";
        StorageUnit[StorageUnit["Int8"] = 3] = "Int8";
        StorageUnit[StorageUnit["Int16"] = 4] = "Int16";
        StorageUnit[StorageUnit["Int32"] = 5] = "Int32";
        StorageUnit[StorageUnit["Float32"] = 6] = "Float32";
        StorageUnit[StorageUnit["Float64"] = 7] = "Float64";
      })(StorageUnit || (StorageUnit = {}));

      var ElementType;

      (function (ElementType) {
        ElementType[ElementType["Scalar"] = 0] = "Scalar";
        ElementType[ElementType["Vec2"] = 1] = "Vec2";
        ElementType[ElementType["Vec3"] = 2] = "Vec3";
        ElementType[ElementType["Vec4"] = 3] = "Vec4";
        ElementType[ElementType["Quat"] = 4] = "Quat";
        ElementType[ElementType["Mat4"] = 5] = "Mat4";
      })(ElementType || (ElementType = {}));

      var elementTypeBits = 3;
      function combineStorageUnitElementType(unit, elementType) {
        return (elementType << elementTypeBits) + unit;
      }
      function extractStorageUnitElementType(combined) {
        return {
          storageUnit: ~(-1 << elementTypeBits) & combined,
          elementType: combined >> elementTypeBits
        };
      }
      var CompactValueTypeArray = exports('CompactValueTypeArray', (_dec$4 = ccclass('cc.CompactValueTypeArray'), _dec$4(_class$4 = (_class2$4 = (_temp$3 = _class3$2 = function () {
        function CompactValueTypeArray() {
          _initializerDefineProperty(this, "_byteOffset", _descriptor$3, this);

          _initializerDefineProperty(this, "_unitCount", _descriptor2$1, this);

          _initializerDefineProperty(this, "_unitElement", _descriptor3$1, this);

          _initializerDefineProperty(this, "_length", _descriptor4, this);
        }

        CompactValueTypeArray.lengthFor = function lengthFor(values, elementType, unit) {
          var elementTraits = getElementTraits(elementType);
          return elementTraits.requiredUnits * values.length * getStorageConstructor(unit).BYTES_PER_ELEMENT;
        };

        CompactValueTypeArray.compress = function compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
          var elementTraits = getElementTraits(elementType);
          var storageConstructor = getStorageConstructor(unit);
          var unitCount = elementTraits.requiredUnits * values.length;
          var storage = new storageConstructor(arrayBuffer, byteOffset, unitCount);

          for (var i = 0; i < values.length; ++i) {
            elementTraits.compress(storage, i, values[i]);
          }

          var result = new CompactValueTypeArray();
          result._unitElement = combineStorageUnitElementType(unit, elementType);
          result._byteOffset = presumedByteOffset;
          result._unitCount = unitCount;
          result._length = values.length;
          return result;
        };

        var _proto = CompactValueTypeArray.prototype;

        _proto.decompress = function decompress(arrayBuffer) {
          var _extractStorageUnitEl = extractStorageUnitElementType(this._unitElement),
              storageUnit = _extractStorageUnitEl.storageUnit,
              elementType = _extractStorageUnitEl.elementType;

          var elementTraits = getElementTraits(elementType);
          var storageConstructor = getStorageConstructor(storageUnit);
          var storage = new storageConstructor(arrayBuffer, this._byteOffset, this._unitCount);
          var result = new Array(this._length);

          for (var i = 0; i < this._length; ++i) {
            result[i] = elementTraits.decompress(storage, i);
          }

          return result;
        };

        return CompactValueTypeArray;
      }(), _class3$2.StorageUnit = StorageUnit, _class3$2.ElementType = ElementType, _temp$3), (_descriptor$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_byteOffset", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$4.prototype, "_unitCount", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$4.prototype, "_unitElement", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return combineStorageUnitElementType(StorageUnit.Uint8, ElementType.Scalar);
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2$4.prototype, "_length", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$4)) || _class$4));

      function getElementTraits(elementType) {
        return BuiltinElementTypeTraits[elementType];
      }

      function getStorageConstructor(unit) {
        switch (unit) {
          case StorageUnit.Uint8:
            return Uint8Array;

          case StorageUnit.Uint16:
            return Uint16Array;

          case StorageUnit.Uint32:
            return Uint32Array;

          case StorageUnit.Int8:
            return Int8Array;

          case StorageUnit.Int16:
            return Int16Array;

          case StorageUnit.Int32:
            return Int32Array;

          case StorageUnit.Float32:
            return Float32Array;

          case StorageUnit.Float64:
            return Float64Array;
        }
      }

      var BuiltinElementTypeTraits = (_BuiltinElementTypeTr = {}, _BuiltinElementTypeTr[ElementType.Scalar] = {
        requiredUnits: 1,
        compress: function compress(storage, index, value) {
          storage[index] = value;
        },
        decompress: function decompress(storage, index) {
          return storage[index];
        }
      }, _BuiltinElementTypeTr[ElementType.Vec2] = {
        requiredUnits: 2,
        compress: function compress(storage, index, value) {
          storage[index * 2] = value.x;
          storage[index * 2 + 1] = value.y;
        },
        decompress: function decompress(storage, index) {
          return new Vec3(storage[index * 2], storage[index * 2 + 1]);
        }
      }, _BuiltinElementTypeTr[ElementType.Vec3] = {
        requiredUnits: 3,
        compress: function compress(storage, index, value) {
          storage[index * 3] = value.x;
          storage[index * 3 + 1] = value.y;
          storage[index * 3 + 2] = value.z;
        },
        decompress: function decompress(storage, index) {
          return new Vec3(storage[index * 3], storage[index * 3 + 1], storage[index * 3 + 2]);
        }
      }, _BuiltinElementTypeTr[ElementType.Vec4] = {
        requiredUnits: 4,
        compress: function compress(storage, index, value) {
          storage[index * 4] = value.x;
          storage[index * 4 + 1] = value.y;
          storage[index * 4 + 2] = value.z;
          storage[index * 4 + 3] = value.w;
        },
        decompress: function decompress(storage, index) {
          return new Vec4(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
        }
      }, _BuiltinElementTypeTr[ElementType.Quat] = {
        requiredUnits: 4,
        compress: function compress(storage, index, value) {
          storage[index * 4] = value.x;
          storage[index * 4 + 1] = value.y;
          storage[index * 4 + 2] = value.z;
          storage[index * 4 + 3] = value.w;
        },
        decompress: function decompress(storage, index) {
          return new Quat(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
        }
      }, _BuiltinElementTypeTr[ElementType.Mat4] = {
        requiredUnits: 16,
        compress: function compress(storage, index, value) {
          Mat4.toArray(storage, value, index * 16);
        },
        decompress: function decompress(storage, index) {
          return Mat4.fromArray(new Mat4(), storage, index * 16);
        }
      }, _BuiltinElementTypeTr);

      legacyCC._decorator = _decorator;

      function constant() {
        return 0;
      }
      function linear(k) {
        return k;
      }
      function quadIn(k) {
        return k * k;
      }
      function quadOut(k) {
        return k * (2 - k);
      }
      function quadInOut(k) {
        k *= 2;

        if (k < 1) {
          return 0.5 * k * k;
        }

        return -0.5 * (--k * (k - 2) - 1);
      }
      function cubicIn(k) {
        return k * k * k;
      }
      function cubicOut(k) {
        return --k * k * k + 1;
      }
      function cubicInOut(k) {
        k *= 2;

        if (k < 1) {
          return 0.5 * k * k * k;
        }

        return 0.5 * ((k -= 2) * k * k + 2);
      }
      function quartIn(k) {
        return k * k * k * k;
      }
      function quartOut(k) {
        return 1 - --k * k * k * k;
      }
      function quartInOut(k) {
        k *= 2;

        if (k < 1) {
          return 0.5 * k * k * k * k;
        }

        return -0.5 * ((k -= 2) * k * k * k - 2);
      }
      function quintIn(k) {
        return k * k * k * k * k;
      }
      function quintOut(k) {
        return --k * k * k * k * k + 1;
      }
      function quintInOut(k) {
        k *= 2;

        if (k < 1) {
          return 0.5 * k * k * k * k * k;
        }

        return 0.5 * ((k -= 2) * k * k * k * k + 2);
      }
      function sineIn(k) {
        if (k === 1) {
          return 1;
        }

        return 1 - Math.cos(k * Math.PI / 2);
      }
      function sineOut(k) {
        return Math.sin(k * Math.PI / 2);
      }
      function sineInOut(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      }
      function expoIn(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
      }
      function expoOut(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
      }
      function expoInOut(k) {
        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        k *= 2;

        if (k < 1) {
          return 0.5 * Math.pow(1024, k - 1);
        }

        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
      }
      function circIn(k) {
        return 1 - Math.sqrt(1 - k * k);
      }
      function circOut(k) {
        return Math.sqrt(1 - --k * k);
      }
      function circInOut(k) {
        k *= 2;

        if (k < 1) {
          return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      }
      function elasticIn(k) {
        var s;
        var a = 0.1;
        var p = 0.4;

        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }

        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      }
      function elasticOut(k) {
        var s;
        var a = 0.1;
        var p = 0.4;

        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }

        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      }
      function elasticInOut(k) {
        var s;
        var a = 0.1;
        var p = 0.4;

        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }

        k *= 2;

        if (k < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
      }
      function backIn(k) {
        if (k === 1) {
          return 1;
        }

        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      }
      function backOut(k) {
        if (k === 0) {
          return 0;
        }

        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      }
      function backInOut(k) {
        var s = 1.70158 * 1.525;
        k *= 2;

        if (k < 1) {
          return 0.5 * (k * k * ((s + 1) * k - s));
        }

        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      }
      function bounceIn(k) {
        return 1 - bounceOut(1 - k);
      }
      function bounceOut(k) {
        if (k < 1 / 2.75) {
          return 7.5625 * k * k;
        } else if (k < 2 / 2.75) {
          return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
        } else if (k < 2.5 / 2.75) {
          return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
        } else {
          return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        }
      }
      function bounceInOut(k) {
        if (k < 0.5) {
          return bounceIn(k * 2) * 0.5;
        }

        return bounceOut(k * 2 - 1) * 0.5 + 0.5;
      }
      function smooth(k) {
        if (k <= 0) {
          return 0;
        }

        if (k >= 1) {
          return 1;
        }

        return k * k * (3 - 2 * k);
      }
      function fade(k) {
        if (k <= 0) {
          return 0;
        }

        if (k >= 1) {
          return 1;
        }

        return k * k * k * (k * (k * 6 - 15) + 10);
      }
      var quadOutIn = _makeOutIn(quadIn, quadOut);
      var cubicOutIn = _makeOutIn(cubicIn, cubicOut);
      var quartOutIn = _makeOutIn(quartIn, quartOut);
      var quintOutIn = _makeOutIn(quintIn, quintOut);
      var sineOutIn = _makeOutIn(sineIn, sineOut);
      var expoOutIn = _makeOutIn(expoIn, expoOut);
      var circOutIn = _makeOutIn(circIn, circOut);
      var elasticOutIn = _makeOutIn(elasticIn, elasticOut);
      var backOutIn = _makeOutIn(backIn, backOut);
      var bounceOutIn = _makeOutIn(bounceIn, bounceOut);

      function _makeOutIn(fnIn, fnOut) {
        return function (k) {
          if (k < 0.5) {
            return fnOut(k * 2) / 2;
          }

          return fnIn(2 * k - 1) / 2 + 0.5;
        };
      }

      var _easingMethodFnMap;
      var EasingMethod;

      (function (EasingMethod) {
        EasingMethod[EasingMethod["LINEAR"] = 0] = "LINEAR";
        EasingMethod[EasingMethod["CONSTANT"] = 1] = "CONSTANT";
        EasingMethod[EasingMethod["QUAD_IN"] = 2] = "QUAD_IN";
        EasingMethod[EasingMethod["QUAD_OUT"] = 3] = "QUAD_OUT";
        EasingMethod[EasingMethod["QUAD_IN_OUT"] = 4] = "QUAD_IN_OUT";
        EasingMethod[EasingMethod["QUAD_OUT_IN"] = 5] = "QUAD_OUT_IN";
        EasingMethod[EasingMethod["CUBIC_IN"] = 6] = "CUBIC_IN";
        EasingMethod[EasingMethod["CUBIC_OUT"] = 7] = "CUBIC_OUT";
        EasingMethod[EasingMethod["CUBIC_IN_OUT"] = 8] = "CUBIC_IN_OUT";
        EasingMethod[EasingMethod["CUBIC_OUT_IN"] = 9] = "CUBIC_OUT_IN";
        EasingMethod[EasingMethod["QUART_IN"] = 10] = "QUART_IN";
        EasingMethod[EasingMethod["QUART_OUT"] = 11] = "QUART_OUT";
        EasingMethod[EasingMethod["QUART_IN_OUT"] = 12] = "QUART_IN_OUT";
        EasingMethod[EasingMethod["QUART_OUT_IN"] = 13] = "QUART_OUT_IN";
        EasingMethod[EasingMethod["QUINT_IN"] = 14] = "QUINT_IN";
        EasingMethod[EasingMethod["QUINT_OUT"] = 15] = "QUINT_OUT";
        EasingMethod[EasingMethod["QUINT_IN_OUT"] = 16] = "QUINT_IN_OUT";
        EasingMethod[EasingMethod["QUINT_OUT_IN"] = 17] = "QUINT_OUT_IN";
        EasingMethod[EasingMethod["SINE_IN"] = 18] = "SINE_IN";
        EasingMethod[EasingMethod["SINE_OUT"] = 19] = "SINE_OUT";
        EasingMethod[EasingMethod["SINE_IN_OUT"] = 20] = "SINE_IN_OUT";
        EasingMethod[EasingMethod["SINE_OUT_IN"] = 21] = "SINE_OUT_IN";
        EasingMethod[EasingMethod["EXPO_IN"] = 22] = "EXPO_IN";
        EasingMethod[EasingMethod["EXPO_OUT"] = 23] = "EXPO_OUT";
        EasingMethod[EasingMethod["EXPO_IN_OUT"] = 24] = "EXPO_IN_OUT";
        EasingMethod[EasingMethod["EXPO_OUT_IN"] = 25] = "EXPO_OUT_IN";
        EasingMethod[EasingMethod["CIRC_IN"] = 26] = "CIRC_IN";
        EasingMethod[EasingMethod["CIRC_OUT"] = 27] = "CIRC_OUT";
        EasingMethod[EasingMethod["CIRC_IN_OUT"] = 28] = "CIRC_IN_OUT";
        EasingMethod[EasingMethod["CIRC_OUT_IN"] = 29] = "CIRC_OUT_IN";
        EasingMethod[EasingMethod["ELASTIC_IN"] = 30] = "ELASTIC_IN";
        EasingMethod[EasingMethod["ELASTIC_OUT"] = 31] = "ELASTIC_OUT";
        EasingMethod[EasingMethod["ELASTIC_IN_OUT"] = 32] = "ELASTIC_IN_OUT";
        EasingMethod[EasingMethod["ELASTIC_OUT_IN"] = 33] = "ELASTIC_OUT_IN";
        EasingMethod[EasingMethod["BACK_IN"] = 34] = "BACK_IN";
        EasingMethod[EasingMethod["BACK_OUT"] = 35] = "BACK_OUT";
        EasingMethod[EasingMethod["BACK_IN_OUT"] = 36] = "BACK_IN_OUT";
        EasingMethod[EasingMethod["BACK_OUT_IN"] = 37] = "BACK_OUT_IN";
        EasingMethod[EasingMethod["BOUNCE_IN"] = 38] = "BOUNCE_IN";
        EasingMethod[EasingMethod["BOUNCE_OUT"] = 39] = "BOUNCE_OUT";
        EasingMethod[EasingMethod["BOUNCE_IN_OUT"] = 40] = "BOUNCE_IN_OUT";
        EasingMethod[EasingMethod["BOUNCE_OUT_IN"] = 41] = "BOUNCE_OUT_IN";
        EasingMethod[EasingMethod["SMOOTH"] = 42] = "SMOOTH";
        EasingMethod[EasingMethod["FADE"] = 43] = "FADE";
      })(EasingMethod || (EasingMethod = {}));

      var easingMethodFnMap = (_easingMethodFnMap = {}, _easingMethodFnMap[EasingMethod.CONSTANT] = constant, _easingMethodFnMap[EasingMethod.LINEAR] = linear, _easingMethodFnMap[EasingMethod.QUAD_IN] = quadIn, _easingMethodFnMap[EasingMethod.QUAD_OUT] = quadOut, _easingMethodFnMap[EasingMethod.QUAD_IN_OUT] = quadInOut, _easingMethodFnMap[EasingMethod.QUAD_OUT_IN] = quadOutIn, _easingMethodFnMap[EasingMethod.CUBIC_IN] = cubicIn, _easingMethodFnMap[EasingMethod.CUBIC_OUT] = cubicOut, _easingMethodFnMap[EasingMethod.CUBIC_IN_OUT] = cubicInOut, _easingMethodFnMap[EasingMethod.CUBIC_OUT_IN] = cubicOutIn, _easingMethodFnMap[EasingMethod.QUART_IN] = quartIn, _easingMethodFnMap[EasingMethod.QUART_OUT] = quartOut, _easingMethodFnMap[EasingMethod.QUART_IN_OUT] = quartInOut, _easingMethodFnMap[EasingMethod.QUART_OUT_IN] = quartOutIn, _easingMethodFnMap[EasingMethod.QUINT_IN] = quintIn, _easingMethodFnMap[EasingMethod.QUINT_OUT] = quintOut, _easingMethodFnMap[EasingMethod.QUINT_IN_OUT] = quintInOut, _easingMethodFnMap[EasingMethod.QUINT_OUT_IN] = quintOutIn, _easingMethodFnMap[EasingMethod.SINE_IN] = sineIn, _easingMethodFnMap[EasingMethod.SINE_OUT] = sineOut, _easingMethodFnMap[EasingMethod.SINE_IN_OUT] = sineInOut, _easingMethodFnMap[EasingMethod.SINE_OUT_IN] = sineOutIn, _easingMethodFnMap[EasingMethod.EXPO_IN] = expoIn, _easingMethodFnMap[EasingMethod.EXPO_OUT] = expoOut, _easingMethodFnMap[EasingMethod.EXPO_IN_OUT] = expoInOut, _easingMethodFnMap[EasingMethod.EXPO_OUT_IN] = expoOutIn, _easingMethodFnMap[EasingMethod.CIRC_IN] = circIn, _easingMethodFnMap[EasingMethod.CIRC_OUT] = circOut, _easingMethodFnMap[EasingMethod.CIRC_IN_OUT] = circInOut, _easingMethodFnMap[EasingMethod.CIRC_OUT_IN] = circOutIn, _easingMethodFnMap[EasingMethod.ELASTIC_IN] = elasticIn, _easingMethodFnMap[EasingMethod.ELASTIC_OUT] = elasticOut, _easingMethodFnMap[EasingMethod.ELASTIC_IN_OUT] = elasticInOut, _easingMethodFnMap[EasingMethod.ELASTIC_OUT_IN] = elasticOutIn, _easingMethodFnMap[EasingMethod.BACK_IN] = backIn, _easingMethodFnMap[EasingMethod.BACK_OUT] = backOut, _easingMethodFnMap[EasingMethod.BACK_IN_OUT] = backInOut, _easingMethodFnMap[EasingMethod.BACK_OUT_IN] = backOutIn, _easingMethodFnMap[EasingMethod.BOUNCE_IN] = bounceIn, _easingMethodFnMap[EasingMethod.BOUNCE_OUT] = bounceOut, _easingMethodFnMap[EasingMethod.BOUNCE_IN_OUT] = bounceInOut, _easingMethodFnMap[EasingMethod.BOUNCE_OUT_IN] = bounceOutIn, _easingMethodFnMap[EasingMethod.SMOOTH] = smooth, _easingMethodFnMap[EasingMethod.FADE] = fade, _easingMethodFnMap);
      function getEasingFn(easingMethod) {
        assertIsTrue(easingMethod in easingMethodFnMap);
        return easingMethodFnMap[easingMethod];
      }

      var _CCClass$fastDefine$1;
      var REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START = 0;
      var REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
      var REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START = 8;
      var REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
      var REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START = 16;
      var REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
      assertIsTrue(REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START === REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START + popCount(REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK));
      assertIsTrue(REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START === REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START + popCount(REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK));
      var REAL_KEYFRAME_VALUE_DEFAULT_FLAGS = RealInterpolationMode.LINEAR << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START | TangentWeightMode.NONE << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START | EasingMethod.LINEAR << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;

      var RealKeyframeValue = function (_EditorExtendable) {
        _inheritsLoose(RealKeyframeValue, _EditorExtendable);

        function RealKeyframeValue() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _EditorExtendable.call.apply(_EditorExtendable, [this].concat(args)) || this;
          _this.value = 0.0;
          _this.rightTangent = 0.0;
          _this.rightTangentWeight = 0.0;
          _this.leftTangent = 0.0;
          _this.leftTangentWeight = 0.0;
          _this._flags = REAL_KEYFRAME_VALUE_DEFAULT_FLAGS;
          return _this;
        }

        _createClass(RealKeyframeValue, [{
          key: "interpolationMode",
          get: function get() {
            return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
          },
          set: function set(value) {
            this._flags &= ~REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK;
            this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
          }
        }, {
          key: "tangentWeightMode",
          get: function get() {
            return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
          },
          set: function set(value) {
            this._flags &= ~REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK;
            this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
          }
        }, {
          key: "easingMethod",
          get: function get() {
            return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
          },
          set: function set(value) {
            this._flags &= ~REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK;
            this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
          }
        }]);

        return RealKeyframeValue;
      }(EditorExtendable);

      CCClass.fastDefine('cc.RealKeyframeValue', RealKeyframeValue, (_CCClass$fastDefine$1 = {
        interpolationMode: RealInterpolationMode.LINEAR,
        tangentWeightMode: TangentWeightMode.NONE,
        value: 0.0,
        rightTangent: 0.0,
        rightTangentWeight: 0.0,
        leftTangent: 0.0,
        leftTangentWeight: 0.0,
        easingMethod: EasingMethod.LINEAR
      }, _CCClass$fastDefine$1[editorExtrasTag] = undefined, _CCClass$fastDefine$1));
      CCClass.Attr.setClassAttr(RealKeyframeValue, editorExtrasTag, 'editorOnly', true);
      getOrCreateSerializationMetadata(RealKeyframeValue).uniquelyReferenced = true;

      function createRealKeyframeValue(params) {
        var realKeyframeValue = new RealKeyframeValue();

        if (typeof params === 'number') {
          realKeyframeValue.value = params;
        } else {
          var interpolationMode = params.interpolationMode,
              tangentWeightMode = params.tangentWeightMode,
              value = params.value,
              rightTangent = params.rightTangent,
              rightTangentWeight = params.rightTangentWeight,
              leftTangent = params.leftTangent,
              leftTangentWeight = params.leftTangentWeight,
              easingMethod = params.easingMethod,
              editorExtras = params[editorExtrasTag];
          realKeyframeValue.value = value !== null && value !== void 0 ? value : realKeyframeValue.value;
          realKeyframeValue.rightTangent = rightTangent !== null && rightTangent !== void 0 ? rightTangent : realKeyframeValue.rightTangent;
          realKeyframeValue.rightTangentWeight = rightTangentWeight !== null && rightTangentWeight !== void 0 ? rightTangentWeight : realKeyframeValue.rightTangentWeight;
          realKeyframeValue.leftTangent = leftTangent !== null && leftTangent !== void 0 ? leftTangent : realKeyframeValue.leftTangent;
          realKeyframeValue.leftTangentWeight = leftTangentWeight !== null && leftTangentWeight !== void 0 ? leftTangentWeight : realKeyframeValue.leftTangentWeight;
          realKeyframeValue.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : realKeyframeValue.interpolationMode;
          realKeyframeValue.tangentWeightMode = tangentWeightMode !== null && tangentWeightMode !== void 0 ? tangentWeightMode : realKeyframeValue.tangentWeightMode;
          realKeyframeValue.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : realKeyframeValue.easingMethod;

          if (editorExtras) {
            realKeyframeValue[editorExtrasTag] = editorExtras;
          }
        }

        return realKeyframeValue;
      }

      var RealCurve = exports('RealCurve', function (_KeyframeCurve) {
        _inheritsLoose(RealCurve, _KeyframeCurve);

        function RealCurve() {
          var _this2;

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          _this2 = _KeyframeCurve.call.apply(_KeyframeCurve, [this].concat(args)) || this;
          _this2.preExtrapolation = ExtrapolationMode.CLAMP;
          _this2.postExtrapolation = ExtrapolationMode.CLAMP;
          return _this2;
        }

        var _proto = RealCurve.prototype;

        _proto.evaluate = function evaluate(time) {
          var times = this._times,
              values = this._values;
          var nFrames = times.length;

          if (nFrames === 0) {
            return 0.0;
          }

          var firstTime = times[0];
          var lastTime = times[nFrames - 1];

          if (time < firstTime) {
            var preExtrapolation = this.preExtrapolation;
            var _preValue = values[0];

            if (preExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
              return _preValue.value;
            }

            switch (preExtrapolation) {
              case ExtrapolationMode.LINEAR:
                return linearTrend(firstTime, values[0].value, times[1], values[1].value, time);

              case ExtrapolationMode.LOOP:
                time = wrapRepeat(time, firstTime, lastTime);
                break;

              case ExtrapolationMode.PING_PONG:
                time = wrapPingPong(time, firstTime, lastTime);
                break;

              default:
                return _preValue.value;
            }
          } else if (time > lastTime) {
            var postExtrapolation = this.postExtrapolation;
            var preFrame = values[nFrames - 1];

            if (postExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
              return preFrame.value;
            }

            switch (postExtrapolation) {
              case ExtrapolationMode.LINEAR:
                return linearTrend(lastTime, preFrame.value, times[nFrames - 2], values[nFrames - 2].value, time);

              case ExtrapolationMode.LOOP:
                time = wrapRepeat(time, firstTime, lastTime);
                break;

              case ExtrapolationMode.PING_PONG:
                time = wrapPingPong(time, firstTime, lastTime);
                break;

              default:
                return preFrame.value;
            }
          }

          var index = binarySearchEpsilon(times, time);

          if (index >= 0) {
            return values[index].value;
          }

          var iNext = ~index;
          assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
          var iPre = iNext - 1;
          var preTime = times[iPre];
          var preValue = values[iPre];
          var nextTime = times[iNext];
          var nextValue = values[iNext];
          assertIsTrue(nextTime > time && time > preTime);
          var dt = nextTime - preTime;
          var ratio = (time - preTime) / dt;
          return evalBetweenTwoKeyFrames(preTime, preValue, nextTime, nextValue, ratio);
        };

        _proto.addKeyFrame = function addKeyFrame(time, value) {
          return _KeyframeCurve.prototype.addKeyFrame.call(this, time, createRealKeyframeValue(value));
        };

        _proto.assignSorted = function assignSorted(times, values) {
          if (values !== undefined) {
            assertIsTrue(Array.isArray(times));
            this.setKeyframes(times.slice(), values.map(function (value) {
              return createRealKeyframeValue(value);
            }));
          } else {
            var _keyframes = Array.from(times);

            this.setKeyframes(_keyframes.map(function (_ref) {
              var time = _ref[0];
              return time;
            }), _keyframes.map(function (_ref2) {
              var value = _ref2[1];
              return createRealKeyframeValue(value);
            }));
          }
        };

        _proto.isConstant = function isConstant(tolerance) {
          if (this._values.length <= 1) {
            return true;
          }

          var firstVal = this._values[0].value;
          return this._values.every(function (frame) {
            return approx(frame.value, firstVal, tolerance);
          });
        };

        _proto[serializeTag] = function (output, context) {
          if (!context.toCCON) {
            output.writeThis();
            return;
          }

          var times = this._times,
              keyframeValues = this._values;
          var nKeyframes = times.length;
          var dataSize = 0 + OVERFLOW_BYTES + OVERFLOW_BYTES + FRAME_COUNT_BYTES + TIME_BYTES * nKeyframes + REAL_KEY_FRAME_VALUE_MAX_SIZE * nKeyframes;
          var dataView = new DataView(new ArrayBuffer(dataSize));
          var currentOffset = 0;
          dataView.setUint8(currentOffset, this.preExtrapolation);
          currentOffset += OVERFLOW_BYTES;
          dataView.setUint8(currentOffset, this.postExtrapolation);
          currentOffset += OVERFLOW_BYTES;
          dataView.setUint32(currentOffset, nKeyframes, true);
          currentOffset += FRAME_COUNT_BYTES;
          times.forEach(function (time, index) {
            return dataView.setFloat32(currentOffset + TIME_BYTES * index, time, true);
          });
          currentOffset += TIME_BYTES * nKeyframes;

          for (var _iterator = _createForOfIteratorHelperLoose(keyframeValues), _step; !(_step = _iterator()).done;) {
            var keyframeValue = _step.value;
            currentOffset = saveRealKeyFrameValue(dataView, keyframeValue, currentOffset);
          }

          var bytes = new Uint8Array(dataView.buffer, 0, currentOffset);
          output.writeProperty('bytes', bytes);
          var keyframeValueEditorExtras = keyframeValues.map(function (keyframeValue) {
            return keyframeValue[editorExtrasTag];
          });

          if (keyframeValueEditorExtras.some(function (extras) {
            return extras !== undefined;
          })) {
            output.writeProperty("keyframeValueEditorExtras", keyframeValueEditorExtras);
          }
        };

        _proto[deserializeTag] = function (input, context) {
          if (!context.fromCCON) {
            input.readThis();
            return;
          }

          var bytes = input.readProperty('bytes');
          var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
          var currentOffset = 0;
          this.preExtrapolation = dataView.getUint8(currentOffset);
          currentOffset += OVERFLOW_BYTES;
          this.postExtrapolation = dataView.getUint8(currentOffset);
          currentOffset += OVERFLOW_BYTES;
          var nKeyframes = dataView.getUint32(currentOffset, true);
          currentOffset += FRAME_COUNT_BYTES;
          var times = Array.from({
            length: nKeyframes
          }, function (_, index) {
            return dataView.getFloat32(currentOffset + TIME_BYTES * index, true);
          });
          currentOffset += TIME_BYTES * nKeyframes;
          var keyframeValues = new Array(nKeyframes);

          for (var iKeyFrame = 0; iKeyFrame < nKeyframes; ++iKeyFrame) {
            var keyframeValue = createRealKeyframeValue({});
            currentOffset = loadRealKeyFrameValue(dataView, keyframeValue, currentOffset);
            keyframeValues[iKeyFrame] = keyframeValue;
          }

          assertIsTrue(currentOffset === bytes.byteLength);
          var keyframeValueEditorExtras = input.readProperty("keyframeValueEditorExtras");

          if (keyframeValueEditorExtras) {
            assertIsTrue(keyframeValueEditorExtras.length === nKeyframes);
            keyframeValueEditorExtras.forEach(function (extras, index) {
              return keyframeValues[index][editorExtrasTag] = extras;
            });
          }

          this._times = times;
          this._values = keyframeValues;
        };

        return RealCurve;
      }(KeyframeCurve));
      CCClass.fastDefine('cc.RealCurve', RealCurve, {
        _times: [],
        _values: [],
        preExtrapolation: ExtrapolationMode.CLAMP,
        postExtrapolation: ExtrapolationMode.CLAMP
      });
      var FLAGS_EASING_METHOD_BITS_START = 8;
      var FLAG_EASING_METHOD_MASK = 0xFF << FLAGS_EASING_METHOD_BITS_START;
      var KeyframeValueFlagMask;

      (function (KeyframeValueFlagMask) {
        KeyframeValueFlagMask[KeyframeValueFlagMask["VALUE"] = 1] = "VALUE";
        KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 2] = "INTERPOLATION_MODE";
        KeyframeValueFlagMask[KeyframeValueFlagMask["TANGENT_WEIGHT_MODE"] = 4] = "TANGENT_WEIGHT_MODE";
        KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT"] = 8] = "LEFT_TANGENT";
        KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT_WEIGHT"] = 16] = "LEFT_TANGENT_WEIGHT";
        KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT"] = 32] = "RIGHT_TANGENT";
        KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT_WEIGHT"] = 64] = "RIGHT_TANGENT_WEIGHT";
      })(KeyframeValueFlagMask || (KeyframeValueFlagMask = {}));

      var OVERFLOW_BYTES = 1;
      var FRAME_COUNT_BYTES = 4;
      var TIME_BYTES = 4;
      var KEY_FRAME_VALUE_FLAGS_BYTES = 4;
      var VALUE_BYTES = 4;
      var INTERPOLATION_MODE_BYTES = 1;
      var TANGENT_WEIGHT_MODE_BYTES = 1;
      var LEFT_TANGENT_BYTES = 4;
      var LEFT_TANGENT_WEIGHT_BYTES = 4;
      var RIGHT_TANGENT_BYTES = 4;
      var RIGHT_TANGENT_WEIGHT_BYTES = 4;

      var _createRealKeyframeVa = createRealKeyframeValue({}),
          DEFAULT_INTERPOLATION_MODE = _createRealKeyframeVa.interpolationMode,
          DEFAULT_TANGENT_WEIGHT_MODE = _createRealKeyframeVa.tangentWeightMode,
          DEFAULT_LEFT_TANGENT = _createRealKeyframeVa.leftTangent,
          DEFAULT_LEFT_TANGENT_WEIGHT = _createRealKeyframeVa.leftTangentWeight,
          DEFAULT_RIGHT_TANGENT = _createRealKeyframeVa.rightTangent,
          DEFAULT_RIGHT_TANGENT_WEIGHT = _createRealKeyframeVa.rightTangentWeight;

      var REAL_KEY_FRAME_VALUE_MAX_SIZE = KEY_FRAME_VALUE_FLAGS_BYTES + VALUE_BYTES + INTERPOLATION_MODE_BYTES + TANGENT_WEIGHT_MODE_BYTES + LEFT_TANGENT_BYTES + LEFT_TANGENT_WEIGHT_BYTES + RIGHT_TANGENT_BYTES + RIGHT_TANGENT_WEIGHT_BYTES + 0;

      function saveRealKeyFrameValue(dataView, keyframeValue, offset) {
        var flags = 0;
        var currentOffset = offset;
        var pFlags = currentOffset;
        currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
        var value = keyframeValue.value,
            interpolationMode = keyframeValue.interpolationMode,
            tangentWeightMode = keyframeValue.tangentWeightMode,
            rightTangent = keyframeValue.rightTangent,
            rightTangentWeight = keyframeValue.rightTangentWeight,
            leftTangent = keyframeValue.leftTangent,
            leftTangentWeight = keyframeValue.leftTangentWeight,
            easingMethod = keyframeValue.easingMethod;
        dataView.setFloat32(currentOffset, value, true);
        currentOffset += VALUE_BYTES;

        if (interpolationMode !== DEFAULT_INTERPOLATION_MODE) {
          flags |= KeyframeValueFlagMask.INTERPOLATION_MODE;
          dataView.setUint8(currentOffset, interpolationMode);
          currentOffset += INTERPOLATION_MODE_BYTES;
        }

        if (tangentWeightMode !== DEFAULT_TANGENT_WEIGHT_MODE) {
          flags |= KeyframeValueFlagMask.TANGENT_WEIGHT_MODE;
          dataView.setUint8(currentOffset, tangentWeightMode);
          currentOffset += TANGENT_WEIGHT_MODE_BYTES;
        }

        if (leftTangent !== DEFAULT_LEFT_TANGENT) {
          flags |= KeyframeValueFlagMask.LEFT_TANGENT;
          dataView.setFloat32(currentOffset, leftTangent, true);
          currentOffset += LEFT_TANGENT_BYTES;
        }

        if (leftTangentWeight !== DEFAULT_LEFT_TANGENT_WEIGHT) {
          flags |= KeyframeValueFlagMask.LEFT_TANGENT_WEIGHT;
          dataView.setFloat32(currentOffset, leftTangentWeight, true);
          currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
        }

        if (rightTangent !== DEFAULT_RIGHT_TANGENT) {
          flags |= KeyframeValueFlagMask.RIGHT_TANGENT;
          dataView.setFloat32(currentOffset, rightTangent, true);
          currentOffset += RIGHT_TANGENT_BYTES;
        }

        if (rightTangentWeight !== DEFAULT_RIGHT_TANGENT_WEIGHT) {
          flags |= KeyframeValueFlagMask.RIGHT_TANGENT_WEIGHT;
          dataView.setFloat32(currentOffset, rightTangentWeight, true);
          currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
        }

        flags |= easingMethod << FLAGS_EASING_METHOD_BITS_START;
        dataView.setUint32(pFlags, flags, true);
        return currentOffset;
      }

      function loadRealKeyFrameValue(dataView, keyframeValue, offset) {
        var currentOffset = offset;
        var flags = dataView.getUint32(currentOffset, true);
        currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
        keyframeValue.value = dataView.getFloat32(currentOffset, true);
        currentOffset += VALUE_BYTES;

        if (flags & KeyframeValueFlagMask.INTERPOLATION_MODE) {
          keyframeValue.interpolationMode = dataView.getUint8(currentOffset);
          currentOffset += INTERPOLATION_MODE_BYTES;
        }

        if (flags & KeyframeValueFlagMask.TANGENT_WEIGHT_MODE) {
          keyframeValue.tangentWeightMode = dataView.getUint8(currentOffset);
          currentOffset += TANGENT_WEIGHT_MODE_BYTES;
        }

        if (flags & KeyframeValueFlagMask.LEFT_TANGENT) {
          keyframeValue.leftTangent = dataView.getFloat32(currentOffset, true);
          currentOffset += LEFT_TANGENT_BYTES;
        }

        if (flags & KeyframeValueFlagMask.LEFT_TANGENT_WEIGHT) {
          keyframeValue.leftTangentWeight = dataView.getFloat32(currentOffset, true);
          currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
        }

        if (flags & KeyframeValueFlagMask.RIGHT_TANGENT) {
          keyframeValue.rightTangent = dataView.getFloat32(currentOffset, true);
          currentOffset += RIGHT_TANGENT_BYTES;
        }

        if (flags & KeyframeValueFlagMask.RIGHT_TANGENT_WEIGHT) {
          keyframeValue.rightTangentWeight = dataView.getFloat32(currentOffset, true);
          currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
        }

        var easingMethod = (flags & FLAG_EASING_METHOD_MASK) >> FLAGS_EASING_METHOD_BITS_START;
        keyframeValue.easingMethod = easingMethod;
        return currentOffset;
      }

      function wrapRepeat(time, prevTime, nextTime) {
        return prevTime + repeat(time - prevTime, nextTime - prevTime);
      }

      function wrapPingPong(time, prevTime, nextTime) {
        return prevTime + pingPong(time - prevTime, nextTime - prevTime);
      }

      function linearTrend(prevTime, prevValue, nextTime, nextValue, time) {
        var slope = (nextValue - prevValue) / (nextTime - prevTime);
        return prevValue + (time - prevTime) * slope;
      }

      function evalBetweenTwoKeyFrames(prevTime, prevValue, nextTime, nextValue, ratio) {
        var dt = nextTime - prevTime;

        switch (prevValue.interpolationMode) {
          default:
          case RealInterpolationMode.CONSTANT:
            return prevValue.value;

          case RealInterpolationMode.LINEAR:
            {
              var transformedRatio = prevValue.easingMethod === EasingMethod.LINEAR ? ratio : getEasingFn(prevValue.easingMethod)(ratio);
              return lerp(prevValue.value, nextValue.value, transformedRatio);
            }

          case RealInterpolationMode.CUBIC:
            {
              var ONE_THIRD = 1.0 / 3.0;
              var prevTangent = prevValue.rightTangent,
                  prevTangentWeightSpecified = prevValue.rightTangentWeight;
              var prevTangentWeightEnabled = isRightTangentWeightEnabled(prevValue.tangentWeightMode);
              var nextTangent = nextValue.leftTangent,
                  nextTangentWeightSpecified = nextValue.leftTangentWeight;
              var nextTangentWeightEnabled = isLeftTangentWeightEnabled(nextValue.tangentWeightMode);

              if (!prevTangentWeightEnabled && !nextTangentWeightEnabled) {
                var p1 = prevValue.value + ONE_THIRD * prevTangent * dt;
                var p2 = nextValue.value - ONE_THIRD * nextTangent * dt;
                return bezierInterpolate(prevValue.value, p1, p2, nextValue.value, ratio);
              } else {
                var prevTangentWeight = 0.0;

                if (prevTangentWeightEnabled) {
                  prevTangentWeight = prevTangentWeightSpecified;
                } else {
                  var x = dt;

                  var _y = dt * prevTangent;

                  prevTangentWeight = Math.sqrt(x * x + _y * _y) * ONE_THIRD;
                }

                var angle0 = Math.atan(prevTangent);
                var tx0 = Math.cos(angle0) * prevTangentWeight + prevTime;
                var ty0 = Math.sin(angle0) * prevTangentWeight + prevValue.value;
                var nextTangentWeight = 0.0;

                if (nextTangentWeightEnabled) {
                  nextTangentWeight = nextTangentWeightSpecified;
                } else {
                  var _x = dt;

                  var _y2 = dt * nextTangent;

                  nextTangentWeight = Math.sqrt(_x * _x + _y2 * _y2) * ONE_THIRD;
                }

                var angle1 = Math.atan(nextTangent);
                var tx1 = -Math.cos(angle1) * nextTangentWeight + nextTime;
                var ty1 = -Math.sin(angle1) * nextTangentWeight + nextValue.value;
                var dx = dt;
                var u0x = (tx0 - prevTime) / dx;
                var u1x = (tx1 - prevTime) / dx;
                var u0y = ty0;
                var u1y = ty1;
                var coeff0 = 0.0;
                var coeff1 = 3.0 * u0x;
                var coeff2 = 3.0 * u1x - 6.0 * u0x;
                var coeff3 = 3.0 * (u0x - u1x) + 1.0;
                var solutions = [0.0, 0.0, 0.0];
                var nSolutions = solveCubic(coeff0 - ratio, coeff1, coeff2, coeff3, solutions);
                var param = getParamFromCubicSolution(solutions, nSolutions, ratio);
                var y = bezierInterpolate(prevValue.value, u0y, u1y, nextValue.value, param);
                return y;
              }
            }
        }
      }

      function isLeftTangentWeightEnabled(tangentWeightMode) {
        return (tangentWeightMode & TangentWeightMode.LEFT) !== 0;
      }

      function isRightTangentWeightEnabled(tangentWeightMode) {
        return (tangentWeightMode & TangentWeightMode.RIGHT) !== 0;
      }

      function bezierInterpolate(p0, p1, p2, p3, t) {
        var u = 1 - t;
        var coeff0 = u * u * u;
        var coeff1 = 3 * u * u * t;
        var coeff2 = 3 * u * t * t;
        var coeff3 = t * t * t;
        return coeff0 * p0 + coeff1 * p1 + coeff2 * p2 + coeff3 * p3;
      }

      function getParamFromCubicSolution(solutions, solutionsCount, x) {
        var param = x;

        if (solutionsCount === 1) {
          param = solutions[0];
        } else {
          param = -Infinity;

          for (var iSolution = 0; iSolution < solutionsCount; ++iSolution) {
            var solution = solutions[iSolution];

            if (solution >= 0.0 && solution <= 1.0) {
              if (solution > param) {
                param = solution;
              }
            }
          }

          if (param === -Infinity) {
            param = 0.0;
          }
        }

        return param;
      }

      function bezier(C1, C2, C3, C4, t) {
        var t1 = 1 - t;
        return t1 * (t1 * (C1 + (C2 * 3 - C1) * t) + C3 * 3 * t * t) + C4 * t * t * t;
      }
      legacyCC.bezier = bezier;
      var cos = Math.cos;
      var acos = Math.acos;
      var max$2 = Math.max;
      var pi = Math.PI;
      var tau = 2 * pi;
      var sqrt = Math.sqrt;

      function crt(v) {
        if (v < 0) {
          return -Math.pow(-v, 1 / 3);
        } else {
          return Math.pow(v, 1 / 3);
        }
      }

      function cardano(curve, x) {
        var pa = x - 0;
        var pb = x - curve[0];
        var pc = x - curve[2];
        var pd = x - 1;
        var pa3 = pa * 3;
        var pb3 = pb * 3;
        var pc3 = pc * 3;
        var d = -pa + pb3 - pc3 + pd;
        var rd = 1 / d;
        var r3 = 1 / 3;
        var a = (pa3 - 6 * pb + pc3) * rd;
        var a3 = a * r3;
        var b = (-pa3 + pb3) * rd;
        var c = pa * rd;
        var p = (3 * b - a * a) * r3;
        var p3 = p * r3;
        var q = (2 * a * a * a - 9 * a * b + 27 * c) / 27;
        var q2 = q / 2;
        var discriminant = q2 * q2 + p3 * p3 * p3;
        var u1;
        var v1;
        var x1;
        var x2;
        var x3;

        if (discriminant < 0) {
          var mp3 = -p * r3;
          var mp33 = mp3 * mp3 * mp3;
          var r = sqrt(mp33);
          var t = -q / (2 * r);
          var cosphi = t < -1 ? -1 : t > 1 ? 1 : t;
          var phi = acos(cosphi);
          var crtr = crt(r);
          var t1 = 2 * crtr;
          x1 = t1 * cos(phi * r3) - a3;
          x2 = t1 * cos((phi + tau) * r3) - a3;
          x3 = t1 * cos((phi + 2 * tau) * r3) - a3;

          if (x1 >= 0 && x1 <= 1) {
            if (x2 >= 0 && x2 <= 1) {
              if (x3 >= 0 && x3 <= 1) {
                return max$2(x1, x2, x3);
              } else {
                return max$2(x1, x2);
              }
            } else if (x3 >= 0 && x3 <= 1) {
              return max$2(x1, x3);
            } else {
              return x1;
            }
          } else if (x2 >= 0 && x2 <= 1) {
            if (x3 >= 0 && x3 <= 1) {
              return max$2(x2, x3);
            } else {
              return x2;
            }
          } else {
            return x3;
          }
        } else if (discriminant === 0) {
          u1 = q2 < 0 ? crt(-q2) : -crt(q2);
          x1 = 2 * u1 - a3;
          x2 = -u1 - a3;

          if (x1 >= 0 && x1 <= 1) {
            if (x2 >= 0 && x2 <= 1) {
              return max$2(x1, x2);
            } else {
              return x1;
            }
          } else {
            return x2;
          }
        } else {
            var sd = sqrt(discriminant);
            u1 = crt(-q2 + sd);
            v1 = crt(q2 + sd);
            x1 = u1 - v1 - a3;
            return x1;
          }
      }

      function bezierByTime(controlPoints, x) {
        var percent = cardano(controlPoints, x);
        var p1y = controlPoints[1];
        var p2y = controlPoints[3];
        return ((1 - percent) * (p1y + (p2y - p1y) * percent) * 3 + percent * percent) * percent;
      }
      legacyCC.bezierByTime = bezierByTime;

      var _dec$5, _class$5, _class2$5, _descriptor$4, _descriptor2$2, _descriptor3$2, _temp$4, _dec2$3, _class4, _class5, _descriptor4$1, _descriptor5, _temp3;
      var QuatInterpolationMode;

      (function (QuatInterpolationMode) {
        QuatInterpolationMode[QuatInterpolationMode["SLERP"] = 0] = "SLERP";
        QuatInterpolationMode[QuatInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
      })(QuatInterpolationMode || (QuatInterpolationMode = exports('QuatInterpolationMode', {})));

      var QuatKeyframeValue = (_dec$5 = ccclass('cc.QuatKeyframeValue'), _dec$5(_class$5 = uniquelyReferenced(_class$5 = (_class2$5 = (_temp$4 = function QuatKeyframeValue(_temp2) {
        var _ref = _temp2 === void 0 ? {} : _temp2,
            value = _ref.value,
            interpolationMode = _ref.interpolationMode,
            easingMethod = _ref.easingMethod;

        _initializerDefineProperty(this, "interpolationMode", _descriptor$4, this);

        _initializerDefineProperty(this, "value", _descriptor2$2, this);

        _initializerDefineProperty(this, "easingMethod", _descriptor3$2, this);

        this.value = value ? Quat.clone(value) : this.value;
        this.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : this.interpolationMode;
        this.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : this.easingMethod;
      }, _temp$4), (_descriptor$4 = _applyDecoratedDescriptor(_class2$5.prototype, "interpolationMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return QuatInterpolationMode.SLERP;
        }
      }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$5.prototype, "value", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Quat.clone(Quat.IDENTITY);
        }
      }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$5.prototype, "easingMethod", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return EasingMethod.LINEAR;
        }
      })), _class2$5)) || _class$5) || _class$5);

      function createQuatKeyframeValue(params) {
        return new QuatKeyframeValue(params);
      }

      var QuatCurve = exports('QuatCurve', (_dec2$3 = ccclass('cc.QuatCurve'), _dec2$3(_class4 = (_class5 = (_temp3 = function (_KeyframeCurve) {
        _inheritsLoose(QuatCurve, _KeyframeCurve);

        function QuatCurve() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _KeyframeCurve.call.apply(_KeyframeCurve, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "preExtrapolation", _descriptor4$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "postExtrapolation", _descriptor5, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = QuatCurve.prototype;

        _proto.evaluate = function evaluate(time, quat) {
          var _quat;

          (_quat = quat) !== null && _quat !== void 0 ? _quat : quat = new Quat();
          var times = this._times,
              values = this._values,
              postExtrapolation = this.postExtrapolation,
              preExtrapolation = this.preExtrapolation;
          var nFrames = times.length;

          if (nFrames === 0) {
            return quat;
          }

          var firstTime = times[0];
          var lastTime = times[nFrames - 1];

          if (time < firstTime) {
            var _preValue = values[0];

            switch (preExtrapolation) {
              case ExtrapolationMode.LOOP:
                time = firstTime + repeat(time - firstTime, lastTime - firstTime);
                break;

              case ExtrapolationMode.PING_PONG:
                time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                break;

              case ExtrapolationMode.CLAMP:
              default:
                return Quat.copy(quat, _preValue.value);
            }
          } else if (time > lastTime) {
            var _preValue2 = values[nFrames - 1];

            switch (postExtrapolation) {
              case ExtrapolationMode.LOOP:
                time = firstTime + repeat(time - firstTime, lastTime - firstTime);
                break;

              case ExtrapolationMode.PING_PONG:
                time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                break;

              case ExtrapolationMode.CLAMP:
              default:
                return Quat.copy(quat, _preValue2.value);
            }
          }

          var index = binarySearchEpsilon(times, time);

          if (index >= 0) {
            return Quat.copy(quat, values[index].value);
          }

          var iNext = ~index;
          assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
          var iPre = iNext - 1;
          var preTime = times[iPre];
          var preValue = values[iPre];
          var nextTime = times[iNext];
          var nextValue = values[iNext];
          assertIsTrue(nextTime > time && time > preTime);
          var dt = nextTime - preTime;
          var ratio = (time - preTime) / dt;

          switch (preValue.interpolationMode) {
            default:
            case QuatInterpolationMode.CONSTANT:
              return Quat.copy(quat, preValue.value);

            case QuatInterpolationMode.SLERP:
              {
                var easingMethod = preValue.easingMethod;
                var transformedRatio = easingMethod === EasingMethod.LINEAR ? ratio : Array.isArray(easingMethod) ? bezierByTime(easingMethod, ratio) : getEasingFn(easingMethod)(ratio);
                return Quat.slerp(quat, preValue.value, nextValue.value, transformedRatio);
              }
          }
        };

        _proto.addKeyFrame = function addKeyFrame(time, value) {
          var keyframeValue = new QuatKeyframeValue(value);
          return _KeyframeCurve.prototype.addKeyFrame.call(this, time, keyframeValue);
        };

        _proto.assignSorted = function assignSorted(times, values) {
          if (values !== undefined) {
            assertIsTrue(Array.isArray(times));
            this.setKeyframes(times.slice(), values.map(function (value) {
              return createQuatKeyframeValue(value);
            }));
          } else {
            var _keyframes = Array.from(times);

            this.setKeyframes(_keyframes.map(function (_ref2) {
              var time = _ref2[0];
              return time;
            }), _keyframes.map(function (_ref3) {
              var value = _ref3[1];
              return createQuatKeyframeValue(value);
            }));
          }
        };

        _proto[serializeTag] = function (output, context) {
          if (!context.toCCON) {
            output.writeThis();
            return;
          }

          var times = this._times,
              keyframeValues = this._values;
          var interpolationModeRepeated = true;
          keyframeValues.forEach(function (keyframeValue, _index, _ref4) {
            var firstKeyframeValue = _ref4[0];

            if (interpolationModeRepeated && keyframeValue.interpolationMode !== firstKeyframeValue.interpolationMode) {
              interpolationModeRepeated = false;
            }
          });
          var nKeyframes = times.length;
          var nFrames = nKeyframes;
          var interpolationModesSize = INTERPOLATION_MODE_BYTES$1 * (interpolationModeRepeated ? 1 : nFrames);
          var easingMethodsSize = keyframeValues.reduce(function (result, _ref5) {
            var easingMethod = _ref5.easingMethod;
            return result += Array.isArray(easingMethod) ? EASING_METHOD_BYTES + EASING_METHOD_BEZIER_COMPONENT_BYTES * 4 : EASING_METHOD_BYTES;
          }, 0);
          var dataSize = 0;
          dataSize += FLAGS_BYTES + FRAME_COUNT_BYTES$1 + TIME_BYTES$1 * nFrames + VALUE_BYTES$1 * 4 * nFrames + easingMethodsSize + interpolationModesSize + 0;
          var dataView = new DataView(new ArrayBuffer(dataSize));
          var P = 0;
          var flags = 0;

          if (interpolationModeRepeated) {
            flags |= KeyframeValueFlagMask$1.INTERPOLATION_MODE;
          }

          dataView.setUint32(P, flags, true);
          P += FLAGS_BYTES;
          dataView.setUint32(P, nFrames, true);
          P += FRAME_COUNT_BYTES$1;
          times.forEach(function (time, index) {
            return dataView.setFloat32(P + TIME_BYTES$1 * index, time, true);
          });
          P += TIME_BYTES$1 * nFrames;
          keyframeValues.forEach(function (_ref6, index) {
            var _ref6$value = _ref6.value,
                x = _ref6$value.x,
                y = _ref6$value.y,
                z = _ref6$value.z,
                w = _ref6$value.w;
            var pQuat = P + VALUE_BYTES$1 * 4 * index;
            dataView.setFloat32(pQuat + VALUE_BYTES$1 * 0, x, true);
            dataView.setFloat32(pQuat + VALUE_BYTES$1 * 1, y, true);
            dataView.setFloat32(pQuat + VALUE_BYTES$1 * 2, z, true);
            dataView.setFloat32(pQuat + VALUE_BYTES$1 * 3, w, true);
          });
          P += VALUE_BYTES$1 * 4 * nFrames;
          keyframeValues.forEach(function (_ref7, index) {
            var easingMethod = _ref7.easingMethod;

            if (!Array.isArray(easingMethod)) {
              dataView.setUint8(P, easingMethod);
              ++P;
            } else {
              dataView.setUint8(P, EASING_METHOD_BEZIER_TAG);
              ++P;
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, easingMethod[0], true);
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, easingMethod[1], true);
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, easingMethod[2], true);
              dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, easingMethod[3], true);
              P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
            }
          });
          var INTERPOLATION_MODES_START = P;
          P += interpolationModesSize;
          var pInterpolationMode = INTERPOLATION_MODES_START;
          keyframeValues.forEach(function (_ref8) {
            var interpolationMode = _ref8.interpolationMode;
            dataView.setUint8(pInterpolationMode, interpolationMode);

            if (!interpolationModeRepeated) {
              pInterpolationMode += INTERPOLATION_MODE_BYTES$1;
            }
          });
          var bytes = new Uint8Array(dataView.buffer);
          output.writeProperty('bytes', bytes);
        };

        _proto[deserializeTag] = function (input, context) {
          if (!context.fromCCON) {
            input.readThis();
            return;
          }

          var bytes = input.readProperty('bytes');
          var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
          var P = 0;
          var flags = dataView.getUint32(P, true);
          P += FLAGS_BYTES;
          var interpolationModeRepeated = flags & KeyframeValueFlagMask$1.INTERPOLATION_MODE;
          var nFrames = dataView.getUint32(P, true);
          P += FRAME_COUNT_BYTES$1;
          var times = Array.from({
            length: nFrames
          }, function (_, index) {
            return dataView.getFloat32(P + TIME_BYTES$1 * index, true);
          });
          P += TIME_BYTES$1 * nFrames;
          var P_VALUES = P;
          P += VALUE_BYTES$1 * 4 * nFrames;
          var keyframeValues = Array.from({
            length: nFrames
          }, function (_, index) {
            var pQuat = P_VALUES + VALUE_BYTES$1 * 4 * index;
            var x = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 0, true);
            var y = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 1, true);
            var z = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 2, true);
            var w = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 3, true);
            var easingMethod = dataView.getUint8(P);
            ++P;
            var keyframeValue = createQuatKeyframeValue({
              value: {
                x: x,
                y: y,
                z: z,
                w: w
              }
            });

            if (easingMethod !== EASING_METHOD_BEZIER_TAG) {
              keyframeValue.easingMethod = easingMethod;
            } else {
              keyframeValue.easingMethod = [dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, true)];
              P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
            }

            return keyframeValue;
          });

          if (interpolationModeRepeated) {
            var interpolationMode = dataView.getUint8(P);
            ++P;

            for (var iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
              keyframeValues[iKeyframe].interpolationMode = interpolationMode;
            }
          } else {
            for (var _iKeyframe = 0; _iKeyframe < nFrames; ++_iKeyframe) {
              var _interpolationMode = dataView.getUint8(P + _iKeyframe);

              keyframeValues[_iKeyframe].interpolationMode = _interpolationMode;
            }

            P += nFrames;
          }

          this._times = times;
          this._values = keyframeValues;
        };

        return QuatCurve;
      }(KeyframeCurve), _temp3), (_descriptor4$1 = _applyDecoratedDescriptor(_class5.prototype, "preExtrapolation", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ExtrapolationMode.CLAMP;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class5.prototype, "postExtrapolation", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ExtrapolationMode.CLAMP;
        }
      })), _class5)) || _class4));
      var KeyframeValueFlagMask$1;

      (function (KeyframeValueFlagMask) {
        KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 1] = "INTERPOLATION_MODE";
      })(KeyframeValueFlagMask$1 || (KeyframeValueFlagMask$1 = {}));

      var FLAGS_BYTES = 1;
      var FRAME_COUNT_BYTES$1 = 4;
      var TIME_BYTES$1 = 4;
      var VALUE_BYTES$1 = 4;
      var INTERPOLATION_MODE_BYTES$1 = 1;
      var EASING_METHOD_BYTES = 1;
      var EASING_METHOD_BEZIER_TAG = 255;
      var EASING_METHOD_BEZIER_COMPONENT_BYTES = 4;

      var _dec$6, _class$6;
      var ObjectCurve = exports('ObjectCurve', (_dec$6 = ccclass('cc.ObjectCurve'), _dec$6(_class$6 = function (_KeyframeCurve) {
        _inheritsLoose(ObjectCurve, _KeyframeCurve);

        function ObjectCurve() {
          return _KeyframeCurve.apply(this, arguments) || this;
        }

        var _proto = ObjectCurve.prototype;

        _proto.evaluate = function evaluate(time) {
          var iSearch = this.searchKeyframe(time);

          if (iSearch >= 0) {
            return this._values[iSearch];
          }

          var iPrev = clamp(~iSearch - 1, 0, this._values.length - 1);
          return this._values[iPrev];
        };

        return ObjectCurve;
      }(KeyframeCurve)) || _class$6));

      var LOOK_FORWARD = 3;
      var Keyframe = function Keyframe() {
        this.time = 0;
        this.value = 0;
        this.inTangent = 0;
        this.outTangent = 0;
      };
      CCClass.fastDefine('cc.Keyframe', Keyframe, {
        time: 0,
        value: 0,
        inTangent: 0,
        outTangent: 0
      });
      var OptimizedKey = function () {
        function OptimizedKey() {
          this.index = void 0;
          this.time = void 0;
          this.endTime = void 0;
          this.coefficient = void 0;
          this.index = -1;
          this.time = 0;
          this.endTime = 0;
          this.coefficient = new Float32Array(4);
        }

        var _proto = OptimizedKey.prototype;

        _proto.evaluate = function evaluate(T) {
          var t = T - this.time;
          return evalOptCurve(t, this.coefficient);
        };

        return OptimizedKey;
      }();
      function evalOptCurve(t, coefs) {
        return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
      }
      var AnimationCurve = function () {
        function AnimationCurve(keyFrames) {
          if (keyFrames === void 0) {
            keyFrames = null;
          }

          this.cachedKey = void 0;

          if (keyFrames instanceof RealCurve) {
            this._curve = keyFrames;
          } else {
            var curve = new RealCurve();
            this._curve = curve;
            curve.preExtrapolation = ExtrapolationMode.LOOP;
            curve.postExtrapolation = ExtrapolationMode.CLAMP;

            if (!keyFrames) {
              curve.assignSorted([[0.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }], [1.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }]]);
            } else {
              curve.assignSorted(keyFrames.map(function (legacyKeyframe) {
                return [legacyKeyframe.time, {
                  interpolationMode: RealInterpolationMode.CUBIC,
                  value: legacyKeyframe.value,
                  leftTangent: legacyKeyframe.inTangent,
                  rightTangent: legacyKeyframe.outTangent
                }];
              }));
            }
          }

          this.cachedKey = new OptimizedKey();
        }

        var _proto2 = AnimationCurve.prototype;

        _proto2.addKey = function addKey(keyFrame) {
          if (!keyFrame) {
            this._curve.clear();
          } else {
            this._curve.addKeyFrame(keyFrame.time, {
              interpolationMode: RealInterpolationMode.CUBIC,
              value: keyFrame.value,
              leftTangent: keyFrame.inTangent,
              rightTangent: keyFrame.outTangent
            });
          }
        };

        _proto2.evaluate_slow = function evaluate_slow(time) {
          return this._curve.evaluate(time);
        };

        _proto2.evaluate = function evaluate(time) {
          var cachedKey = this.cachedKey,
              curve = this._curve;
          var nKeyframes = curve.keyFramesCount;
          var lastKeyframeIndex = nKeyframes - 1;
          var wrappedTime = time;
          var extrapolationMode = time < 0 ? curve.preExtrapolation : curve.postExtrapolation;
          var startTime = curve.getKeyframeTime(0);
          var endTime = curve.getKeyframeTime(lastKeyframeIndex);

          switch (extrapolationMode) {
            case ExtrapolationMode.LOOP:
              wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
              break;

            case ExtrapolationMode.PING_PONG:
              wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
              break;

            case ExtrapolationMode.CLAMP:
            default:
              wrappedTime = clamp(time, startTime, endTime);
              break;
          }

          if (wrappedTime >= cachedKey.time && wrappedTime < cachedKey.endTime) {
            return cachedKey.evaluate(wrappedTime);
          }

          var leftIndex = this.findIndex(cachedKey, wrappedTime);
          var rightIndex = Math.min(leftIndex + 1, lastKeyframeIndex);
          this.calcOptimizedKey(cachedKey, leftIndex, rightIndex);
          return cachedKey.evaluate(wrappedTime);
        };

        _proto2.calcOptimizedKey = function calcOptimizedKey(optKey, leftIndex, rightIndex) {
          var lhsTime = this._curve.getKeyframeTime(leftIndex);

          var rhsTime = this._curve.getKeyframeTime(rightIndex);

          var _this$_curve$getKeyfr = this._curve.getKeyframeValue(leftIndex),
              lhsValue = _this$_curve$getKeyfr.value,
              lhsOutTangent = _this$_curve$getKeyfr.leftTangent;

          var _this$_curve$getKeyfr2 = this._curve.getKeyframeValue(rightIndex),
              rhsValue = _this$_curve$getKeyfr2.value,
              rhsInTangent = _this$_curve$getKeyfr2.rightTangent;

          optKey.index = leftIndex;
          optKey.time = lhsTime;
          optKey.endTime = rhsTime;
          var dx = rhsTime - lhsTime;
          var dy = rhsValue - lhsValue;
          var length = 1 / (dx * dx);
          var d1 = lhsOutTangent * dx;
          var d2 = rhsInTangent * dx;
          optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx;
          optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length;
          optKey.coefficient[2] = lhsOutTangent;
          optKey.coefficient[3] = lhsValue;
        };

        _proto2.findIndex = function findIndex(optKey, t) {
          var curve = this._curve;
          var nKeyframes = curve.keyFramesCount;
          var cachedIndex = optKey.index;

          if (cachedIndex !== -1) {
            var cachedTime = curve.getKeyframeTime(cachedIndex);

            if (t > cachedTime) {
              for (var i = 0; i < LOOK_FORWARD; i++) {
                var currIndex = cachedIndex + i;

                if (currIndex + 1 < nKeyframes && curve.getKeyframeTime(currIndex + 1) > t) {
                  return currIndex;
                }
              }
            } else {
              for (var _i = 0; _i < LOOK_FORWARD; _i++) {
                var _currIndex = cachedIndex - _i;

                if (_currIndex >= 0 && curve.getKeyframeTime(_currIndex - 1) <= t) {
                  return _currIndex - 1;
                }
              }
            }
          }

          var left = 0;
          var right = nKeyframes;
          var mid;

          while (right - left > 1) {
            mid = Math.floor((left + right) / 2);

            if (curve.getKeyframeTime(mid) >= t) {
              right = mid;
            } else {
              left = mid;
            }
          }

          return left;
        };

        _createClass(AnimationCurve, [{
          key: "_internalCurve",
          get: function get() {
            return this._curve;
          }
        }, {
          key: "keyFrames",
          get: function get() {
            return Array.from(this._curve.keyframes()).map(function (_ref) {
              var time = _ref[0],
                  value = _ref[1];
              var legacyKeyframe = new Keyframe();
              legacyKeyframe.time = time;
              legacyKeyframe.value = value.value;
              legacyKeyframe.inTangent = value.leftTangent;
              legacyKeyframe.outTangent = value.rightTangent;
              return legacyKeyframe;
            });
          },
          set: function set(value) {
            this._curve.assignSorted(value.map(function (legacyCurve) {
              return [legacyCurve.time, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: legacyCurve.value,
                leftTangent: legacyCurve.inTangent,
                rightTangent: legacyCurve.outTangent
              }];
            }));
          }
        }, {
          key: "preWrapMode",
          get: function get() {
            return toLegacyWrapMode(this._curve.preExtrapolation);
          },
          set: function set(value) {
            this._curve.preExtrapolation = fromLegacyWrapMode(value);
          }
        }, {
          key: "postWrapMode",
          get: function get() {
            return toLegacyWrapMode(this._curve.postExtrapolation);
          },
          set: function set(value) {
            this._curve.postExtrapolation = fromLegacyWrapMode(value);
          }
        }]);

        return AnimationCurve;
      }();
      AnimationCurve.defaultKF = [{
        time: 0,
        value: 1,
        inTangent: 0,
        outTangent: 0
      }, {
        time: 1,
        value: 1,
        inTangent: 0,
        outTangent: 0
      }];
      CCClass.fastDefine('cc.AnimationCurve', AnimationCurve, {
        _curve: null
      });

      function fromLegacyWrapMode(legacyWrapMode) {
        switch (legacyWrapMode) {
          default:
          case WrapModeMask.Default:
          case WrapModeMask.Normal:
          case WrapModeMask.Clamp:
            return ExtrapolationMode.CLAMP;

          case WrapModeMask.PingPong:
            return ExtrapolationMode.PING_PONG;

          case WrapModeMask.Loop:
            return ExtrapolationMode.LOOP;
        }
      }

      function toLegacyWrapMode(extrapolationMode) {
        switch (extrapolationMode) {
          default:
          case ExtrapolationMode.LINEAR:
          case ExtrapolationMode.CLAMP:
            return WrapModeMask.Clamp;

          case ExtrapolationMode.PING_PONG:
            return WrapModeMask.PingPong;

          case ExtrapolationMode.LOOP:
            return WrapModeMask.Loop;
        }
      }

      replaceProperty(intersect, 'intersect', [{
        name: 'ray_aabb',
        newName: 'rayAABB'
      }, {
        name: 'ray_plane',
        newName: 'rayPlane'
      }, {
        name: 'ray_triangle',
        newName: 'rayTriangle'
      }, {
        name: 'ray_sphere',
        newName: 'raySphere'
      }, {
        name: 'ray_obb',
        newName: 'rayOBB'
      }, {
        name: 'ray_capsule',
        newName: 'rayCapsule'
      }, {
        name: 'ray_subMesh',
        newName: 'raySubMesh'
      }, {
        name: 'ray_mesh',
        newName: 'rayMesh'
      }, {
        name: 'ray_model',
        newName: 'rayModel'
      }, {
        name: 'line_plane',
        newName: 'linePlane'
      }, {
        name: 'line_triangle',
        newName: 'lineTriangle'
      }, {
        name: 'line_aabb',
        newName: 'lineAABB'
      }, {
        name: 'line_obb',
        newName: 'lineOBB'
      }, {
        name: 'line_sphere',
        newName: 'lineSphere'
      }, {
        name: 'aabb_aabb',
        newName: 'aabbWithAABB'
      }, {
        name: 'aabb_obb',
        newName: 'aabbWithOBB'
      }, {
        name: 'aabb_plane',
        newName: 'aabbPlane'
      }, {
        name: 'aabb_frustum',
        newName: 'aabbFrustum'
      }, {
        name: 'aabbFrustum_accurate',
        newName: 'aabbFrustumAccurate'
      }, {
        name: 'obb_point',
        newName: 'obbPoint'
      }, {
        name: 'obb_plane',
        newName: 'obbPlane'
      }, {
        name: 'obb_frustum',
        newName: 'obbFrustum'
      }, {
        name: 'obbFrustum_accurate',
        newName: 'obbFrustumAccurate'
      }, {
        name: 'obb_obb',
        newName: 'obbWithOBB'
      }, {
        name: 'obb_capsule',
        newName: 'obbCapsule'
      }, {
        name: 'sphere_plane',
        newName: 'spherePlane'
      }, {
        name: 'sphere_frustum',
        newName: 'sphereFrustum'
      }, {
        name: 'sphereFrustum_accurate',
        newName: 'sphereFrustumAccurate'
      }, {
        name: 'sphere_sphere',
        newName: 'sphereWithSphere'
      }, {
        name: 'sphere_aabb',
        newName: 'sphereAABB'
      }, {
        name: 'sphere_obb',
        newName: 'sphereOBB'
      }, {
        name: 'sphere_capsule',
        newName: 'sphereCapsule'
      }, {
        name: 'capsule_capsule',
        newName: 'capsuleWithCapsule'
      }]);

      function deprecatedClassMessage(oldClassName, newClassName) {
        console.warn(oldClassName + " is deprecated, please use " + newClassName + " instead.");
      }

      var line = function (_Line) {
        _inheritsLoose(line, _Line);

        function line() {
          var _this;

          _this = _Line.call(this) || this;
          deprecatedClassMessage('line', 'Line');
          return _this;
        }

        return line;
      }(Line);
      var plane = function (_Plane) {
        _inheritsLoose(plane, _Plane);

        function plane() {
          var _this2;

          _this2 = _Plane.call(this) || this;
          deprecatedClassMessage('plane', 'Plane');
          return _this2;
        }

        return plane;
      }(Plane);
      var ray = function (_Ray) {
        _inheritsLoose(ray, _Ray);

        function ray() {
          var _this3;

          _this3 = _Ray.call(this) || this;
          deprecatedClassMessage('ray', 'Ray');
          return _this3;
        }

        return ray;
      }(Ray);
      var triangle = function (_Triangle) {
        _inheritsLoose(triangle, _Triangle);

        function triangle() {
          var _this4;

          _this4 = _Triangle.call(this) || this;
          deprecatedClassMessage('triangle', 'Triangle');
          return _this4;
        }

        return triangle;
      }(Triangle);
      var sphere = function (_Sphere) {
        _inheritsLoose(sphere, _Sphere);

        function sphere() {
          var _this5;

          _this5 = _Sphere.call(this) || this;
          deprecatedClassMessage('sphere', 'Sphere');
          return _this5;
        }

        return sphere;
      }(Sphere);
      var aabb = function (_AABB) {
        _inheritsLoose(aabb, _AABB);

        function aabb() {
          var _this6;

          _this6 = _AABB.call(this) || this;
          deprecatedClassMessage('aabb', 'AABB');
          return _this6;
        }

        return aabb;
      }(AABB);
      var obb = function (_OBB) {
        _inheritsLoose(obb, _OBB);

        function obb() {
          var _this7;

          _this7 = _OBB.call(this) || this;
          deprecatedClassMessage('obb', 'OBB');
          return _this7;
        }

        return obb;
      }(OBB);
      var capsule = function (_Capsule) {
        _inheritsLoose(capsule, _Capsule);

        function capsule() {
          var _this8;

          _this8 = _Capsule.call(this) || this;
          deprecatedClassMessage('capsule', 'Capsule');
          return _this8;
        }

        return capsule;
      }(Capsule);
      var frustum = function (_Frustum) {
        _inheritsLoose(frustum, _Frustum);

        function frustum() {
          var _this9;

          _this9 = _Frustum.call(this) || this;
          deprecatedClassMessage('frustum', 'Frustum');
          return _this9;
        }

        return frustum;
      }(Frustum);

      var geometry = /*#__PURE__*/Object.freeze({
        __proto__: null,
        distance: distance,
        enums: enums,
        intersect: intersect,
        Line: Line,
        Plane: Plane,
        Ray: Ray,
        Triangle: Triangle,
        Sphere: Sphere,
        AABB: AABB,
        OBB: OBB,
        Capsule: Capsule,
        Frustum: Frustum,
        Keyframe: Keyframe,
        AnimationCurve: AnimationCurve,
        get ERaycastMode () { return ERaycastMode; },
        line: line,
        plane: plane,
        ray: ray,
        triangle: triangle,
        sphere: sphere,
        aabb: aabb,
        obb: obb,
        capsule: capsule,
        frustum: frustum
      });
      exports('geometry', geometry);

      var layerList = {
        NONE: 0,
        IGNORE_RAYCAST: 1 << 20,
        GIZMOS: 1 << 21,
        EDITOR: 1 << 22,
        UI_3D: 1 << 23,
        SCENE_GIZMO: 1 << 24,
        UI_2D: 1 << 25,
        PROFILER: 1 << 28,
        DEFAULT: 1 << 30,
        ALL: 0xffffffff
      };
      var Layers = exports('Layers', function () {
        function Layers() {}

        Layers.makeMaskInclude = function makeMaskInclude(includes) {
          var mask = 0;

          for (var _iterator = _createForOfIteratorHelperLoose(includes), _step; !(_step = _iterator()).done;) {
            var inc = _step.value;
            mask |= inc;
          }

          return mask;
        };

        Layers.makeMaskExclude = function makeMaskExclude(excludes) {
          return ~Layers.makeMaskInclude(excludes);
        };

        Layers.addLayer = function addLayer(name, bitNum) {
          if (bitNum === undefined) {
            console.warn('bitNum can\'t be undefined');
            return;
          }

          if (bitNum > 19 || bitNum < 0) {
            console.warn('maximum layers reached.');
            return;
          }

          var val = 1 << bitNum;
          assertIsTrue(!Layers.Enum[name], getError(2104, name));
          Layers.Enum[name] = val;
          js.value(Layers.Enum, String(val), name);
          Layers.BitMask[name] = val;
          js.value(Layers.BitMask, String(val), name);
        };

        Layers.deleteLayer = function deleteLayer(bitNum) {
          if (bitNum > 19 || bitNum < 0) {
            console.warn('do not change buildin layers.');
            return;
          }

          var val = 1 << bitNum;
          delete Layers.Enum[Layers.Enum[val]];
          delete Layers.Enum[val];
          delete Layers.BitMask[Layers.BitMask[val]];
          delete Layers.BitMask[val];
        };

        Layers.nameToLayer = function nameToLayer(name) {
          if (name === undefined) {
            console.warn('name can\'t be undefined');
            return -1;
          }

          return log2(Layers.Enum[name]);
        };

        Layers.layerToName = function layerToName(bitNum) {
          if (bitNum > 31 || bitNum < 0) {
            console.warn('Unable to access unknown layer.');
            return '';
          }

          return Layers.Enum[1 << bitNum];
        };

        return Layers;
      }());
      Layers.Enum = Enum(layerList);
      Layers.BitMask = BitMask(_extends({}, layerList));
      legacyCC.Layers = Layers;

      var PIPELINE_FLOW_MAIN = 'MainFlow';
      var PIPELINE_FLOW_FORWARD = 'ForwardFlow';
      var PIPELINE_FLOW_SHADOW = 'ShadowFlow';
      var PIPELINE_FLOW_SMAA = 'SMAAFlow';
      var PIPELINE_FLOW_TONEMAP = 'ToneMapFlow';
      var RenderPassStage;

      (function (RenderPassStage) {
        RenderPassStage[RenderPassStage["DEFAULT"] = 100] = "DEFAULT";
        RenderPassStage[RenderPassStage["UI"] = 200] = "UI";
      })(RenderPassStage || (RenderPassStage = {}));

      legacyCC.RenderPassStage = RenderPassStage;
      var RenderPriority;

      (function (RenderPriority) {
        RenderPriority[RenderPriority["MIN"] = 0] = "MIN";
        RenderPriority[RenderPriority["MAX"] = 255] = "MAX";
        RenderPriority[RenderPriority["DEFAULT"] = 128] = "DEFAULT";
      })(RenderPriority || (RenderPriority = {}));

      var globalDescriptorSetLayout = {
        bindings: [],
        layouts: {}
      };
      var localDescriptorSetLayout = {
        bindings: [],
        layouts: {}
      };
      var PipelineGlobalBindings;

      (function (PipelineGlobalBindings) {
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_GLOBAL"] = 0] = "UBO_GLOBAL";
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_CAMERA"] = 1] = "UBO_CAMERA";
        PipelineGlobalBindings[PipelineGlobalBindings["UBO_SHADOW"] = 2] = "UBO_SHADOW";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SHADOWMAP"] = 3] = "SAMPLER_SHADOWMAP";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_ENVIRONMENT"] = 4] = "SAMPLER_ENVIRONMENT";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SPOT_LIGHTING_MAP"] = 5] = "SAMPLER_SPOT_LIGHTING_MAP";
        PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_DIFFUSEMAP"] = 6] = "SAMPLER_DIFFUSEMAP";
        PipelineGlobalBindings[PipelineGlobalBindings["COUNT"] = 7] = "COUNT";
      })(PipelineGlobalBindings || (PipelineGlobalBindings = {}));

      var GLOBAL_UBO_COUNT = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
      var GLOBAL_SAMPLER_COUNT = PipelineGlobalBindings.COUNT - GLOBAL_UBO_COUNT;
      var ModelLocalBindings;

      (function (ModelLocalBindings) {
        ModelLocalBindings[ModelLocalBindings["UBO_LOCAL"] = 0] = "UBO_LOCAL";
        ModelLocalBindings[ModelLocalBindings["UBO_FORWARD_LIGHTS"] = 1] = "UBO_FORWARD_LIGHTS";
        ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_ANIMATION"] = 2] = "UBO_SKINNING_ANIMATION";
        ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_TEXTURE"] = 3] = "UBO_SKINNING_TEXTURE";
        ModelLocalBindings[ModelLocalBindings["UBO_MORPH"] = 4] = "UBO_MORPH";
        ModelLocalBindings[ModelLocalBindings["UBO_UI_LOCAL"] = 5] = "UBO_UI_LOCAL";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_JOINTS"] = 6] = "SAMPLER_JOINTS";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_POSITION"] = 7] = "SAMPLER_MORPH_POSITION";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_NORMAL"] = 8] = "SAMPLER_MORPH_NORMAL";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_TANGENT"] = 9] = "SAMPLER_MORPH_TANGENT";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_LIGHTMAP"] = 10] = "SAMPLER_LIGHTMAP";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_SPRITE"] = 11] = "SAMPLER_SPRITE";
        ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION"] = 12] = "SAMPLER_REFLECTION";
        ModelLocalBindings[ModelLocalBindings["STORAGE_REFLECTION"] = 13] = "STORAGE_REFLECTION";
        ModelLocalBindings[ModelLocalBindings["COUNT"] = 14] = "COUNT";
      })(ModelLocalBindings || (ModelLocalBindings = {}));

      var LOCAL_UBO_COUNT = ModelLocalBindings.SAMPLER_JOINTS;
      var LOCAL_SAMPLER_COUNT = ModelLocalBindings.STORAGE_REFLECTION - LOCAL_UBO_COUNT;
      var LOCAL_STORAGE_IMAGE_COUNT = ModelLocalBindings.COUNT - LOCAL_UBO_COUNT - LOCAL_SAMPLER_COUNT;
      var SetIndex;

      (function (SetIndex) {
        SetIndex[SetIndex["GLOBAL"] = 0] = "GLOBAL";
        SetIndex[SetIndex["MATERIAL"] = 1] = "MATERIAL";
        SetIndex[SetIndex["LOCAL"] = 2] = "LOCAL";
      })(SetIndex || (SetIndex = {}));

      var bindingMappingInfo = new BindingMappingInfo([GLOBAL_UBO_COUNT, 0, LOCAL_UBO_COUNT], [GLOBAL_SAMPLER_COUNT, 0, LOCAL_SAMPLER_COUNT], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, LOCAL_STORAGE_IMAGE_COUNT], [0, 0, 0], [0, 2, 1]);
      var UBOGlobal = function UBOGlobal() {};
      UBOGlobal.TIME_OFFSET = 0;
      UBOGlobal.NATIVE_SIZE_OFFSET = UBOGlobal.TIME_OFFSET + 4;
      UBOGlobal.SCREEN_SIZE_OFFSET = UBOGlobal.NATIVE_SIZE_OFFSET + 4;
      UBOGlobal.COUNT = UBOGlobal.SCREEN_SIZE_OFFSET + 4;
      UBOGlobal.SIZE = UBOGlobal.COUNT * 4;
      UBOGlobal.NAME = 'CCGlobal';
      UBOGlobal.BINDING = PipelineGlobalBindings.UBO_GLOBAL;
      UBOGlobal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOGlobal.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
      UBOGlobal.LAYOUT = new UniformBlock(SetIndex.GLOBAL, UBOGlobal.BINDING, UBOGlobal.NAME, [new Uniform('cc_time', Type.FLOAT4, 1), new Uniform('cc_screenSize', Type.FLOAT4, 1), new Uniform('cc_nativeSize', Type.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOGlobal.NAME] = UBOGlobal.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOGlobal.BINDING] = UBOGlobal.DESCRIPTOR;
      var UBOCamera = function UBOCamera() {};
      UBOCamera.MAT_VIEW_OFFSET = 0;
      UBOCamera.MAT_VIEW_INV_OFFSET = UBOCamera.MAT_VIEW_OFFSET + 16;
      UBOCamera.MAT_PROJ_OFFSET = UBOCamera.MAT_VIEW_INV_OFFSET + 16;
      UBOCamera.MAT_PROJ_INV_OFFSET = UBOCamera.MAT_PROJ_OFFSET + 16;
      UBOCamera.MAT_VIEW_PROJ_OFFSET = UBOCamera.MAT_PROJ_INV_OFFSET + 16;
      UBOCamera.MAT_VIEW_PROJ_INV_OFFSET = UBOCamera.MAT_VIEW_PROJ_OFFSET + 16;
      UBOCamera.CAMERA_POS_OFFSET = UBOCamera.MAT_VIEW_PROJ_INV_OFFSET + 16;
      UBOCamera.SCREEN_SCALE_OFFSET = UBOCamera.CAMERA_POS_OFFSET + 4;
      UBOCamera.EXPOSURE_OFFSET = UBOCamera.SCREEN_SCALE_OFFSET + 4;
      UBOCamera.MAIN_LIT_DIR_OFFSET = UBOCamera.EXPOSURE_OFFSET + 4;
      UBOCamera.MAIN_LIT_COLOR_OFFSET = UBOCamera.MAIN_LIT_DIR_OFFSET + 4;
      UBOCamera.AMBIENT_SKY_OFFSET = UBOCamera.MAIN_LIT_COLOR_OFFSET + 4;
      UBOCamera.AMBIENT_GROUND_OFFSET = UBOCamera.AMBIENT_SKY_OFFSET + 4;
      UBOCamera.GLOBAL_FOG_COLOR_OFFSET = UBOCamera.AMBIENT_GROUND_OFFSET + 4;
      UBOCamera.GLOBAL_FOG_BASE_OFFSET = UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 4;
      UBOCamera.GLOBAL_FOG_ADD_OFFSET = UBOCamera.GLOBAL_FOG_BASE_OFFSET + 4;
      UBOCamera.NEAR_FAR_OFFSET = UBOCamera.GLOBAL_FOG_ADD_OFFSET + 4;
      UBOCamera.VIEW_PORT_OFFSET = UBOCamera.NEAR_FAR_OFFSET + 4;
      UBOCamera.COUNT = UBOCamera.VIEW_PORT_OFFSET + 4;
      UBOCamera.SIZE = UBOCamera.COUNT * 4;
      UBOCamera.NAME = 'CCCamera';
      UBOCamera.BINDING = PipelineGlobalBindings.UBO_CAMERA;
      UBOCamera.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOCamera.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
      UBOCamera.LAYOUT = new UniformBlock(SetIndex.GLOBAL, UBOCamera.BINDING, UBOCamera.NAME, [new Uniform('cc_matView', Type.MAT4, 1), new Uniform('cc_matViewInv', Type.MAT4, 1), new Uniform('cc_matProj', Type.MAT4, 1), new Uniform('cc_matProjInv', Type.MAT4, 1), new Uniform('cc_matViewProj', Type.MAT4, 1), new Uniform('cc_matViewProjInv', Type.MAT4, 1), new Uniform('cc_cameraPos', Type.FLOAT4, 1), new Uniform('cc_screenScale', Type.FLOAT4, 1), new Uniform('cc_exposure', Type.FLOAT4, 1), new Uniform('cc_mainLitDir', Type.FLOAT4, 1), new Uniform('cc_mainLitColor', Type.FLOAT4, 1), new Uniform('cc_ambientSky', Type.FLOAT4, 1), new Uniform('cc_ambientGround', Type.FLOAT4, 1), new Uniform('cc_fogColor', Type.FLOAT4, 1), new Uniform('cc_fogBase', Type.FLOAT4, 1), new Uniform('cc_fogAdd', Type.FLOAT4, 1), new Uniform('cc_nearFar', Type.FLOAT4, 1), new Uniform('cc_viewPort', Type.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOCamera.NAME] = UBOCamera.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOCamera.BINDING] = UBOCamera.DESCRIPTOR;
      var UBOShadow = function UBOShadow() {};
      UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0;
      UBOShadow.MAT_LIGHT_VIEW_OFFSET = UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET + 16;
      UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET = UBOShadow.MAT_LIGHT_VIEW_OFFSET + 16;
      UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET = UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET + 16;
      UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET = UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 4;
      UBOShadow.SHADOW_PROJ_INFO_OFFSET = UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 4;
      UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET = UBOShadow.SHADOW_PROJ_INFO_OFFSET + 4;
      UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET = UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 4;
      UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET = UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 4;
      UBOShadow.SHADOW_COLOR_OFFSET = UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 4;
      UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET = UBOShadow.SHADOW_COLOR_OFFSET + 4;
      UBOShadow.COUNT = UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 4;
      UBOShadow.SIZE = UBOShadow.COUNT * 4;
      UBOShadow.NAME = 'CCShadow';
      UBOShadow.BINDING = PipelineGlobalBindings.UBO_SHADOW;
      UBOShadow.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOShadow.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
      UBOShadow.LAYOUT = new UniformBlock(SetIndex.GLOBAL, UBOShadow.BINDING, UBOShadow.NAME, [new Uniform('cc_matLightPlaneProj', Type.MAT4, 1), new Uniform('cc_matLightView', Type.MAT4, 1), new Uniform('cc_matLightViewProj', Type.MAT4, 1), new Uniform('cc_shadowInvProjDepthInfo', Type.FLOAT4, 1), new Uniform('cc_shadowProjDepthInfo', Type.FLOAT4, 1), new Uniform('cc_shadowProjInfo', Type.FLOAT4, 1), new Uniform('cc_shadowNFLSInfo', Type.FLOAT4, 1), new Uniform('cc_shadowWHPBInfo', Type.FLOAT4, 1), new Uniform('cc_shadowLPNNInfo', Type.FLOAT4, 1), new Uniform('cc_shadowColor', Type.FLOAT4, 1), new Uniform('cc_planarNDInfo', Type.FLOAT4, 1)], 1);
      globalDescriptorSetLayout.layouts[UBOShadow.NAME] = UBOShadow.LAYOUT;
      globalDescriptorSetLayout.bindings[UBOShadow.BINDING] = UBOShadow.DESCRIPTOR;
      var UNIFORM_SHADOWMAP_NAME = 'cc_shadowMap';
      var UNIFORM_SHADOWMAP_BINDING = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
      var UNIFORM_SHADOWMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SHADOWMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      var UNIFORM_SHADOWMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SHADOWMAP_BINDING, UNIFORM_SHADOWMAP_NAME, Type.SAMPLER2D, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_SHADOWMAP_NAME] = UNIFORM_SHADOWMAP_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_SHADOWMAP_BINDING] = UNIFORM_SHADOWMAP_DESCRIPTOR;
      var UNIFORM_ENVIRONMENT_NAME = 'cc_environment';
      var UNIFORM_ENVIRONMENT_BINDING = PipelineGlobalBindings.SAMPLER_ENVIRONMENT;
      var UNIFORM_ENVIRONMENT_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_ENVIRONMENT_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      var UNIFORM_ENVIRONMENT_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_ENVIRONMENT_BINDING, UNIFORM_ENVIRONMENT_NAME, Type.SAMPLER_CUBE, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_ENVIRONMENT_NAME] = UNIFORM_ENVIRONMENT_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_ENVIRONMENT_BINDING] = UNIFORM_ENVIRONMENT_DESCRIPTOR;
      var UNIFORM_DIFFUSEMAP_NAME = 'cc_diffuseMap';
      var UNIFORM_DIFFUSEMAP_BINDING = PipelineGlobalBindings.SAMPLER_DIFFUSEMAP;
      var UNIFORM_DIFFUSEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_DIFFUSEMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      var UNIFORM_DIFFUSEMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_DIFFUSEMAP_BINDING, UNIFORM_DIFFUSEMAP_NAME, Type.SAMPLER_CUBE, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_DIFFUSEMAP_NAME] = UNIFORM_DIFFUSEMAP_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_DIFFUSEMAP_BINDING] = UNIFORM_DIFFUSEMAP_DESCRIPTOR;
      var UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME = 'cc_spotLightingMap';
      var UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING = PipelineGlobalBindings.SAMPLER_SPOT_LIGHTING_MAP;
      var UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      var UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME, Type.SAMPLER2D, 1);
      globalDescriptorSetLayout.layouts[UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME] = UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_LAYOUT;
      globalDescriptorSetLayout.bindings[UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING] = UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_DESCRIPTOR;
      var UBOLocal = function UBOLocal() {};
      UBOLocal.MAT_WORLD_OFFSET = 0;
      UBOLocal.MAT_WORLD_IT_OFFSET = UBOLocal.MAT_WORLD_OFFSET + 16;
      UBOLocal.LIGHTINGMAP_UVPARAM = UBOLocal.MAT_WORLD_IT_OFFSET + 16;
      UBOLocal.LOCAL_SHADOW_BIAS = UBOLocal.LIGHTINGMAP_UVPARAM + 4;
      UBOLocal.COUNT = UBOLocal.LOCAL_SHADOW_BIAS + 4;
      UBOLocal.SIZE = UBOLocal.COUNT * 4;
      UBOLocal.NAME = 'CCLocal';
      UBOLocal.BINDING = ModelLocalBindings.UBO_LOCAL;
      UBOLocal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOLocal.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
      UBOLocal.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOLocal.BINDING, UBOLocal.NAME, [new Uniform('cc_matWorld', Type.MAT4, 1), new Uniform('cc_matWorldIT', Type.MAT4, 1), new Uniform('cc_lightingMapUVParam', Type.FLOAT4, 1), new Uniform('cc_localShadowBias', Type.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOLocal.NAME] = UBOLocal.LAYOUT;
      localDescriptorSetLayout.bindings[UBOLocal.BINDING] = UBOLocal.DESCRIPTOR;
      var UBOWorldBound = function UBOWorldBound() {};
      UBOWorldBound.WORLD_BOUND_CENTER = 0;
      UBOWorldBound.WORLD_BOUND_HALF_EXTENTS = UBOWorldBound.WORLD_BOUND_CENTER + 4;
      UBOWorldBound.COUNT = UBOWorldBound.WORLD_BOUND_HALF_EXTENTS + 4;
      UBOWorldBound.SIZE = UBOWorldBound.COUNT * 4;
      UBOWorldBound.NAME = 'CCWorldBound';
      UBOWorldBound.BINDING = ModelLocalBindings.UBO_LOCAL;
      UBOWorldBound.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOWorldBound.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
      UBOWorldBound.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOWorldBound.BINDING, UBOWorldBound.NAME, [new Uniform('cc_worldBoundCenter', Type.FLOAT4, 1), new Uniform('cc_worldBoundHalfExtents', Type.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOWorldBound.NAME] = UBOWorldBound.LAYOUT;
      localDescriptorSetLayout.bindings[UBOWorldBound.BINDING] = UBOWorldBound.DESCRIPTOR;
      var INST_MAT_WORLD = 'a_matWorld0';
      var UBOLocalBatched = function UBOLocalBatched() {};
      UBOLocalBatched.BATCHING_COUNT = 10;
      UBOLocalBatched.MAT_WORLDS_OFFSET = 0;
      UBOLocalBatched.COUNT = 16 * UBOLocalBatched.BATCHING_COUNT;
      UBOLocalBatched.SIZE = UBOLocalBatched.COUNT * 4;
      UBOLocalBatched.NAME = 'CCLocalBatched';
      UBOLocalBatched.BINDING = ModelLocalBindings.UBO_LOCAL;
      UBOLocalBatched.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOLocalBatched.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
      UBOLocalBatched.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOLocalBatched.BINDING, UBOLocalBatched.NAME, [new Uniform('cc_matWorlds', Type.MAT4, UBOLocalBatched.BATCHING_COUNT)], 1);
      localDescriptorSetLayout.layouts[UBOLocalBatched.NAME] = UBOLocalBatched.LAYOUT;
      localDescriptorSetLayout.bindings[UBOLocalBatched.BINDING] = UBOLocalBatched.DESCRIPTOR;
      var UBOForwardLight = function UBOForwardLight() {};
      UBOForwardLight.LIGHTS_PER_PASS = 1;
      UBOForwardLight.LIGHT_POS_OFFSET = 0;
      UBOForwardLight.LIGHT_COLOR_OFFSET = UBOForwardLight.LIGHT_POS_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
      UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET = UBOForwardLight.LIGHT_COLOR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
      UBOForwardLight.LIGHT_DIR_OFFSET = UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
      UBOForwardLight.COUNT = UBOForwardLight.LIGHT_DIR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
      UBOForwardLight.SIZE = UBOForwardLight.COUNT * 4;
      UBOForwardLight.NAME = 'CCForwardLight';
      UBOForwardLight.BINDING = ModelLocalBindings.UBO_FORWARD_LIGHTS;
      UBOForwardLight.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOForwardLight.BINDING, DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, ShaderStageFlagBit.FRAGMENT);
      UBOForwardLight.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOForwardLight.BINDING, UBOForwardLight.NAME, [new Uniform('cc_lightPos', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightColor', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightSizeRangeAngle', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightDir', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS)], 1);
      localDescriptorSetLayout.layouts[UBOForwardLight.NAME] = UBOForwardLight.LAYOUT;
      localDescriptorSetLayout.bindings[UBOForwardLight.BINDING] = UBOForwardLight.DESCRIPTOR;
      var UBODeferredLight = function UBODeferredLight() {};
      UBODeferredLight.LIGHTS_PER_PASS = 10;
      var JOINT_UNIFORM_CAPACITY = 30;
      var UBOSkinningTexture = function UBOSkinningTexture() {};
      UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0;
      UBOSkinningTexture.COUNT = UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET + 4;
      UBOSkinningTexture.SIZE = UBOSkinningTexture.COUNT * 4;
      UBOSkinningTexture.NAME = 'CCSkinningTexture';
      UBOSkinningTexture.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
      UBOSkinningTexture.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinningTexture.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOSkinningTexture.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOSkinningTexture.BINDING, UBOSkinningTexture.NAME, [new Uniform('cc_jointTextureInfo', Type.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOSkinningTexture.NAME] = UBOSkinningTexture.LAYOUT;
      localDescriptorSetLayout.bindings[UBOSkinningTexture.BINDING] = UBOSkinningTexture.DESCRIPTOR;
      var UBOSkinningAnimation = function UBOSkinningAnimation() {};
      UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0;
      UBOSkinningAnimation.COUNT = UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET + 4;
      UBOSkinningAnimation.SIZE = UBOSkinningAnimation.COUNT * 4;
      UBOSkinningAnimation.NAME = 'CCSkinningAnimation';
      UBOSkinningAnimation.BINDING = ModelLocalBindings.UBO_SKINNING_ANIMATION;
      UBOSkinningAnimation.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinningAnimation.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOSkinningAnimation.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOSkinningAnimation.BINDING, UBOSkinningAnimation.NAME, [new Uniform('cc_jointAnimInfo', Type.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOSkinningAnimation.NAME] = UBOSkinningAnimation.LAYOUT;
      localDescriptorSetLayout.bindings[UBOSkinningAnimation.BINDING] = UBOSkinningAnimation.DESCRIPTOR;
      var INST_JOINT_ANIM_INFO = 'a_jointAnimInfo';
      var UBOSkinning = function UBOSkinning() {};
      UBOSkinning.JOINTS_OFFSET = 0;
      UBOSkinning.COUNT = UBOSkinning.JOINTS_OFFSET + JOINT_UNIFORM_CAPACITY * 12;
      UBOSkinning.SIZE = UBOSkinning.COUNT * 4;
      UBOSkinning.NAME = 'CCSkinning';
      UBOSkinning.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
      UBOSkinning.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinning.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOSkinning.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOSkinning.BINDING, UBOSkinning.NAME, [new Uniform('cc_joints', Type.FLOAT4, JOINT_UNIFORM_CAPACITY * 3)], 1);
      localDescriptorSetLayout.layouts[UBOSkinning.NAME] = UBOSkinning.LAYOUT;
      localDescriptorSetLayout.bindings[UBOSkinning.BINDING] = UBOSkinning.DESCRIPTOR;
      var UBOMorph = function UBOMorph() {};
      UBOMorph.MAX_MORPH_TARGET_COUNT = 60;
      UBOMorph.OFFSET_OF_WEIGHTS = 0;
      UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 4 * UBOMorph.MAX_MORPH_TARGET_COUNT;
      UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH + 4;
      UBOMorph.OFFSET_OF_VERTICES_COUNT = UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT + 4;
      UBOMorph.COUNT_BASE_4_BYTES = 4 * Math.ceil(UBOMorph.MAX_MORPH_TARGET_COUNT / 4) + 4;
      UBOMorph.SIZE = UBOMorph.COUNT_BASE_4_BYTES * 4;
      UBOMorph.NAME = 'CCMorph';
      UBOMorph.BINDING = ModelLocalBindings.UBO_MORPH;
      UBOMorph.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOMorph.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOMorph.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOMorph.BINDING, UBOMorph.NAME, [new Uniform('cc_displacementWeights', Type.FLOAT4, UBOMorph.MAX_MORPH_TARGET_COUNT / 4), new Uniform('cc_displacementTextureInfo', Type.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOMorph.NAME] = UBOMorph.LAYOUT;
      localDescriptorSetLayout.bindings[UBOMorph.BINDING] = UBOMorph.DESCRIPTOR;
      var UBOUILocal = function UBOUILocal() {};
      UBOUILocal.NAME = 'CCUILocal';
      UBOUILocal.BINDING = ModelLocalBindings.UBO_UI_LOCAL;
      UBOUILocal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOUILocal.BINDING, DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
      UBOUILocal.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOUILocal.BINDING, UBOUILocal.NAME, [new Uniform('cc_local_data', Type.FLOAT4, 1)], 1);
      localDescriptorSetLayout.layouts[UBOUILocal.NAME] = UBOUILocal.LAYOUT;
      localDescriptorSetLayout.bindings[UBOUILocal.BINDING] = UBOUILocal.DESCRIPTOR;
      var UNIFORM_JOINT_TEXTURE_NAME = 'cc_jointTexture';
      var UNIFORM_JOINT_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_JOINTS;
      var UNIFORM_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_JOINT_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      var UNIFORM_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_JOINT_TEXTURE_BINDING, UNIFORM_JOINT_TEXTURE_NAME, Type.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_JOINT_TEXTURE_NAME] = UNIFORM_JOINT_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_JOINT_TEXTURE_BINDING] = UNIFORM_JOINT_TEXTURE_DESCRIPTOR;
      var UNIFORM_POSITION_MORPH_TEXTURE_NAME = 'cc_PositionDisplacements';
      var UNIFORM_POSITION_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_POSITION;
      var UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_POSITION_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      var UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_POSITION_MORPH_TEXTURE_BINDING, UNIFORM_POSITION_MORPH_TEXTURE_NAME, Type.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_POSITION_MORPH_TEXTURE_NAME] = UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_POSITION_MORPH_TEXTURE_BINDING] = UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR;
      var UNIFORM_NORMAL_MORPH_TEXTURE_NAME = 'cc_NormalDisplacements';
      var UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_NORMAL;
      var UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      var UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, UNIFORM_NORMAL_MORPH_TEXTURE_NAME, Type.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_NORMAL_MORPH_TEXTURE_NAME] = UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_NORMAL_MORPH_TEXTURE_BINDING] = UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR;
      var UNIFORM_TANGENT_MORPH_TEXTURE_NAME = 'cc_TangentDisplacements';
      var UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_TANGENT;
      var UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
      var UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, UNIFORM_TANGENT_MORPH_TEXTURE_NAME, Type.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_TANGENT_MORPH_TEXTURE_NAME] = UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_TANGENT_MORPH_TEXTURE_BINDING] = UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR;
      var UNIFORM_LIGHTMAP_TEXTURE_NAME = 'cc_lightingMap';
      var UNIFORM_LIGHTMAP_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_LIGHTMAP;
      var UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_LIGHTMAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      var UNIFORM_LIGHTMAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_LIGHTMAP_TEXTURE_BINDING, UNIFORM_LIGHTMAP_TEXTURE_NAME, Type.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_LIGHTMAP_TEXTURE_NAME] = UNIFORM_LIGHTMAP_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_LIGHTMAP_TEXTURE_BINDING] = UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR;
      var UNIFORM_SPRITE_TEXTURE_NAME = 'cc_spriteTexture';
      var UNIFORM_SPRITE_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_SPRITE;
      var UNIFORM_SPRITE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPRITE_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      var UNIFORM_SPRITE_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_SPRITE_TEXTURE_BINDING, UNIFORM_SPRITE_TEXTURE_NAME, Type.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_SPRITE_TEXTURE_NAME] = UNIFORM_SPRITE_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_SPRITE_TEXTURE_BINDING] = UNIFORM_SPRITE_TEXTURE_DESCRIPTOR;
      var UNIFORM_REFLECTION_TEXTURE_NAME = 'cc_reflectionTexture';
      var UNIFORM_REFLECTION_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_REFLECTION;
      var UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
      var UNIFORM_REFLECTION_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_TEXTURE_BINDING, UNIFORM_REFLECTION_TEXTURE_NAME, Type.SAMPLER2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_TEXTURE_NAME] = UNIFORM_REFLECTION_TEXTURE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_TEXTURE_BINDING] = UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR;
      var UNIFORM_REFLECTION_STORAGE_NAME = 'cc_reflectionStorage';
      var UNIFORM_REFLECTION_STORAGE_BINDING = ModelLocalBindings.STORAGE_REFLECTION;
      var UNIFORM_REFLECTION_STORAGE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_STORAGE_BINDING, DescriptorType.STORAGE_IMAGE, 1, ShaderStageFlagBit.COMPUTE);
      var UNIFORM_REFLECTION_STORAGE_LAYOUT = new UniformStorageImage(SetIndex.LOCAL, UNIFORM_REFLECTION_STORAGE_BINDING, UNIFORM_REFLECTION_STORAGE_NAME, Type.IMAGE2D, 1);
      localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_STORAGE_NAME] = UNIFORM_REFLECTION_STORAGE_LAYOUT;
      localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_STORAGE_BINDING] = UNIFORM_REFLECTION_STORAGE_DESCRIPTOR;
      var CAMERA_DEFAULT_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER]);
      var CAMERA_EDITOR_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.PROFILER]);
      var MODEL_ALWAYS_MASK = Layers.Enum.ALL;
      function supportsR16HalfFloatTexture(device) {
        return (device.getFormatFeatures(Format.R16F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);
      }
      function supportsR32FloatTexture(device) {
        return (device.getFormatFeatures(Format.R32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);
      }

      var define$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PIPELINE_FLOW_MAIN: PIPELINE_FLOW_MAIN,
        PIPELINE_FLOW_FORWARD: PIPELINE_FLOW_FORWARD,
        PIPELINE_FLOW_SHADOW: PIPELINE_FLOW_SHADOW,
        PIPELINE_FLOW_SMAA: PIPELINE_FLOW_SMAA,
        PIPELINE_FLOW_TONEMAP: PIPELINE_FLOW_TONEMAP,
        get RenderPassStage () { return RenderPassStage; },
        get RenderPriority () { return RenderPriority; },
        globalDescriptorSetLayout: globalDescriptorSetLayout,
        localDescriptorSetLayout: localDescriptorSetLayout,
        get PipelineGlobalBindings () { return PipelineGlobalBindings; },
        get ModelLocalBindings () { return ModelLocalBindings; },
        get SetIndex () { return SetIndex; },
        bindingMappingInfo: bindingMappingInfo,
        UBOGlobal: UBOGlobal,
        UBOCamera: UBOCamera,
        UBOShadow: UBOShadow,
        UNIFORM_SHADOWMAP_BINDING: UNIFORM_SHADOWMAP_BINDING,
        UNIFORM_ENVIRONMENT_BINDING: UNIFORM_ENVIRONMENT_BINDING,
        UNIFORM_DIFFUSEMAP_BINDING: UNIFORM_DIFFUSEMAP_BINDING,
        UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING: UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING,
        UBOLocal: UBOLocal,
        UBOWorldBound: UBOWorldBound,
        INST_MAT_WORLD: INST_MAT_WORLD,
        UBOLocalBatched: UBOLocalBatched,
        UBOForwardLight: UBOForwardLight,
        UBODeferredLight: UBODeferredLight,
        JOINT_UNIFORM_CAPACITY: JOINT_UNIFORM_CAPACITY,
        UBOSkinningTexture: UBOSkinningTexture,
        UBOSkinningAnimation: UBOSkinningAnimation,
        INST_JOINT_ANIM_INFO: INST_JOINT_ANIM_INFO,
        UBOSkinning: UBOSkinning,
        UBOMorph: UBOMorph,
        UBOUILocal: UBOUILocal,
        UNIFORM_JOINT_TEXTURE_BINDING: UNIFORM_JOINT_TEXTURE_BINDING,
        UNIFORM_POSITION_MORPH_TEXTURE_BINDING: UNIFORM_POSITION_MORPH_TEXTURE_BINDING,
        UNIFORM_NORMAL_MORPH_TEXTURE_BINDING: UNIFORM_NORMAL_MORPH_TEXTURE_BINDING,
        UNIFORM_TANGENT_MORPH_TEXTURE_BINDING: UNIFORM_TANGENT_MORPH_TEXTURE_BINDING,
        UNIFORM_LIGHTMAP_TEXTURE_BINDING: UNIFORM_LIGHTMAP_TEXTURE_BINDING,
        UNIFORM_SPRITE_TEXTURE_BINDING: UNIFORM_SPRITE_TEXTURE_BINDING,
        UNIFORM_REFLECTION_TEXTURE_BINDING: UNIFORM_REFLECTION_TEXTURE_BINDING,
        UNIFORM_REFLECTION_STORAGE_BINDING: UNIFORM_REFLECTION_STORAGE_BINDING,
        CAMERA_DEFAULT_MASK: CAMERA_DEFAULT_MASK,
        CAMERA_EDITOR_MASK: CAMERA_EDITOR_MASK,
        MODEL_ALWAYS_MASK: MODEL_ALWAYS_MASK,
        supportsR16HalfFloatTexture: supportsR16HalfFloatTexture,
        supportsR32FloatTexture: supportsR32FloatTexture
      });
      exports('pipeline', define$1);

      var _type2reader, _type2writer;
      var typeMask = 0xfc000000;
      var bindingMask = 0x03f00000;
      var countMask = 0x000ff000;
      var offsetMask = 0x00000fff;
      var genHandle = function genHandle(binding, type, count, offset) {
        if (offset === void 0) {
          offset = 0;
        }

        return type << 26 & typeMask | binding << 20 & bindingMask | count << 12 & countMask | offset & offsetMask;
      };
      var getTypeFromHandle = function getTypeFromHandle(handle) {
        return (handle & typeMask) >>> 26;
      };
      var getBindingFromHandle = function getBindingFromHandle(handle) {
        return (handle & bindingMask) >>> 20;
      };
      var getCountFromHandle = function getCountFromHandle(handle) {
        return (handle & countMask) >>> 12;
      };
      var getOffsetFromHandle = function getOffsetFromHandle(handle) {
        return handle & offsetMask;
      };
      var customizeType = function customizeType(handle, type) {
        return handle & ~typeMask | type << 26 & typeMask;
      };
      var type2reader = (_type2reader = {}, _type2reader[Type.UNKNOWN] = function (a, v, idx) {

        return console.warn('illegal uniform handle');
      }, _type2reader[Type.INT] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return a[idx];
      }, _type2reader[Type.INT2] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec2.fromArray(v, a, idx);
      }, _type2reader[Type.INT3] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec3.fromArray(v, a, idx);
      }, _type2reader[Type.INT4] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec4.fromArray(v, a, idx);
      }, _type2reader[Type.FLOAT] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return a[idx];
      }, _type2reader[Type.FLOAT2] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec2.fromArray(v, a, idx);
      }, _type2reader[Type.FLOAT3] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec3.fromArray(v, a, idx);
      }, _type2reader[Type.FLOAT4] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec4.fromArray(v, a, idx);
      }, _type2reader[Type.MAT3] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Mat3.fromArray(v, a, idx);
      }, _type2reader[Type.MAT4] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Mat4.fromArray(v, a, idx);
      }, _type2reader);
      var type2writer = (_type2writer = {}, _type2writer[Type.UNKNOWN] = function (a, v, idx) {

        return console.warn('illegal uniform handle');
      }, _type2writer[Type.INT] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return a[idx] = v;
      }, _type2writer[Type.INT2] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec2.toArray(a, v, idx);
      }, _type2writer[Type.INT3] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec3.toArray(a, v, idx);
      }, _type2writer[Type.INT4] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec4.toArray(a, v, idx);
      }, _type2writer[Type.FLOAT] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return a[idx] = v;
      }, _type2writer[Type.FLOAT2] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec2.toArray(a, v, idx);
      }, _type2writer[Type.FLOAT3] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec3.toArray(a, v, idx);
      }, _type2writer[Type.FLOAT4] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Vec4.toArray(a, v, idx);
      }, _type2writer[Type.MAT3] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Mat3.toArray(a, v, idx);
      }, _type2writer[Type.MAT4] = function (a, v, idx) {
        if (idx === void 0) {
          idx = 0;
        }

        return Mat4.toArray(a, v, idx);
      }, _type2writer);
      var defaultValues = [Object.freeze([0]), Object.freeze([0, 0]), Object.freeze([0, 0, 0, 0]), Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])];
      function getDefaultFromType(type) {
        switch (type) {
          case Type.BOOL:
          case Type.INT:
          case Type.UINT:
          case Type.FLOAT:
            return defaultValues[0];

          case Type.BOOL2:
          case Type.INT2:
          case Type.UINT2:
          case Type.FLOAT2:
            return defaultValues[1];

          case Type.BOOL4:
          case Type.INT4:
          case Type.UINT4:
          case Type.FLOAT4:
            return defaultValues[2];

          case Type.MAT4:
            return defaultValues[3];

          case Type.SAMPLER2D:
            return 'default-texture';

          case Type.SAMPLER_CUBE:
            return 'default-cube-texture';
        }

        return defaultValues[0];
      }
      function overrideMacros(target, source) {
        var entries = Object.entries(source);
        var isDifferent = false;

        for (var i = 0; i < entries.length; i++) {
          if (target[entries[i][0]] !== entries[i][1]) {
            target[entries[i][0]] = entries[i][1];
            isDifferent = true;
          }
        }

        return isDifferent;
      }

      var _dsLayoutInfo = new DescriptorSetLayoutInfo();

      function getBitCount(cnt) {
        return Math.ceil(Math.log2(Math.max(cnt, 2)));
      }

      function mapDefine(info, def) {
        switch (info.type) {
          case 'boolean':
            return typeof def === 'number' ? def.toString() : def ? '1' : '0';

          case 'string':
            return def !== undefined ? def : info.options[0];

          case 'number':
            return def !== undefined ? def.toString() : info.range[0].toString();

          default:
            console.warn("unknown define type '" + info.type + "'");
            return '-1';
        }
      }

      function prepareDefines(defs, tDefs) {
        var macros = [];

        for (var i = 0; i < tDefs.length; i++) {
          var tmpl = tDefs[i];
          var name = tmpl.name;
          var v = defs[name];

          var _value = mapDefine(tmpl, v);

          var isDefault = !v || v === '0';
          macros.push({
            name: name,
            value: _value,
            isDefault: isDefault
          });
        }

        return macros;
      }

      function getShaderInstanceName(name, macros) {
        return name + macros.reduce(function (acc, cur) {
          return cur.isDefault ? acc : acc + "|" + cur.name + cur.value;
        }, '');
      }

      function insertBuiltinBindings(tmpl, tmplInfo, source, type, outBindings) {
        var target = tmpl.builtins[type];
        var tempBlocks = [];

        var _loop = function _loop(i) {
          var b = target.blocks[i];
          var info = source.layouts[b.name];
          var binding = info && source.bindings.find(function (bd) {
            return bd.binding === info.binding;
          });

          if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_BUFFER_TYPE)) {
            console.warn("builtin UBO '" + b.name + "' not available!");
            return "continue";
          }

          tempBlocks.push(info);
          if (outBindings && !outBindings.includes(binding)) outBindings.push(binding);
        };

        for (var i = 0; i < target.blocks.length; i++) {
          var _ret = _loop(i);

          if (_ret === "continue") continue;
        }

        Array.prototype.unshift.apply(tmplInfo.shaderInfo.blocks, tempBlocks);
        var tempSamplerTextures = [];

        var _loop2 = function _loop2(_i) {
          var s = target.samplerTextures[_i];
          var info = source.layouts[s.name];
          var binding = info && source.bindings.find(function (bd) {
            return bd.binding === info.binding;
          });

          if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_SAMPLER_TYPE)) {
            console.warn("builtin samplerTexture '" + s.name + "' not available!");
            return "continue";
          }

          tempSamplerTextures.push(info);
          if (outBindings && !outBindings.includes(binding)) outBindings.push(binding);
        };

        for (var _i = 0; _i < target.samplerTextures.length; _i++) {
          var _ret2 = _loop2(_i);

          if (_ret2 === "continue") continue;
        }

        Array.prototype.unshift.apply(tmplInfo.shaderInfo.samplerTextures, tempSamplerTextures);
        if (outBindings) outBindings.sort(function (a, b) {
          return a.binding - b.binding;
        });
      }

      function getSize(block) {
        return block.members.reduce(function (s, m) {
          return s + GetTypeSize(m.type) * m.count;
        }, 0);
      }

      function genHandles(tmpl) {
        var handleMap = {};

        for (var i = 0; i < tmpl.blocks.length; i++) {
          var block = tmpl.blocks[i];
          var members = block.members;
          var offset = 0;

          for (var j = 0; j < members.length; j++) {
            var uniform = members[j];
            handleMap[uniform.name] = genHandle(block.binding, uniform.type, uniform.count, offset);
            offset += (GetTypeSize(uniform.type) >> 2) * uniform.count;
          }
        }

        for (var _i2 = 0; _i2 < tmpl.samplerTextures.length; _i2++) {
          var samplerTexture = tmpl.samplerTextures[_i2];
          handleMap[samplerTexture.name] = genHandle(samplerTexture.binding, samplerTexture.type, samplerTexture.count);
        }

        return handleMap;
      }

      function dependencyCheck(dependencies, defines) {
        for (var i = 0; i < dependencies.length; i++) {
          var d = dependencies[i];

          if (d[0] === '!') {
            if (defines[d.slice(1)]) {
              return false;
            }
          } else if (!defines[d]) {
            return false;
          }
        }

        return true;
      }

      function getActiveAttributes(tmpl, tmplInfo, defines) {
        var out = [];
        var attributes = tmpl.attributes;
        var gfxAttributes = tmplInfo.gfxAttributes;

        for (var i = 0; i < attributes.length; i++) {
          if (!dependencyCheck(attributes[i].defines, defines)) {
            continue;
          }

          out.push(gfxAttributes[i]);
        }

        return out;
      }

      var ProgramLib = function () {
        function ProgramLib() {
          this._templates = {};
          this._cache = {};
          this._templateInfos = {};
        }

        var _proto = ProgramLib.prototype;

        _proto.register = function register(effect) {
          for (var i = 0; i < effect.shaders.length; i++) {
            var tmpl = this.define(effect.shaders[i]);
            tmpl.effectName = effect.name;
          }

          for (var _i3 = 0; _i3 < effect.techniques.length; _i3++) {
            var tech = effect.techniques[_i3];

            for (var j = 0; j < tech.passes.length; j++) {
              var pass = tech.passes[j];

              if (pass.propertyIndex !== undefined && pass.properties === undefined) {
                pass.properties = tech.passes[pass.propertyIndex].properties;
              }
            }
          }
        };

        _proto.define = function define(shader) {
          var curTmpl = this._templates[shader.name];

          if (curTmpl && curTmpl.hash === shader.hash) {
            return curTmpl;
          }

          var tmpl = _extends({}, shader);

          var offset = 0;

          var _loop3 = function _loop3(i) {
            var def = tmpl.defines[i];
            var cnt = 1;

            if (def.type === 'number') {
              var range = def.range;
              cnt = getBitCount(range[1] - range[0] + 1);

              def._map = function (value) {
                return value - range[0];
              };
            } else if (def.type === 'string') {
              cnt = getBitCount(def.options.length);

              def._map = function (value) {
                return Math.max(0, def.options.findIndex(function (s) {
                  return s === value;
                }));
              };
            } else if (def.type === 'boolean') {
              def._map = function (value) {
                return value ? 1 : 0;
              };
            }

            def._offset = offset;
            offset += cnt;
          };

          for (var i = 0; i < tmpl.defines.length; i++) {
            _loop3(i);
          }

          if (offset > 31) {
            tmpl.uber = true;
          }

          tmpl.constantMacros = '';

          for (var key in tmpl.builtins.statistics) {
            tmpl.constantMacros += "#define " + key + " " + tmpl.builtins.statistics[key] + "\n";
          }

          this._templates[shader.name] = tmpl;

          if (!this._templateInfos[tmpl.hash]) {
            var tmplInfo = {};
            tmplInfo.samplerStartBinding = tmpl.blocks.length;
            tmplInfo.shaderInfo = new ShaderInfo();
            tmplInfo.blockSizes = [];
            tmplInfo.bindings = [];

            for (var _i4 = 0; _i4 < tmpl.blocks.length; _i4++) {
              var block = tmpl.blocks[_i4];
              tmplInfo.blockSizes.push(getSize(block));
              tmplInfo.bindings.push(new DescriptorSetLayoutBinding(block.binding, DescriptorType.UNIFORM_BUFFER, 1, block.stageFlags));
              tmplInfo.shaderInfo.blocks.push(new UniformBlock(SetIndex.MATERIAL, block.binding, block.name, block.members.map(function (m) {
                return new Uniform(m.name, m.type, m.count);
              }), 1));
            }

            for (var _i5 = 0; _i5 < tmpl.samplerTextures.length; _i5++) {
              var samplerTexture = tmpl.samplerTextures[_i5];
              tmplInfo.bindings.push(new DescriptorSetLayoutBinding(samplerTexture.binding, DescriptorType.SAMPLER_TEXTURE, samplerTexture.count, samplerTexture.stageFlags));
              tmplInfo.shaderInfo.samplerTextures.push(new UniformSamplerTexture(SetIndex.MATERIAL, samplerTexture.binding, samplerTexture.name, samplerTexture.type, samplerTexture.count));
            }

            for (var _i6 = 0; _i6 < tmpl.samplers.length; _i6++) {
              var sampler = tmpl.samplers[_i6];
              tmplInfo.bindings.push(new DescriptorSetLayoutBinding(sampler.binding, DescriptorType.SAMPLER, sampler.count, sampler.stageFlags));
              tmplInfo.shaderInfo.samplers.push(new UniformSampler(SetIndex.MATERIAL, sampler.binding, sampler.name, sampler.count));
            }

            for (var _i7 = 0; _i7 < tmpl.textures.length; _i7++) {
              var texture = tmpl.textures[_i7];
              tmplInfo.bindings.push(new DescriptorSetLayoutBinding(texture.binding, DescriptorType.TEXTURE, texture.count, texture.stageFlags));
              tmplInfo.shaderInfo.textures.push(new UniformTexture(SetIndex.MATERIAL, texture.binding, texture.name, texture.type, texture.count));
            }

            for (var _i8 = 0; _i8 < tmpl.buffers.length; _i8++) {
              var buffer = tmpl.buffers[_i8];
              tmplInfo.bindings.push(new DescriptorSetLayoutBinding(buffer.binding, DescriptorType.STORAGE_BUFFER, 1, buffer.stageFlags));
              tmplInfo.shaderInfo.buffers.push(new UniformStorageBuffer(SetIndex.MATERIAL, buffer.binding, buffer.name, 1, buffer.memoryAccess));
            }

            for (var _i9 = 0; _i9 < tmpl.images.length; _i9++) {
              var image = tmpl.images[_i9];
              tmplInfo.bindings.push(new DescriptorSetLayoutBinding(image.binding, DescriptorType.STORAGE_IMAGE, image.count, image.stageFlags));
              tmplInfo.shaderInfo.images.push(new UniformStorageImage(SetIndex.MATERIAL, image.binding, image.name, image.type, image.count, image.memoryAccess));
            }

            for (var _i10 = 0; _i10 < tmpl.subpassInputs.length; _i10++) {
              var subpassInput = tmpl.subpassInputs[_i10];
              tmplInfo.bindings.push(new DescriptorSetLayoutBinding(subpassInput.binding, DescriptorType.INPUT_ATTACHMENT, subpassInput.count, subpassInput.stageFlags));
              tmplInfo.shaderInfo.subpassInputs.push(new UniformInputAttachment(SetIndex.MATERIAL, subpassInput.binding, subpassInput.name, subpassInput.count));
            }

            tmplInfo.gfxAttributes = [];

            for (var _i11 = 0; _i11 < tmpl.attributes.length; _i11++) {
              var attr = tmpl.attributes[_i11];
              tmplInfo.gfxAttributes.push(new Attribute(attr.name, attr.format, attr.isNormalized, 0, attr.isInstanced, attr.location));
            }

            insertBuiltinBindings(tmpl, tmplInfo, localDescriptorSetLayout, 'locals');
            tmplInfo.shaderInfo.stages.push(new ShaderStage(ShaderStageFlagBit.VERTEX, ''));
            tmplInfo.shaderInfo.stages.push(new ShaderStage(ShaderStageFlagBit.FRAGMENT, ''));
            tmplInfo.handleMap = genHandles(tmpl);
            tmplInfo.setLayouts = [];
            this._templateInfos[tmpl.hash] = tmplInfo;
          }

          return tmpl;
        };

        _proto.getTemplate = function getTemplate(name) {
          return this._templates[name];
        };

        _proto.getTemplateInfo = function getTemplateInfo(name) {
          var hash = this._templates[name].hash;
          return this._templateInfos[hash];
        };

        _proto.getDescriptorSetLayout = function getDescriptorSetLayout(device, name, isLocal) {
          if (isLocal === void 0) {
            isLocal = false;
          }

          var tmpl = this._templates[name];
          var tmplInfo = this._templateInfos[tmpl.hash];

          if (!tmplInfo.setLayouts.length) {
            _dsLayoutInfo.bindings = tmplInfo.bindings;
            tmplInfo.setLayouts[SetIndex.MATERIAL] = device.createDescriptorSetLayout(_dsLayoutInfo);
            _dsLayoutInfo.bindings = localDescriptorSetLayout.bindings;
            tmplInfo.setLayouts[SetIndex.LOCAL] = device.createDescriptorSetLayout(_dsLayoutInfo);
          }

          return tmplInfo.setLayouts[isLocal ? SetIndex.LOCAL : SetIndex.MATERIAL];
        };

        _proto.hasProgram = function hasProgram(name) {
          return this._templates[name] !== undefined;
        };

        _proto.getKey = function getKey(name, defines) {
          var tmpl = this._templates[name];
          var tmplDefs = tmpl.defines;

          if (tmpl.uber) {
            var _key = '';

            for (var i = 0; i < tmplDefs.length; i++) {
              var tmplDef = tmplDefs[i];
              var _value2 = defines[tmplDef.name];

              if (!_value2 || !tmplDef._map) {
                continue;
              }

              var mapped = tmplDef._map(_value2);

              var offset = tmplDef._offset;
              _key += "" + offset + mapped + "|";
            }

            return "" + _key + tmpl.hash;
          }

          var key = 0;

          for (var _i12 = 0; _i12 < tmplDefs.length; _i12++) {
            var _tmplDef = tmplDefs[_i12];
            var _value3 = defines[_tmplDef.name];

            if (!_value3 || !_tmplDef._map) {
              continue;
            }

            var _mapped = _tmplDef._map(_value3);

            var _offset = _tmplDef._offset;
            key |= _mapped << _offset;
          }

          return key.toString(16) + "|" + tmpl.hash;
        };

        _proto.destroyShaderByDefines = function destroyShaderByDefines(defines) {
          var _this = this;

          var names = Object.keys(defines);

          if (!names.length) {
            return;
          }

          var regexes = names.map(function (cur) {
            var val = defines[cur];

            if (typeof val === 'boolean') {
              val = val ? '1' : '0';
            }

            return new RegExp("" + cur + val);
          });
          var keys = Object.keys(this._cache).filter(function (k) {
            return regexes.every(function (re) {
              return re.test(_this._cache[k].name);
            });
          });

          for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            var prog = this._cache[k];
            debug("destroyed shader " + prog.name);
            prog.destroy();
            delete this._cache[k];
          }
        };

        _proto.getGFXShader = function getGFXShader(device, name, defines, pipeline, key) {
          Object.assign(defines, pipeline.macros);
          if (!key) key = this.getKey(name, defines);
          var res = this._cache[key];

          if (res) {
            return res;
          }

          var tmpl = this._templates[name];
          var tmplInfo = this._templateInfos[tmpl.hash];

          if (!tmplInfo.pipelineLayout) {
            this.getDescriptorSetLayout(device, name);
            insertBuiltinBindings(tmpl, tmplInfo, globalDescriptorSetLayout, 'globals');
            tmplInfo.setLayouts[SetIndex.GLOBAL] = pipeline.descriptorSetLayout;
            tmplInfo.pipelineLayout = device.createPipelineLayout(new PipelineLayoutInfo(tmplInfo.setLayouts));
          }

          var macroArray = prepareDefines(defines, tmpl.defines);
          var prefix = pipeline.constantMacros + tmpl.constantMacros + macroArray.reduce(function (acc, cur) {
            return acc + "#define " + cur.name + " " + cur.value + "\n";
          }, '');
          var src = tmpl.glsl3;
          var deviceShaderVersion = getDeviceShaderVersion(device);

          if (deviceShaderVersion) {
            src = tmpl[deviceShaderVersion];
          } else {
            console.error('Invalid GFX API!');
          }

          tmplInfo.shaderInfo.stages[0].source = prefix + src.vert;
          tmplInfo.shaderInfo.stages[1].source = prefix + src.frag;
          tmplInfo.shaderInfo.attributes = getActiveAttributes(tmpl, tmplInfo, defines);
          tmplInfo.shaderInfo.name = getShaderInstanceName(name, macroArray);
          return this._cache[key] = device.createShader(tmplInfo.shaderInfo);
        };

        return ProgramLib;
      }();

      function getDeviceShaderVersion(device) {
        switch (device.gfxAPI) {
          case API.GLES2:
          case API.WEBGL:
            return 'glsl1';

          case API.GLES3:
          case API.WEBGL2:
            return 'glsl3';

          default:
            return 'glsl4';
        }
      }
      var programLib = new ProgramLib();
      legacyCC.programLib = programLib;

      var _dec$7, _class$7, _class2$6, _descriptor$5, _descriptor2$3, _descriptor3$3, _descriptor4$2, _class3$3, _temp$5;
      var EffectAsset = exports('EffectAsset', (_dec$7 = ccclass('cc.EffectAsset'), _dec$7(_class$7 = (_class2$6 = (_temp$5 = _class3$3 = function (_Asset) {
        _inheritsLoose(EffectAsset, _Asset);

        function EffectAsset() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "techniques", _descriptor$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "shaders", _descriptor2$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "combinations", _descriptor3$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "hideInEditor", _descriptor4$2, _assertThisInitialized(_this));

          return _this;
        }

        EffectAsset.register = function register(asset) {
          EffectAsset._effects[asset.name] = asset;
        };

        EffectAsset.remove = function remove(asset) {
          if (typeof asset !== 'string') {
            if (EffectAsset._effects[asset.name] && EffectAsset._effects[asset.name] === asset) {
              delete EffectAsset._effects[asset.name];
            }
          } else {
            if (EffectAsset._effects[asset]) {
              delete EffectAsset._effects[asset];
              return;
            }

            for (var n in EffectAsset._effects) {
              if (EffectAsset._effects[n]._uuid === asset) {
                delete EffectAsset._effects[n];
                return;
              }
            }
          }
        };

        EffectAsset.get = function get(name) {
          if (EffectAsset._effects[name]) {
            return EffectAsset._effects[name];
          }

          for (var n in EffectAsset._effects) {
            if (EffectAsset._effects[n]._uuid === name) {
              return EffectAsset._effects[n];
            }
          }

          return null;
        };

        EffectAsset.getAll = function getAll() {
          return EffectAsset._effects;
        };

        var _proto = EffectAsset.prototype;

        _proto.onLoaded = function onLoaded() {
          programLib.register(this);
          EffectAsset.register(this);

          {
            legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this._precompile, this);
          }
        };

        _proto._precompile = function _precompile() {
          var _this2 = this;

          var root = legacyCC.director.root;

          var _loop = function _loop(i) {
            var shader = _this2.shaders[i];
            var combination = _this2.combinations[i];

            if (!combination) {
              return "continue";
            }

            var defines = Object.keys(combination).reduce(function (out, name) {
              return out.reduce(function (acc, cur) {
                var choices = combination[name];

                for (var _i = 0; _i < choices.length; ++_i) {
                  var _defines = _extends({}, cur);

                  _defines[name] = choices[_i];
                  acc.push(_defines);
                }

                return acc;
              }, []);
            }, [{}]);
            defines.forEach(function (defines) {
              return programLib.getGFXShader(root.device, shader.name, defines, root.pipeline);
            });
          };

          for (var i = 0; i < this.shaders.length; i++) {
            var _ret = _loop(i);

            if (_ret === "continue") continue;
          }
        };

        _proto.destroy = function destroy() {
          EffectAsset.remove(this);
          return _Asset.prototype.destroy.call(this);
        };

        _proto.initDefault = function initDefault(uuid) {
          _Asset.prototype.initDefault.call(this, uuid);

          var effect = EffectAsset.get('unlit');
          this.name = 'unlit';
          this.shaders = effect.shaders;
          this.combinations = effect.combinations;
          this.techniques = effect.techniques;
        };

        _proto.validate = function validate() {
          return this.techniques.length > 0 && this.shaders.length > 0;
        };

        return EffectAsset;
      }(Asset), _class3$3._effects = {}, _temp$5), (_descriptor$5 = _applyDecoratedDescriptor(_class2$6.prototype, "techniques", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$6.prototype, "shaders", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$6.prototype, "combinations", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor4$2 = _applyDecoratedDescriptor(_class2$6.prototype, "hideInEditor", [serializable, editorOnly], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2$6)) || _class$7));
      legacyCC.EffectAsset = EffectAsset;

      var CUSTOM_PIXEL_FORMAT = 1024;
      var PixelFormat;

      (function (PixelFormat) {
        PixelFormat[PixelFormat["RGB565"] = Format.R5G6B5] = "RGB565";
        PixelFormat[PixelFormat["RGB5A1"] = Format.RGB5A1] = "RGB5A1";
        PixelFormat[PixelFormat["RGBA4444"] = Format.RGBA4] = "RGBA4444";
        PixelFormat[PixelFormat["RGB888"] = Format.RGB8] = "RGB888";
        PixelFormat[PixelFormat["RGB32F"] = Format.RGB32F] = "RGB32F";
        PixelFormat[PixelFormat["RGBA8888"] = Format.RGBA8] = "RGBA8888";
        PixelFormat[PixelFormat["RGBA32F"] = Format.RGBA32F] = "RGBA32F";
        PixelFormat[PixelFormat["A8"] = Format.A8] = "A8";
        PixelFormat[PixelFormat["I8"] = Format.L8] = "I8";
        PixelFormat[PixelFormat["AI8"] = Format.LA8] = "AI8";
        PixelFormat[PixelFormat["RGB_PVRTC_2BPPV1"] = Format.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1";
        PixelFormat[PixelFormat["RGBA_PVRTC_2BPPV1"] = Format.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1";
        PixelFormat[PixelFormat["RGB_A_PVRTC_2BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_2BPPV1";
        PixelFormat[PixelFormat["RGB_PVRTC_4BPPV1"] = Format.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1";
        PixelFormat[PixelFormat["RGBA_PVRTC_4BPPV1"] = Format.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1";
        PixelFormat[PixelFormat["RGB_A_PVRTC_4BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_4BPPV1";
        PixelFormat[PixelFormat["RGB_ETC1"] = Format.ETC_RGB8] = "RGB_ETC1";
        PixelFormat[PixelFormat["RGBA_ETC1"] = CUSTOM_PIXEL_FORMAT++] = "RGBA_ETC1";
        PixelFormat[PixelFormat["RGB_ETC2"] = Format.ETC2_RGB8] = "RGB_ETC2";
        PixelFormat[PixelFormat["RGBA_ETC2"] = Format.ETC2_RGBA8] = "RGBA_ETC2";
        PixelFormat[PixelFormat["RGBA_ASTC_4x4"] = Format.ASTC_RGBA_4X4] = "RGBA_ASTC_4x4";
        PixelFormat[PixelFormat["RGBA_ASTC_5x4"] = Format.ASTC_RGBA_5X4] = "RGBA_ASTC_5x4";
        PixelFormat[PixelFormat["RGBA_ASTC_5x5"] = Format.ASTC_RGBA_5X5] = "RGBA_ASTC_5x5";
        PixelFormat[PixelFormat["RGBA_ASTC_6x5"] = Format.ASTC_RGBA_6X5] = "RGBA_ASTC_6x5";
        PixelFormat[PixelFormat["RGBA_ASTC_6x6"] = Format.ASTC_RGBA_6X6] = "RGBA_ASTC_6x6";
        PixelFormat[PixelFormat["RGBA_ASTC_8x5"] = Format.ASTC_RGBA_8X5] = "RGBA_ASTC_8x5";
        PixelFormat[PixelFormat["RGBA_ASTC_8x6"] = Format.ASTC_RGBA_8X6] = "RGBA_ASTC_8x6";
        PixelFormat[PixelFormat["RGBA_ASTC_8x8"] = Format.ASTC_RGBA_8X8] = "RGBA_ASTC_8x8";
        PixelFormat[PixelFormat["RGBA_ASTC_10x5"] = Format.ASTC_RGBA_10X5] = "RGBA_ASTC_10x5";
        PixelFormat[PixelFormat["RGBA_ASTC_10x6"] = Format.ASTC_RGBA_10X6] = "RGBA_ASTC_10x6";
        PixelFormat[PixelFormat["RGBA_ASTC_10x8"] = Format.ASTC_RGBA_10X8] = "RGBA_ASTC_10x8";
        PixelFormat[PixelFormat["RGBA_ASTC_10x10"] = Format.ASTC_RGBA_10X10] = "RGBA_ASTC_10x10";
        PixelFormat[PixelFormat["RGBA_ASTC_12x10"] = Format.ASTC_RGBA_12X10] = "RGBA_ASTC_12x10";
        PixelFormat[PixelFormat["RGBA_ASTC_12x12"] = Format.ASTC_RGBA_12X12] = "RGBA_ASTC_12x12";
      })(PixelFormat || (PixelFormat = {}));

      var WrapMode$1;

      (function (WrapMode) {
        WrapMode[WrapMode["REPEAT"] = Address.WRAP] = "REPEAT";
        WrapMode[WrapMode["CLAMP_TO_EDGE"] = Address.CLAMP] = "CLAMP_TO_EDGE";
        WrapMode[WrapMode["MIRRORED_REPEAT"] = Address.MIRROR] = "MIRRORED_REPEAT";
        WrapMode[WrapMode["CLAMP_TO_BORDER"] = Address.BORDER] = "CLAMP_TO_BORDER";
      })(WrapMode$1 || (WrapMode$1 = {}));

      var Filter$1;

      (function (Filter$1) {
        Filter$1[Filter$1["NONE"] = Filter.NONE] = "NONE";
        Filter$1[Filter$1["LINEAR"] = Filter.LINEAR] = "LINEAR";
        Filter$1[Filter$1["NEAREST"] = Filter.POINT] = "NEAREST";
      })(Filter$1 || (Filter$1 = {}));

      var _dec$8, _class$8, _class2$7, _descriptor$6, _descriptor2$4, _descriptor3$4, _descriptor4$3, _descriptor5$1, _descriptor6, _descriptor7, _descriptor8, _class3$4, _temp$6;
      ccenum(Format);
      var idGenerator$1 = new IDGenerator('Tex');
      var TextureBase = (_dec$8 = ccclass('cc.TextureBase'), _dec$8(_class$8 = (_class2$7 = (_temp$6 = _class3$4 = function (_Asset) {
        _inheritsLoose(TextureBase, _Asset);

        function TextureBase() {
          var _this;

          _this = _Asset.call(this) || this;

          _initializerDefineProperty(_this, "_format", _descriptor$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_minFilter", _descriptor2$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_magFilter", _descriptor3$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_mipFilter", _descriptor4$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_wrapS", _descriptor5$1, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_wrapT", _descriptor6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_wrapR", _descriptor7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_anisotropy", _descriptor8, _assertThisInitialized(_this));

          _this._width = 1;
          _this._height = 1;
          _this._id = void 0;
          _this._samplerInfo = new SamplerInfo();
          _this._gfxSampler = null;
          _this._gfxDevice = null;
          _this._textureHash = 0;
          _this._id = idGenerator$1.getNewId();
          _this._gfxDevice = _this._getGFXDevice();
          _this._textureHash = murmurhash2_32_gc(_this._id, 666);
          return _this;
        }

        var _proto = TextureBase.prototype;

        _proto.getId = function getId() {
          return this._id;
        };

        _proto.getPixelFormat = function getPixelFormat() {
          return this._format;
        };

        _proto.getAnisotropy = function getAnisotropy() {
          return this._anisotropy;
        };

        _proto.setWrapMode = function setWrapMode(wrapS, wrapT, wrapR) {
          if (wrapR === undefined) wrapR = wrapS;
          this._wrapS = wrapS;
          this._samplerInfo.addressU = wrapS;
          this._wrapT = wrapT;
          this._samplerInfo.addressV = wrapT;
          this._wrapR = wrapR;
          this._samplerInfo.addressW = wrapR;

          if (this._gfxDevice) {
            this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
          }
        };

        _proto.setFilters = function setFilters(minFilter, magFilter) {
          this._minFilter = minFilter;
          this._samplerInfo.minFilter = minFilter;
          this._magFilter = magFilter;
          this._samplerInfo.magFilter = magFilter;

          if (this._gfxDevice) {
            this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
          }
        };

        _proto.setMipFilter = function setMipFilter(mipFilter) {
          this._mipFilter = mipFilter;
          this._samplerInfo.mipFilter = mipFilter;

          if (this._gfxDevice) {
            this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
          }
        };

        _proto.setAnisotropy = function setAnisotropy(anisotropy) {
          this._anisotropy = anisotropy;
          this._samplerInfo.maxAnisotropy = anisotropy;

          if (this._gfxDevice) {
            this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
          }
        };

        _proto.destroy = function destroy() {
          var _legacyCC$director$ro;

          var destroyed = _Asset.prototype.destroy.call(this);

          if (destroyed && ((_legacyCC$director$ro = legacyCC.director.root) === null || _legacyCC$director$ro === void 0 ? void 0 : _legacyCC$director$ro.batcher2D)) {
            legacyCC.director.root.batcher2D._releaseDescriptorSetCache(this._textureHash);
          }

          return destroyed;
        };

        _proto.getHash = function getHash() {
          return this._textureHash;
        };

        _proto.getGFXTexture = function getGFXTexture() {
          return null;
        };

        _proto.getSamplerInfo = function getSamplerInfo() {
          return this._samplerInfo;
        };

        _proto.getGFXSampler = function getGFXSampler() {
          if (!this._gfxSampler) {
            if (this._gfxDevice) {
              this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
            } else {
              errorID(9302);
            }
          }

          return this._gfxSampler;
        };

        _proto._serialize = function _serialize(ctxForExporting) {

          return '';
        };

        _proto._deserialize = function _deserialize(serializedData, handle) {
          var data = serializedData;
          var fields = data.split(',');
          fields.unshift('');

          if (fields.length >= 5) {
            this.setFilters(parseInt(fields[1]), parseInt(fields[2]));
            this.setWrapMode(parseInt(fields[3]), parseInt(fields[4]));
          }

          if (fields.length >= 7) {
            this.setMipFilter(parseInt(fields[5]));
            this.setAnisotropy(parseInt(fields[6]));
          }
        };

        _proto._getGFXDevice = function _getGFXDevice() {
          if (legacyCC.director.root) {
            return legacyCC.director.root.device;
          }

          return null;
        };

        _proto._getGFXFormat = function _getGFXFormat() {
          return this._getGFXPixelFormat(this._format);
        };

        _proto._setGFXFormat = function _setGFXFormat(format) {
          this._format = format === undefined ? PixelFormat.RGBA8888 : format;
        };

        _proto._getGFXPixelFormat = function _getGFXPixelFormat(format) {
          if (format === PixelFormat.RGBA_ETC1) {
            format = PixelFormat.RGB_ETC1;
          } else if (format === PixelFormat.RGB_A_PVRTC_4BPPV1) {
            format = PixelFormat.RGB_PVRTC_4BPPV1;
          } else if (format === PixelFormat.RGB_A_PVRTC_2BPPV1) {
            format = PixelFormat.RGB_PVRTC_2BPPV1;
          }

          return format;
        };

        _createClass(TextureBase, [{
          key: "isCompressed",
          get: function get() {
            return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_ASTC_12x12 || this._format >= PixelFormat.RGB_A_PVRTC_2BPPV1 && this._format <= PixelFormat.RGBA_ETC1;
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          }
        }]);

        return TextureBase;
      }(Asset), _class3$4.PixelFormat = PixelFormat, _class3$4.WrapMode = WrapMode$1, _class3$4.Filter = Filter$1, _temp$6), (_descriptor$6 = _applyDecoratedDescriptor(_class2$7.prototype, "_format", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return PixelFormat.RGBA8888;
        }
      }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$7.prototype, "_minFilter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Filter$1.LINEAR;
        }
      }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$7.prototype, "_magFilter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Filter$1.LINEAR;
        }
      }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$7.prototype, "_mipFilter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Filter$1.NONE;
        }
      }), _descriptor5$1 = _applyDecoratedDescriptor(_class2$7.prototype, "_wrapS", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return WrapMode$1.REPEAT;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2$7.prototype, "_wrapT", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return WrapMode$1.REPEAT;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2$7.prototype, "_wrapR", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return WrapMode$1.REPEAT;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2$7.prototype, "_anisotropy", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$7)) || _class$8);
      legacyCC.TextureBase = TextureBase;

      var _dec$9, _class$9, _class2$8, _class3$5, _temp$7;

      function isImageBitmap(imageSource) {
        return !!(legacyCC.sys.hasFeature(legacyCC.sys.Feature.IMAGE_BITMAP) && imageSource instanceof ImageBitmap);
      }

      function isNativeImage(imageSource) {

        return imageSource instanceof HTMLImageElement || imageSource instanceof HTMLCanvasElement || isImageBitmap(imageSource);
      }

      var ImageAsset = exports('ImageAsset', (_dec$9 = ccclass('cc.ImageAsset'), _dec$9(_class$9 = (_class2$8 = (_temp$7 = _class3$5 = function (_Asset) {
        _inheritsLoose(ImageAsset, _Asset);

        function ImageAsset(nativeAsset) {
          var _this;

          _this = _Asset.call(this) || this;
          _this._nativeData = void 0;
          _this._exportedExts = undefined;
          _this._format = PixelFormat.RGBA8888;
          _this._width = 0;
          _this._height = 0;
          _this._nativeData = {
            _data: null,
            width: 0,
            height: 0,
            format: 0,
            _compressed: false
          };

          if (nativeAsset !== undefined) {
            _this.reset(nativeAsset);
          }

          return _this;
        }

        var _proto = ImageAsset.prototype;

        _proto.reset = function reset(data) {
          if (isImageBitmap(data)) {
            this._nativeData = data;
          } else if (!(data instanceof HTMLElement)) {
            this._nativeData = data;
            this._format = data.format;
          } else {
            this._nativeData = data;
          }
        };

        _proto.destroy = function destroy() {
          if (this.data && this.data instanceof HTMLImageElement) {
            this.data.src = '';

            this._setRawAsset('');
          } else if (isImageBitmap(this.data)) {
            this.data.close && this.data.close();
          }

          return _Asset.prototype.destroy.call(this);
        };

        _proto._serialize = function _serialize() {
        };

        _proto._deserialize = function _deserialize(data) {
          var fmtStr = '';

          if (typeof data === 'string') {
            fmtStr = data;
          } else {
            this._width = data.w;
            this._height = data.h;
            fmtStr = data.fmt;
          }

          var device = _getGlobalDevice();

          var extensionIDs = fmtStr.split('_');
          var preferedExtensionIndex = Number.MAX_VALUE;
          var format = this._format;
          var ext = '';
          var SupportTextureFormats = legacyCC.macro.SUPPORT_TEXTURE_FORMATS;

          for (var _iterator2 = _createForOfIteratorHelperLoose(extensionIDs), _step2; !(_step2 = _iterator2()).done;) {
            var extensionID = _step2.value;
            var extFormat = extensionID.split('@');
            var i = parseInt(extFormat[0], undefined);
            var tmpExt = ImageAsset.extnames[i] || extFormat[0];
            var index = SupportTextureFormats.indexOf(tmpExt);

            if (index !== -1 && index < preferedExtensionIndex) {
              var fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;

              if (tmpExt === '.astc' && (!device || !(device.getFormatFeatures(Format.ASTC_RGBA_4X4) & FormatFeatureBit.SAMPLED_TEXTURE))) {
                continue;
              } else if (tmpExt === '.pvr' && (!device || !(device.getFormatFeatures(Format.PVRTC_RGBA4) & FormatFeatureBit.SAMPLED_TEXTURE))) {
                continue;
              } else if ((fmt === PixelFormat.RGB_ETC1 || fmt === PixelFormat.RGBA_ETC1) && (!device || !(device.getFormatFeatures(Format.ETC_RGB8) & FormatFeatureBit.SAMPLED_TEXTURE))) {
                continue;
              } else if ((fmt === PixelFormat.RGB_ETC2 || fmt === PixelFormat.RGBA_ETC2) && (!device || !(device.getFormatFeatures(Format.ETC2_RGB8) & FormatFeatureBit.SAMPLED_TEXTURE))) {
                continue;
              } else if (tmpExt === '.webp' && !legacyCC.sys.hasFeature(legacyCC.sys.Feature.WEBP)) {
                continue;
              }

              preferedExtensionIndex = index;
              ext = tmpExt;
              format = fmt;
            }
          }

          if (ext) {
            this._setRawAsset(ext);

            this._format = format;
          } else {
            warnID(3121);
          }
        };

        _proto.initDefault = function initDefault(uuid) {
          _Asset.prototype.initDefault.call(this, uuid);

          if (!ImageAsset._sharedPlaceHolderCanvas) {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            var l = canvas.width = canvas.height = 2;
            context.fillStyle = '#ff00ff';
            context.fillRect(0, 0, l, l);
            this.reset(canvas);
            ImageAsset._sharedPlaceHolderCanvas = canvas;
          } else {
            this.reset(ImageAsset._sharedPlaceHolderCanvas);
          }
        };

        _proto.validate = function validate() {
          return !!this.data;
        };

        _createClass(ImageAsset, [{
          key: "_nativeAsset",
          get: function get() {
            return this._nativeData;
          },
          set: function set(value) {
            if (!(value instanceof HTMLElement) && !isImageBitmap(value)) {
              value.format = value.format || this._format;
            }

            this.reset(value);
          }
        }, {
          key: "data",
          get: function get() {
            if (this._nativeData && isNativeImage(this._nativeData)) {
              return this._nativeData;
            }

            return this._nativeData && this._nativeData._data;
          }
        }, {
          key: "width",
          get: function get() {
            return this._nativeData.width || this._width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._nativeData.height || this._height;
          }
        }, {
          key: "format",
          get: function get() {
            return this._format;
          }
        }, {
          key: "isCompressed",
          get: function get() {
            return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_ASTC_12x12 || this._format >= PixelFormat.RGB_A_PVRTC_2BPPV1 && this._format <= PixelFormat.RGBA_ETC1;
          }
        }, {
          key: "url",
          get: function get() {
            return this.nativeUrl;
          }
        }]);

        return ImageAsset;
      }(Asset), _class3$5.extnames = ['.png', '.jpg', '.jpeg', '.bmp', '.webp', '.pvr', '.pkm', '.astc'], _class3$5._sharedPlaceHolderCanvas = null, _temp$7), (_applyDecoratedDescriptor(_class2$8.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$8.prototype, "_nativeAsset"), _class2$8.prototype)), _class2$8)) || _class$9));

      function _getGlobalDevice() {
        if (legacyCC.director.root) {
          return legacyCC.director.root.device;
        }

        return null;
      }

      legacyCC.ImageAsset = ImageAsset;

      var dependMap = new WeakMap();
      var nativeDependMap = new WeakSet();
      var onLoadedInvokedMap = new WeakSet();

      function deserializeAsset(json, options) {
        var classFinder;

        {
          classFinder = MissingScript.safeFindClass;
        }

        var tdInfo = Details.pool.get();
        var asset;

        try {
          asset = deserialize(json, tdInfo, {
            classFinder: classFinder,
            customEnv: options
          });
        } catch (e) {
          error(e);
          Details.pool.put(tdInfo);
          throw e;
        }

        asset._uuid = options.__uuid__ || '';

        var uuidList = tdInfo.uuidList;
        var objList = tdInfo.uuidObjList;
        var propList = tdInfo.uuidPropList;
        var typeList = tdInfo.uuidTypeList || [];
        var depends = [];

        for (var i = 0; i < uuidList.length; i++) {
          var dependUuid = uuidList[i];
          depends[i] = {
            uuid: decodeUuid(dependUuid),
            owner: objList[i],
            prop: propList[i],
            type: js._getClassById(typeList[i])
          };
        }

        dependMap.set(asset, depends);

        if (asset._native) {
          nativeDependMap.add(asset);
        }

        Details.pool.put(tdInfo);
        return asset;
      }

      var DependUtil = function () {
        function DependUtil() {
          this._depends = new Cache();
        }

        var _proto = DependUtil.prototype;

        _proto.init = function init() {
          this._depends.clear();
        };

        _proto.getNativeDep = function getNativeDep(uuid) {
          var depend = this._depends.get(uuid);

          if (depend && depend.nativeDep) {
            return _extends({}, depend.nativeDep);
          }

          return null;
        };

        _proto.getDeps = function getDeps(uuid) {
          if (this._depends.has(uuid)) {
            return this._depends.get(uuid).deps;
          }

          return [];
        };

        _proto.getDepsRecursively = function getDepsRecursively(uuid) {
          var exclude = Object.create(null);
          var depends = [];

          this._descend(uuid, exclude, depends);

          return depends;
        };

        _proto.remove = function remove(uuid) {
          this._depends.remove(uuid);
        };

        _proto.parse = function parse(uuid, json) {
          var out = null;

          if (Array.isArray(json) || json.__type__ || json instanceof CCON) {
            if (this._depends.has(uuid)) {
              return this._depends.get(uuid);
            }

            if (Array.isArray(json) && ( !hasNativeDep(json))) {
              out = {
                deps: this._parseDepsFromJson(json)
              };
            } else {
              try {
                var asset = deserializeAsset(json, {
                  __uuid__: uuid
                });
                out = this._parseDepsFromAsset(asset);

                if (out.nativeDep) {
                  out.nativeDep.uuid = uuid;
                }

                parsed.add(uuid + "@import", asset);
              } catch (e) {
                files.remove(uuid + "@import");
                out = {
                  deps: []
                };
              }
            }
          } else {
            if ( this._depends.has(uuid)) {
              out = this._depends.get(uuid);

              if (out.parsedFromExistAsset) {
                return out;
              }
            }

            out = this._parseDepsFromAsset(json);
          }

          this._depends.add(uuid, out);

          return out;
        };

        _proto._parseDepsFromAsset = function _parseDepsFromAsset(asset) {
          var out = {
            deps: [],
            parsedFromExistAsset: true
          };
          var deps = dependMap.get(asset);
          assertIsNonNullable(deps);

          for (var i = 0, l = deps.length; i < l; i++) {
            out.deps.push(deps[i].uuid);
          }

          if (nativeDependMap.has(asset)) {
            out.nativeDep = asset._nativeDep;
          }

          return out;
        };

        _proto._parseDepsFromJson = function _parseDepsFromJson(json) {
          var depends = parseUuidDependencies(json);
          depends.forEach(function (uuid, index) {
            return depends[index] = decodeUuid(uuid);
          });
          return depends;
        };

        _proto._descend = function _descend(uuid, exclude, depends) {
          var deps = this.getDeps(uuid);

          for (var i = 0; i < deps.length; i++) {
            var depend = deps[i];

            if (!exclude[depend]) {
              exclude[depend] = true;
              depends.push(depend);

              this._descend(depend, exclude, depends);
            }
          }
        };

        return DependUtil;
      }();
      var dependUtil = new DependUtil();

      var _dec$a, _class$a, _temp$8;
      var _regions = [new BufferTextureCopy()];

      function getMipLevel(width, height) {
        var size = Math.max(width, height);
        var level = 0;

        while (size) {
          size >>= 1;
          level++;
        }

        return level;
      }

      function isPOT(n) {
        return n && (n & n - 1) === 0;
      }

      function canGenerateMipmap(device, w, h) {
        var needCheckPOT = device.gfxAPI === API.WEBGL;

        if (needCheckPOT) {
          return isPOT(w) && isPOT(h);
        }

        return true;
      }

      var SimpleTexture = (_dec$a = ccclass('cc.SimpleTexture'), _dec$a(_class$a = (_temp$8 = function (_TextureBase) {
        _inheritsLoose(SimpleTexture, _TextureBase);

        function SimpleTexture() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _TextureBase.call.apply(_TextureBase, [this].concat(args)) || this;
          _this._gfxTexture = null;
          _this._gfxTextureView = null;
          _this._mipmapLevel = 1;
          _this._textureWidth = 0;
          _this._textureHeight = 0;
          _this._baseLevel = 0;
          _this._maxLevel = 1000;
          return _this;
        }

        var _proto = SimpleTexture.prototype;

        _proto.getGFXTexture = function getGFXTexture() {
          return this._gfxTextureView;
        };

        _proto.destroy = function destroy() {
          this._tryDestroyTextureView();

          this._tryDestroyTexture();

          return _TextureBase.prototype.destroy.call(this);
        };

        _proto.updateImage = function updateImage() {
          this.updateMipmaps(0);
        };

        _proto.updateMipmaps = function updateMipmaps(firstLevel, count) {
        };

        _proto.uploadData = function uploadData(source, level, arrayIndex) {
          if (level === void 0) {
            level = 0;
          }

          if (arrayIndex === void 0) {
            arrayIndex = 0;
          }

          if (!this._gfxTexture || this._mipmapLevel <= level) {
            return;
          }

          var gfxDevice = this._getGFXDevice();

          if (!gfxDevice) {
            return;
          }

          var region = _regions[0];
          region.texExtent.width = this._textureWidth >> level;
          region.texExtent.height = this._textureHeight >> level;
          region.texSubres.mipLevel = level;
          region.texSubres.baseArrayLayer = arrayIndex;

          if (ArrayBuffer.isView(source)) {
            gfxDevice.copyBuffersToTexture([source], this._gfxTexture, _regions);
          } else {
            gfxDevice.copyTexImagesToTexture([source], this._gfxTexture, _regions);
          }
        };

        _proto._assignImage = function _assignImage(image, level, arrayIndex) {
          var data = image.data;

          if (!data) {
            return;
          }

          this.uploadData(data, level, arrayIndex);

          this._checkTextureLoaded();

          if (macro.CLEANUP_IMAGE_CACHE) {
            var deps = dependUtil.getDeps(this._uuid);
            var index = deps.indexOf(image._uuid);

            if (index !== -1) {
              fastRemoveAt(deps, index);
              image.decRef();
            }
          }
        };

        _proto._checkTextureLoaded = function _checkTextureLoaded() {
          this._textureReady();
        };

        _proto._textureReady = function _textureReady() {
          this.loaded = true;
          this.emit('load');
        };

        _proto._setMipmapLevel = function _setMipmapLevel(value) {
          this._mipmapLevel = value < 1 ? 1 : value;
        };

        _proto._setMipRange = function _setMipRange(baseLevel, maxLevel) {
          this._baseLevel = baseLevel < 1 ? 0 : baseLevel;
          this._maxLevel = maxLevel < 1 ? 0 : maxLevel;
        };

        _proto.setMipRange = function setMipRange(baseLevel, maxLevel) {
          assertID(baseLevel <= maxLevel, 3124);

          this._setMipRange(baseLevel, maxLevel);

          var device = this._getGFXDevice();

          if (!device) {
            return;
          }

          var textureView = this._createTextureView(device);

          this._tryDestroyTextureView();

          this._gfxTextureView = textureView;
        };

        _proto._getGfxTextureCreateInfo = function _getGfxTextureCreateInfo(presumed) {
          return null;
        };

        _proto._getGfxTextureViewCreateInfo = function _getGfxTextureViewCreateInfo(presumed) {
          return null;
        };

        _proto._tryReset = function _tryReset() {
          this._tryDestroyTextureView();

          this._tryDestroyTexture();

          if (this._mipmapLevel === 0) {
            return;
          }

          var device = this._getGFXDevice();

          if (!device) {
            return;
          }

          this._createTexture(device);

          this._gfxTextureView = this._createTextureView(device);
        };

        _proto._createTexture = function _createTexture(device) {
          if (this._width === 0 || this._height === 0) {
            return;
          }

          var flags = TextureFlagBit.NONE;

          if (this._mipFilter !== Filter$1.NONE && canGenerateMipmap(device, this._width, this._height)) {
            this._mipmapLevel = getMipLevel(this._width, this._height);
            flags = TextureFlagBit.GEN_MIPMAP;
          }

          var textureCreateInfo = this._getGfxTextureCreateInfo({
            usage: TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST,
            format: this._getGFXFormat(),
            levelCount: this._mipmapLevel,
            flags: flags
          });

          if (!textureCreateInfo) {
            return;
          }

          var texture = device.createTexture(textureCreateInfo);
          this._textureWidth = textureCreateInfo.width;
          this._textureHeight = textureCreateInfo.height;
          this._gfxTexture = texture;
        };

        _proto._createTextureView = function _createTextureView(device) {
          if (!this._gfxTexture) {
            return null;
          }

          var maxLevel = this._maxLevel < this._mipmapLevel ? this._maxLevel : this._mipmapLevel - 1;

          var textureViewCreateInfo = this._getGfxTextureViewCreateInfo({
            texture: this._gfxTexture,
            format: this._getGFXFormat(),
            baseLevel: this._baseLevel,
            levelCount: maxLevel - this._baseLevel + 1
          });

          if (!textureViewCreateInfo) {
            return null;
          }

          return device.createTexture(textureViewCreateInfo);
        };

        _proto._tryDestroyTexture = function _tryDestroyTexture() {
          if (this._gfxTexture) {
            this._gfxTexture.destroy();

            this._gfxTexture = null;
          }
        };

        _proto._tryDestroyTextureView = function _tryDestroyTextureView() {
          if (this._gfxTextureView) {
            this._gfxTextureView.destroy();

            this._gfxTextureView = null;
          }
        };

        _createClass(SimpleTexture, [{
          key: "mipmapLevel",
          get: function get() {
            return this._mipmapLevel;
          }
        }]);

        return SimpleTexture;
      }(TextureBase), _temp$8)) || _class$a);
      legacyCC.SimpleTexture = SimpleTexture;

      var _dec$b, _dec2$4, _class$b, _class2$9, _descriptor$7, _temp$9;
      var Texture2D = exports('Texture2D', (_dec$b = ccclass('cc.Texture2D'), _dec2$4 = type([ImageAsset]), _dec$b(_class$b = (_class2$9 = (_temp$9 = function (_SimpleTexture) {
        _inheritsLoose(Texture2D, _SimpleTexture);

        function Texture2D() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _SimpleTexture.call.apply(_SimpleTexture, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_mipmaps", _descriptor$7, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = Texture2D.prototype;

        _proto.initialize = function initialize() {
          this.mipmaps = this._mipmaps;
        };

        _proto.onLoaded = function onLoaded() {
          this.initialize();
        };

        _proto.reset = function reset(info) {
          this._width = info.width;
          this._height = info.height;

          this._setGFXFormat(info.format);

          var mipLevels = info.mipmapLevel === undefined ? 1 : info.mipmapLevel;

          this._setMipmapLevel(mipLevels);

          var minLod = info.baseLevel === undefined ? 0 : info.baseLevel;
          var maxLod = info.maxLevel === undefined ? 1000 : info.maxLevel;

          this._setMipRange(minLod, maxLod);

          this._tryReset();
        };

        _proto.create = function create(width, height, format, mipmapLevel, baseLevel, maxLevel) {
          if (format === void 0) {
            format = PixelFormat.RGBA8888;
          }

          if (mipmapLevel === void 0) {
            mipmapLevel = 1;
          }

          if (baseLevel === void 0) {
            baseLevel = 0;
          }

          if (maxLevel === void 0) {
            maxLevel = 1000;
          }

          this.reset({
            width: width,
            height: height,
            format: format,
            mipmapLevel: mipmapLevel,
            baseLevel: baseLevel,
            maxLevel: maxLevel
          });
        };

        _proto.toString = function toString() {
          return this._mipmaps.length !== 0 ? this._mipmaps[0].url : '';
        };

        _proto.updateMipmaps = function updateMipmaps(firstLevel, count) {
          if (firstLevel === void 0) {
            firstLevel = 0;
          }

          if (firstLevel >= this._mipmaps.length) {
            return;
          }

          var nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

          for (var i = 0; i < nUpdate; ++i) {
            var level = firstLevel + i;

            this._assignImage(this._mipmaps[level], level);
          }
        };

        _proto.getHtmlElementObj = function getHtmlElementObj() {
          return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
        };

        _proto.destroy = function destroy() {
          this._mipmaps = [];
          return _SimpleTexture.prototype.destroy.call(this);
        };

        _proto.description = function description() {
          var url = this._mipmaps[0] ? this._mipmaps[0].url : '';
          return "<cc.Texture2D | Name = " + url + " | Dimension = " + this.width + " x " + this.height + ">";
        };

        _proto.releaseTexture = function releaseTexture() {
          this.destroy();
        };

        _proto._serialize = function _serialize(ctxForExporting) {

          return null;
        };

        _proto._deserialize = function _deserialize(serializedData, handle) {
          var data = serializedData;

          _SimpleTexture.prototype._deserialize.call(this, data.base, handle);

          this._mipmaps = new Array(data.mipmaps.length);

          for (var i = 0; i < data.mipmaps.length; ++i) {
            this._mipmaps[i] = new ImageAsset();

            if (!data.mipmaps[i]) {
              continue;
            }

            var mipmapUUID = data.mipmaps[i];
            handle.result.push(this._mipmaps, "" + i, mipmapUUID, js._getClassId(ImageAsset));
          }
        };

        _proto._getGfxTextureCreateInfo = function _getGfxTextureCreateInfo(presumed) {
          var texInfo = new TextureInfo(TextureType.TEX2D);
          texInfo.width = this._width;
          texInfo.height = this._height;
          Object.assign(texInfo, presumed);
          return texInfo;
        };

        _proto._getGfxTextureViewCreateInfo = function _getGfxTextureViewCreateInfo(presumed) {
          var texViewInfo = new TextureViewInfo();
          texViewInfo.type = TextureType.TEX2D;
          Object.assign(texViewInfo, presumed);
          return texViewInfo;
        };

        _proto.initDefault = function initDefault(uuid) {
          _SimpleTexture.prototype.initDefault.call(this, uuid);

          var imageAsset = new ImageAsset();
          imageAsset.initDefault();
          this.image = imageAsset;
        };

        _proto.validate = function validate() {
          return this.mipmaps && this.mipmaps.length !== 0;
        };

        _createClass(Texture2D, [{
          key: "mipmaps",
          get: function get() {
            return this._mipmaps;
          },
          set: function set(value) {
            var _this2 = this;

            this._mipmaps = value;

            this._setMipmapLevel(this._mipmaps.length);

            if (this._mipmaps.length > 0) {
              var imageAsset = this._mipmaps[0];
              this.reset({
                width: imageAsset.width,
                height: imageAsset.height,
                format: imageAsset.format,
                mipmapLevel: this._mipmaps.length,
                baseLevel: this._baseLevel,
                maxLevel: this._maxLevel
              });

              this._mipmaps.forEach(function (mipmap, level) {
                _this2._assignImage(mipmap, level);
              });
            } else {
              this.reset({
                width: 0,
                height: 0,
                mipmapLevel: this._mipmaps.length,
                baseLevel: this._baseLevel,
                maxLevel: this._maxLevel
              });
            }
          }
        }, {
          key: "image",
          get: function get() {
            return this._mipmaps.length === 0 ? null : this._mipmaps[0];
          },
          set: function set(value) {
            this.mipmaps = value ? [value] : [];
          }
        }]);

        return Texture2D;
      }(SimpleTexture), _temp$9), (_descriptor$7 = _applyDecoratedDescriptor(_class2$9.prototype, "_mipmaps", [_dec2$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$9)) || _class$b));
      legacyCC.Texture2D = Texture2D;

      var _dec$c, _class$c, _class2$a, _descriptor$8, _descriptor2$5, _class3$6, _temp$a;
      var FaceIndex;

      (function (FaceIndex) {
        FaceIndex[FaceIndex["right"] = 0] = "right";
        FaceIndex[FaceIndex["left"] = 1] = "left";
        FaceIndex[FaceIndex["top"] = 2] = "top";
        FaceIndex[FaceIndex["bottom"] = 3] = "bottom";
        FaceIndex[FaceIndex["front"] = 4] = "front";
        FaceIndex[FaceIndex["back"] = 5] = "back";
      })(FaceIndex || (FaceIndex = {}));

      var TextureCube = exports('TextureCube', (_dec$c = ccclass('cc.TextureCube'), _dec$c(_class$c = (_class2$a = (_temp$a = _class3$6 = function (_SimpleTexture) {
        _inheritsLoose(TextureCube, _SimpleTexture);

        function TextureCube() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _SimpleTexture.call.apply(_SimpleTexture, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "isRGBE", _descriptor$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_mipmaps", _descriptor2$5, _assertThisInitialized(_this));

          return _this;
        }

        TextureCube.fromTexture2DArray = function fromTexture2DArray(textures, out) {
          var mipmaps = [];
          var nMipmaps = textures.length / 6;

          for (var i = 0; i < nMipmaps; i++) {
            var x = i * 6;
            mipmaps.push({
              front: textures[x + FaceIndex.front].image,
              back: textures[x + FaceIndex.back].image,
              left: textures[x + FaceIndex.left].image,
              right: textures[x + FaceIndex.right].image,
              top: textures[x + FaceIndex.top].image,
              bottom: textures[x + FaceIndex.bottom].image
            });
          }

          out = out || new TextureCube();
          out.mipmaps = mipmaps;
          return out;
        };

        var _proto = TextureCube.prototype;

        _proto.onLoaded = function onLoaded() {
          this.mipmaps = this._mipmaps;
        };

        _proto.reset = function reset(info) {
          this._width = info.width;
          this._height = info.height;

          this._setGFXFormat(info.format);

          var mipLevels = info.mipmapLevel === undefined ? 1 : info.mipmapLevel;

          this._setMipmapLevel(mipLevels);

          var minLod = info.baseLevel === undefined ? 0 : info.baseLevel;
          var maxLod = info.maxLevel === undefined ? 1000 : info.maxLevel;

          this._setMipRange(minLod, maxLod);

          this._tryReset();
        };

        _proto.updateMipmaps = function updateMipmaps(firstLevel, count) {
          var _this2 = this;

          if (firstLevel === void 0) {
            firstLevel = 0;
          }

          if (firstLevel >= this._mipmaps.length) {
            return;
          }

          var nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

          var _loop = function _loop(i) {
            var level = firstLevel + i;

            _forEachFace(_this2._mipmaps[level], function (face, faceIndex) {
              _this2._assignImage(face, level, faceIndex);
            });
          };

          for (var i = 0; i < nUpdate; ++i) {
            _loop(i);
          }
        };

        _proto.destroy = function destroy() {
          this._mipmaps = [];
          return _SimpleTexture.prototype.destroy.call(this);
        };

        _proto.releaseTexture = function releaseTexture() {
          this.mipmaps = [];
        };

        _proto._serialize = function _serialize(ctxForExporting) {

          return null;
        };

        _proto._deserialize = function _deserialize(serializedData, handle) {
          var data = serializedData;

          _SimpleTexture.prototype._deserialize.call(this, data.base, handle);

          this.isRGBE = data.rgbe;
          this._mipmaps = new Array(data.mipmaps.length);

          for (var i = 0; i < data.mipmaps.length; ++i) {
            this._mipmaps[i] = {
              front: new ImageAsset(),
              back: new ImageAsset(),
              left: new ImageAsset(),
              right: new ImageAsset(),
              top: new ImageAsset(),
              bottom: new ImageAsset()
            };
            var mipmap = data.mipmaps[i];

            var imageAssetClassId = js._getClassId(ImageAsset);

            handle.result.push(this._mipmaps[i], "front", mipmap.front, imageAssetClassId);
            handle.result.push(this._mipmaps[i], "back", mipmap.back, imageAssetClassId);
            handle.result.push(this._mipmaps[i], "left", mipmap.left, imageAssetClassId);
            handle.result.push(this._mipmaps[i], "right", mipmap.right, imageAssetClassId);
            handle.result.push(this._mipmaps[i], "top", mipmap.top, imageAssetClassId);
            handle.result.push(this._mipmaps[i], "bottom", mipmap.bottom, imageAssetClassId);
          }
        };

        _proto._getGfxTextureCreateInfo = function _getGfxTextureCreateInfo(presumed) {
          var texInfo = new TextureInfo(TextureType.CUBE);
          texInfo.width = this._width;
          texInfo.height = this._height;
          texInfo.layerCount = 6;
          Object.assign(texInfo, presumed);
          return texInfo;
        };

        _proto._getGfxTextureViewCreateInfo = function _getGfxTextureViewCreateInfo(presumed) {
          var texViewInfo = new TextureViewInfo();
          texViewInfo.type = TextureType.CUBE;
          texViewInfo.baseLayer = 0;
          texViewInfo.layerCount = 6;
          Object.assign(texViewInfo, presumed);
          return texViewInfo;
        };

        _proto.initDefault = function initDefault(uuid) {
          _SimpleTexture.prototype.initDefault.call(this, uuid);

          var imageAsset = new ImageAsset();
          imageAsset.initDefault();
          this.mipmaps = [{
            front: imageAsset,
            back: imageAsset,
            top: imageAsset,
            bottom: imageAsset,
            left: imageAsset,
            right: imageAsset
          }];
        };

        _proto.validate = function validate() {
          return this._mipmaps.length !== 0 && !this._mipmaps.find(function (x) {
            return !(x.top && x.bottom && x.front && x.back && x.left && x.right);
          });
        };

        _createClass(TextureCube, [{
          key: "mipmaps",
          get: function get() {
            return this._mipmaps;
          },
          set: function set(value) {
            var _this3 = this;

            this._mipmaps = value;

            this._setMipmapLevel(this._mipmaps.length);

            if (this._mipmaps.length > 0) {
              var imageAsset = this._mipmaps[0].front;
              this.reset({
                width: imageAsset.width,
                height: imageAsset.height,
                format: imageAsset.format,
                mipmapLevel: this._mipmaps.length,
                baseLevel: this._baseLevel,
                maxLevel: this._maxLevel
              });

              this._mipmaps.forEach(function (mipmap, level) {
                _forEachFace(mipmap, function (face, faceIndex) {
                  _this3._assignImage(face, level, faceIndex);
                });
              });
            } else {
              this.reset({
                width: 0,
                height: 0,
                mipmapLevel: this._mipmaps.length,
                baseLevel: this._baseLevel,
                maxLevel: this._maxLevel
              });
            }
          }
        }, {
          key: "image",
          get: function get() {
            return this._mipmaps.length === 0 ? null : this._mipmaps[0];
          },
          set: function set(value) {
            this.mipmaps = value ? [value] : [];
          }
        }]);

        return TextureCube;
      }(SimpleTexture), _class3$6.FaceIndex = FaceIndex, _temp$a), (_descriptor$8 = _applyDecoratedDescriptor(_class2$a.prototype, "isRGBE", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$a.prototype, "_mipmaps", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$a)) || _class$c));
      legacyCC.TextureCube = TextureCube;

      function _forEachFace(mipmap, callback) {
        callback(mipmap.front, FaceIndex.front);
        callback(mipmap.back, FaceIndex.back);
        callback(mipmap.left, FaceIndex.left);
        callback(mipmap.right, FaceIndex.right);
        callback(mipmap.top, FaceIndex.top);
        callback(mipmap.bottom, FaceIndex.bottom);
      }

      var effects = exports('effects', [{
        "name": "billboard",
        "techniques": [{
          "name": "add",
          "passes": [{
            "rasterizerState": {
              "cullMode": 0
            },
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 1,
                "blendSrcAlpha": 2,
                "blendDstAlpha": 1
              }]
            },
            "program": "billboard|vert:vs_main|tinted-fs:add",
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false
            },
            "properties": {
              "mainTexture": {
                "value": "grey",
                "type": 28
              },
              "mainTiling_Offset": {
                "value": [1, 1, 0, 0],
                "type": 16
              },
              "tintColor": {
                "value": [0.5, 0.5, 0.5, 0.5],
                "type": 16
              }
            }
          }]
        }],
        "shaders": [{
          "name": "billboard|vert:vs_main|tinted-fs:add",
          "hash": 3642336485,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 54,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 1
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 2
          }],
          "blocks": [{
            "name": "Constants",
            "defines": [],
            "binding": 0,
            "stageFlags": 1,
            "members": [{
              "name": "mainTiling_Offset",
              "type": 16,
              "count": 1
            }, {
              "name": "frameTile_velLenScale",
              "type": 16,
              "count": 1
            }, {
              "name": "scale",
              "type": 16,
              "count": 1
            }, {
              "name": "nodeRotation",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "builtin",
            "defines": [],
            "binding": 1,
            "stageFlags": 1,
            "members": [{
              "name": "cc_size_rotation",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "FragConstants",
            "defines": [],
            "binding": 2,
            "stageFlags": 16,
            "members": [{
              "name": "tintColor",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "mainTexture",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 3
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "clear-stencil",
        "techniques": [{
          "passes": [{
            "blendState": {
              "targets": [{
                "blend": true
              }]
            },
            "rasterizerState": {
              "cullMode": 0
            },
            "program": "clear-stencil|sprite-vs:vert|sprite-fs:frag",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }]
        }],
        "shaders": [{
          "name": "clear-stencil|sprite-vs:vert|sprite-fs:frag",
          "hash": 3507038093,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 0,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
            },
            "globals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "geometry-renderer",
        "techniques": [{
          "passes": [{
            "primitive": 1,
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "geometry-renderer|line-vs:vert|line-fs:front",
            "priority": 245,
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }]
        }, {
          "passes": [{
            "primitive": 1,
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "geometry-renderer|line-vs:vert|line-fs:front",
            "priority": 245,
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false
            }
          }, {
            "primitive": 1,
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "geometry-renderer|line-vs:vert|line-fs:back",
            "priority": 245,
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false,
              "depthFunc": 4
            }
          }]
        }, {
          "passes": [{
            "primitive": 1,
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:front",
            "priority": 245,
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }]
        }, {
          "passes": [{
            "primitive": 1,
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:front",
            "priority": 245,
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false
            }
          }, {
            "primitive": 1,
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:back",
            "priority": 245,
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false,
              "depthFunc": 4
            }
          }]
        }, {
          "passes": [{
            "rasterizerState": {
              "cullMode": 2
            },
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "geometry-renderer|triangle-vs:vert|triangle-fs:front",
            "priority": 245,
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }]
        }, {
          "passes": [{
            "rasterizerState": {
              "cullMode": 2
            },
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "geometry-renderer|triangle-vs:vert|triangle-fs:front",
            "priority": 245,
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false
            }
          }, {
            "rasterizerState": {
              "cullMode": 2
            },
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "geometry-renderer|triangle-vs:vert|triangle-fs:back",
            "priority": 245,
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false,
              "depthFunc": 4
            }
          }]
        }],
        "shaders": [{
          "name": "geometry-renderer|line-vs:vert|line-fs:front",
          "hash": 3617431000,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_FORWARD_PIPELINE",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 1
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "geometry-renderer|line-vs:vert|line-fs:back",
          "hash": 4168905198,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_FORWARD_PIPELINE",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 1
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:front",
          "hash": 4034582016,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_FORWARD_PIPELINE",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 1
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:back",
          "hash": 1762165009,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_FORWARD_PIPELINE",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 1
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "geometry-renderer|triangle-vs:vert|triangle-fs:front",
          "hash": 4143142643,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_FORWARD_PIPELINE",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 44,
            "location": 1
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 2
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "geometry-renderer|triangle-vs:vert|triangle-fs:back",
          "hash": 826026446,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_FORWARD_PIPELINE",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 44,
            "location": 1
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 2
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "graphics",
        "techniques": [{
          "passes": [{
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 1,
                "blendDst": 4,
                "blendSrcAlpha": 1,
                "blendDstAlpha": 4
              }]
            },
            "rasterizerState": {
              "cullMode": 0
            },
            "program": "graphics|vs:vert|fs:frag",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }]
        }],
        "shaders": [{
          "name": "graphics|vs:vert|fs:frag",
          "hash": 4284763886,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 49,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 1
          }, {
            "name": "a_dist",
            "defines": [],
            "format": 11,
            "location": 2
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "occlusion-query",
        "techniques": [{
          "passes": [{
            "rasterizerState": {
              "cullMode": 2
            },
            "blendState": {
              "targets": [{
                "blendColorMask": 0
              }]
            },
            "program": "occlusion-query|occlusion-query-vs:vert|occlusion-query-fs:frag",
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false
            }
          }]
        }],
        "shaders": [{
          "name": "occlusion-query|occlusion-query-vs:vert|occlusion-query-fs:frag",
          "hash": 1571978323,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 41,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCWorldBound",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "particle-gpu",
        "techniques": [{
          "name": "add",
          "passes": [{
            "rasterizerState": {
              "cullMode": 0
            },
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 1,
                "blendSrcAlpha": 2,
                "blendDstAlpha": 1
              }]
            },
            "program": "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false
            },
            "properties": {
              "mainTexture": {
                "value": "grey",
                "type": 28
              },
              "mainTiling_Offset": {
                "value": [1, 1, 0, 0],
                "type": 16
              },
              "tintColor": {
                "value": [0.5, 0.5, 0.5, 0.5],
                "type": 16
              }
            }
          }]
        }],
        "shaders": [{
          "name": "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
          "hash": 851293782,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 64,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "CC_RENDER_MODE",
            "type": "number",
            "range": [0, 4]
          }, {
            "name": "USE_VK_SHADER",
            "type": "boolean"
          }, {
            "name": "COLOR_OVER_TIME_MODULE_ENABLE",
            "type": "boolean"
          }, {
            "name": "ROTATION_OVER_TIME_MODULE_ENABLE",
            "type": "boolean"
          }, {
            "name": "SIZE_OVER_TIME_MODULE_ENABLE",
            "type": "boolean"
          }, {
            "name": "FORCE_OVER_TIME_MODULE_ENABLE",
            "type": "boolean"
          }, {
            "name": "VELOCITY_OVER_TIME_MODULE_ENABLE",
            "type": "boolean"
          }, {
            "name": "TEXTURE_ANIMATION_MODULE_ENABLE",
            "type": "boolean"
          }, {
            "name": "CC_USE_WORLD_SPACE",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position_starttime",
            "defines": [],
            "format": 44,
            "location": 0
          }, {
            "name": "a_size_uv",
            "defines": [],
            "format": 44,
            "location": 1
          }, {
            "name": "a_rotation_uv",
            "defines": [],
            "format": 44,
            "location": 2
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_dir_life",
            "defines": [],
            "format": 44,
            "location": 4
          }, {
            "name": "a_rndSeed",
            "defines": [],
            "format": 11,
            "location": 5
          }, {
            "name": "a_texCoord",
            "defines": ["CC_RENDER_MODE"],
            "format": 32,
            "location": 6
          }, {
            "name": "a_texCoord3",
            "defines": ["CC_RENDER_MODE"],
            "format": 32,
            "location": 7
          }, {
            "name": "a_normal",
            "defines": ["CC_RENDER_MODE"],
            "format": 32,
            "location": 8
          }, {
            "name": "a_color1",
            "defines": ["CC_RENDER_MODE"],
            "format": 44,
            "location": 9
          }],
          "blocks": [{
            "name": "Constants",
            "defines": [],
            "binding": 0,
            "stageFlags": 1,
            "members": [{
              "name": "mainTiling_Offset",
              "type": 16,
              "count": 1
            }, {
              "name": "frameTile_velLenScale",
              "type": 16,
              "count": 1
            }, {
              "name": "scale",
              "type": 16,
              "count": 1
            }, {
              "name": "nodeRotation",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "SampleConstants",
            "defines": [],
            "binding": 1,
            "stageFlags": 1,
            "members": [{
              "name": "u_sampleInfo",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "TickConstants",
            "defines": [],
            "binding": 2,
            "stageFlags": 1,
            "members": [{
              "name": "u_worldRot",
              "type": 16,
              "count": 1
            }, {
              "name": "u_timeDelta",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "ColorConstant",
            "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
            "binding": 3,
            "stageFlags": 1,
            "members": [{
              "name": "u_color_mode",
              "type": 5,
              "count": 1
            }]
          }, {
            "name": "RotationConstant",
            "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
            "binding": 4,
            "stageFlags": 1,
            "members": [{
              "name": "u_rotation_mode",
              "type": 5,
              "count": 1
            }]
          }, {
            "name": "SizeConstant",
            "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
            "binding": 5,
            "stageFlags": 1,
            "members": [{
              "name": "u_size_mode",
              "type": 5,
              "count": 1
            }]
          }, {
            "name": "ForceConstant",
            "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
            "binding": 6,
            "stageFlags": 1,
            "members": [{
              "name": "u_force_mode",
              "type": 5,
              "count": 1
            }, {
              "name": "u_force_space",
              "type": 5,
              "count": 1
            }]
          }, {
            "name": "VelocityConstant",
            "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
            "binding": 7,
            "stageFlags": 1,
            "members": [{
              "name": "u_velocity_mode",
              "type": 5,
              "count": 1
            }, {
              "name": "u_velocity_space",
              "type": 5,
              "count": 1
            }]
          }, {
            "name": "AnimationConstant",
            "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
            "binding": 8,
            "stageFlags": 1,
            "members": [{
              "name": "u_anim_info",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "FragConstants",
            "defines": [],
            "binding": 9,
            "stageFlags": 16,
            "members": [{
              "name": "tintColor",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "color_over_time_tex0",
            "type": 28,
            "count": 1,
            "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
            "stageFlags": 1,
            "binding": 10
          }, {
            "name": "rotation_over_time_tex0",
            "type": 28,
            "count": 1,
            "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
            "stageFlags": 1,
            "binding": 11
          }, {
            "name": "size_over_time_tex0",
            "type": 28,
            "count": 1,
            "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
            "stageFlags": 1,
            "binding": 12
          }, {
            "name": "force_over_time_tex0",
            "type": 28,
            "count": 1,
            "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
            "stageFlags": 1,
            "binding": 13
          }, {
            "name": "velocity_over_time_tex0",
            "type": 28,
            "count": 1,
            "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
            "stageFlags": 1,
            "binding": 14
          }, {
            "name": "texture_animation_tex0",
            "type": 28,
            "count": 1,
            "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
            "stageFlags": 1,
            "binding": 15
          }, {
            "name": "mainTexture",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 16
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "particle-trail",
        "techniques": [{
          "name": "add",
          "passes": [{
            "rasterizerState": {
              "cullMode": 0
            },
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 1,
                "blendSrcAlpha": 2,
                "blendDstAlpha": 1
              }]
            },
            "program": "particle-trail|particle-trail:vs_main|tinted-fs:add",
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false
            },
            "properties": {
              "mainTexture": {
                "value": "grey",
                "type": 28
              },
              "mainTiling_Offset": {
                "value": [1, 1, 0, 0],
                "type": 16
              },
              "frameTile_velLenScale": {
                "value": [1, 1, 0, 0],
                "type": 16
              },
              "tintColor": {
                "value": [0.5, 0.5, 0.5, 0.5],
                "type": 16
              }
            }
          }]
        }],
        "shaders": [{
          "name": "particle-trail|particle-trail:vs_main|tinted-fs:add",
          "hash": 2502358098,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 53,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "CC_RENDER_MODE",
            "type": "number",
            "range": [0, 4]
          }, {
            "name": "CC_DRAW_WIRE_FRAME",
            "type": "boolean"
          }, {
            "name": "CC_USE_WORLD_SPACE",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 44,
            "location": 1
          }, {
            "name": "a_texCoord1",
            "defines": [],
            "format": 32,
            "location": 2
          }, {
            "name": "a_texCoord2",
            "defines": [],
            "format": 32,
            "location": 3
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 4
          }],
          "blocks": [{
            "name": "Constants",
            "defines": [],
            "binding": 0,
            "stageFlags": 1,
            "members": [{
              "name": "mainTiling_Offset",
              "type": 16,
              "count": 1
            }, {
              "name": "frameTile_velLenScale",
              "type": 16,
              "count": 1
            }, {
              "name": "scale",
              "type": 16,
              "count": 1
            }, {
              "name": "nodeRotation",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "FragConstants",
            "defines": [],
            "binding": 1,
            "stageFlags": 16,
            "members": [{
              "name": "tintColor",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "mainTexture",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 2
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "particle",
        "techniques": [{
          "name": "add",
          "passes": [{
            "rasterizerState": {
              "cullMode": 0
            },
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 1,
                "blendSrcAlpha": 2,
                "blendDstAlpha": 1
              }]
            },
            "program": "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false
            },
            "properties": {
              "mainTexture": {
                "value": "grey",
                "type": 28
              },
              "mainTiling_Offset": {
                "value": [1, 1, 0, 0],
                "type": 16
              },
              "tintColor": {
                "value": [0.5, 0.5, 0.5, 0.5],
                "type": 16
              }
            }
          }]
        }],
        "shaders": [{
          "name": "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
          "hash": 585841727,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 53,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "CC_RENDER_MODE",
            "type": "number",
            "range": [0, 4]
          }, {
            "name": "CC_USE_WORLD_SPACE",
            "type": "boolean"
          }, {
            "name": "ROTATION_OVER_TIME_MODULE_ENABLE",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord1",
            "defines": [],
            "format": 32,
            "location": 2
          }, {
            "name": "a_texCoord2",
            "defines": [],
            "format": 32,
            "location": 3
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 4
          }, {
            "name": "a_color1",
            "defines": ["CC_RENDER_MODE"],
            "format": 32,
            "location": 8
          }, {
            "name": "a_texCoord3",
            "defines": ["CC_RENDER_MODE"],
            "format": 32,
            "location": 6
          }, {
            "name": "a_normal",
            "defines": ["CC_RENDER_MODE"],
            "format": 32,
            "location": 7
          }],
          "blocks": [{
            "name": "Constants",
            "defines": [],
            "binding": 0,
            "stageFlags": 1,
            "members": [{
              "name": "mainTiling_Offset",
              "type": 16,
              "count": 1
            }, {
              "name": "frameTile_velLenScale",
              "type": 16,
              "count": 1
            }, {
              "name": "scale",
              "type": 16,
              "count": 1
            }, {
              "name": "nodeRotation",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "FragConstants",
            "defines": [],
            "binding": 1,
            "stageFlags": 16,
            "members": [{
              "name": "tintColor",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "mainTexture",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 2
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "spine",
        "techniques": [{
          "passes": [{
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "rasterizerState": {
              "cullMode": 0
            },
            "program": "spine|sprite-vs:vert|sprite-fs:frag",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            },
            "properties": {
              "alphaThreshold": {
                "value": [0.5],
                "type": 13
              }
            }
          }]
        }],
        "shaders": [{
          "name": "spine|sprite-vs:vert|sprite-fs:frag",
          "hash": 2499219289,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 49,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": ["USE_LOCAL"]
              }],
              "samplerTextures": [{
                "name": "cc_spriteTexture",
                "defines": []
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_LOCAL",
            "type": "boolean"
          }, {
            "name": "TWO_COLORED",
            "type": "boolean"
          }, {
            "name": "USE_ALPHA_TEST",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 1
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 2
          }, {
            "name": "a_color2",
            "defines": ["TWO_COLORED"],
            "format": 44,
            "location": 3
          }],
          "blocks": [{
            "name": "ALPHA_TEST_DATA",
            "defines": ["USE_ALPHA_TEST"],
            "binding": 0,
            "stageFlags": 16,
            "members": [{
              "name": "alphaThreshold",
              "type": 13,
              "count": 1
            }]
          }],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "sprite",
        "techniques": [{
          "passes": [{
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "rasterizerState": {
              "cullMode": 0
            },
            "program": "sprite|sprite-vs:vert|sprite-fs:frag",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            },
            "properties": {
              "alphaThreshold": {
                "value": [0.5],
                "type": 13
              }
            }
          }]
        }],
        "shaders": [{
          "name": "sprite|sprite-vs:vert|sprite-fs:frag",
          "hash": 67215139,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 49,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": ["USE_LOCAL"]
              }],
              "samplerTextures": [{
                "name": "cc_spriteTexture",
                "defines": ["USE_TEXTURE"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_LOCAL",
            "type": "boolean"
          }, {
            "name": "SAMPLE_FROM_RT",
            "type": "boolean"
          }, {
            "name": "USE_PIXEL_ALIGNMENT",
            "type": "boolean"
          }, {
            "name": "CC_USE_EMBEDDED_ALPHA",
            "type": "boolean"
          }, {
            "name": "USE_ALPHA_TEST",
            "type": "boolean"
          }, {
            "name": "USE_TEXTURE",
            "type": "boolean"
          }, {
            "name": "IS_GRAY",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 1
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 2
          }],
          "blocks": [{
            "name": "ALPHA_TEST_DATA",
            "defines": ["USE_ALPHA_TEST"],
            "binding": 0,
            "stageFlags": 16,
            "members": [{
              "name": "alphaThreshold",
              "type": 13,
              "count": 1
            }]
          }],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "standard",
        "techniques": [{
          "name": "opaque",
          "passes": [{
            "program": "standard|standard-vs|standard-fs",
            "properties": {
              "tilingOffset": {
                "value": [1, 1, 0, 0],
                "type": 16
              },
              "mainColor": {
                "value": [1, 1, 1, 1],
                "linear": true,
                "type": 16,
                "handleInfo": ["albedo", 0, 16]
              },
              "albedoScale": {
                "value": [1, 1, 1],
                "type": 15,
                "handleInfo": ["albedoScaleAndCutoff", 0, 15]
              },
              "alphaThreshold": {
                "value": [0.5],
                "type": 13,
                "handleInfo": ["albedoScaleAndCutoff", 3, 13]
              },
              "occlusion": {
                "value": [1],
                "type": 13,
                "handleInfo": ["pbrParams", 0, 13]
              },
              "roughness": {
                "value": [0.8],
                "type": 13,
                "handleInfo": ["pbrParams", 1, 13]
              },
              "metallic": {
                "value": [0.6],
                "type": 13,
                "handleInfo": ["pbrParams", 2, 13]
              },
              "specularIntensity": {
                "value": [0.5],
                "type": 13,
                "handleInfo": ["pbrParams", 3, 13]
              },
              "emissive": {
                "value": [0, 0, 0, 1],
                "linear": true,
                "type": 16
              },
              "emissiveScale": {
                "value": [1, 1, 1],
                "type": 15,
                "handleInfo": ["emissiveScaleParam", 0, 15]
              },
              "normalStrength": {
                "value": [1],
                "type": 13,
                "handleInfo": ["emissiveScaleParam", 3, 13]
              },
              "mainTexture": {
                "value": "grey",
                "type": 28,
                "handleInfo": ["albedoMap", 0, 28]
              },
              "normalMap": {
                "value": "normal",
                "type": 28
              },
              "pbrMap": {
                "value": "grey",
                "type": 28
              },
              "metallicRoughnessMap": {
                "value": "grey",
                "type": 28
              },
              "occlusionMap": {
                "value": "white",
                "type": 28
              },
              "emissiveMap": {
                "value": "grey",
                "type": 28
              },
              "albedo": {
                "type": 16,
                "value": [1, 1, 1, 1]
              },
              "albedoScaleAndCutoff": {
                "type": 16,
                "value": [1, 1, 1, 0.5]
              },
              "pbrParams": {
                "type": 16,
                "value": [1, 0.8, 0.6, 0.5]
              },
              "emissiveScaleParam": {
                "type": 16,
                "value": [1, 1, 1, 1]
              },
              "albedoMap": {
                "type": 28,
                "value": "grey"
              }
            }
          }, {
            "phase": "forward-add",
            "propertyIndex": 0,
            "embeddedMacros": {
              "CC_FORWARD_ADD": true
            },
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 1,
                "blendDst": 1,
                "blendSrcAlpha": 0,
                "blendDstAlpha": 1
              }]
            },
            "program": "standard|standard-vs|standard-fs",
            "depthStencilState": {
              "depthFunc": 2,
              "depthTest": true,
              "depthWrite": false
            }
          }, {
            "phase": "shadow-caster",
            "propertyIndex": 0,
            "rasterizerState": {
              "cullMode": 1
            },
            "program": "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
            "properties": {
              "tilingOffset": {
                "value": [1, 1, 0, 0],
                "type": 16
              },
              "mainColor": {
                "value": [1, 1, 1, 1],
                "type": 16,
                "handleInfo": ["albedo", 0, 16]
              },
              "albedoScale": {
                "value": [1, 1, 1],
                "type": 15,
                "handleInfo": ["albedoScaleAndCutoff", 0, 15]
              },
              "alphaThreshold": {
                "value": [0.5],
                "type": 13,
                "handleInfo": ["albedoScaleAndCutoff", 3, 13]
              },
              "mainTexture": {
                "value": "grey",
                "type": 28,
                "handleInfo": ["albedoMap", 0, 28]
              },
              "albedo": {
                "type": 16,
                "value": [1, 1, 1, 1]
              },
              "albedoScaleAndCutoff": {
                "type": 16,
                "value": [1, 1, 1, 0.5]
              },
              "albedoMap": {
                "type": 28,
                "value": "grey"
              }
            }
          }]
        }],
        "shaders": [{
          "name": "standard|standard-vs|standard-fs",
          "hash": 4079105024,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 223,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 75
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }, {
                "name": "CCShadow",
                "defines": []
              }],
              "samplerTextures": [{
                "name": "cc_shadowMap",
                "defines": ["CC_RECEIVE_SHADOW"]
              }, {
                "name": "cc_spotLightingMap",
                "defines": ["CC_RECEIVE_SHADOW"]
              }, {
                "name": "cc_environment",
                "defines": ["CC_USE_IBL"]
              }, {
                "name": "cc_diffuseMap",
                "defines": ["CC_USE_DIFFUSEMAP"]
              }],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCMorph",
                "defines": ["CC_USE_MORPH"]
              }, {
                "name": "CCSkinningTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinningAnimation",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinning",
                "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCLocalBatched",
                "defines": ["!USE_INSTANCING", "USE_BATCHING"]
              }, {
                "name": "CCLocal",
                "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
              }, {
                "name": "CCForwardLight",
                "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"]
              }],
              "samplerTextures": [{
                "name": "cc_PositionDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
              }, {
                "name": "cc_NormalDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
              }, {
                "name": "cc_TangentDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
              }, {
                "name": "cc_jointTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "cc_lightingMap",
                "defines": ["CC_USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_COUNT",
            "type": "number",
            "range": [2, 8]
          }, {
            "name": "CC_MORPH_PRECOMPUTED",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_POSITION",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_NORMAL",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_TANGENT",
            "type": "boolean"
          }, {
            "name": "CC_USE_FOG",
            "type": "number",
            "range": [0, 4]
          }, {
            "name": "CC_USE_ACCURATE_FOG",
            "type": "boolean"
          }, {
            "name": "USE_VERTEX_COLOR",
            "type": "boolean"
          }, {
            "name": "HAS_SECOND_UV",
            "type": "boolean"
          }, {
            "name": "USE_NORMAL_MAP",
            "type": "boolean"
          }, {
            "name": "CC_FORWARD_ADD",
            "type": "boolean"
          }, {
            "name": "USE_TWOSIDE",
            "type": "boolean"
          }, {
            "name": "SAMPLE_FROM_RT",
            "type": "boolean"
          }, {
            "name": "CC_USE_IBL",
            "type": "number",
            "range": [0, 2]
          }, {
            "name": "CC_USE_DIFFUSEMAP",
            "type": "number",
            "range": [0, 2]
          }, {
            "name": "USE_REFLECTION_DENOISE",
            "type": "boolean"
          }, {
            "name": "CC_USE_HDR",
            "type": "boolean"
          }, {
            "name": "USE_ALBEDO_MAP",
            "type": "boolean"
          }, {
            "name": "ALBEDO_UV",
            "type": "string",
            "options": ["v_uv", "v_uv1"]
          }, {
            "name": "NORMAL_UV",
            "type": "string",
            "options": ["v_uv", "v_uv1"]
          }, {
            "name": "PBR_UV",
            "type": "string",
            "options": ["v_uv", "v_uv1"]
          }, {
            "name": "USE_PBR_MAP",
            "type": "boolean"
          }, {
            "name": "USE_METALLIC_ROUGHNESS_MAP",
            "type": "boolean"
          }, {
            "name": "USE_OCCLUSION_MAP",
            "type": "boolean"
          }, {
            "name": "USE_EMISSIVE_MAP",
            "type": "boolean"
          }, {
            "name": "EMISSIVE_UV",
            "type": "string",
            "options": ["v_uv", "v_uv1"]
          }, {
            "name": "USE_ALPHA_TEST",
            "type": "boolean"
          }, {
            "name": "ALPHA_TEST_CHANNEL",
            "type": "string",
            "options": ["a", "r"]
          }, {
            "name": "CC_PIPELINE_TYPE",
            "type": "number",
            "range": [0, 1]
          }, {
            "name": "CC_FORCE_FORWARD_SHADING",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }, {
            "name": "a_color",
            "defines": ["USE_VERTEX_COLOR"],
            "format": 44,
            "location": 14
          }, {
            "name": "a_texCoord1",
            "defines": [],
            "format": 21,
            "location": 15
          }],
          "blocks": [{
            "name": "Constants",
            "defines": [],
            "binding": 0,
            "stageFlags": 17,
            "members": [{
              "name": "tilingOffset",
              "type": 16,
              "count": 1
            }, {
              "name": "albedo",
              "type": 16,
              "count": 1
            }, {
              "name": "albedoScaleAndCutoff",
              "type": 16,
              "count": 1
            }, {
              "name": "pbrParams",
              "type": 16,
              "count": 1
            }, {
              "name": "emissive",
              "type": 16,
              "count": 1
            }, {
              "name": "emissiveScaleParam",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "albedoMap",
            "type": 28,
            "count": 1,
            "defines": ["USE_ALBEDO_MAP"],
            "stageFlags": 16,
            "binding": 1
          }, {
            "name": "normalMap",
            "type": 28,
            "count": 1,
            "defines": ["USE_NORMAL_MAP"],
            "stageFlags": 16,
            "binding": 2
          }, {
            "name": "pbrMap",
            "type": 28,
            "count": 1,
            "defines": ["USE_PBR_MAP"],
            "stageFlags": 16,
            "binding": 3
          }, {
            "name": "metallicRoughnessMap",
            "type": 28,
            "count": 1,
            "defines": ["USE_METALLIC_ROUGHNESS_MAP"],
            "stageFlags": 16,
            "binding": 4
          }, {
            "name": "occlusionMap",
            "type": 28,
            "count": 1,
            "defines": ["USE_OCCLUSION_MAP"],
            "stageFlags": 16,
            "binding": 5
          }, {
            "name": "emissiveMap",
            "type": 28,
            "count": 1,
            "defines": ["USE_EMISSIVE_MAP"],
            "stageFlags": 16,
            "binding": 6
          }],
          "buffers": [{
            "name": "b_ccLightsBuffer",
            "memoryAccess": 1,
            "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
            "stageFlags": 16,
            "binding": 7
          }, {
            "name": "b_clusterLightIndicesBuffer",
            "memoryAccess": 1,
            "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
            "stageFlags": 16,
            "binding": 8
          }, {
            "name": "b_clusterLightGridBuffer",
            "memoryAccess": 1,
            "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
            "stageFlags": 16,
            "binding": 9
          }],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
          "hash": 3928335406,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 184,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 75
            },
            "globals": {
              "blocks": [{
                "name": "CCShadow",
                "defines": []
              }, {
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [{
                "name": "cc_shadowMap",
                "defines": ["CC_RECEIVE_SHADOW"]
              }, {
                "name": "cc_spotLightingMap",
                "defines": ["CC_RECEIVE_SHADOW"]
              }],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCMorph",
                "defines": ["CC_USE_MORPH"]
              }, {
                "name": "CCSkinningTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinningAnimation",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinning",
                "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCLocalBatched",
                "defines": ["!USE_INSTANCING", "USE_BATCHING"]
              }, {
                "name": "CCLocal",
                "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
              }],
              "samplerTextures": [{
                "name": "cc_PositionDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
              }, {
                "name": "cc_NormalDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
              }, {
                "name": "cc_TangentDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
              }, {
                "name": "cc_jointTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_COUNT",
            "type": "number",
            "range": [2, 8]
          }, {
            "name": "CC_MORPH_PRECOMPUTED",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_POSITION",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_NORMAL",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_TANGENT",
            "type": "boolean"
          }, {
            "name": "HAS_SECOND_UV",
            "type": "boolean"
          }, {
            "name": "USE_ALBEDO_MAP",
            "type": "boolean"
          }, {
            "name": "ALBEDO_UV",
            "type": "string",
            "options": ["v_uv", "v_uv1"]
          }, {
            "name": "USE_ALPHA_TEST",
            "type": "boolean"
          }, {
            "name": "ALPHA_TEST_CHANNEL",
            "type": "string",
            "options": ["a", "r"]
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }, {
            "name": "a_texCoord1",
            "defines": [],
            "format": 21,
            "location": 14
          }],
          "blocks": [{
            "name": "Constants",
            "defines": [],
            "binding": 0,
            "stageFlags": 17,
            "members": [{
              "name": "tilingOffset",
              "type": 16,
              "count": 1
            }, {
              "name": "albedo",
              "type": 16,
              "count": 1
            }, {
              "name": "albedoScaleAndCutoff",
              "type": 16,
              "count": 1
            }, {
              "name": "pbrParams",
              "type": 16,
              "count": 1
            }, {
              "name": "emissive",
              "type": 16,
              "count": 1
            }, {
              "name": "emissiveScaleParam",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "albedoMap",
            "type": 28,
            "count": 1,
            "defines": ["USE_ALBEDO_MAP"],
            "stageFlags": 16,
            "binding": 1
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "terrain",
        "techniques": [{
          "name": "opaque",
          "passes": [{
            "program": "terrain|terrain-vs|terrain-fs",
            "properties": {
              "UVScale": {
                "value": [1, 1, 1, 1],
                "type": 16
              },
              "lightMapUVParam": {
                "value": [0, 0, 0, 0],
                "type": 16
              },
              "metallic": {
                "value": [0, 0, 0, 0],
                "type": 16
              },
              "roughness": {
                "value": [1, 1, 1, 1],
                "type": 16
              },
              "weightMap": {
                "value": "black",
                "type": 28
              },
              "detailMap0": {
                "value": "grey",
                "type": 28
              },
              "detailMap1": {
                "value": "grey",
                "type": 28
              },
              "detailMap2": {
                "value": "grey",
                "type": 28
              },
              "detailMap3": {
                "value": "grey",
                "type": 28
              },
              "normalMap0": {
                "value": "normal",
                "type": 28
              },
              "normalMap1": {
                "value": "normal",
                "type": 28
              },
              "normalMap2": {
                "value": "normal",
                "type": 28
              },
              "normalMap3": {
                "value": "normal",
                "type": 28
              },
              "lightMap": {
                "value": "grey",
                "type": 28
              }
            }
          }, {
            "phase": "forward-add",
            "propertyIndex": 0,
            "embeddedMacros": {
              "CC_FORWARD_ADD": true
            },
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 1,
                "blendDst": 1,
                "blendSrcAlpha": 0,
                "blendDstAlpha": 1
              }]
            },
            "program": "terrain|terrain-vs|terrain-fs",
            "depthStencilState": {
              "depthFunc": 2,
              "depthTest": true,
              "depthWrite": false
            },
            "properties": {
              "UVScale": {
                "value": [1, 1, 1, 1],
                "type": 16
              },
              "lightMapUVParam": {
                "value": [0, 0, 0, 0],
                "type": 16
              },
              "metallic": {
                "value": [0, 0, 0, 0],
                "type": 16
              },
              "roughness": {
                "value": [1, 1, 1, 1],
                "type": 16
              },
              "weightMap": {
                "value": "black",
                "type": 28
              },
              "detailMap0": {
                "value": "grey",
                "type": 28
              },
              "detailMap1": {
                "value": "grey",
                "type": 28
              },
              "detailMap2": {
                "value": "grey",
                "type": 28
              },
              "detailMap3": {
                "value": "grey",
                "type": 28
              },
              "normalMap0": {
                "value": "normal",
                "type": 28
              },
              "normalMap1": {
                "value": "normal",
                "type": 28
              },
              "normalMap2": {
                "value": "normal",
                "type": 28
              },
              "normalMap3": {
                "value": "normal",
                "type": 28
              },
              "lightMap": {
                "value": "grey",
                "type": 28
              }
            }
          }, {
            "phase": "shadow-add",
            "propertyIndex": 0,
            "rasterizerState": {
              "cullMode": 2
            },
            "program": "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag"
          }]
        }],
        "shaders": [{
          "name": "terrain|terrain-vs|terrain-fs",
          "hash": 3669699677,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 71,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 71
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }, {
                "name": "CCShadow",
                "defines": []
              }],
              "samplerTextures": [{
                "name": "cc_shadowMap",
                "defines": ["CC_RECEIVE_SHADOW"]
              }, {
                "name": "cc_spotLightingMap",
                "defines": ["CC_RECEIVE_SHADOW"]
              }, {
                "name": "cc_environment",
                "defines": ["CC_USE_IBL"]
              }, {
                "name": "cc_diffuseMap",
                "defines": ["CC_USE_DIFFUSEMAP"]
              }],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": []
              }, {
                "name": "CCForwardLight",
                "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"]
              }],
              "samplerTextures": [{
                "name": "cc_lightingMap",
                "defines": ["CC_USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "CC_USE_FOG",
            "type": "number",
            "range": [0, 4]
          }, {
            "name": "CC_USE_ACCURATE_FOG",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_USE_IBL",
            "type": "number",
            "range": [0, 2]
          }, {
            "name": "CC_USE_DIFFUSEMAP",
            "type": "number",
            "range": [0, 2]
          }, {
            "name": "USE_REFLECTION_DENOISE",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_FORWARD_ADD",
            "type": "boolean"
          }, {
            "name": "CC_USE_HDR",
            "type": "boolean"
          }, {
            "name": "LAYERS",
            "type": "number",
            "range": [0, 4]
          }, {
            "name": "USE_NORMALMAP",
            "type": "boolean"
          }, {
            "name": "USE_PBR",
            "type": "boolean"
          }, {
            "name": "CC_PIPELINE_TYPE",
            "type": "number",
            "range": [0, 1]
          }, {
            "name": "CC_FORCE_FORWARD_SHADING",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }],
          "blocks": [{
            "name": "TexCoords",
            "defines": [],
            "binding": 0,
            "stageFlags": 1,
            "members": [{
              "name": "UVScale",
              "type": 16,
              "count": 1
            }, {
              "name": "lightMapUVParam",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "PbrParams",
            "defines": [],
            "binding": 1,
            "stageFlags": 16,
            "members": [{
              "name": "metallic",
              "type": 16,
              "count": 1
            }, {
              "name": "roughness",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "weightMap",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 2
          }, {
            "name": "detailMap0",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 3
          }, {
            "name": "detailMap1",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 4
          }, {
            "name": "detailMap2",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 5
          }, {
            "name": "detailMap3",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 6
          }, {
            "name": "normalMap0",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 7
          }, {
            "name": "normalMap1",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 8
          }, {
            "name": "normalMap2",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 9
          }, {
            "name": "normalMap3",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 10
          }, {
            "name": "lightMap",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 11
          }],
          "buffers": [{
            "name": "b_ccLightsBuffer",
            "memoryAccess": 1,
            "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
            "stageFlags": 16,
            "binding": 12
          }, {
            "name": "b_clusterLightIndicesBuffer",
            "memoryAccess": 1,
            "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
            "stageFlags": 16,
            "binding": 13
          }, {
            "name": "b_clusterLightGridBuffer",
            "memoryAccess": 1,
            "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
            "stageFlags": 16,
            "binding": 14
          }],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag",
          "hash": 2218105608,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 69,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }, {
                "name": "CCShadow",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "unlit",
        "techniques": [{
          "name": "opaque",
          "passes": [{
            "program": "unlit|unlit-vs:vert|unlit-fs:frag",
            "properties": {
              "mainTexture": {
                "value": "grey",
                "type": 28
              },
              "tilingOffset": {
                "value": [1, 1, 0, 0],
                "type": 16
              },
              "mainColor": {
                "value": [1, 1, 1, 1],
                "linear": true,
                "type": 16
              },
              "colorScale": {
                "value": [1, 1, 1],
                "type": 15,
                "handleInfo": ["colorScaleAndCutoff", 0, 15]
              },
              "alphaThreshold": {
                "value": [0.5],
                "type": 13,
                "handleInfo": ["colorScaleAndCutoff", 3, 13]
              },
              "color": {
                "linear": true,
                "type": 16,
                "handleInfo": ["mainColor", 0, 16]
              },
              "colorScaleAndCutoff": {
                "type": 16,
                "value": [1, 1, 1, 0.5]
              }
            }
          }]
        }],
        "shaders": [{
          "name": "unlit|unlit-vs:vert|unlit-fs:frag",
          "hash": 3152709001,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 198,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 41
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCMorph",
                "defines": ["CC_USE_MORPH"]
              }, {
                "name": "CCSkinningTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinningAnimation",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinning",
                "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCLocalBatched",
                "defines": ["!USE_INSTANCING", "USE_BATCHING"]
              }, {
                "name": "CCLocal",
                "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
              }],
              "samplerTextures": [{
                "name": "cc_PositionDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
              }, {
                "name": "cc_NormalDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
              }, {
                "name": "cc_TangentDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
              }, {
                "name": "cc_jointTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_COUNT",
            "type": "number",
            "range": [2, 8]
          }, {
            "name": "CC_MORPH_PRECOMPUTED",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_POSITION",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_NORMAL",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_TANGENT",
            "type": "boolean"
          }, {
            "name": "CC_USE_FOG",
            "type": "number",
            "range": [0, 4]
          }, {
            "name": "CC_USE_ACCURATE_FOG",
            "type": "boolean"
          }, {
            "name": "USE_VERTEX_COLOR",
            "type": "boolean"
          }, {
            "name": "USE_TEXTURE",
            "type": "boolean"
          }, {
            "name": "SAMPLE_FROM_RT",
            "type": "boolean"
          }, {
            "name": "CC_USE_HDR",
            "type": "boolean"
          }, {
            "name": "USE_ALPHA_TEST",
            "type": "boolean"
          }, {
            "name": "ALPHA_TEST_CHANNEL",
            "type": "string",
            "options": ["a", "r", "g", "b"]
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }, {
            "name": "a_color",
            "defines": ["USE_VERTEX_COLOR"],
            "format": 44,
            "location": 14
          }],
          "blocks": [{
            "name": "TexCoords",
            "defines": ["USE_TEXTURE"],
            "binding": 0,
            "stageFlags": 1,
            "members": [{
              "name": "tilingOffset",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "Constant",
            "defines": [],
            "binding": 1,
            "stageFlags": 16,
            "members": [{
              "name": "mainColor",
              "type": 16,
              "count": 1
            }, {
              "name": "colorScaleAndCutoff",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "mainTexture",
            "type": 28,
            "count": 1,
            "defines": ["USE_TEXTURE"],
            "stageFlags": 16,
            "binding": 2
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "bloom",
        "techniques": [{
          "passes": [{
            "phase": "bloom-prefilter",
            "program": "bloom|bloom-vs|prefilter-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-downsample",
            "program": "bloom|bloom-vs|downsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-downsample",
            "program": "bloom|bloom-vs|downsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-downsample",
            "program": "bloom|bloom-vs|downsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-downsample",
            "program": "bloom|bloom-vs|downsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-downsample",
            "program": "bloom|bloom-vs|downsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-downsample",
            "program": "bloom|bloom-vs|downsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-upsample",
            "program": "bloom|bloom-vs|upsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-upsample",
            "program": "bloom|bloom-vs|upsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-upsample",
            "program": "bloom|bloom-vs|upsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-upsample",
            "program": "bloom|bloom-vs|upsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-upsample",
            "program": "bloom|bloom-vs|upsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-upsample",
            "program": "bloom|bloom-vs|upsample-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }, {
            "phase": "bloom-combine",
            "program": "bloom|bloom-vs|combine-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }]
        }],
        "shaders": [{
          "name": "bloom|bloom-vs|prefilter-fs",
          "hash": 837263906,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCMorph",
                "defines": ["CC_USE_MORPH"]
              }, {
                "name": "CCSkinningTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinningAnimation",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinning",
                "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
              }],
              "samplerTextures": [{
                "name": "cc_PositionDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
              }, {
                "name": "cc_NormalDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
              }, {
                "name": "cc_TangentDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
              }, {
                "name": "cc_jointTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_COUNT",
            "type": "number",
            "range": [2, 8]
          }, {
            "name": "CC_MORPH_PRECOMPUTED",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_POSITION",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_NORMAL",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_TANGENT",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }],
          "blocks": [{
            "name": "BloomUBO",
            "defines": [],
            "binding": 0,
            "stageFlags": 16,
            "members": [{
              "name": "texSize",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "outputResultMap",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 1
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "bloom|bloom-vs|downsample-fs",
          "hash": 682261797,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCMorph",
                "defines": ["CC_USE_MORPH"]
              }, {
                "name": "CCSkinningTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinningAnimation",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinning",
                "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
              }],
              "samplerTextures": [{
                "name": "cc_PositionDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
              }, {
                "name": "cc_NormalDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
              }, {
                "name": "cc_TangentDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
              }, {
                "name": "cc_jointTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_COUNT",
            "type": "number",
            "range": [2, 8]
          }, {
            "name": "CC_MORPH_PRECOMPUTED",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_POSITION",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_NORMAL",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_TANGENT",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }],
          "blocks": [{
            "name": "BloomUBO",
            "defines": [],
            "binding": 0,
            "stageFlags": 16,
            "members": [{
              "name": "texSize",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "bloomTexture",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 1
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "bloom|bloom-vs|upsample-fs",
          "hash": 3663548873,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCMorph",
                "defines": ["CC_USE_MORPH"]
              }, {
                "name": "CCSkinningTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinningAnimation",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinning",
                "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
              }],
              "samplerTextures": [{
                "name": "cc_PositionDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
              }, {
                "name": "cc_NormalDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
              }, {
                "name": "cc_TangentDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
              }, {
                "name": "cc_jointTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_COUNT",
            "type": "number",
            "range": [2, 8]
          }, {
            "name": "CC_MORPH_PRECOMPUTED",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_POSITION",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_NORMAL",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_TANGENT",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }],
          "blocks": [{
            "name": "BloomUBO",
            "defines": [],
            "binding": 0,
            "stageFlags": 16,
            "members": [{
              "name": "texSize",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "bloomTexture",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 1
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }, {
          "name": "bloom|bloom-vs|combine-fs",
          "hash": 670444562,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCMorph",
                "defines": ["CC_USE_MORPH"]
              }, {
                "name": "CCSkinningTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinningAnimation",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinning",
                "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
              }],
              "samplerTextures": [{
                "name": "cc_PositionDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
              }, {
                "name": "cc_NormalDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
              }, {
                "name": "cc_TangentDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
              }, {
                "name": "cc_jointTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_COUNT",
            "type": "number",
            "range": [2, 8]
          }, {
            "name": "CC_MORPH_PRECOMPUTED",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_POSITION",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_NORMAL",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_TANGENT",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }],
          "blocks": [{
            "name": "BloomUBO",
            "defines": [],
            "binding": 0,
            "stageFlags": 16,
            "members": [{
              "name": "texSize",
              "type": 16,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "outputResultMap",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 1
          }, {
            "name": "bloomTexture",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 2
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "deferred-lighting",
        "techniques": [{
          "passes": [{
            "phase": "deferred-lighting",
            "program": "deferred-lighting|lighting-vs|lighting-fs",
            "depthStencilState": {
              "depthFunc": 4,
              "depthTest": true,
              "depthWrite": false
            }
          }]
        }],
        "shaders": [{
          "name": "deferred-lighting|lighting-vs|lighting-fs",
          "hash": 2587574837,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 69
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }, {
                "name": "CCShadow",
                "defines": []
              }],
              "samplerTextures": [{
                "name": "cc_shadowMap",
                "defines": ["CC_RECEIVE_SHADOW"]
              }, {
                "name": "cc_spotLightingMap",
                "defines": ["CC_RECEIVE_SHADOW"]
              }, {
                "name": "cc_environment",
                "defines": ["CC_USE_IBL"]
              }, {
                "name": "cc_diffuseMap",
                "defines": ["CC_USE_DIFFUSEMAP"]
              }],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCLocal",
                "defines": []
              }, {
                "name": "CCForwardLight",
                "defines": ["CC_ENABLE_CLUSTERED_LIGHT_CULLING"]
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_USE_IBL",
            "type": "number",
            "range": [0, 2]
          }, {
            "name": "CC_USE_DIFFUSEMAP",
            "type": "number",
            "range": [0, 2]
          }, {
            "name": "USE_REFLECTION_DENOISE",
            "type": "boolean"
          }, {
            "name": "CC_FORWARD_ADD",
            "type": "boolean"
          }, {
            "name": "CC_PIPELINE_TYPE",
            "type": "number",
            "range": [0, 1]
          }, {
            "name": "CC_FORCE_FORWARD_SHADING",
            "type": "boolean"
          }, {
            "name": "CC_USE_HDR",
            "type": "boolean"
          }, {
            "name": "CC_USE_FOG",
            "type": "number",
            "range": [0, 4]
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [{
            "name": "b_ccLightsBuffer",
            "memoryAccess": 1,
            "defines": ["CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
            "stageFlags": 16,
            "binding": 4
          }, {
            "name": "b_clusterLightIndicesBuffer",
            "memoryAccess": 1,
            "defines": ["CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
            "stageFlags": 16,
            "binding": 5
          }, {
            "name": "b_clusterLightGridBuffer",
            "memoryAccess": 1,
            "defines": ["CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
            "stageFlags": 16,
            "binding": 6
          }],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": [{
            "name": "gbuffer_albedoMap",
            "count": 1,
            "defines": ["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],
            "stageFlags": 16,
            "binding": 0
          }, {
            "name": "gbuffer_normalMap",
            "count": 1,
            "defines": ["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],
            "stageFlags": 16,
            "binding": 1
          }, {
            "name": "gbuffer_emissiveMap",
            "count": 1,
            "defines": ["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],
            "stageFlags": 16,
            "binding": 2
          }, {
            "name": "depth_stencil",
            "count": 1,
            "defines": ["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],
            "stageFlags": 16,
            "binding": 3
          }]
        }]
      }, {
        "name": "planar-shadow",
        "techniques": [{
          "passes": [{
            "phase": "planarShadow",
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "program": "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false,
              "stencilTestFront": true,
              "stencilFuncFront": 5,
              "stencilPassOpFront": 2,
              "stencilRefBack": 128,
              "stencilRefFront": 128,
              "stencilReadMaskBack": 128,
              "stencilReadMaskFront": 128,
              "stencilWriteMaskBack": 128,
              "stencilWriteMaskFront": 128
            }
          }]
        }],
        "shaders": [{
          "name": "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
          "hash": 3542426468,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 217,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 59
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }, {
                "name": "CCShadow",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCMorph",
                "defines": ["CC_USE_MORPH"]
              }, {
                "name": "CCSkinningTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinningAnimation",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinning",
                "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCLocalBatched",
                "defines": ["!USE_INSTANCING", "USE_BATCHING"]
              }, {
                "name": "CCLocal",
                "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
              }],
              "samplerTextures": [{
                "name": "cc_PositionDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
              }, {
                "name": "cc_NormalDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
              }, {
                "name": "cc_TangentDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
              }, {
                "name": "cc_jointTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_COUNT",
            "type": "number",
            "range": [2, 8]
          }, {
            "name": "CC_MORPH_PRECOMPUTED",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_POSITION",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_NORMAL",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_TANGENT",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "post-process",
        "techniques": [{
          "passes": [{
            "phase": "post-process",
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendSrcAlpha": 2,
                "blendDstAlpha": 4
              }]
            },
            "program": "post-process|post-process-vs|post-process-fs",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }]
        }],
        "shaders": [{
          "name": "post-process|post-process-vs|post-process-fs",
          "hash": 2960965003,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [{
                "name": "CCMorph",
                "defines": ["CC_USE_MORPH"]
              }, {
                "name": "CCSkinningTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinningAnimation",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }, {
                "name": "CCSkinning",
                "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
              }],
              "samplerTextures": [{
                "name": "cc_PositionDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
              }, {
                "name": "cc_NormalDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
              }, {
                "name": "cc_TangentDisplacements",
                "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
              }, {
                "name": "cc_jointTexture",
                "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
              }],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_COUNT",
            "type": "number",
            "range": [2, 8]
          }, {
            "name": "CC_MORPH_PRECOMPUTED",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_POSITION",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_NORMAL",
            "type": "boolean"
          }, {
            "name": "CC_MORPH_TARGET_HAS_TANGENT",
            "type": "boolean"
          }, {
            "name": "ANTIALIAS_TYPE",
            "type": "number",
            "range": [0, 3]
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }],
          "blocks": [],
          "samplerTextures": [{
            "name": "outputResultMap",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 0
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "skybox",
        "techniques": [{
          "passes": [{
            "rasterizerState": {
              "cullMode": 0
            },
            "program": "skybox|sky-vs:vert|sky-fs:frag",
            "priority": 245,
            "depthStencilState": {
              "depthTest": true,
              "depthWrite": false
            }
          }]
        }],
        "shaders": [{
          "name": "skybox|sky-vs:vert|sky-fs:frag",
          "hash": 2207113861,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [{
                "name": "cc_environment",
                "defines": []
              }],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [{
            "name": "USE_INSTANCING",
            "type": "boolean"
          }, {
            "name": "USE_BATCHING",
            "type": "boolean"
          }, {
            "name": "CC_USE_SKINNING",
            "type": "boolean"
          }, {
            "name": "CC_USE_BAKED_ANIMATION",
            "type": "boolean"
          }, {
            "name": "CC_USE_LIGHTMAP",
            "type": "boolean"
          }, {
            "name": "CC_RECEIVE_SHADOW",
            "type": "boolean"
          }, {
            "name": "CC_USE_MORPH",
            "type": "boolean"
          }, {
            "name": "CC_USE_IBL",
            "type": "number",
            "range": [0, 2]
          }, {
            "name": "CC_USE_HDR",
            "type": "boolean"
          }, {
            "name": "USE_RGBE_CUBEMAP",
            "type": "boolean"
          }],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_normal",
            "defines": [],
            "format": 32,
            "location": 1
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 2
          }, {
            "name": "a_tangent",
            "defines": [],
            "format": 44,
            "location": 3
          }, {
            "name": "a_joints",
            "defines": ["CC_USE_SKINNING"],
            "location": 4
          }, {
            "name": "a_weights",
            "defines": ["CC_USE_SKINNING"],
            "format": 44,
            "location": 5
          }, {
            "name": "a_jointAnimInfo",
            "defines": ["USE_INSTANCING", "CC_USE_BAKED_ANIMATION"],
            "format": 44,
            "isInstanced": true,
            "location": 6
          }, {
            "name": "a_matWorld0",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 7
          }, {
            "name": "a_matWorld1",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 8
          }, {
            "name": "a_matWorld2",
            "defines": ["USE_INSTANCING"],
            "format": 44,
            "isInstanced": true,
            "location": 9
          }, {
            "name": "a_lightingMapUVParam",
            "defines": ["USE_INSTANCING", "CC_USE_LIGHTMAP"],
            "format": 44,
            "isInstanced": true,
            "location": 10
          }, {
            "name": "a_localShadowBias",
            "defines": ["USE_INSTANCING", "CC_RECEIVE_SHADOW"],
            "format": 21,
            "isInstanced": true,
            "location": 11
          }, {
            "name": "a_dyn_batch_id",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"],
            "format": 11,
            "location": 12
          }, {
            "name": "a_vertexId",
            "defines": ["CC_USE_MORPH"],
            "format": 11,
            "location": 13
          }],
          "blocks": [],
          "samplerTextures": [],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "profiler",
        "techniques": [{
          "passes": [{
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "rasterizerState": {
              "cullMode": 0
            },
            "program": "profiler|profiler-vs:vert|profiler-fs:frag",
            "priority": 255,
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            }
          }]
        }],
        "shaders": [{
          "name": "profiler|profiler-vs:vert|profiler-fs:frag",
          "hash": 179162168,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 60,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
            },
            "globals": {
              "blocks": [{
                "name": "CCGlobal",
                "defines": []
              }, {
                "name": "CCCamera",
                "defines": []
              }],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 32,
            "location": 0
          }, {
            "name": "a_color",
            "defines": [],
            "format": 44,
            "location": 1
          }],
          "blocks": [{
            "name": "Constants",
            "defines": [],
            "binding": 0,
            "stageFlags": 1,
            "members": [{
              "name": "offset",
              "type": 16,
              "count": 1
            }]
          }, {
            "name": "PerFrameInfo",
            "defines": [],
            "binding": 1,
            "stageFlags": 1,
            "members": [{
              "name": "digits",
              "type": 16,
              "count": 20
            }]
          }],
          "samplerTextures": [{
            "name": "mainTexture",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 2
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }, {
        "name": "splash-screen",
        "techniques": [{
          "name": "default",
          "passes": [{
            "blendState": {
              "targets": [{
                "blend": true,
                "blendSrc": 2,
                "blendDst": 4,
                "blendDstAlpha": 4
              }]
            },
            "rasterizerState": {
              "cullMode": 0
            },
            "program": "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
            "depthStencilState": {
              "depthTest": false,
              "depthWrite": false
            },
            "properties": {
              "mainTexture": {
                "value": "grey",
                "type": 28
              },
              "resolution": {
                "value": [640, 960],
                "type": 14,
                "handleInfo": ["u_buffer0", 0, 14]
              },
              "percent": {
                "value": [0.5],
                "type": 13,
                "handleInfo": ["u_percent", 0, 13]
              },
              "scale": {
                "value": [200, 500],
                "type": 14,
                "handleInfo": ["u_buffer1", 0, 14]
              },
              "translate": {
                "value": [320, 480],
                "type": 14,
                "handleInfo": ["u_buffer1", 2, 14]
              },
              "u_buffer0": {
                "type": 16,
                "value": [640, 960, 0, 0]
              },
              "u_percent": {
                "type": 13,
                "value": [0.5]
              },
              "u_buffer1": {
                "type": 16,
                "value": [200, 500, 320, 480]
              }
            }
          }]
        }],
        "shaders": [{
          "name": "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
          "hash": 3189094080,
          "builtins": {
            "statistics": {
              "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 6,
              "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
            },
            "globals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            },
            "locals": {
              "blocks": [],
              "samplerTextures": [],
              "buffers": [],
              "images": []
            }
          },
          "defines": [],
          "attributes": [{
            "name": "a_position",
            "defines": [],
            "format": 21,
            "location": 0
          }, {
            "name": "a_texCoord",
            "defines": [],
            "format": 21,
            "location": 1
          }],
          "blocks": [{
            "name": "Constant",
            "defines": [],
            "binding": 0,
            "stageFlags": 1,
            "members": [{
              "name": "u_buffer0",
              "type": 16,
              "count": 1
            }, {
              "name": "u_buffer1",
              "type": 16,
              "count": 1
            }, {
              "name": "u_projection",
              "type": 25,
              "count": 1
            }]
          }, {
            "name": "Factor",
            "defines": [],
            "binding": 1,
            "stageFlags": 16,
            "members": [{
              "name": "u_percent",
              "type": 13,
              "count": 1
            }]
          }],
          "samplerTextures": [{
            "name": "mainTexture",
            "type": 28,
            "count": 1,
            "defines": [],
            "stageFlags": 16,
            "binding": 2
          }],
          "buffers": [],
          "images": [],
          "textures": [],
          "samplers": [],
          "subpassInputs": []
        }]
      }]);

      var glsl1 = [[{
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      }], [{
        "vert": "\nprecision highp float;\nattribute vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nvoid main() { gl_FragColor = front(); }"
      }, {
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nvoid main() { gl_FragColor = back(); }"
      }, {
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 front() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nvoid main() { gl_FragColor = front(); }"
      }, {
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 back() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nvoid main() { gl_FragColor = back(); }"
      }, {
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_normal;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nvoid main() { gl_FragColor = front(); }"
      }, {
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_normal;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nvoid main() { gl_FragColor = back(); }"
      }], [{
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute float a_dist;\nvarying float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\nvarying vec4 v_color;\nvarying float v_dist;\nvec4 frag () {\nvec4 o = v_color;\n#ifdef GL_OES_standard_derivatives\nfloat aa = fwidth(v_dist);\n#else\nfloat aa = 0.05;\n#endif\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_worldBoundCenter;\nuniform highp vec4 cc_worldBoundHalfExtents;\nattribute vec3 a_position;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition *= cc_worldBoundHalfExtents;\nposition += cc_worldBoundCenter;\nposition = cc_matViewProj * position;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvec4 frag () {\nreturn vec4(1, 0, 0, 1);\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 eulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom(float x) {\n#if USE_VK_SHADER\nfloat o = x;\nx = mod(x - 1.0, 2.0) - 1.0;\nfloat freqVar = 10.16640753482;\nfloat y = sin(freqVar * floor(o * 0.5 - 0.5));\nfloat v = max(0.0, 1.0-abs(x));\nv *= 0.7071067812;\nv = y < 0.0 ? -v : v;\nreturn v;\n#else\nfloat seed = mod(x, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n#endif\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nuniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nuniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nuniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nuniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nuniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nuniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = startRotation.xyz;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., startRotation.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(startRotation);\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture2D(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      }], [{
        "vert": "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      }], [{
        "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\nattribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n#else\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = a_texCoord2;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(a_texCoord2);\n#endif\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      }], [{
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 v_light;\nvarying vec2 uv0;\n#if TWO_COLORED\nattribute vec4 a_color2;\nvarying vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 v_light;\n#if TWO_COLORED\nvarying vec4 v_dark;\n#endif\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture2D(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture2D(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture2D(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n#if USE_BATCHING\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\nuniform highp vec4 cc_localShadowBias;\n#endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nuniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n#if USE_INSTANCING\nreturn vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n#elif !USE_BATCHING\nreturn vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n#else\nreturn vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n#endif\n}\n#endif\n#if USE_VERTEX_COLOR\nattribute vec4 a_color;\nvarying lowp vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\nvarying mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\nvarying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\nvarying mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\nv_luv.z = cc_lightingMapUVParam.w;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\nv_luv.z = a_lightingMapUVParam.w;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if CC_RECEIVE_SHADOW\nv_shadowBias = CCGetShadowBias();\n#endif\n#if USE_TWOSIDE\nvec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\nv_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n#endif\n#if USE_NORMAL_MAP\nv_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_tangent.w = In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(pos);\nv_shadowPos = cc_matLightViewProj * pos;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
        "frag": "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_nearFar;\nuniform mediump vec4 cc_viewPort;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp vec4 cc_shadowInvProjDepthInfo;\nuniform highp vec4 cc_shadowProjDepthInfo;\nuniform highp vec4 cc_shadowProjInfo;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = textureCube(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = textureCube(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\nvarying mediump vec2 v_uv1;\n#endif\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\nvarying mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\nvarying lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nvarying mediump vec4 v_tangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture2D(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\ns.lightmap = lightColor.xyz * v_luv.z;\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if CC_RECEIVE_SHADOW\ns.shadowBias = v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\nvec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\nvec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\ns.normal =\n(nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n(nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture2D(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.a;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture2D(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = pbr.x;\ns.roughness = pbr.y;\ns.specularIntensity = 0.5;\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nreadonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nreadonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nreadonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\nvec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\nreturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\ngl_FragData[2] = vec4(s.emissive, s.occlusion);\n}\n#endif"
      }, {
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\n#if !USE_INSTANCING\n#if USE_BATCHING\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nuniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\nvarying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\nvarying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture2D(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nreturn vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform highp mat4 cc_matWorld;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_RECEIVE_SHADOW\nvarying vec2 v_shadowBias;\n#endif\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 luv;\nvarying mediump vec3 diffuse;\nuniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if CC_USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.z;\nluv.z = lightMapUVParam.w;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\nCC_TRANSFER_FOG(vec4(worldPos, 1.0));\n#if CC_RECEIVE_SHADOW\nv_shadowBias = vec2(0.0, 0.0);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
        "frag": "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_nearFar;\nuniform mediump vec4 cc_viewPort;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp vec4 cc_shadowInvProjDepthInfo;\nuniform highp vec4 cc_shadowProjDepthInfo;\nuniform highp vec4 cc_shadowProjInfo;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = textureCube(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = textureCube(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\nvarying vec2 v_shadowBias;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 diffuse;\nvarying mediump vec3 luv;\nuniform vec4 metallic;\nuniform vec4 roughness;\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture2D(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture2D(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\nbaseColor += texture2D(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture2D(detailMap0, uv0);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture2D(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\nbaseNormal += texture2D(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture2D(normalMap0, uv0);\n#endif\nvec3 tangent = vec3(1.0, 0.0, 0.0);\nvec3 binormal = vec3(0.0, 0.0, 1.0);\nbinormal = cross(tangent, v_normal);\ntangent = cross(v_normal, binormal);\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(tangent) +\nnmmp.y * normalize(binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\n#if CC_RECEIVE_SHADOW\ns.shadowBias = v_shadowBias;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#if LAYERS == 1\ns.specularIntensity = 0.5;\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(lightMap, luv.xy);\ns.lightmap = lightColor.xyz * luv.z;\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nreadonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nreadonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nreadonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\nvec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\nreturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\ngl_FragData[2] = vec4(s.emissive, s.occlusion);\n}\n#endif"
      }, {
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matLightViewProj;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nvarying vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n#if USE_BATCHING\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\nattribute lowp vec4 a_color;\nvarying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform vec4 tilingOffset;\n#endif\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(matWorld * position);\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\nvarying lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no.rgb *= SRGBToLinear(v_color.rgb);\no.a *= v_color.a;\n#endif\n#if USE_TEXTURE\nvec4 texColor = texture2D(mainTexture, v_uv);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\no *= texColor;\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\nCC_APPLY_FOG(o);\nreturn CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D outputResultMap;\nfloat luminance(vec3 color) {\nreturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\nvoid main() {\nvec3 color = texture2D(outputResultMap, v_uv).xyz;\nif (luminance(SRGBToLinear(color)) > texSize.z) {\ngl_FragColor = vec4(color, 1.0);\n} else {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}"
      }, {
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D bloomTexture;\nvec3 downsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture2D(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main()\n{\nvec3 result = downsample4taps(v_uv, 1.0 / texSize.xy).rgb;\ngl_FragColor = vec4(result, 1.0);\n}"
      }, {
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D bloomTexture;\nvec3 upsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture2D(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main() {\nvec3 result = upsample4taps(v_uv, 0.5 / texSize.xy).rgb;\ngl_FragColor = vec4(result, 1.0);\n}"
      }, {
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D outputResultMap;\nuniform sampler2D bloomTexture;\nvoid main() {\nvec4 hdrColor = texture2D(outputResultMap, v_uv);\nvec3 bloomColor = texture2D(bloomTexture, v_uv).rgb;\nvec3 result = hdrColor.rgb + bloomColor * texSize.w * hdrColor.a;\ngl_FragColor = vec4(result, hdrColor.a);\n}"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\n#endif\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
        "frag": "\n#ifdef GL_EXT_shader_framebuffer_fetch\n#extension GL_EXT_shader_framebuffer_fetch: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewProjInv;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_nearFar;\nuniform mediump vec4 cc_viewPort;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp mat4 cc_matLightViewProj;\nuniform highp vec4 cc_shadowInvProjDepthInfo;\nuniform highp vec4 cc_shadowProjDepthInfo;\nuniform highp vec4 cc_shadowProjInfo;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = textureCube(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = textureCube(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nreadonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nreadonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nreadonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec3 oct_to_float32x3(vec2 e) {\nvec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\nif (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\nreturn normalize(v);\n}\nvec4 screen2WS(vec3 coord) {\nvec3 ndc = vec3(\n2.0 * (coord.x - cc_viewPort.x) / cc_viewPort.z - 1.0,\n2.0 * (coord.y - cc_viewPort.y) / cc_viewPort.w - 1.0,\n2.0 * coord.z - 1.0);\nvec4 world = ((cc_matViewProjInv) * (vec4(ndc, 1.0)));\nworld      = world / world.w;\nreturn world;\n}\nvarying vec2 v_uv;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nuniform sampler2D depth_stencil;\n#else\nuniform sampler2D gbuffer_albedoMap;\nuniform sampler2D gbuffer_normalMap;\nuniform sampler2D gbuffer_emissiveMap;\nuniform sampler2D depth_stencil;\n#endif\n#if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\n#endif\nvoid main () {\nStandardSurface s;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nvec4 albedoMap = gl_LastFragData[0];\nvec4 normalMap = gl_LastFragData[1];\nvec4 emissiveMap = gl_LastFragData[2];\nfloat depth = texture2D(depth_stencil, v_uv).x;\n#else\nvec4 albedoMap = texture2D(gbuffer_albedoMap,v_uv);\nvec4 normalMap = texture2D(gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture2D(gbuffer_emissiveMap,v_uv);\nfloat depth = texture2D(depth_stencil, v_uv).x;\n#endif\ns.albedo = albedoMap;\nvec3 position = screen2WS(vec3(gl_FragCoord.xy, depth)).xyz;\ns.position = position;\ns.roughness = normalMap.z;\ns.normal = oct_to_float32x3(normalMap.xy);\ns.specularIntensity = 0.5;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\nCC_TRANSFER_FOG_BASE(vec4(position, 1), fogFactor);\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nCCClusterShadingAdditive(s, shadowPos);\n#else\nCCStandardShadingAdditive(s, shadowPos);\n#endif\nCC_APPLY_FOG_BASE(color, fogFactor);\ncolor = CCFragOutput(color);\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\ngl_FragData[2] = color;\n#else\ngl_FragColor = color;\n#endif\n}"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\n#if !USE_INSTANCING\n#if USE_BATCHING\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nuniform mediump vec4 cc_planarNDInfo;\nvarying float v_dist;\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\nvec3 P = (matWorld * position).xyz;\nvec3 L = cc_mainLitDir.xyz;\nvec3 N = cc_planarNDInfo.xyz;\nfloat d = cc_planarNDInfo.w + 0.001;\nfloat dist = (-d - dot(P, N)) / (dot(L, N) + 0.0001);\nvec3 shadowPos = P + L * dist;\nvec3 view = normalize(cc_cameraPos.xyz - shadowPos);\nfloat viewLength = length(cc_cameraPos.xyz - shadowPos);\nshadowPos += view * min(1.0, 0.005 * viewLength);\nposition = cc_matProj * cc_matView * vec4(shadowPos, 1.0);\nv_dist = dist;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying float v_dist;\nvec4 frag () {\nif(v_dist < 0.0)\ndiscard;\nreturn CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\n#if ANTIALIAS_TYPE == 1\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\nvec4 texColor = texture2D(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\n#endif\nvarying vec2 v_uv;\nuniform sampler2D outputResultMap;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\n#if ANTIALIAS_TYPE == 1\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\ngl_FragColor = fxaa(outputResultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n#else\ngl_FragColor = texture2D(outputResultMap, v_uv);\n#endif\n}"
      }], [{
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\n#endif\nvarying mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nvec4 pos = matViewRotOnly * viewDir;\nif (cc_matProj[3].w > 0.0) {\nmat4 matProj = cc_matProj;\nmatProj[0].x = 5.2;\nmatProj[1].y = 2.6;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\npos = matProj * pos;\n} else {\npos = cc_matProj * pos;\n}\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nvarying mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nmat2 proj = mat2(cc_matProj[0].xy, cc_matProj[1].xy);\nproj /= abs(proj[1].x + proj[1].y);\nvec2 position = proj * a_position.xy + offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn vec4(position, 0.0, 1.0);\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nuniform vec4 u_buffer0;\nuniform vec4 u_buffer1;\nuniform mat4 u_projection;\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvarying vec2 v_uv;\nuniform float u_percent;\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture2D(mainTexture, v_uv);\nfloat percent = clamp(u_percent, 0.0, 1.0);\ncolor.xyz *= percent;\nreturn color;\n}\nvoid main() { gl_FragColor = frag(); }"
      }]];

      var glsl3 = [[{
        "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nlayout(std140) uniform builtin {\nvec4 cc_size_rotation;\n};\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      }], [{
        "vert": "\nprecision highp float;\nin vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"
      }, {
        "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"
      }, {
        "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nout float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nin float v_distance;\nvec4 front() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"
      }, {
        "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nout float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nin float v_distance;\nvec4 back() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"
      }, {
        "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_normal;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"
      }, {
        "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_normal;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"
      }], [{
        "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin float a_dist;\nout float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nin vec4 v_color;\nin float v_dist;\nvec4 frag () {\nvec4 o = v_color;\nfloat aa = fwidth(v_dist);\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCWorldBound {\nhighp vec4 cc_worldBoundCenter;\nhighp vec4 cc_worldBoundHalfExtents;\n};\nin vec3 a_position;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition *= cc_worldBoundHalfExtents;\nposition += cc_worldBoundCenter;\nposition = cc_matViewProj * position;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nvec4 frag () {\nreturn vec4(1, 0, 0, 1);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 eulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(std140) uniform SampleConstants {\nvec4 u_sampleInfo;\n};\nlayout(std140) uniform TickConstants {\nvec4 u_worldRot;\nvec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord;\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom(float x) {\n#if USE_VK_SHADER\nfloat o = x;\nx = mod(x - 1.0, 2.0) - 1.0;\nfloat freqVar = 10.16640753482;\nfloat y = sin(freqVar * floor(o * 0.5 - 0.5));\nfloat v = max(0.0, 1.0-abs(x));\nv *= 0.7071067812;\nv = y < 0.0 ? -v : v;\nreturn v;\n#else\nfloat seed = mod(x, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n#endif\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nlayout(std140) uniform ColorConstant {\nint u_color_mode;\n};\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nlayout(std140) uniform RotationConstant {\nint u_rotation_mode;\n};\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nlayout(std140) uniform SizeConstant {\nint u_size_mode;\n};\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nlayout(std140) uniform ForceConstant {\nint u_force_mode;\nint u_force_space;\n};\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nlayout(std140) uniform VelocityConstant {\nint u_velocity_mode;\nint u_velocity_space;\n};\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nlayout(std140) uniform AnimationConstant {\nvec4 u_anim_info;\n};\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = startRotation.xyz;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., startRotation.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(startRotation);\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      }], [{
        "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nout vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\n#if CC_DRAW_WIRE_FRAME\nin vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      }], [{
        "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\nin vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n#else\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = a_texCoord2;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(a_texCoord2);\n#endif\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      }], [{
        "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 v_light;\nout vec2 uv0;\n#if TWO_COLORED\nin vec4 a_color2;\nout vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 v_light;\n#if TWO_COLORED\nin vec4 v_dark;\n#endif\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#if SAMPLE_FROM_RT\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 color;\n#if USE_TEXTURE\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n#if USE_BATCHING\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n#if USE_INSTANCING\nreturn vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n#elif !USE_BATCHING\nreturn vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n#else\nreturn vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n#endif\n}\n#endif\n#if USE_VERTEX_COLOR\nin vec4 a_color;\nout lowp vec4 v_color;\n#endif\nout vec3 v_position;\nout mediump vec3 v_normal;\nout vec2 v_uv;\n#if HAS_SECOND_UV\nout mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\nout mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\nout mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nout vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\nv_luv.z = cc_lightingMapUVParam.w;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\nv_luv.z = a_lightingMapUVParam.w;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if CC_RECEIVE_SHADOW\nv_shadowBias = CCGetShadowBias();\n#endif\n#if USE_TWOSIDE\nvec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\nv_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n#endif\n#if USE_NORMAL_MAP\nv_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_tangent.w = In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(pos);\nv_shadowPos = cc_matLightViewProj * pos;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
        "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\n#if HAS_SECOND_UV\nin mediump vec2 v_uv1;\n#endif\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\nin mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\nin lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nin mediump vec4 v_tangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(cc_lightingMap, v_luv.xy);\ns.lightmap = lightColor.xyz * v_luv.z;\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if CC_RECEIVE_SHADOW\ns.shadowBias = v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\nvec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\nvec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\ns.normal =\n(nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n(nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.a;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = pbr.x;\ns.roughness = pbr.y;\ns.specularIntensity = 0.5;\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\nvec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\nreturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\nfragColor2 = vec4(s.emissive, s.occlusion);\n}\n#endif"
      }, {
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\n#if !USE_INSTANCING\n#if USE_BATCHING\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\n#if HAS_SECOND_UV\nout vec2 v_uv1;\n#endif\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\n#if HAS_SECOND_UV\nin vec2 v_uv1;\n#endif\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nreturn vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_RECEIVE_SHADOW\nout vec2 v_shadowBias;\n#endif\nout highp vec3 v_position;\nout mediump vec3 v_normal;\nout mediump vec2 uvw;\nout mediump vec2 uv0;\nout mediump vec2 uv1;\nout mediump vec2 uv2;\nout mediump vec2 uv3;\nout mediump vec3 luv;\nout mediump vec3 diffuse;\nlayout(std140) uniform TexCoords {\nvec4 UVScale;\nvec4 lightMapUVParam;\n};\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if CC_USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.z;\nluv.z = lightMapUVParam.w;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\nCC_TRANSFER_FOG(vec4(worldPos, 1.0));\n#if CC_RECEIVE_SHADOW\nv_shadowBias = vec2(0.0, 0.0);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
        "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nin highp vec3 v_position;\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\nin vec2 v_shadowBias;\n#endif\nin mediump vec2 uvw;\nin mediump vec2 uv0;\nin mediump vec2 uv1;\nin mediump vec2 uv2;\nin mediump vec2 uv3;\nin mediump vec3 diffuse;\nin mediump vec3 luv;\nlayout(std140) uniform PbrParams {\nvec4 metallic;\nvec4 roughness;\n};\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\nbaseColor += texture(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture(detailMap0, uv0);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\nbaseNormal += texture(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture(normalMap0, uv0);\n#endif\nvec3 tangent = vec3(1.0, 0.0, 0.0);\nvec3 binormal = vec3(0.0, 0.0, 1.0);\nbinormal = cross(tangent, v_normal);\ntangent = cross(v_normal, binormal);\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(tangent) +\nnmmp.y * normalize(binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\n#if CC_RECEIVE_SHADOW\ns.shadowBias = v_shadowBias;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#if LAYERS == 1\ns.specularIntensity = 0.5;\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(lightMap, luv.xy);\ns.lightmap = lightColor.xyz * luv.z;\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\nvec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\nreturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\nfragColor2 = vec4(s.emissive, s.occlusion);\n}\n#endif"
      }, {
        "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nin vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n#if USE_BATCHING\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\nin lowp vec4 a_color;\nout lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nout vec2 v_uv;\nlayout(std140) uniform TexCoords {\nvec4 tilingOffset;\n};\n#endif\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(matWorld * position);\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nin vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\nvec4 mainColor;\nvec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\nin lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no.rgb *= SRGBToLinear(v_color.rgb);\no.a *= v_color.a;\n#endif\n#if USE_TEXTURE\nvec4 texColor = texture(mainTexture, v_uv);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\no *= texColor;\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\nCC_APPLY_FOG(o);\nreturn CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D outputResultMap;\nlayout(location = 0) out vec4 fragColor;\nfloat luminance(vec3 color) {\nreturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\nvoid main() {\nvec3 color = texture(outputResultMap, v_uv).xyz;\nif (luminance(SRGBToLinear(color)) > texSize.z) {\nfragColor = vec4(color, 1.0);\n} else {\nfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}"
      }, {
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvec3 downsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main()\n{\nvec3 result = downsample4taps(v_uv, 1.0 / texSize.xy).rgb;\nfragColor = vec4(result, 1.0);\n}"
      }, {
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvec3 upsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main() {\nvec3 result = upsample4taps(v_uv, 0.5 / texSize.xy).rgb;\nfragColor = vec4(result, 1.0);\n}"
      }, {
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D outputResultMap;\nuniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvoid main() {\nvec4 hdrColor = texture(outputResultMap, v_uv);\nvec3 bloomColor = texture(bloomTexture, v_uv).rgb;\nvec3 result = hdrColor.rgb + bloomColor * texSize.w * hdrColor.a;\nfragColor = vec4(result, hdrColor.a);\n}"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
        "frag": "\n#ifdef GL_EXT_shader_framebuffer_fetch\n#extension GL_EXT_shader_framebuffer_fetch: enable\n#endif\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec3 oct_to_float32x3(vec2 e) {\nvec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\nif (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\nreturn normalize(v);\n}\nvec4 screen2WS(vec3 coord) {\nvec3 ndc = vec3(\n2.0 * (coord.x - cc_viewPort.x) / cc_viewPort.z - 1.0,\n2.0 * (coord.y - cc_viewPort.y) / cc_viewPort.w - 1.0,\n2.0 * coord.z - 1.0);\nvec4 world = ((cc_matViewProjInv) * (vec4(ndc, 1.0)));\nworld      = world / world.w;\nreturn world;\n}\nin vec2 v_uv;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nlayout(location = 0) inout vec4 gbuffer_albedoMap;\nlayout(location = 1) inout vec4 gbuffer_normalMap;\nlayout(location = 2) inout vec4 gbuffer_emissiveMap;\nuniform sampler2D depth_stencil;\n#else\nuniform sampler2D gbuffer_albedoMap;\nuniform sampler2D gbuffer_normalMap;\nuniform sampler2D gbuffer_emissiveMap;\nuniform sampler2D depth_stencil;\n#endif\n#if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\nlayout(location = 0) out vec4 fragColor;\n#endif\nvoid main () {\nStandardSurface s;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nvec4 albedoMap = gbuffer_albedoMap;\nvec4 normalMap = gbuffer_normalMap;\nvec4 emissiveMap = gbuffer_emissiveMap;\nfloat depth = texture(depth_stencil, v_uv).x;\n#else\nvec4 albedoMap = texture(gbuffer_albedoMap,v_uv);\nvec4 normalMap = texture(gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture(gbuffer_emissiveMap,v_uv);\nfloat depth = texture(depth_stencil, v_uv).x;\n#endif\ns.albedo = albedoMap;\nvec3 position = screen2WS(vec3(gl_FragCoord.xy, depth)).xyz;\ns.position = position;\ns.roughness = normalMap.z;\ns.normal = oct_to_float32x3(normalMap.xy);\ns.specularIntensity = 0.5;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\nCC_TRANSFER_FOG_BASE(vec4(position, 1), fogFactor);\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nCCClusterShadingAdditive(s, shadowPos);\n#else\nCCStandardShadingAdditive(s, shadowPos);\n#endif\nCC_APPLY_FOG_BASE(color, fogFactor);\ncolor = CCFragOutput(color);\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\ngbuffer_emissiveMap = color;\n#else\nfragColor = color;\n#endif\n}"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n#if USE_BATCHING\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nout float v_dist;\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\nvec3 P = (matWorld * position).xyz;\nvec3 L = cc_mainLitDir.xyz;\nvec3 N = cc_planarNDInfo.xyz;\nfloat d = cc_planarNDInfo.w + 0.001;\nfloat dist = (-d - dot(P, N)) / (dot(L, N) + 0.0001);\nvec3 shadowPos = P + L * dist;\nvec3 view = normalize(cc_cameraPos.xyz - shadowPos);\nfloat viewLength = length(cc_cameraPos.xyz - shadowPos);\nshadowPos += view * min(1.0, 0.005 * viewLength);\nposition = cc_matProj * cc_matView * vec4(shadowPos, 1.0);\nv_dist = dist;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin float v_dist;\nvec4 frag () {\nif(v_dist < 0.0)\ndiscard;\nreturn CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
        "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if ANTIALIAS_TYPE == 1\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture(tex, v_rgbSE).xyz;\nvec4 texColor = texture(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\n#endif\nin vec2 v_uv;\nuniform sampler2D outputResultMap;\nlayout(location = 0) out vec4 fragColor;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\n#if ANTIALIAS_TYPE == 1\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\nfragColor = fxaa(outputResultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n#else\nfragColor = texture(outputResultMap, v_uv);\n#endif\n}"
      }], [{
        "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\n#endif\nout mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nvec4 pos = matViewRotOnly * viewDir;\nif (cc_matProj[3].w > 0.0) {\nmat4 matProj = cc_matProj;\nmatProj[0].x = 5.2;\nmatProj[1].y = 2.6;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\npos = matProj * pos;\n} else {\npos = cc_matProj * pos;\n}\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nin mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nlayout(std140) uniform Constants {\nvec4 offset;\n};\nlayout(std140) uniform PerFrameInfo {\nvec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nmat2 proj = mat2(cc_matProj[0].xy, cc_matProj[1].xy);\nproj /= abs(proj[1].x + proj[1].y);\nvec2 position = proj * a_position.xy + offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn vec4(position, 0.0, 1.0);\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }], [{
        "vert": "\nprecision mediump float;\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nlayout(std140) uniform Constant {\nvec4 u_buffer0;\nvec4 u_buffer1;\nmat4 u_projection;\n};\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nin vec2 v_uv;\nlayout(std140) uniform Factor {\nfloat u_percent;\n};\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture(mainTexture, v_uv);\nfloat percent = clamp(u_percent, 0.0, 1.0);\ncolor.xyz *= percent;\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      }]];

      var assembly = function () {
        {
          return {
            glsl1: glsl1,
            glsl3: glsl3
          };
        }
      }();

      var BuiltinResMgr = function () {
        function BuiltinResMgr() {
          this._device = null;
          this._resources = {};
        }

        var _proto = BuiltinResMgr.prototype;

        _proto.initBuiltinRes = function initBuiltinRes(device) {
          var _this = this;

          this._device = device;
          var resources = this._resources;
          var len = 2;
          var numChannels = 4;
          var blackValueView = new Uint8Array(len * len * numChannels);
          var emptyValueView = new Uint8Array(len * len * numChannels);
          var greyValueView = new Uint8Array(len * len * numChannels);
          var whiteValueView = new Uint8Array(len * len * numChannels);
          var normalValueView = new Uint8Array(len * len * numChannels);
          var offset = 0;

          for (var i = 0; i < len * len; i++) {
            blackValueView[offset] = 0;
            blackValueView[offset + 1] = 0;
            blackValueView[offset + 2] = 0;
            blackValueView[offset + 3] = 255;
            emptyValueView[offset] = 0;
            emptyValueView[offset + 1] = 0;
            emptyValueView[offset + 2] = 0;
            emptyValueView[offset + 3] = 0;
            greyValueView[offset] = 119;
            greyValueView[offset + 1] = 119;
            greyValueView[offset + 2] = 119;
            greyValueView[offset + 3] = 255;
            whiteValueView[offset] = 255;
            whiteValueView[offset + 1] = 255;
            whiteValueView[offset + 2] = 255;
            whiteValueView[offset + 3] = 255;
            normalValueView[offset] = 127;
            normalValueView[offset + 1] = 127;
            normalValueView[offset + 2] = 255;
            normalValueView[offset + 3] = 255;
            offset += numChannels;
          }

          var defaultSize = 16;
          var halfDefaultSize = defaultSize / 2;
          var defaultValueView = new Uint8Array(defaultSize * defaultSize * numChannels);
          offset = 0;

          for (var _i = 0; _i < defaultSize * defaultSize; _i++) {
            defaultValueView[offset] = 221;
            defaultValueView[offset + 1] = 221;
            defaultValueView[offset + 2] = 221;
            defaultValueView[offset + 3] = 255;
            offset += numChannels;
          }

          offset = 0;

          for (var _i2 = 0; _i2 < halfDefaultSize; _i2++) {
            for (var j = 0; j < halfDefaultSize; j++) {
              defaultValueView[offset] = 85;
              defaultValueView[offset + 1] = 85;
              defaultValueView[offset + 2] = 85;
              defaultValueView[offset + 3] = 255;
              offset += numChannels;
            }

            offset += halfDefaultSize * numChannels;
          }

          offset += halfDefaultSize * numChannels;

          for (var _i3 = 0; _i3 < halfDefaultSize; _i3++) {
            for (var _j = 0; _j < halfDefaultSize; _j++) {
              defaultValueView[offset] = 85;
              defaultValueView[offset + 1] = 85;
              defaultValueView[offset + 2] = 85;
              defaultValueView[offset + 3] = 255;
              offset += numChannels;
            }

            offset += halfDefaultSize * numChannels;
          }

          var blackMemImageSource = {
            width: len,
            height: len,
            _data: blackValueView,
            _compressed: false,
            format: Texture2D.PixelFormat.RGBA8888
          };
          var emptyMemImageSource = {
            width: len,
            height: len,
            _data: emptyValueView,
            _compressed: false,
            format: Texture2D.PixelFormat.RGBA8888
          };
          var greyMemImageSource = {
            width: len,
            height: len,
            _data: greyValueView,
            _compressed: false,
            format: Texture2D.PixelFormat.RGBA8888
          };
          var whiteMemImageSource = {
            width: len,
            height: len,
            _data: whiteValueView,
            _compressed: false,
            format: Texture2D.PixelFormat.RGBA8888
          };
          var normalMemImageSource = {
            width: len,
            height: len,
            _data: normalValueView,
            _compressed: false,
            format: Texture2D.PixelFormat.RGBA8888
          };
          var defaultMemImageSource = {
            width: defaultSize,
            height: defaultSize,
            _data: defaultValueView,
            _compressed: false,
            format: Texture2D.PixelFormat.RGBA8888
          };
          var imgAsset = new ImageAsset(blackMemImageSource);
          var blackTexture = new Texture2D();
          blackTexture._uuid = 'black-texture';
          blackTexture.image = imgAsset;
          resources[blackTexture._uuid] = blackTexture;
          var emptyImgAsset = new ImageAsset(emptyMemImageSource);
          var emptyTexture = new Texture2D();
          emptyTexture._uuid = 'empty-texture';
          emptyTexture.image = emptyImgAsset;
          resources[emptyTexture._uuid] = emptyTexture;
          var blackCubeTexture = new TextureCube();
          blackCubeTexture._uuid = 'black-cube-texture';
          blackCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
          blackCubeTexture.image = {
            front: new ImageAsset(blackMemImageSource),
            back: new ImageAsset(blackMemImageSource),
            left: new ImageAsset(blackMemImageSource),
            right: new ImageAsset(blackMemImageSource),
            top: new ImageAsset(blackMemImageSource),
            bottom: new ImageAsset(blackMemImageSource)
          };
          resources[blackCubeTexture._uuid] = blackCubeTexture;
          var greyImgAsset = new ImageAsset(greyMemImageSource);
          var greyTexture = new Texture2D();
          greyTexture._uuid = 'grey-texture';
          greyTexture.image = greyImgAsset;
          resources[greyTexture._uuid] = greyTexture;
          var whiteImgAsset = new ImageAsset(whiteMemImageSource);
          var whiteTexture = new Texture2D();
          whiteTexture._uuid = 'white-texture';
          whiteTexture.image = whiteImgAsset;
          resources[whiteTexture._uuid] = whiteTexture;
          var whiteCubeTexture = new TextureCube();
          whiteCubeTexture._uuid = 'white-cube-texture';
          whiteCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
          whiteCubeTexture.image = {
            front: new ImageAsset(whiteMemImageSource),
            back: new ImageAsset(whiteMemImageSource),
            left: new ImageAsset(whiteMemImageSource),
            right: new ImageAsset(whiteMemImageSource),
            top: new ImageAsset(whiteMemImageSource),
            bottom: new ImageAsset(whiteMemImageSource)
          };
          resources[whiteCubeTexture._uuid] = whiteCubeTexture;
          var normalImgAsset = new ImageAsset(normalMemImageSource);
          var normalTexture = new Texture2D();
          normalTexture._uuid = 'normal-texture';
          normalTexture.image = normalImgAsset;
          resources[normalTexture._uuid] = normalTexture;
          var defaultImgAsset = new ImageAsset(defaultMemImageSource);
          var defaultTexture = new Texture2D();
          defaultTexture._uuid = 'default-texture';
          defaultTexture.image = defaultImgAsset;
          resources[defaultTexture._uuid] = defaultTexture;
          var defaultCubeTexture = new TextureCube();
          defaultCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
          defaultCubeTexture._uuid = 'default-cube-texture';
          defaultCubeTexture.image = {
            front: new ImageAsset(defaultMemImageSource),
            back: new ImageAsset(defaultMemImageSource),
            left: new ImageAsset(defaultMemImageSource),
            right: new ImageAsset(defaultMemImageSource),
            top: new ImageAsset(defaultMemImageSource),
            bottom: new ImageAsset(defaultMemImageSource)
          };
          resources[defaultCubeTexture._uuid] = defaultCubeTexture;

          if (legacyCC.SpriteFrame) {
            var spriteFrame = new legacyCC.SpriteFrame();
            var image = imgAsset;
            var texture = new Texture2D();
            texture.image = image;
            spriteFrame.texture = texture;
            spriteFrame._uuid = 'default-spriteframe';
            resources[spriteFrame._uuid] = spriteFrame;
          }

          var shaderVersionKey = getDeviceShaderVersion(device);

          if (!shaderVersionKey) {
            return Promise.reject(Error('Failed to initialize builtin shaders: unknown device.'));
          }

          var shaderSources = assembly[shaderVersionKey];

          if (!shaderSources) {
            return Promise.reject(Error("Current device is requiring builtin shaders of version " + shaderVersionKey + " " + "but shaders of that version are not assembled in this build."));
          }

          return Promise.resolve().then(function () {
            effects.forEach(function (e, effectIndex) {
              var effect = Object.assign(new legacyCC.EffectAsset(), e);
              effect.shaders.forEach(function (shaderInfo, shaderIndex) {
                var shaderSource = shaderSources[effectIndex][shaderIndex];

                if (shaderSource) {
                  shaderInfo[shaderVersionKey] = shaderSource;
                }
              });
              effect.hideInEditor = true;
              effect.onLoaded();
            });

            _this._initMaterials();
          });
        };

        _proto.get = function get(uuid) {
          return this._resources[uuid];
        };

        _proto._initMaterials = function _initMaterials() {
          var resources = this._resources;
          var materialsToBeCompiled = [];
          var standardMtl = new legacyCC.Material();
          standardMtl._uuid = 'standard-material';
          standardMtl.initialize({
            effectName: 'standard'
          });
          resources[standardMtl._uuid] = standardMtl;
          materialsToBeCompiled.push(standardMtl);
          var missingEfxMtl = new legacyCC.Material();
          missingEfxMtl._uuid = 'missing-effect-material';
          missingEfxMtl.initialize({
            effectName: 'unlit',
            defines: {
              USE_COLOR: true
            }
          });
          missingEfxMtl.setProperty('mainColor', legacyCC.color('#ffff00'));
          resources[missingEfxMtl._uuid] = missingEfxMtl;
          materialsToBeCompiled.push(missingEfxMtl);
          var missingMtl = new legacyCC.Material();
          missingMtl._uuid = 'missing-material';
          missingMtl.initialize({
            effectName: 'unlit',
            defines: {
              USE_COLOR: true
            }
          });
          missingMtl.setProperty('mainColor', legacyCC.color('#ff00ff'));
          resources[missingMtl._uuid] = missingMtl;
          materialsToBeCompiled.push(missingMtl);
          var clearStencilMtl = new legacyCC.Material();
          clearStencilMtl._uuid = 'default-clear-stencil';
          clearStencilMtl.initialize({
            defines: {
              USE_TEXTURE: false
            },
            effectName: 'clear-stencil'
          });
          resources[clearStencilMtl._uuid] = clearStencilMtl;
          materialsToBeCompiled.push(clearStencilMtl);
          var spriteMtl = new legacyCC.Material();
          spriteMtl._uuid = 'ui-base-material';
          spriteMtl.initialize({
            defines: {
              USE_TEXTURE: false
            },
            effectName: 'sprite'
          });
          resources[spriteMtl._uuid] = spriteMtl;
          materialsToBeCompiled.push(spriteMtl);
          var spriteColorMtl = new legacyCC.Material();
          spriteColorMtl._uuid = 'ui-sprite-material';
          spriteColorMtl.initialize({
            defines: {
              USE_TEXTURE: true,
              CC_USE_EMBEDDED_ALPHA: false,
              IS_GRAY: false
            },
            effectName: 'sprite'
          });
          resources[spriteColorMtl._uuid] = spriteColorMtl;
          materialsToBeCompiled.push(spriteColorMtl);
          var alphaTestMaskMtl = new legacyCC.Material();
          alphaTestMaskMtl._uuid = 'ui-alpha-test-material';
          alphaTestMaskMtl.initialize({
            defines: {
              USE_TEXTURE: true,
              USE_ALPHA_TEST: true,
              CC_USE_EMBEDDED_ALPHA: false,
              IS_GRAY: false
            },
            effectName: 'sprite'
          });
          resources[alphaTestMaskMtl._uuid] = alphaTestMaskMtl;
          materialsToBeCompiled.push(alphaTestMaskMtl);
          var spriteGrayMtl = new legacyCC.Material();
          spriteGrayMtl._uuid = 'ui-sprite-gray-material';
          spriteGrayMtl.initialize({
            defines: {
              USE_TEXTURE: true,
              CC_USE_EMBEDDED_ALPHA: false,
              IS_GRAY: true
            },
            effectName: 'sprite'
          });
          resources[spriteGrayMtl._uuid] = spriteGrayMtl;
          materialsToBeCompiled.push(spriteGrayMtl);
          var spriteAlphaMtl = new legacyCC.Material();
          spriteAlphaMtl._uuid = 'ui-sprite-alpha-sep-material';
          spriteAlphaMtl.initialize({
            defines: {
              USE_TEXTURE: true,
              CC_USE_EMBEDDED_ALPHA: true,
              IS_GRAY: false
            },
            effectName: 'sprite'
          });
          resources[spriteAlphaMtl._uuid] = spriteAlphaMtl;
          materialsToBeCompiled.push(spriteAlphaMtl);
          var spriteAlphaGrayMtl = new legacyCC.Material();
          spriteAlphaGrayMtl._uuid = 'ui-sprite-gray-alpha-sep-material';
          spriteAlphaGrayMtl.initialize({
            defines: {
              USE_TEXTURE: true,
              CC_USE_EMBEDDED_ALPHA: true,
              IS_GRAY: true
            },
            effectName: 'sprite'
          });
          resources[spriteAlphaGrayMtl._uuid] = spriteAlphaGrayMtl;
          materialsToBeCompiled.push(spriteAlphaGrayMtl);
          var defaultGraphicsMtl = new legacyCC.Material();
          defaultGraphicsMtl._uuid = 'ui-graphics-material';
          defaultGraphicsMtl.initialize({
            effectName: 'graphics'
          });
          resources[defaultGraphicsMtl._uuid] = defaultGraphicsMtl;
          materialsToBeCompiled.push(defaultGraphicsMtl);
          var defaultParticleMtl = new legacyCC.Material();
          defaultParticleMtl._uuid = 'default-particle-material';
          defaultParticleMtl.initialize({
            effectName: 'particle'
          });
          resources[defaultParticleMtl._uuid] = defaultParticleMtl;
          materialsToBeCompiled.push(defaultParticleMtl);

          {
            var defaultParticleGPUMtl = new legacyCC.Material();
            defaultParticleGPUMtl._uuid = 'default-particle-gpu-material';
            defaultParticleGPUMtl.initialize({
              effectName: 'particle-gpu'
            });
            resources[defaultParticleGPUMtl._uuid] = defaultParticleGPUMtl;
            materialsToBeCompiled.push(defaultParticleGPUMtl);
          }

          var defaultTrailMtl = new legacyCC.Material();
          defaultTrailMtl._uuid = 'default-trail-material';
          defaultTrailMtl.initialize({
            effectName: 'particle-trail'
          });
          resources[defaultTrailMtl._uuid] = defaultTrailMtl;
          materialsToBeCompiled.push(defaultTrailMtl);
          var defaultBillboardMtl = new legacyCC.Material();
          defaultBillboardMtl._uuid = 'default-billboard-material';
          defaultBillboardMtl.initialize({
            effectName: 'billboard'
          });
          resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
          materialsToBeCompiled.push(defaultBillboardMtl);
          var spineTwoColorMtl = new legacyCC.Material();
          spineTwoColorMtl._uuid = 'default-spine-material';
          spineTwoColorMtl.initialize({
            defines: {
              USE_TEXTURE: true,
              CC_USE_EMBEDDED_ALPHA: false,
              IS_GRAY: false
            },
            effectName: 'spine'
          });
          resources[spineTwoColorMtl._uuid] = spineTwoColorMtl;
          materialsToBeCompiled.push(spineTwoColorMtl);
          legacyCC.game.on(legacyCC.Game.EVENT_GAME_INITED, function () {
            for (var i = 0; i < materialsToBeCompiled.length; ++i) {
              var mat = materialsToBeCompiled[i];

              for (var j = 0; j < mat.passes.length; ++j) {
                mat.passes[j].tryCompile();
              }
            }
          });
        };

        return BuiltinResMgr;
      }();

      var builtinResMgr = exports('builtinResMgr', legacyCC.builtinResMgr = new BuiltinResMgr());

      var getPhaseID = exports('getPhaseID', function () {
        var phases = new Map();
        var phaseNum = 0;
        return function (phaseName) {
          if (typeof phaseName === 'number') {
            return phaseName;
          }

          if (!phases.has(phaseName)) {
            phases.set(phaseName, 1 << phaseNum);
            phaseNum++;
          }

          return phases.get(phaseName);
        };
      }());

      var INITIAL_CAPACITY = 32;
      var MAX_CAPACITY = 1024;
      var InstancedBuffer = exports('InstancedBuffer', function () {
        function InstancedBuffer(pass) {
          this.instances = [];
          this.pass = void 0;
          this.hasPendingModels = false;
          this.dynamicOffsets = [];
          this._device = void 0;
          this._device = pass.device;
          this.pass = pass;
        }

        var _proto = InstancedBuffer.prototype;

        _proto.destroy = function destroy() {
          for (var i = 0; i < this.instances.length; ++i) {
            var instance = this.instances[i];
            instance.vb.destroy();
            instance.ia.destroy();
          }

          this.instances.length = 0;
        };

        _proto.merge = function merge(subModel, attrs, passIdx, shaderImplant) {
          if (shaderImplant === void 0) {
            shaderImplant = null;
          }

          var stride = attrs.buffer.length;

          if (!stride) {
            return;
          }

          var sourceIA = subModel.inputAssembler;
          var lightingMap = subModel.descriptorSet.getTexture(UNIFORM_LIGHTMAP_TEXTURE_BINDING);
          var shader = shaderImplant;

          if (!shader) {
            shader = subModel.shaders[passIdx];
          }

          var descriptorSet = subModel.descriptorSet;

          for (var i = 0; i < this.instances.length; ++i) {
            var instance = this.instances[i];

            if (instance.ia.indexBuffer !== sourceIA.indexBuffer || instance.count >= MAX_CAPACITY) {
              continue;
            }

            if (instance.lightingMap !== lightingMap) {
              continue;
            }

            if (instance.stride !== stride) {
              continue;
            }

            if (instance.count >= instance.capacity) {
              instance.capacity <<= 1;
              var newSize = instance.stride * instance.capacity;
              var oldData = instance.data;
              instance.data = new Uint8Array(newSize);
              instance.data.set(oldData);
              instance.vb.resize(newSize);
            }

            if (instance.shader !== shader) {
              instance.shader = shader;
            }

            if (instance.descriptorSet !== descriptorSet) {
              instance.descriptorSet = descriptorSet;
            }

            instance.data.set(attrs.buffer, instance.stride * instance.count++);
            this.hasPendingModels = true;
            return;
          }

          var vb = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, stride * INITIAL_CAPACITY, stride));

          var data = new Uint8Array(stride * INITIAL_CAPACITY);
          var vertexBuffers = sourceIA.vertexBuffers.slice();
          var attributes = sourceIA.attributes.slice();
          var indexBuffer = sourceIA.indexBuffer;

          for (var _i = 0; _i < attrs.attributes.length; _i++) {
            var attr = attrs.attributes[_i];
            var newAttr = new Attribute(attr.name, attr.format, attr.isNormalized, vertexBuffers.length, true);
            attributes.push(newAttr);
          }

          data.set(attrs.buffer);
          vertexBuffers.push(vb);
          var iaInfo = new InputAssemblerInfo(attributes, vertexBuffers, indexBuffer);

          var ia = this._device.createInputAssembler(iaInfo);

          this.instances.push({
            count: 1,
            capacity: INITIAL_CAPACITY,
            vb: vb,
            data: data,
            ia: ia,
            stride: stride,
            shader: shader,
            descriptorSet: descriptorSet,
            lightingMap: lightingMap
          });
          this.hasPendingModels = true;
        };

        _proto.uploadBuffers = function uploadBuffers(cmdBuff) {
          for (var i = 0; i < this.instances.length; ++i) {
            var instance = this.instances[i];

            if (!instance.count) {
              continue;
            }

            instance.ia.instanceCount = instance.count;
            cmdBuff.updateBuffer(instance.vb, instance.data);
          }
        };

        _proto.clear = function clear() {
          for (var i = 0; i < this.instances.length; ++i) {
            var instance = this.instances[i];
            instance.count = 0;
          }

          this.hasPendingModels = false;
        };

        return InstancedBuffer;
      }());

      var BatchedBuffer = function () {
        function BatchedBuffer(pass) {
          this.batches = [];
          this.dynamicOffsets = [];
          this._device = void 0;
          this._device = pass.device;
        }

        var _proto = BatchedBuffer.prototype;

        _proto.destroy = function destroy() {
          for (var i = 0; i < this.batches.length; ++i) {
            var batch = this.batches[i];

            for (var j = 0; j < batch.vbs.length; ++j) {
              batch.vbs[j].destroy();
            }

            batch.vbIdx.destroy();
            batch.ia.destroy();
            batch.ubo.destroy();
          }

          this.batches.length = 0;
        };

        _proto.merge = function merge(subModel, passIdx, model) {
          var flatBuffers = subModel.subMesh.flatBuffers;

          if (flatBuffers.length === 0) {
            return;
          }

          var vbSize = 0;
          var vbIdxSize = 0;
          var vbCount = flatBuffers[0].count;
          var pass = subModel.passes[passIdx];
          var shader = subModel.shaders[passIdx];
          var descriptorSet = subModel.descriptorSet;
          var isBatchExist = false;

          for (var i = 0; i < this.batches.length; ++i) {
            var batch = this.batches[i];

            if (batch.vbs.length === flatBuffers.length && batch.mergeCount < UBOLocalBatched.BATCHING_COUNT) {
              isBatchExist = true;

              for (var j = 0; j < batch.vbs.length; ++j) {
                var vb = batch.vbs[j];

                if (vb.stride !== flatBuffers[j].stride) {
                  isBatchExist = false;
                  break;
                }
              }

              if (isBatchExist) {
                for (var _j = 0; _j < batch.vbs.length; ++_j) {
                  var flatBuff = flatBuffers[_j];
                  var batchVB = batch.vbs[_j];
                  var vbBuf = batch.vbDatas[_j];
                  vbSize = (vbCount + batch.vbCount) * flatBuff.stride;

                  if (vbSize > batchVB.size) {
                    batchVB.resize(vbSize);
                    batch.vbDatas[_j] = new Uint8Array(vbSize);

                    batch.vbDatas[_j].set(vbBuf);
                  }

                  batch.vbDatas[_j].set(flatBuff.buffer, batch.vbCount * flatBuff.stride);
                }

                var vbIdxBuf = batch.vbIdxData;
                vbIdxSize = (vbCount + batch.vbCount) * 4;

                if (vbIdxSize > batch.vbIdx.size) {
                  batch.vbIdx.resize(vbIdxSize);
                  batch.vbIdxData = new Float32Array(vbIdxSize / Float32Array.BYTES_PER_ELEMENT);
                  batch.vbIdxData.set(vbIdxBuf);
                  vbIdxBuf = batch.vbIdxData;
                }

                var start = batch.vbCount;
                var end = start + vbCount;
                var mergeCount = batch.mergeCount;

                if (vbIdxBuf[start] !== mergeCount || vbIdxBuf[end - 1] !== mergeCount) {
                  for (var _j2 = start; _j2 < end; _j2++) {
                    vbIdxBuf[_j2] = mergeCount + 0.1;
                  }
                }

                Mat4.toArray(batch.uboData, model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET + batch.mergeCount * 16);

                if (!batch.mergeCount) {
                  descriptorSet.bindBuffer(UBOLocalBatched.BINDING, batch.ubo);
                  descriptorSet.update();
                  batch.pass = pass;
                  batch.shader = shader;
                  batch.descriptorSet = descriptorSet;
                }

                ++batch.mergeCount;
                batch.vbCount += vbCount;
                batch.ia.vertexCount += vbCount;
                return;
              }
            }
          }

          var vbs = [];
          var vbDatas = [];
          var totalVBs = [];

          for (var _i = 0; _i < flatBuffers.length; ++_i) {
            var _flatBuff = flatBuffers[_i];

            var newVB = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, _flatBuff.count * _flatBuff.stride, _flatBuff.stride));

            newVB.update(_flatBuff.buffer.buffer);
            vbs.push(newVB);
            vbDatas.push(new Uint8Array(newVB.size));
            totalVBs.push(newVB);
          }

          var vbIdx = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbCount * 4, 4));

          var vbIdxData = new Float32Array(vbCount);
          vbIdxData.fill(0);
          vbIdx.update(vbIdxData);
          totalVBs.push(vbIdx);
          var attributes = subModel.inputAssembler.attributes;
          var attrs = new Array(attributes.length + 1);

          for (var a = 0; a < attributes.length; ++a) {
            attrs[a] = attributes[a];
          }

          attrs[attributes.length] = new Attribute('a_dyn_batch_id', Format.R32F, false, flatBuffers.length);
          var iaInfo = new InputAssemblerInfo(attrs, totalVBs);

          var ia = this._device.createInputAssembler(iaInfo);

          var ubo = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocalBatched.SIZE, UBOLocalBatched.SIZE));

          descriptorSet.bindBuffer(UBOLocalBatched.BINDING, ubo);
          descriptorSet.update();
          var uboData = new Float32Array(UBOLocalBatched.COUNT);
          Mat4.toArray(uboData, model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET);
          this.batches.push({
            mergeCount: 1,
            vbs: vbs,
            vbDatas: vbDatas,
            vbIdx: vbIdx,
            vbIdxData: vbIdxData,
            vbCount: vbCount,
            ia: ia,
            ubo: ubo,
            uboData: uboData,
            pass: pass,
            shader: shader,
            descriptorSet: descriptorSet
          });
        };

        _proto.clear = function clear() {
          for (var i = 0; i < this.batches.length; ++i) {
            var batch = this.batches[i];
            batch.vbCount = 0;
            batch.mergeCount = 0;
            batch.ia.vertexCount = 0;
          }
        };

        return BatchedBuffer;
      }();

      var _bufferInfo = new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE);

      var _bufferViewInfo = new BufferViewInfo(null);

      var _dsInfo = new DescriptorSetInfo(null);

      var BatchingSchemes;

      (function (BatchingSchemes) {
        BatchingSchemes[BatchingSchemes["NONE"] = 0] = "NONE";
        BatchingSchemes[BatchingSchemes["INSTANCING"] = 1] = "INSTANCING";
        BatchingSchemes[BatchingSchemes["VB_MERGING"] = 2] = "VB_MERGING";
      })(BatchingSchemes || (BatchingSchemes = {}));

      var Pass = function () {
        Pass.fillPipelineInfo = function fillPipelineInfo(pass, info) {
          if (info.priority !== undefined) {
            pass._setPriority(info.priority);
          }

          if (info.primitive !== undefined) {
            pass._setPrimitive(info.primitive);
          }

          if (info.stage !== undefined) {
            pass._setStage(info.stage);
          }

          if (info.dynamicStates !== undefined) {
            pass._setDynamicState(info.dynamicStates);
          }

          if (info.phase !== undefined) {
            pass._setPhase(getPhaseID(info.phase));
          }

          var bs = pass._bs;

          if (info.blendState) {
            var bsInfo = info.blendState;
            var targets = bsInfo.targets;

            if (targets) {
              targets.forEach(function (t, i) {
                bs.setTarget(i, t);
              });
            }

            if (bsInfo.isA2C !== undefined) {
              bs.isA2C = bsInfo.isA2C;
            }

            if (bsInfo.isIndepend !== undefined) {
              bs.isIndepend = bsInfo.isIndepend;
            }

            if (bsInfo.blendColor !== undefined) {
              bs.blendColor = bsInfo.blendColor;
            }
          }

          pass._rs.assign(info.rasterizerState);

          pass._dss.assign(info.depthStencilState);
        };

        Pass.getPassHash = function getPassHash(pass) {
          var shaderKey = programLib.getKey(pass.program, pass.defines);
          var res = shaderKey + "," + pass._primitive + "," + pass._dynamicStates;
          res += serializeBlendState(pass._bs);
          res += serializeDepthStencilState(pass._dss);
          res += serializeRasterizerState(pass._rs);
          return murmurhash2_32_gc(res, 666);
        };

        function Pass(root) {
          this._rootBuffer = null;
          this._buffers = [];
          this._descriptorSet = null;
          this._pipelineLayout = null;
          this._passIndex = 0;
          this._propertyIndex = 0;
          this._programName = '';
          this._dynamics = {};
          this._propertyHandleMap = {};
          this._rootBlock = null;
          this._blocksInt = [];
          this._blocks = [];
          this._shaderInfo = null;
          this._defines = {};
          this._properties = {};
          this._shader = null;
          this._bs = new BlendState();
          this._dss = new DepthStencilState();
          this._rs = new RasterizerState();
          this._priority = RenderPriority.DEFAULT;
          this._stage = RenderPassStage.DEFAULT;
          this._phase = getPhaseID('default');
          this._primitive = PrimitiveMode.TRIANGLE_LIST;
          this._batchingScheme = BatchingSchemes.NONE;
          this._dynamicStates = DynamicStateFlagBit.NONE;
          this._instancedBuffers = {};
          this._batchedBuffers = {};
          this._hash = 0;
          this._root = void 0;
          this._device = void 0;
          this._passHandle = NULL_HANDLE;
          this._rootBufferDirty = false;
          this._root = root;
          this._device = root.device;
        }

        var _proto = Pass.prototype;

        _proto.initialize = function initialize(info) {
          this._doInit(info);

          this.resetUBOs();
          this.resetTextures();
          this.tryCompile();
        };

        _proto.getHandle = function getHandle(name, offset, targetType) {
          if (offset === void 0) {
            offset = 0;
          }

          if (targetType === void 0) {
            targetType = Type.UNKNOWN;
          }

          var handle = this._propertyHandleMap[name];

          if (!handle) {
            return 0;
          }

          if (targetType) {
            handle = customizeType(handle, targetType);
          } else if (offset) {
            handle = customizeType(handle, getTypeFromHandle(handle) - offset);
          }

          return handle + offset;
        };

        _proto.getBinding = function getBinding(name) {
          var handle = this.getHandle(name);

          if (!handle) {
            return -1;
          }

          return Pass.getBindingFromHandle(handle);
        };

        _proto.setUniform = function setUniform(handle, value) {
          var binding = Pass.getBindingFromHandle(handle);
          var type = Pass.getTypeFromHandle(handle);
          var ofs = Pass.getOffsetFromHandle(handle);

          var block = this._getBlockView(type, binding);

          type2writer[type](block, value, ofs);

          this._setRootBufferDirty(true);
        };

        _proto.getUniform = function getUniform(handle, out) {
          var binding = Pass.getBindingFromHandle(handle);
          var type = Pass.getTypeFromHandle(handle);
          var ofs = Pass.getOffsetFromHandle(handle);

          var block = this._getBlockView(type, binding);

          return type2reader[type](block, out, ofs);
        };

        _proto.setUniformArray = function setUniformArray(handle, value) {
          var binding = Pass.getBindingFromHandle(handle);
          var type = Pass.getTypeFromHandle(handle);
          var stride = GetTypeSize(type) >> 2;

          var block = this._getBlockView(type, binding);

          var ofs = Pass.getOffsetFromHandle(handle);

          for (var i = 0; i < value.length; i++, ofs += stride) {
            if (value[i] === null) {
              continue;
            }

            type2writer[type](block, value[i], ofs);
          }

          this._setRootBufferDirty(true);
        };

        _proto.bindTexture = function bindTexture(binding, value, index) {
          this._descriptorSet.bindTexture(binding, value, index || 0);
        };

        _proto.bindSampler = function bindSampler(binding, value, index) {
          this._descriptorSet.bindSampler(binding, value, index || 0);
        };

        _proto.setDynamicState = function setDynamicState(state, value) {
          var ds = this._dynamics[state];

          if (ds && ds.value === value) {
            return;
          }

          ds.value = value;
          ds.dirty = true;
        };

        _proto.overridePipelineStates = function overridePipelineStates(original, overrides) {
          console.warn('base pass cannot override states, please use pass instance instead.');
        };

        _proto._setRootBufferDirty = function _setRootBufferDirty(val) {
          this._rootBufferDirty = val;
        };

        _proto.update = function update() {
          if (!this._descriptorSet) {
            errorID(12006);
            return;
          }

          if (this._rootBuffer && this._rootBufferDirty) {
            this._rootBuffer.update(this._rootBlock);

            this._setRootBufferDirty(false);
          }

          this._descriptorSet.update();
        };

        _proto.getInstancedBuffer = function getInstancedBuffer(extraKey) {
          if (extraKey === void 0) {
            extraKey = 0;
          }

          return this._instancedBuffers[extraKey] || (this._instancedBuffers[extraKey] = new InstancedBuffer(this));
        };

        _proto.getBatchedBuffer = function getBatchedBuffer(extraKey) {
          if (extraKey === void 0) {
            extraKey = 0;
          }

          return this._batchedBuffers[extraKey] || (this._batchedBuffers[extraKey] = new BatchedBuffer(this));
        };

        _proto._initNative = function _initNative() {
        };

        _proto._destroy = function _destroy() {
        };

        _proto.destroy = function destroy() {
          for (var i = 0; i < this._shaderInfo.blocks.length; i++) {
            var u = this._shaderInfo.blocks[i];

            this._buffers[u.binding].destroy();
          }

          this._buffers = [];

          if (this._rootBuffer) {
            this._rootBuffer.destroy();

            this._rootBuffer = null;
          }

          for (var ib in this._instancedBuffers) {
            this._instancedBuffers[ib].destroy();
          }

          for (var bb in this._batchedBuffers) {
            this._batchedBuffers[bb].destroy();
          }

          this._descriptorSet.destroy();

          this._rs.destroy();

          this._dss.destroy();

          this._bs.destroy();

          this._destroy();
        };

        _proto.resetUniform = function resetUniform(name) {
          var handle = this.getHandle(name);

          if (!handle) {
            return;
          }

          var type = Pass.getTypeFromHandle(handle);
          var binding = Pass.getBindingFromHandle(handle);
          var ofs = Pass.getOffsetFromHandle(handle);
          var count = Pass.getCountFromHandle(handle);

          var block = this._getBlockView(type, binding);

          var info = this._properties[name];
          var givenDefault = info && info.value;
          var value = givenDefault || getDefaultFromType(type);
          var size = (GetTypeSize(type) >> 2) * count;

          for (var k = 0; k + value.length <= size; k += value.length) {
            block.set(value, ofs + k);
          }

          this._setRootBufferDirty(true);
        };

        _proto.resetTexture = function resetTexture(name, index) {
          var handle = this.getHandle(name);

          if (!handle) {
            return;
          }

          var type = Pass.getTypeFromHandle(handle);
          var binding = Pass.getBindingFromHandle(handle);
          var info = this._properties[name];
          var value = info && info.value;
          var texName = value ? value + "-texture" : getDefaultFromType(type);
          var textureBase = builtinResMgr.get(texName);
          var texture = textureBase && textureBase.getGFXTexture();
          var samplerInfo = info && info.samplerHash !== undefined ? Sampler.unpackFromHash(info.samplerHash) : textureBase && textureBase.getSamplerInfo();

          var sampler = this._device.getSampler(samplerInfo);

          this._descriptorSet.bindSampler(binding, sampler, index);

          this._descriptorSet.bindTexture(binding, texture, index);
        };

        _proto.resetUBOs = function resetUBOs() {
          for (var i = 0; i < this._shaderInfo.blocks.length; i++) {
            var u = this._shaderInfo.blocks[i];
            var ofs = 0;

            for (var j = 0; j < u.members.length; j++) {
              var cur = u.members[j];

              var block = this._getBlockView(cur.type, u.binding);

              var info = this._properties[cur.name];
              var givenDefault = info && info.value;
              var value = givenDefault || getDefaultFromType(cur.type);
              var size = (GetTypeSize(cur.type) >> 2) * cur.count;

              for (var k = 0; k + value.length <= size; k += value.length) {
                block.set(value, ofs + k);
              }

              ofs += size;
            }
          }

          this._setRootBufferDirty(true);
        };

        _proto.resetTextures = function resetTextures() {
          for (var i = 0; i < this._shaderInfo.samplerTextures.length; i++) {
            var u = this._shaderInfo.samplerTextures[i];

            for (var j = 0; j < u.count; j++) {
              this.resetTexture(u.name, j);
            }
          }
        };

        _proto.tryCompile = function tryCompile() {
          var pipeline = this._root.pipeline;

          if (!pipeline) {
            return false;
          }

          this._syncBatchingScheme();

          var shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

          if (!shader) {
            console.warn("create shader " + this._programName + " failed");
            return false;
          }

          this._shader = shader;

          this._setPipelineLayout(programLib.getTemplateInfo(this._programName).pipelineLayout);

          this._setHash(Pass.getPassHash(this));

          return true;
        };

        _proto.getShaderVariant = function getShaderVariant(patches) {
          if (patches === void 0) {
            patches = null;
          }

          if (!this._shader && !this.tryCompile()) {
            console.warn('pass resources incomplete');
            return null;
          }

          if (!patches) {
            return this._shader;
          }

          var pipeline = this._root.pipeline;

          for (var _i = 0; _i < patches.length; _i++) {
            var patch = patches[_i];
            this._defines[patch.name] = patch.value;
          }

          var shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

          for (var _i2 = 0; _i2 < patches.length; _i2++) {
            var _patch = patches[_i2];
            delete this._defines[_patch.name];
          }

          return shader;
        };

        _proto.beginChangeStatesSilently = function beginChangeStatesSilently() {};

        _proto.endChangeStatesSilently = function endChangeStatesSilently() {};

        _proto._setPriority = function _setPriority(val) {
          this._priority = val;
        };

        _proto._setStage = function _setStage(val) {
          this._stage = val;
        };

        _proto._setPhase = function _setPhase(val) {
          this._phase = val;
        };

        _proto._setPrimitive = function _setPrimitive(val) {
          this._primitive = val;
        };

        _proto._setState = function _setState(bs, dss, rs, ds) {
          this._bs = bs;
          this._dss = dss;
          this._rs = rs;
          this._descriptorSet = ds;
        };

        _proto._doInit = function _doInit(info, copyDefines) {
          if (copyDefines === void 0) {
            copyDefines = false;
          }

          this._initNative();

          this._setPriority(RenderPriority.DEFAULT);

          this._setStage(RenderPassStage.DEFAULT);

          this._setPhase(getPhaseID('default'));

          this._setPrimitive(PrimitiveMode.TRIANGLE_LIST);

          this._passIndex = info.passIndex;
          this._propertyIndex = info.propertyIndex !== undefined ? info.propertyIndex : info.passIndex;
          this._programName = info.program;
          this._defines = copyDefines ? _extends({}, info.defines) : info.defines;
          this._shaderInfo = programLib.getTemplate(info.program);
          this._properties = info.properties || this._properties;
          var device = this._device;
          Pass.fillPipelineInfo(this, info);

          if (info.stateOverrides) {
            Pass.fillPipelineInfo(this, info.stateOverrides);
          }

          _dsInfo.layout = programLib.getDescriptorSetLayout(this._device, info.program);
          this._descriptorSet = this._device.createDescriptorSet(_dsInfo);

          this._setState(this._bs, this._dss, this._rs, this._descriptorSet);

          var blocks = this._shaderInfo.blocks;
          var tmplInfo = programLib.getTemplateInfo(info.program);
          var blockSizes = tmplInfo.blockSizes,
              handleMap = tmplInfo.handleMap;
          var alignment = device.capabilities.uboOffsetAlignment;
          var startOffsets = [];
          var lastSize = 0;
          var lastOffset = 0;

          for (var i = 0; i < blocks.length; i++) {
            var size = blockSizes[i];
            startOffsets.push(lastOffset);
            lastOffset += Math.ceil(size / alignment) * alignment;
            lastSize = size;
          }

          var totalSize = startOffsets[startOffsets.length - 1] + lastSize;

          if (totalSize) {
            _bufferInfo.size = Math.ceil(totalSize / 16) * 16;
            this._rootBuffer = device.createBuffer(_bufferInfo);
            this._rootBlock = new ArrayBuffer(totalSize);
          }

          for (var _i3 = 0, count = 0; _i3 < blocks.length; _i3++) {
            var binding = blocks[_i3].binding;
            var _size = blockSizes[_i3];
            _bufferViewInfo.buffer = this._rootBuffer;
            _bufferViewInfo.offset = startOffsets[count++];
            _bufferViewInfo.range = Math.ceil(_size / 16) * 16;
            var bufferView = this._buffers[binding] = device.createBuffer(_bufferViewInfo);
            this._blocks[binding] = new Float32Array(this._rootBlock, _bufferViewInfo.offset, _size / Float32Array.BYTES_PER_ELEMENT);
            this._blocksInt[binding] = new Int32Array(this._blocks[binding].buffer, this._blocks[binding].byteOffset, this._blocks[binding].length);

            this._descriptorSet.bindBuffer(binding, bufferView);
          }

          var directHandleMap = this._propertyHandleMap = handleMap;
          var indirectHandleMap = {};

          for (var name in this._properties) {
            var prop = this._properties[name];

            if (!prop.handleInfo) {
              continue;
            }

            indirectHandleMap[name] = this.getHandle.apply(this, prop.handleInfo);
          }

          Object.assign(directHandleMap, indirectHandleMap);
        };

        _proto._syncBatchingScheme = function _syncBatchingScheme() {
          if (this._defines.USE_INSTANCING) {
            if (this._device.hasFeature(Feature.INSTANCED_ARRAYS)) {
              this._setBatchingScheme(BatchingSchemes.INSTANCING);
            } else {
              this._defines.USE_INSTANCING = false;

              this._setBatchingScheme(BatchingSchemes.NONE);
            }
          } else if (this._defines.USE_BATCHING) {
            this._setBatchingScheme(BatchingSchemes.VB_MERGING);
          } else {
            this._setBatchingScheme(BatchingSchemes.NONE);
          }
        };

        _proto._setBatchingScheme = function _setBatchingScheme(val) {
          this._batchingScheme = val;
        };

        _proto._setDynamicState = function _setDynamicState(val) {
          this._dynamicStates = val;
        };

        _proto._setHash = function _setHash(val) {
          this._hash = val;
        };

        _proto._getBlockView = function _getBlockView(type, binding) {
          return type < Type.FLOAT ? this._blocksInt[binding] : this._blocks[binding];
        };

        _proto._setPipelineLayout = function _setPipelineLayout(pipelineLayout) {
          this._pipelineLayout = pipelineLayout;
        };

        _proto._initPassFromTarget = function _initPassFromTarget(target, dss, bs, hashFactor) {
          this._initNative();

          this._setPriority(target.priority);

          this._setStage(target.stage);

          this._setPhase(target.phase);

          this._setBatchingScheme(target.batchingScheme);

          this._setPrimitive(target.primitive);

          this._setDynamicState(target.dynamicStates);

          this._setState(bs, dss, target.rasterizerState, target.descriptorSet);

          this._passIndex = target.passIndex;
          this._propertyIndex = target.propertyIndex;
          this._programName = target.program;
          this._defines = target.defines;
          this._shaderInfo = target._shaderInfo;
          this._properties = target._properties;
          this._blocks = target._blocks;
          this._blocksInt = target._blocksInt;
          this._dynamics = target._dynamics;
          this._shader = target._shader;

          this._setPipelineLayout(programLib.getTemplateInfo(this._programName).pipelineLayout);

          this._setHash(target._hash ^ hashFactor);
        };

        _createClass(Pass, [{
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "root",
          get: function get() {
            return this._root;
          }
        }, {
          key: "device",
          get: function get() {
            return this._device;
          }
        }, {
          key: "shaderInfo",
          get: function get() {
            return this._shaderInfo;
          }
        }, {
          key: "localSetLayout",
          get: function get() {
            return programLib.getDescriptorSetLayout(this._device, this._programName, true);
          }
        }, {
          key: "program",
          get: function get() {
            return this._programName;
          }
        }, {
          key: "properties",
          get: function get() {
            return this._properties;
          }
        }, {
          key: "defines",
          get: function get() {
            return this._defines;
          }
        }, {
          key: "passIndex",
          get: function get() {
            return this._passIndex;
          }
        }, {
          key: "propertyIndex",
          get: function get() {
            return this._propertyIndex;
          }
        }, {
          key: "dynamics",
          get: function get() {
            return this._dynamics;
          }
        }, {
          key: "blocks",
          get: function get() {
            return this._blocks;
          }
        }, {
          key: "blocksInt",
          get: function get() {
            return this._blocksInt;
          }
        }, {
          key: "rootBufferDirty",
          get: function get() {
            return this._rootBufferDirty;
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          }
        }, {
          key: "primitive",
          get: function get() {
            return this._primitive;
          }
        }, {
          key: "stage",
          get: function get() {
            return this._stage;
          }
        }, {
          key: "phase",
          get: function get() {
            return this._phase;
          }
        }, {
          key: "rasterizerState",
          get: function get() {
            return this._rs;
          }
        }, {
          key: "depthStencilState",
          get: function get() {
            return this._dss;
          }
        }, {
          key: "blendState",
          get: function get() {
            return this._bs;
          }
        }, {
          key: "dynamicStates",
          get: function get() {
            return this._dynamicStates;
          }
        }, {
          key: "batchingScheme",
          get: function get() {
            return this._batchingScheme;
          }
        }, {
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }, {
          key: "pipelineLayout",
          get: function get() {
            return this._pipelineLayout;
          }
        }]);

        return Pass;
      }();
      Pass.getTypeFromHandle = getTypeFromHandle;
      Pass.getBindingFromHandle = getBindingFromHandle;
      Pass.getCountFromHandle = getCountFromHandle;
      Pass.getOffsetFromHandle = getOffsetFromHandle;

      function serializeBlendState(bs) {
        var res = ",bs," + bs.isA2C;

        for (var _iterator = _createForOfIteratorHelperLoose(bs.targets), _step; !(_step = _iterator()).done;) {
          var t = _step.value;
          res += ",bt," + t.blend + "," + t.blendEq + "," + t.blendAlphaEq + "," + t.blendColorMask;
          res += "," + t.blendSrc + "," + t.blendDst + "," + t.blendSrcAlpha + "," + t.blendDstAlpha;
        }

        return res;
      }

      function serializeRasterizerState(rs) {
        return ",rs," + rs.cullMode + "," + rs.depthBias + "," + rs.isFrontFaceCCW;
      }

      function serializeDepthStencilState(dss) {
        var res = ",dss," + dss.depthTest + "," + dss.depthWrite + "," + dss.depthFunc;
        res += "," + dss.stencilTestFront + "," + dss.stencilFuncFront + "," + dss.stencilRefFront + "," + dss.stencilReadMaskFront;
        res += "," + dss.stencilFailOpFront + "," + dss.stencilZFailOpFront + "," + dss.stencilPassOpFront + "," + dss.stencilWriteMaskFront;
        res += "," + dss.stencilTestBack + "," + dss.stencilFuncBack + "," + dss.stencilRefBack + "," + dss.stencilReadMaskBack;
        res += "," + dss.stencilFailOpBack + "," + dss.stencilZFailOpBack + "," + dss.stencilPassOpBack + "," + dss.stencilWriteMaskBack;
        return res;
      }

      var PipelineStateManager = exports('PipelineStateManager', function () {
        function PipelineStateManager() {}

        PipelineStateManager.getOrCreatePipelineState = function getOrCreatePipelineState(device, pass, shader, renderPass, ia) {
          var hash1 = pass.hash;
          var hash2 = renderPass.hash;
          var hash3 = ia.attributesHash;
          var hash4 = shader.typedID;
          var newHash = hash1 ^ hash2 ^ hash3 ^ hash4;

          var pso = this._PSOHashMap.get(newHash);

          if (!pso) {
            var pipelineLayout = pass.pipelineLayout;
            var inputState = new InputState(ia.attributes);
            var psoInfo = new PipelineStateInfo(shader, pipelineLayout, renderPass, inputState, pass.rasterizerState, pass.depthStencilState, pass.blendState, pass.primitive, pass.dynamicStates);
            pso = device.createPipelineState(psoInfo);

            this._PSOHashMap.set(newHash, pso);
          }

          return pso;
        };

        return PipelineStateManager;
      }());
      PipelineStateManager._PSOHashMap = new Map();

      var profilerViewport = new Viewport();
      var profilerScissor = new Rect$1();
      function SRGBToLinear(out, gamma) {
        out.x = gamma.x * gamma.x;
        out.y = gamma.y * gamma.y;
        out.z = gamma.z * gamma.z;
      }
      var profilerCamera = null;
      function decideProfilerCamera(cameras) {
        for (var i = cameras.length - 1; i >= 0; --i) {
          var camera = cameras[i];

          if (camera.window.swapchain) {
            profilerCamera = camera;
            return;
          }
        }

        profilerCamera = null;
      }
      function renderProfiler(device, renderPass, cmdBuff, profiler, camera) {
        if (profiler && profiler.enabled && camera === profilerCamera) {
          var _profiler$subModels$ = profiler.subModels[0],
              inputAssembler = _profiler$subModels$.inputAssembler,
              passes = _profiler$subModels$.passes,
              shaders = _profiler$subModels$.shaders,
              descriptorSet = _profiler$subModels$.descriptorSet;
          profilerViewport.width = profilerScissor.width = camera.window.width;
          profilerViewport.height = profilerScissor.height = camera.window.height;
          var pso = PipelineStateManager.getOrCreatePipelineState(device, passes[0], shaders[0], renderPass, inputAssembler);
          cmdBuff.setViewport(profilerViewport);
          cmdBuff.setScissor(profilerScissor);
          cmdBuff.bindPipelineState(pso);
          cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, passes[0].descriptorSet);
          cmdBuff.bindDescriptorSet(SetIndex.LOCAL, descriptorSet);
          cmdBuff.bindInputAssembler(inputAssembler);
          cmdBuff.draw(inputAssembler);
        }
      }

      var _dec$d, _dec2$5, _class$d, _class2$b, _descriptor$9, _descriptor2$6, _descriptor3$5, _descriptor4$4, _descriptor5$2, _temp$b;
      var v4_1 = new Vec4();
      var Material = exports('Material', (_dec$d = ccclass('cc.Material'), _dec2$5 = type(EffectAsset), _dec$d(_class$d = (_class2$b = (_temp$b = function (_Asset) {
        _inheritsLoose(Material, _Asset);

        Material.getHash = function getHash(material) {
          var hash = 0;

          for (var _iterator = _createForOfIteratorHelperLoose(material.passes), _step; !(_step = _iterator()).done;) {
            var pass = _step.value;
            hash ^= pass.hash;
          }

          return hash;
        };

        function Material() {
          var _this;

          _this = _Asset.call(this) || this;

          _initializerDefineProperty(_this, "_effectAsset", _descriptor$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_techIdx", _descriptor2$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_defines", _descriptor3$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_states", _descriptor4$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_props", _descriptor5$2, _assertThisInitialized(_this));

          _this._passes = [];
          _this._hash = 0;
          return _this;
        }

        var _proto = Material.prototype;

        _proto.initialize = function initialize(info) {
          if (this._passes.length) {
            warnID(12005);
            return;
          }

          if (!this._defines) {
            this._defines = [];
          }

          if (!this._states) {
            this._states = [];
          }

          if (!this._props) {
            this._props = [];
          }

          this._fillInfo(info);

          this._update();
        };

        _proto.reset = function reset(info) {
          this.initialize(info);
        };

        _proto.destroy = function destroy() {
          this._doDestroy();

          return _Asset.prototype.destroy.call(this);
        };

        _proto.recompileShaders = function recompileShaders(overrides, passIdx) {
          console.warn("Shaders in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.");
        };

        _proto.overridePipelineStates = function overridePipelineStates(overrides, passIdx) {
          console.warn("Pipeline states in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.");
        };

        _proto.onLoaded = function onLoaded() {
          this._update();
        };

        _proto.resetUniforms = function resetUniforms(clearPasses) {
          if (clearPasses === void 0) {
            clearPasses = true;
          }

          this._props.length = this._passes.length;

          for (var i = 0; i < this._props.length; i++) {
            this._props[i] = {};
          }

          if (!clearPasses) {
            return;
          }

          for (var _iterator2 = _createForOfIteratorHelperLoose(this._passes), _step2; !(_step2 = _iterator2()).done;) {
            var pass = _step2.value;
            pass.resetUBOs();
            pass.resetTextures();
          }
        };

        _proto.setProperty = function setProperty(name, val, passIdx) {
          var success = false;

          if (passIdx === undefined) {
            var passes = this._passes;
            var len = passes.length;

            for (var i = 0; i < len; i++) {
              var pass = passes[i];

              if (this._uploadProperty(pass, name, val)) {
                this._props[pass.propertyIndex][name] = val;
                success = true;
              }
            }
          } else {
            if (passIdx >= this._passes.length) {
              console.warn("illegal pass index: " + passIdx + ".");
              return;
            }

            var _pass = this._passes[passIdx];

            if (this._uploadProperty(_pass, name, val)) {
              this._props[_pass.propertyIndex][name] = val;
              success = true;
            }
          }

          if (!success) {
            console.warn("illegal property name: " + name + ".");
          }
        };

        _proto.getProperty = function getProperty(name, passIdx) {
          if (passIdx === undefined) {
            var propsArray = this._props;
            var len = propsArray.length;

            for (var i = 0; i < len; i++) {
              var props = propsArray[i];

              if (name in props) {
                return props[name];
              }
            }
          } else {
            if (passIdx >= this._props.length) {
              console.warn("illegal pass index: " + passIdx + ".");
              return null;
            }

            var _props = this._props[this._passes[passIdx].propertyIndex];

            if (name in _props) {
              return _props[name];
            }
          }

          return null;
        };

        _proto.copy = function copy(mat, overrides) {
          this._techIdx = mat._techIdx;
          this._props.length = mat._props.length;

          for (var i = 0; i < mat._props.length; i++) {
            this._props[i] = _extends({}, mat._props[i]);
          }

          this._defines.length = mat._defines.length;

          for (var _i = 0; _i < mat._defines.length; _i++) {
            this._defines[_i] = _extends({}, mat._defines[_i]);
          }

          this._states.length = mat._states.length;

          for (var _i2 = 0; _i2 < mat._states.length; _i2++) {
            this._states[_i2] = _extends({}, mat._states[_i2]);
          }

          this._effectAsset = mat._effectAsset;
          if (overrides) this._fillInfo(overrides);

          this._update();
        };

        _proto._fillInfo = function _fillInfo(info) {
          if (info.technique !== undefined) {
            this._techIdx = info.technique;
          }

          if (info.effectAsset) {
            this._effectAsset = info.effectAsset;
          } else if (info.effectName) {
            this._effectAsset = EffectAsset.get(info.effectName);
          }

          if (info.defines) {
            this._prepareInfo(info.defines, this._defines);
          }

          if (info.states) {
            this._prepareInfo(info.states, this._states);
          }
        };

        _proto._prepareInfo = function _prepareInfo(patch, cur) {
          var patchArray = patch;

          if (!Array.isArray(patchArray)) {
            var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
            patchArray = Array(len).fill(patchArray);
          }

          for (var i = 0; i < patchArray.length; ++i) {
            Object.assign(cur[i] || (cur[i] = {}), patchArray[i]);
          }
        };

        _proto._createPasses = function _createPasses() {
          var tech = this._effectAsset.techniques[this._techIdx || 0];

          if (!tech) {
            return [];
          }

          var passNum = tech.passes.length;
          var passes = [];

          for (var k = 0; k < passNum; ++k) {
            var passInfo = tech.passes[k];
            var propIdx = passInfo.passIndex = k;
            var defines = passInfo.defines = this._defines[propIdx] || (this._defines[propIdx] = {});
            passInfo.stateOverrides = this._states[propIdx] || (this._states[propIdx] = {});

            if (passInfo.propertyIndex !== undefined) {
              Object.assign(defines, this._defines[passInfo.propertyIndex]);
            }

            if (passInfo.embeddedMacros !== undefined) {
              Object.assign(defines, passInfo.embeddedMacros);
            }

            if (passInfo["switch"] && !defines[passInfo["switch"]]) {
              continue;
            }

            var pass = new Pass(legacyCC.director.root);
            pass.initialize(passInfo);
            passes.push(pass);
          }

          return passes;
        };

        _proto._update = function _update(keepProps) {
          var _this2 = this;

          if (keepProps === void 0) {
            keepProps = true;
          }

          if (this._effectAsset) {
            this._passes = this._createPasses();
            var totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
            this._props.length = totalPasses;

            if (keepProps) {
              this._passes.forEach(function (pass, i) {
                var props = _this2._props[i];

                if (!props) {
                  props = _this2._props[i] = {};
                }

                if (pass.propertyIndex !== undefined) {
                  Object.assign(props, _this2._props[pass.propertyIndex]);
                }

                for (var p in props) {
                  _this2._uploadProperty(pass, p, props[p]);
                }
              });
            } else {
              for (var i = 0; i < this._props.length; i++) {
                this._props[i] = {};
              }
            }
          }

          this._hash = Material.getHash(this);
        };

        _proto._uploadProperty = function _uploadProperty(pass, name, val) {
          var handle = pass.getHandle(name);

          if (!handle) {
            return false;
          }

          var type = Pass.getTypeFromHandle(handle);

          if (type < Type.SAMPLER1D) {
            if (Array.isArray(val)) {
              pass.setUniformArray(handle, val);
            } else if (val !== null) {
              var _pass$properties$name;

              if ((_pass$properties$name = pass.properties[name]) === null || _pass$properties$name === void 0 ? void 0 : _pass$properties$name.linear) {
                var v4 = val;
                SRGBToLinear(v4_1, v4);
                v4_1.w = v4.w;
                val = v4_1;
              }

              pass.setUniform(handle, val);
            } else {
              pass.resetUniform(name);
            }
          } else if (Array.isArray(val)) {
            for (var i = 0; i < val.length; i++) {
              this._bindTexture(pass, handle, val[i], i);
            }
          } else if (val) {
            this._bindTexture(pass, handle, val);
          } else {
            pass.resetTexture(name);
          }

          return true;
        };

        _proto._bindTexture = function _bindTexture(pass, handle, val, index) {
          var binding = Pass.getBindingFromHandle(handle);

          if (val instanceof Texture) {
            pass.bindTexture(binding, val, index);
          } else if (val instanceof TextureBase) {
            var texture = val.getGFXTexture();

            if (!texture || !texture.width || !texture.height) {
              return;
            }

            pass.bindTexture(binding, texture, index);
            pass.bindSampler(binding, val.getGFXSampler(), index);
          }
        };

        _proto._doDestroy = function _doDestroy() {
          if (this._passes && this._passes.length) {
            for (var _iterator3 = _createForOfIteratorHelperLoose(this._passes), _step3; !(_step3 = _iterator3()).done;) {
              var pass = _step3.value;
              pass.destroy();
            }
          }

          this._passes.length = 0;
        };

        _proto.initDefault = function initDefault(uuid) {
          _Asset.prototype.initDefault.call(this, uuid);

          this.initialize({
            effectName: 'unlit',
            defines: {
              USE_COLOR: true
            },
            technique: 0
          });
          this.setProperty('mainColor', new Color('#ff00ff'));
        };

        _proto.validate = function validate() {
          return !!this._effectAsset && !this._effectAsset.isDefault && this.passes.length > 0;
        };

        _createClass(Material, [{
          key: "effectAsset",
          get: function get() {
            return this._effectAsset;
          }
        }, {
          key: "effectName",
          get: function get() {
            return this._effectAsset ? this._effectAsset.name : '';
          }
        }, {
          key: "technique",
          get: function get() {
            return this._techIdx;
          }
        }, {
          key: "passes",
          get: function get() {
            return this._passes;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }, {
          key: "parent",
          get: function get() {
            return null;
          }
        }, {
          key: "owner",
          get: function get() {
            return null;
          }
        }]);

        return Material;
      }(Asset), _temp$b), (_descriptor$9 = _applyDecoratedDescriptor(_class2$b.prototype, "_effectAsset", [_dec2$5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$b.prototype, "_techIdx", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor3$5 = _applyDecoratedDescriptor(_class2$b.prototype, "_defines", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$b.prototype, "_states", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$b.prototype, "_props", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$b)) || _class$d));
      legacyCC.Material = Material;

      var CameraFOVAxis;

      (function (CameraFOVAxis) {
        CameraFOVAxis[CameraFOVAxis["VERTICAL"] = 0] = "VERTICAL";
        CameraFOVAxis[CameraFOVAxis["HORIZONTAL"] = 1] = "HORIZONTAL";
      })(CameraFOVAxis || (CameraFOVAxis = {}));

      var CameraProjection;

      (function (CameraProjection) {
        CameraProjection[CameraProjection["ORTHO"] = 0] = "ORTHO";
        CameraProjection[CameraProjection["PERSPECTIVE"] = 1] = "PERSPECTIVE";
      })(CameraProjection || (CameraProjection = {}));

      var CameraAperture;

      (function (CameraAperture) {
        CameraAperture[CameraAperture["F1_8"] = 0] = "F1_8";
        CameraAperture[CameraAperture["F2_0"] = 1] = "F2_0";
        CameraAperture[CameraAperture["F2_2"] = 2] = "F2_2";
        CameraAperture[CameraAperture["F2_5"] = 3] = "F2_5";
        CameraAperture[CameraAperture["F2_8"] = 4] = "F2_8";
        CameraAperture[CameraAperture["F3_2"] = 5] = "F3_2";
        CameraAperture[CameraAperture["F3_5"] = 6] = "F3_5";
        CameraAperture[CameraAperture["F4_0"] = 7] = "F4_0";
        CameraAperture[CameraAperture["F4_5"] = 8] = "F4_5";
        CameraAperture[CameraAperture["F5_0"] = 9] = "F5_0";
        CameraAperture[CameraAperture["F5_6"] = 10] = "F5_6";
        CameraAperture[CameraAperture["F6_3"] = 11] = "F6_3";
        CameraAperture[CameraAperture["F7_1"] = 12] = "F7_1";
        CameraAperture[CameraAperture["F8_0"] = 13] = "F8_0";
        CameraAperture[CameraAperture["F9_0"] = 14] = "F9_0";
        CameraAperture[CameraAperture["F10_0"] = 15] = "F10_0";
        CameraAperture[CameraAperture["F11_0"] = 16] = "F11_0";
        CameraAperture[CameraAperture["F13_0"] = 17] = "F13_0";
        CameraAperture[CameraAperture["F14_0"] = 18] = "F14_0";
        CameraAperture[CameraAperture["F16_0"] = 19] = "F16_0";
        CameraAperture[CameraAperture["F18_0"] = 20] = "F18_0";
        CameraAperture[CameraAperture["F20_0"] = 21] = "F20_0";
        CameraAperture[CameraAperture["F22_0"] = 22] = "F22_0";
      })(CameraAperture || (CameraAperture = {}));

      var CameraISO;

      (function (CameraISO) {
        CameraISO[CameraISO["ISO100"] = 0] = "ISO100";
        CameraISO[CameraISO["ISO200"] = 1] = "ISO200";
        CameraISO[CameraISO["ISO400"] = 2] = "ISO400";
        CameraISO[CameraISO["ISO800"] = 3] = "ISO800";
      })(CameraISO || (CameraISO = {}));

      var CameraShutter;

      (function (CameraShutter) {
        CameraShutter[CameraShutter["D1"] = 0] = "D1";
        CameraShutter[CameraShutter["D2"] = 1] = "D2";
        CameraShutter[CameraShutter["D4"] = 2] = "D4";
        CameraShutter[CameraShutter["D8"] = 3] = "D8";
        CameraShutter[CameraShutter["D15"] = 4] = "D15";
        CameraShutter[CameraShutter["D30"] = 5] = "D30";
        CameraShutter[CameraShutter["D60"] = 6] = "D60";
        CameraShutter[CameraShutter["D125"] = 7] = "D125";
        CameraShutter[CameraShutter["D250"] = 8] = "D250";
        CameraShutter[CameraShutter["D500"] = 9] = "D500";
        CameraShutter[CameraShutter["D1000"] = 10] = "D1000";
        CameraShutter[CameraShutter["D2000"] = 11] = "D2000";
        CameraShutter[CameraShutter["D4000"] = 12] = "D4000";
      })(CameraShutter || (CameraShutter = {}));

      var FSTOPS = [1.8, 2.0, 2.2, 2.5, 2.8, 3.2, 3.5, 4.0, 4.5, 5.0, 5.6, 6.3, 7.1, 8.0, 9.0, 10.0, 11.0, 13.0, 14.0, 16.0, 18.0, 20.0, 22.0];
      var SHUTTERS = [1.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 15.0, 1.0 / 30.0, 1.0 / 60.0, 1.0 / 125.0, 1.0 / 250.0, 1.0 / 500.0, 1.0 / 1000.0, 1.0 / 2000.0, 1.0 / 4000.0];
      var ISOS = [100.0, 200.0, 400.0, 800.0];
      var v_a = new Vec3();
      var v_b = new Vec3();

      var _tempMat1 = new Mat4();

      var SKYBOX_FLAG = ClearFlagBit.STENCIL << 1;
      var correctionMatrices = [];
      var Camera = function () {
        function Camera(device) {
          this.isWindowSize = true;
          this.screenScale = void 0;
          this._device = void 0;
          this._scene = null;
          this._node = null;
          this._name = null;
          this._enabled = false;
          this._proj = -1;
          this._aspect = void 0;
          this._orthoHeight = 10.0;
          this._fovAxis = CameraFOVAxis.VERTICAL;
          this._fov = toRadian(45);
          this._nearClip = 1.0;
          this._farClip = 1000.0;
          this._clearColor = new Color$1(0.2, 0.2, 0.2, 1);
          this._viewport = new Rect(0, 0, 1, 1);
          this._orientedViewport = new Rect(0, 0, 1, 1);
          this._curTransform = SurfaceTransform.IDENTITY;
          this._isProjDirty = true;
          this._matView = new Mat4();
          this._matProj = new Mat4();
          this._matProjInv = new Mat4();
          this._matViewProj = new Mat4();
          this._matViewProjInv = new Mat4();
          this._frustum = new Frustum();
          this._forward = new Vec3();
          this._position = new Vec3();
          this._priority = 0;
          this._aperture = CameraAperture.F16_0;
          this._apertureValue = void 0;
          this._shutter = CameraShutter.D125;
          this._shutterValue = 0.0;
          this._iso = CameraISO.ISO100;
          this._isoValue = 0.0;
          this._window = null;
          this._width = 1;
          this._height = 1;
          this._clearFlag = ClearFlagBit.NONE;
          this._clearDepth = 1.0;
          this._visibility = CAMERA_DEFAULT_MASK;
          this._exposure = 0;
          this._clearStencil = 0;
          this._device = device;
          this._apertureValue = FSTOPS[this._aperture];
          this._shutterValue = SHUTTERS[this._shutter];
          this._isoValue = ISOS[this._iso];
          this._aspect = this.screenScale = 1;
          this._frustum.accurate = true;

          if (!correctionMatrices.length) {
            var ySign = device.capabilities.clipSpaceSignY;
            correctionMatrices[SurfaceTransform.IDENTITY] = new Mat4(1, 0, 0, 0, 0, ySign);
            correctionMatrices[SurfaceTransform.ROTATE_90] = new Mat4(0, 1, 0, 0, -ySign, 0);
            correctionMatrices[SurfaceTransform.ROTATE_180] = new Mat4(-1, 0, 0, 0, 0, -ySign);
            correctionMatrices[SurfaceTransform.ROTATE_270] = new Mat4(0, -1, 0, 0, ySign, 0);
          }
        }

        var _proto = Camera.prototype;

        _proto._setWidth = function _setWidth(val) {
          this._width = val;
        };

        _proto._setHeight = function _setHeight(val) {
          this._height = val;
        };

        _proto._setScene = function _setScene(scene) {
          this._scene = scene;
        };

        _proto._updateAspect = function _updateAspect(oriented) {
          if (oriented === void 0) {
            oriented = true;
          }

          this._aspect = this.window.width * this._viewport.width / (this.window.height * this._viewport.height);

          if (oriented) {
            var swapchain = this.window.swapchain;
            var orientation = swapchain && swapchain.surfaceTransform || SurfaceTransform.IDENTITY;
            if (orientation % 2) this._aspect = 1 / this._aspect;
          }

          this._isProjDirty = true;
        };

        _proto._init = function _init(info) {
        };

        _proto._destroy = function _destroy() {
        };

        _proto.initialize = function initialize(info) {
          this._init(info);

          this.node = info.node;

          this._setWidth(1);

          this._setHeight(1);

          this.clearFlag = ClearFlagBit.NONE;
          this.clearDepth = 1.0;
          this.visibility = CAMERA_DEFAULT_MASK;
          this._name = info.name;
          this._proj = info.projection;
          this._priority = info.priority || 0;
          this._aspect = this.screenScale = 1;
          this.updateExposure();
          this.changeTargetWindow(info.window);
        };

        _proto.destroy = function destroy() {
          this._node = null;
          this.detachFromScene();

          if (this._window) {
            this._window.detachCamera(this);

            this.window = null;
          }

          this._name = null;

          this._destroy();
        };

        _proto.attachToScene = function attachToScene(scene) {
          this._enabled = true;

          this._setScene(scene);
        };

        _proto.detachFromScene = function detachFromScene() {
          this._enabled = false;

          this._setScene(null);
        };

        _proto.resize = function resize(width, height) {
          if (!this._window) return;

          this._setWidth(width);

          this._setHeight(height);

          this._updateAspect();
        };

        _proto.setFixedSize = function setFixedSize(width, height) {
          this._setWidth(width);

          this._setHeight(height);

          this._updateAspect(false);

          this.isWindowSize = false;
        };

        _proto.syncCameraEditor = function syncCameraEditor(camera) {
        };

        _proto.update = function update(forceUpdate) {
          var _this$window;

          if (forceUpdate === void 0) {
            forceUpdate = false;
          }

          if (!this._node) return;
          var viewProjDirty = false;

          if (this._node.hasChangedFlags || forceUpdate) {
            Mat4.invert(this._matView, this._node.worldMatrix);

            this._forward.x = -this._matView.m02;
            this._forward.y = -this._matView.m06;
            this._forward.z = -this._matView.m10;

            this._node.getWorldPosition(this._position);

            viewProjDirty = true;
          }

          var swapchain = (_this$window = this.window) === null || _this$window === void 0 ? void 0 : _this$window.swapchain;
          var orientation = swapchain && swapchain.surfaceTransform || SurfaceTransform.IDENTITY;

          if (this._isProjDirty || this._curTransform !== orientation) {
            this._curTransform = orientation;
            var projectionSignY = this._device.capabilities.clipSpaceSignY;

            if (this._proj === CameraProjection.PERSPECTIVE) {
              Mat4.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip, this._fovAxis === CameraFOVAxis.VERTICAL, this._device.capabilities.clipSpaceMinZ, projectionSignY, orientation);
            } else {
              var x = this._orthoHeight * this._aspect;
              var y = this._orthoHeight;
              Mat4.ortho(this._matProj, -x, x, -y, y, this._nearClip, this._farClip, this._device.capabilities.clipSpaceMinZ, projectionSignY, orientation);
            }

            Mat4.invert(this._matProjInv, this._matProj);

            viewProjDirty = true;
            this._isProjDirty = false;
          }

          if (viewProjDirty) {
            Mat4.multiply(this._matViewProj, this._matProj, this._matView);
            Mat4.invert(this._matViewProjInv, this._matViewProj);

            this._frustum.update(this._matViewProj, this._matViewProjInv);
          }
        };

        _proto.setViewportInOrientedSpace = function setViewportInOrientedSpace(val) {
          var _this$window2;

          var x = val.x,
              width = val.width,
              height = val.height;
          var y = this._device.capabilities.screenSpaceSignY < 0 ? 1 - val.y - height : val.y;
          var swapchain = (_this$window2 = this.window) === null || _this$window2 === void 0 ? void 0 : _this$window2.swapchain;
          var orientation = swapchain && swapchain.surfaceTransform || SurfaceTransform.IDENTITY;

          switch (orientation) {
            case SurfaceTransform.ROTATE_90:
              this._viewport.x = 1 - y - height;
              this._viewport.y = x;
              this._viewport.width = height;
              this._viewport.height = width;
              break;

            case SurfaceTransform.ROTATE_180:
              this._viewport.x = 1 - x - width;
              this._viewport.y = 1 - y - height;
              this._viewport.width = width;
              this._viewport.height = height;
              break;

            case SurfaceTransform.ROTATE_270:
              this._viewport.x = y;
              this._viewport.y = 1 - x - width;
              this._viewport.width = height;
              this._viewport.height = width;
              break;

            case SurfaceTransform.IDENTITY:
              this._viewport.x = x;
              this._viewport.y = y;
              this._viewport.width = width;
              this._viewport.height = height;
              break;
          }

          this._orientedViewport.x = x;
          this._orientedViewport.y = y;
          this._orientedViewport.width = width;
          this._orientedViewport.height = height;

          this.resize(this.width, this.height);
        };

        _proto.changeTargetWindow = function changeTargetWindow(window) {
          if (window === void 0) {
            window = null;
          }

          if (this._window) {
            this._window.detachCamera(this);
          }

          var win = window || legacyCC.director.root.mainWindow;

          if (win) {
            win.attachCamera(this);
            this.window = win;
            var swapchain = win.swapchain;
            var orientation = swapchain && swapchain.surfaceTransform || SurfaceTransform.IDENTITY;
            if (orientation % 2) this.resize(win.height, win.width);else this.resize(win.width, win.height);
          }
        };

        _proto.detachCamera = function detachCamera() {
          if (this._window) {
            this._window.detachCamera(this);
          }
        };

        _proto.screenPointToRay = function screenPointToRay(out, x, y) {
          if (!this._node) return null;
          var width = this.width;
          var height = this.height;
          var cx = this._orientedViewport.x * width;
          var cy = this._orientedViewport.y * height;
          var cw = this._orientedViewport.width * width;
          var ch = this._orientedViewport.height * height;
          var isProj = this._proj === CameraProjection.PERSPECTIVE;
          var ySign = this._device.capabilities.clipSpaceSignY;
          var preTransform = preTransforms[this._curTransform];
          Vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, isProj ? 1 : -1);
          var ox = v_a.x,
              oy = v_a.y;
          v_a.x = ox * preTransform[0] + oy * preTransform[2] * ySign;
          v_a.y = ox * preTransform[1] + oy * preTransform[3] * ySign;
          Vec3.transformMat4(isProj ? v_a : out.o, v_a, this._matViewProjInv);

          if (isProj) {
            this._node.getWorldPosition(v_b);

            Ray.fromPoints(out, v_b, v_a);
          } else {
            Vec3.transformQuat(out.d, Vec3.FORWARD, this._node.worldRotation);
          }

          return out;
        };

        _proto.screenToWorld = function screenToWorld(out, screenPos) {
          var width = this.width;
          var height = this.height;
          var cx = this._orientedViewport.x * width;
          var cy = this._orientedViewport.y * height;
          var cw = this._orientedViewport.width * width;
          var ch = this._orientedViewport.height * height;
          var ySign = this._device.capabilities.clipSpaceSignY;
          var preTransform = preTransforms[this._curTransform];

          if (this._proj === CameraProjection.PERSPECTIVE) {
            Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1.0);
            var x = out.x,
                y = out.y;
            out.x = x * preTransform[0] + y * preTransform[2] * ySign;
            out.y = x * preTransform[1] + y * preTransform[3] * ySign;
            Vec3.transformMat4(out, out, this._matViewProjInv);

            if (this._node) {
              this._node.getWorldPosition(v_a);
            }

            Vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z));
          } else {
            Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, screenPos.z * 2 - 1);
            var _x = out.x,
                _y = out.y;
            out.x = _x * preTransform[0] + _y * preTransform[2] * ySign;
            out.y = _x * preTransform[1] + _y * preTransform[3] * ySign;
            Vec3.transformMat4(out, out, this._matViewProjInv);
          }

          return out;
        };

        _proto.worldToScreen = function worldToScreen(out, worldPos) {
          var ySign = this._device.capabilities.clipSpaceSignY;
          var preTransform = preTransforms[this._curTransform];
          Vec3.transformMat4(out, worldPos, this._matViewProj);
          var x = out.x,
              y = out.y;
          out.x = x * preTransform[0] + y * preTransform[2] * ySign;
          out.y = x * preTransform[1] + y * preTransform[3] * ySign;
          var width = this.width;
          var height = this.height;
          var cx = this._orientedViewport.x * width;
          var cy = this._orientedViewport.y * height;
          var cw = this._orientedViewport.width * width;
          var ch = this._orientedViewport.height * height;
          out.x = cx + (out.x + 1) * 0.5 * cw;
          out.y = cy + (out.y + 1) * 0.5 * ch;
          out.z = out.z * 0.5 + 0.5;
          return out;
        };

        _proto.worldMatrixToScreen = function worldMatrixToScreen(out, worldMatrix, width, height) {
          Mat4.multiply(out, this._matViewProj, worldMatrix);
          Mat4.multiply(out, correctionMatrices[this._curTransform], out);
          var halfWidth = width / 2;
          var halfHeight = height / 2;
          Mat4.identity(_tempMat1);
          Mat4.transform(_tempMat1, _tempMat1, Vec3.set(v_a, halfWidth, halfHeight, 0));
          Mat4.scale(_tempMat1, _tempMat1, Vec3.set(v_a, halfWidth, halfHeight, 1));
          Mat4.multiply(out, _tempMat1, out);
          return out;
        };

        _proto.setExposure = function setExposure(ev100) {
          this._exposure = 0.833333 / Math.pow(2.0, ev100);
        };

        _proto.updateExposure = function updateExposure() {
          var ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100.0 / this._isoValue);
          this.setExposure(ev100);
        };

        _createClass(Camera, [{
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "scene",
          get: function get() {
            return this._scene;
          }
        }, {
          key: "node",
          get: function get() {
            return this._node;
          },
          set: function set(val) {
            this._node = val;
          }
        }, {
          key: "window",
          get: function get() {
            return this._window;
          },
          set: function set(val) {
            this._window = val;
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            this._enabled = val;
          }
        }, {
          key: "visibility",
          get: function get() {
            return this._visibility;
          },
          set: function set(vis) {
            this._visibility = vis;
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(val) {
            this._priority = val;
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          }
        }, {
          key: "position",
          get: function get() {
            return this._position;
          },
          set: function set(val) {
            this._position = val;
          }
        }, {
          key: "forward",
          get: function get() {
            return this._forward;
          },
          set: function set(val) {
            this._forward = val;
          }
        }, {
          key: "aperture",
          get: function get() {
            return this._aperture;
          },
          set: function set(val) {
            this._aperture = val;
            this._apertureValue = FSTOPS[this._aperture];
            this.updateExposure();
          }
        }, {
          key: "apertureValue",
          get: function get() {
            return this._apertureValue;
          }
        }, {
          key: "shutter",
          get: function get() {
            return this._shutter;
          },
          set: function set(val) {
            this._shutter = val;
            this._shutterValue = SHUTTERS[this._shutter];
            this.updateExposure();
          }
        }, {
          key: "shutterValue",
          get: function get() {
            return this._shutterValue;
          }
        }, {
          key: "iso",
          get: function get() {
            return this._iso;
          },
          set: function set(val) {
            this._iso = val;
            this._isoValue = ISOS[this._iso];
            this.updateExposure();
          }
        }, {
          key: "isoValue",
          get: function get() {
            return this._isoValue;
          }
        }, {
          key: "exposure",
          get: function get() {
            return this._exposure;
          }
        }, {
          key: "clearFlag",
          get: function get() {
            return this._clearFlag;
          },
          set: function set(flag) {
            this._clearFlag = flag;
          }
        }, {
          key: "clearColor",
          get: function get() {
            return this._clearColor;
          },
          set: function set(val) {
            this._clearColor.x = val.x;
            this._clearColor.y = val.y;
            this._clearColor.z = val.z;
            this._clearColor.w = val.w;
          }
        }, {
          key: "clearDepth",
          get: function get() {
            return this._clearDepth;
          },
          set: function set(depth) {
            this._clearDepth = depth;
          }
        }, {
          key: "clearStencil",
          get: function get() {
            return this._clearStencil;
          },
          set: function set(stencil) {
            this._clearStencil = stencil;
          }
        }, {
          key: "projectionType",
          get: function get() {
            return this._proj;
          },
          set: function set(val) {
            this._proj = val;
            this._isProjDirty = true;
          }
        }, {
          key: "aspect",
          get: function get() {
            return this._aspect;
          }
        }, {
          key: "orthoHeight",
          get: function get() {
            return this._orthoHeight;
          },
          set: function set(val) {
            this._orthoHeight = val;
            this._isProjDirty = true;
          }
        }, {
          key: "fovAxis",
          get: function get() {
            return this._fovAxis;
          },
          set: function set(axis) {
            this._fovAxis = axis;
            this._isProjDirty = true;
          }
        }, {
          key: "fov",
          get: function get() {
            return this._fov;
          },
          set: function set(fov) {
            this._fov = fov;

            this._isProjDirty = true;
          }
        }, {
          key: "nearClip",
          get: function get() {
            return this._nearClip;
          },
          set: function set(nearClip) {
            this._nearClip = nearClip;

            this._isProjDirty = true;
          }
        }, {
          key: "farClip",
          get: function get() {
            return this._farClip;
          },
          set: function set(farClip) {
            this._farClip = farClip;

            this._isProjDirty = true;
          }
        }, {
          key: "viewport",
          get: function get() {
            return this._viewport;
          },
          set: function set(val) {
            warnID(8302);
            this.setViewportInOrientedSpace(val);
          }
        }, {
          key: "frustum",
          get: function get() {
            return this._frustum;
          },
          set: function set(val) {
            this._frustum = val;
          }
        }, {
          key: "matView",
          get: function get() {
            return this._matView;
          }
        }, {
          key: "matProj",
          get: function get() {
            return this._matProj;
          }
        }, {
          key: "matProjInv",
          get: function get() {
            return this._matProjInv;
          }
        }, {
          key: "matViewProj",
          get: function get() {
            return this._matViewProj;
          }
        }, {
          key: "matViewProjInv",
          get: function get() {
            return this._matViewProjInv;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }], [{
          key: "standardExposureValue",
          get: function get() {
            return 1.0 / 38400.0;
          }
        }, {
          key: "standardLightMeterScale",
          get: function get() {
            return 10000.0;
          }
        }]);

        return Camera;
      }();

      var ShadowSize = Enum({
        Low_256x256: 256,
        Medium_512x512: 512,
        High_1024x1024: 1024,
        Ultra_2048x2048: 2048
      });
      var ShadowType = Enum({
        Planar: 0,
        ShadowMap: 1
      });
      var PCFType = Enum({
        HARD: 0,
        SOFT: 1,
        SOFT_2X: 2
      });
      var SHADOW_TYPE_NONE = ShadowType.ShadowMap + 1;
      var Shadows = function () {
        function Shadows() {
          this.fixedSphere = new Sphere(0.0, 0.0, 0.0, 0.01);
          this.maxReceived = 4;
          this.firstSetCSM = false;
          this.shadowCameraFar = 0;
          this.matShadowView = new Mat4();
          this.matShadowProj = new Mat4();
          this.matShadowViewProj = new Mat4();
          this._enabled = false;
          this._type = SHADOW_TYPE_NONE;
          this._distance = 0;
          this._normal = new Vec3(0, 1, 0);
          this._shadowColor = new Color(0, 0, 0, 76);
          this._size = new Vec2(512, 512);
          this._shadowMapDirty = false;
          this._matLight = new Mat4();
          this._material = null;
          this._instancingMaterial = null;
        }

        var _proto = Shadows.prototype;

        _proto.getPlanarShader = function getPlanarShader(patches) {
          if (!this._material) {
            this._material = new Material();

            this._material.initialize({
              effectName: 'planar-shadow'
            });
          }

          return this._material.passes[0].getShaderVariant(patches);
        };

        _proto.getPlanarInstanceShader = function getPlanarInstanceShader(patches) {
          if (!this._instancingMaterial) {
            this._instancingMaterial = new Material();

            this._instancingMaterial.initialize({
              effectName: 'planar-shadow',
              defines: {
                USE_INSTANCING: true
              }
            });
          }

          return this._instancingMaterial.passes[0].getShaderVariant(patches);
        };

        _proto._setEnable = function _setEnable(val) {
          this._enabled = val;
        };

        _proto._setType = function _setType(val) {
          this._type = this.enabled ? val : SHADOW_TYPE_NONE;
        };

        _proto.initialize = function initialize(shadowsInfo) {
          this._setEnable(shadowsInfo.enabled);

          this._setType(shadowsInfo.type);

          this.normal = shadowsInfo.planeDirection;
          this.distance = shadowsInfo.planeHeight;
          this.shadowColor = shadowsInfo.shadowColor;
          this.maxReceived = shadowsInfo.maxReceived;
          this.size = shadowsInfo.size;
        };

        _proto.activate = function activate() {
          if (this.enabled) {
            if (this.type === ShadowType.Planar) {
              this._updatePlanarInfo();
            }
          }
        };

        _proto._updatePlanarInfo = function _updatePlanarInfo() {
          if (!this._material) {
            this._material = new Material();

            this._material.initialize({
              effectName: 'planar-shadow'
            });
          }

          if (!this._instancingMaterial) {
            this._instancingMaterial = new Material();

            this._instancingMaterial.initialize({
              effectName: 'planar-shadow',
              defines: {
                USE_INSTANCING: true
              }
            });
          }
        };

        _proto._destroy = function _destroy() {
        };

        _proto.destroy = function destroy() {
          this._destroy();

          if (this._material) {
            this._material.destroy();
          }

          if (this._instancingMaterial) {
            this._instancingMaterial.destroy();
          }

          this.fixedSphere.destroy();
        };

        _createClass(Shadows, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            this._setEnable(val);

            this.activate();
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(val) {
            this._setType(val);

            this.activate();
          }
        }, {
          key: "normal",
          get: function get() {
            return this._normal;
          },
          set: function set(val) {
            Vec3.copy(this._normal, val);
          }
        }, {
          key: "distance",
          get: function get() {
            return this._distance;
          },
          set: function set(val) {
            this._distance = val;
          }
        }, {
          key: "shadowColor",
          get: function get() {
            return this._shadowColor;
          },
          set: function set(color) {
            this._shadowColor = color;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(val) {
            this._size.set(val);
          }
        }, {
          key: "shadowMapDirty",
          get: function get() {
            return this._shadowMapDirty;
          },
          set: function set(val) {
            this._shadowMapDirty = val;
          }
        }, {
          key: "matLight",
          get: function get() {
            return this._matLight;
          }
        }, {
          key: "material",
          get: function get() {
            return this._material;
          }
        }, {
          key: "instancingMaterial",
          get: function get() {
            return this._instancingMaterial;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return Shadows;
      }();
      Shadows.MAX_FAR = 2000.0;
      Shadows.COEFFICIENT_OF_EXPANSION = 2.0 * Math.sqrt(3.0);
      legacyCC.Shadows = Shadows;

      var _tempVec3 = new Vec3();

      var _dir_negate = new Vec3();

      var _vec3_p = new Vec3();

      var _shadowPos = new Vec3();

      var _mat4_trans = new Mat4();

      var _castLightViewBounds = new AABB();

      var _castWorldBounds = new AABB();

      var _castBoundsInited = false;

      var _sphere = Sphere.create(0, 0, 0, 1);

      var _cameraBoundingSphere = new Sphere();

      var _validFrustum = new Frustum();

      _validFrustum.accurate = true;

      var _lightViewFrustum = new Frustum();

      _lightViewFrustum.accurate = true;

      var _dirLightFrustum = new Frustum();

      var _matShadowTrans = new Mat4();

      var _matShadowView = new Mat4();

      var _matShadowViewInv = new Mat4();

      var _matShadowProj = new Mat4();

      var _matShadowViewProj = new Mat4();

      var _matShadowViewProjArbitaryPos = new Mat4();

      var _matShadowViewProjArbitaryPosInv = new Mat4();

      var _projPos = new Vec3();

      var _texelSize = new Vec2();

      var _projSnap = new Vec3();

      var _snap = new Vec3();

      var _focus = new Vec3(0, 0, 0);

      var _ab = new AABB();

      var roPool = new Pool$1(function () {
        return {
          model: null,
          depth: 0
        };
      }, 128);
      var dirShadowPool = new Pool$1(function () {
        return {
          model: null,
          depth: 0
        };
      }, 128);
      var castShadowPool = new Pool$1(function () {
        return {
          model: null,
          depth: 0
        };
      }, 128);

      function getRenderObject(model, camera) {
        var depth = 0;

        if (model.node) {
          Vec3.subtract(_tempVec3, model.node.worldPosition, camera.position);
          depth = Vec3.dot(_tempVec3, camera.forward);
        }

        var ro = roPool.alloc();
        ro.model = model;
        ro.depth = depth;
        return ro;
      }

      function getDirShadowRenderObject(model, camera) {
        var depth = 0;

        if (model.node) {
          Vec3.subtract(_tempVec3, model.node.worldPosition, camera.position);
          depth = Vec3.dot(_tempVec3, camera.forward);
        }

        var ro = dirShadowPool.alloc();
        ro.model = model;
        ro.depth = depth;
        return ro;
      }

      function getCastShadowRenderObject(model, camera) {
        var depth = 0;

        if (model.node) {
          Vec3.subtract(_tempVec3, model.node.worldPosition, camera.position);
          depth = Vec3.dot(_tempVec3, camera.forward);
        }

        var ro = castShadowPool.alloc();
        ro.model = model;
        ro.depth = depth;
        return ro;
      }

      function updateDirLight(pipeline, light) {
        var shadows = pipeline.pipelineSceneData.shadows;
        var dir = light.direction;
        var n = shadows.normal;
        var d = shadows.distance + 0.001;
        var NdL = Vec3.dot(n, dir);
        var scale = 1 / NdL;
        var lx = dir.x * scale;
        var ly = dir.y * scale;
        var lz = dir.z * scale;
        var nx = n.x;
        var ny = n.y;
        var nz = n.z;
        var m = shadows.matLight;
        m.m00 = 1 - nx * lx;
        m.m01 = -nx * ly;
        m.m02 = -nx * lz;
        m.m03 = 0;
        m.m04 = -ny * lx;
        m.m05 = 1 - ny * ly;
        m.m06 = -ny * lz;
        m.m07 = 0;
        m.m08 = -nz * lx;
        m.m09 = -nz * ly;
        m.m10 = 1 - nz * lz;
        m.m11 = 0;
        m.m12 = lx * d;
        m.m13 = ly * d;
        m.m14 = lz * d;
        m.m15 = 1;
        pipeline.pipelineUBO.updateShadowUBORange(UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET, shadows.matLight);
      }

      function updatePlanarPROJ(shadowInfo, light, shadowUBO) {
        var dir = light.direction;
        var n = shadowInfo.normal;
        var d = shadowInfo.distance + 0.001;
        var NdL = Vec3.dot(n, dir);
        var scale = 1 / NdL;
        var lx = dir.x * scale;
        var ly = dir.y * scale;
        var lz = dir.z * scale;
        var nx = n.x;
        var ny = n.y;
        var nz = n.z;
        var m = shadowInfo.matLight;
        m.m00 = 1 - nx * lx;
        m.m01 = -nx * ly;
        m.m02 = -nx * lz;
        m.m03 = 0;
        m.m04 = -ny * lx;
        m.m05 = 1 - ny * ly;
        m.m06 = -ny * lz;
        m.m07 = 0;
        m.m08 = -nz * lx;
        m.m09 = -nz * ly;
        m.m10 = 1 - nz * lz;
        m.m11 = 0;
        m.m12 = lx * d;
        m.m13 = ly * d;
        m.m14 = lz * d;
        m.m15 = 1;
        Mat4.toArray(shadowUBO, m, UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET);
      }
      function updatePlanarNormalAndDistance(shadowInfo, shadowUBO) {
        Vec3.normalize(_tempVec3, shadowInfo.normal);
        shadowUBO[UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 0] = _tempVec3.x;
        shadowUBO[UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 1] = _tempVec3.y;
        shadowUBO[UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 2] = _tempVec3.z;
        shadowUBO[UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 3] = shadowInfo.distance;
      }
      function validPunctualLightsCulling(pipeline, camera) {
        var sceneData = pipeline.pipelineSceneData;
        var validPunctualLights = sceneData.validPunctualLights;
        validPunctualLights.length = 0;
        var _ref = camera.scene,
            spotLights = _ref.spotLights;

        for (var i = 0; i < spotLights.length; i++) {
          var light = spotLights[i];

          if (light.baked) {
            continue;
          }

          Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);

          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(light);
          }
        }

        var _ref2 = camera.scene,
            sphereLights = _ref2.sphereLights;

        for (var _i = 0; _i < sphereLights.length; _i++) {
          var _light = sphereLights[_i];

          if (_light.baked) {
            continue;
          }

          Sphere.set(_sphere, _light.position.x, _light.position.y, _light.position.z, _light.range);

          if (intersect.sphereFrustum(_sphere, camera.frustum)) {
            validPunctualLights.push(_light);
          }
        }
      }
      function getCameraWorldMatrix(out, camera) {
        if (!camera.node) {
          return;
        }

        var cameraNode = camera.node;
        var position = cameraNode.getWorldPosition();
        var rotation = cameraNode.getWorldRotation();
        Mat4.fromRT(out, rotation, position);
        out.m08 *= -1.0;
        out.m09 *= -1.0;
        out.m10 *= -1.0;
      }
      function QuantizeDirLightShadowCamera(out, pipeline, dirLight, camera, shadowInfo) {
        var device = pipeline.device;

        if (dirLight.shadowFixedArea) {
          var x = dirLight.shadowOrthoSize;
          var y = dirLight.shadowOrthoSize;
          var near = dirLight.shadowNear;
          var far = dirLight.shadowFar;
          Mat4.fromRT(_matShadowTrans, dirLight.node.getWorldRotation(), dirLight.node.getWorldPosition());
          Mat4.invert(_matShadowView, _matShadowTrans);
          Mat4.ortho(_matShadowProj, -x, x, -y, y, near, far, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY);
          Mat4.multiply(_matShadowViewProj, _matShadowProj, _matShadowView);
          Mat4.invert(_matShadowViewInv, _matShadowView);
          shadowInfo.matShadowView = _matShadowView;
          shadowInfo.matShadowProj = _matShadowProj;
          shadowInfo.matShadowViewProj = _matShadowViewProj;
          Frustum.createOrtho(out, x * 2.0, y * 2.0, near, far, _matShadowViewInv);
        } else {
          var invisibleOcclusionRange = dirLight.shadowInvisibleOcclusionRange;
          var shadowMapWidth = shadowInfo.size.x;
          getCameraWorldMatrix(_mat4_trans, camera);
          Frustum.split(_validFrustum, camera, _mat4_trans, 0.1, dirLight.shadowDistance);
          _lightViewFrustum = Frustum.clone(_validFrustum);
          Mat4.fromRT(_matShadowTrans, dirLight.node.rotation, _focus);
          Mat4.invert(_matShadowView, _matShadowTrans);
          Mat4.invert(_matShadowViewInv, _matShadowView);

          var shadowViewArbitaryPos = _matShadowView.clone();

          _lightViewFrustum.transform(_matShadowView);

          AABB.fromPoints(_castLightViewBounds, new Vec3(10000000, 10000000, 10000000), new Vec3(-10000000, -10000000, -10000000));

          _castLightViewBounds.mergeFrustum(_lightViewFrustum);

          var r = _castLightViewBounds.halfExtents.z * 2.0;

          _shadowPos.set(_castLightViewBounds.center.x, _castLightViewBounds.center.y, _castLightViewBounds.center.z + _castLightViewBounds.halfExtents.z + invisibleOcclusionRange);

          Vec3.transformMat4(_shadowPos, _shadowPos, _matShadowViewInv);
          Mat4.fromRT(_matShadowTrans, dirLight.node.rotation, _shadowPos);
          Mat4.invert(_matShadowView, _matShadowTrans);
          Mat4.invert(_matShadowViewInv, _matShadowView);
          var orthoSizeMin = Vec3.distance(_validFrustum.vertices[0], _validFrustum.vertices[6]);

          _cameraBoundingSphere.center.set(0, 0, 0);

          _cameraBoundingSphere.radius = -1.0;

          _cameraBoundingSphere.mergePoints(_validFrustum.vertices);

          var orthoSizeMax = _cameraBoundingSphere.radius * 2.0;
          var orthoSize = orthoSizeMin * 0.8 + orthoSizeMax * 0.2;
          shadowInfo.shadowCameraFar = r + invisibleOcclusionRange;
          var halfOrthoSize = orthoSize * 0.5;
          Mat4.ortho(_matShadowProj, -halfOrthoSize, halfOrthoSize, -halfOrthoSize, halfOrthoSize, 0.1, shadowInfo.shadowCameraFar, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY);

          if (shadowMapWidth > 0.0) {
            Mat4.multiply(_matShadowViewProjArbitaryPos, _matShadowProj, shadowViewArbitaryPos);
            Vec3.transformMat4(_projPos, _shadowPos, _matShadowViewProjArbitaryPos);
            var invActualSize = 2.0 / shadowMapWidth;

            _texelSize.set(invActualSize, invActualSize);

            var modX = _projPos.x % _texelSize.x;
            var modY = _projPos.y % _texelSize.y;

            _projSnap.set(_projPos.x - modX, _projPos.y - modY, _projPos.z);

            Mat4.invert(_matShadowViewProjArbitaryPosInv, _matShadowViewProjArbitaryPos);
            Vec3.transformMat4(_snap, _projSnap, _matShadowViewProjArbitaryPosInv);
            Mat4.fromRT(_matShadowTrans, dirLight.node.rotation, _snap);
            Mat4.invert(_matShadowView, _matShadowTrans);
            Mat4.invert(_matShadowViewInv, _matShadowView);
            Frustum.createOrtho(out, orthoSize, orthoSize, 0.1, shadowInfo.shadowCameraFar, _matShadowViewInv);
          } else {
            for (var i = 0; i < 8; i++) {
              out.vertices[i].set(0.0, 0.0, 0.0);
            }

            out.updatePlanes();
          }

          Mat4.multiply(_matShadowViewProj, _matShadowProj, _matShadowView);
          shadowInfo.matShadowView = _matShadowView;
          shadowInfo.matShadowProj = _matShadowProj;
          shadowInfo.matShadowViewProj = _matShadowViewProj;
        }
      }
      function sceneCulling(pipeline, camera) {
        var scene = camera.scene;
        var mainLight = scene.mainLight;
        var sceneData = pipeline.pipelineSceneData;
        var shadows = sceneData.shadows;
        var skybox = sceneData.skybox;
        var renderObjects = sceneData.renderObjects;
        roPool.freeArray(renderObjects);
        renderObjects.length = 0;
        var castShadowObjects = sceneData.castShadowObjects;
        castShadowPool.freeArray(castShadowObjects);
        castShadowObjects.length = 0;
        _castBoundsInited = false;
        var dirShadowObjects = null;

        if (shadows.enabled) {
          pipeline.pipelineUBO.updateShadowUBORange(UBOShadow.SHADOW_COLOR_OFFSET, shadows.shadowColor);

          if (shadows.type === ShadowType.ShadowMap) {
            dirShadowObjects = pipeline.pipelineSceneData.dirShadowObjects;
            dirShadowPool.freeArray(dirShadowObjects);
            dirShadowObjects.length = 0;

            if (mainLight && mainLight.node) {
              QuantizeDirLightShadowCamera(_dirLightFrustum, pipeline, mainLight, camera, shadows);
            } else {
              for (var i = 0; i < 8; i++) {
                _dirLightFrustum.vertices[i].set(0.0, 0.0, 0.0);
              }

              _dirLightFrustum.updatePlanes();
            }
          }
        }

        if (mainLight) {
          if (shadows.type === ShadowType.Planar) {
            updateDirLight(pipeline, mainLight);
          }
        }

        if (skybox.enabled && skybox.model && camera.clearFlag & SKYBOX_FLAG) {
          renderObjects.push(getRenderObject(skybox.model, camera));
        }

        var models = scene.models;
        var visibility = camera.visibility;

        for (var _i2 = 0; _i2 < models.length; _i2++) {
          var model = models[_i2];

          if (model.enabled) {
            if (model.castShadow) {
              castShadowObjects.push(getCastShadowRenderObject(model, camera));
            }

            if (shadows.firstSetCSM && model.worldBounds) {
              if (!_castBoundsInited) {
                _castWorldBounds.copy(model.worldBounds);

                _castBoundsInited = true;
              }

              AABB.merge(_castWorldBounds, _castWorldBounds, model.worldBounds);
            }

            if (model.node && (visibility & model.node.layer) === model.node.layer || visibility & model.visFlags) {
              if (dirShadowObjects != null && model.castShadow && model.worldBounds) {
                if (intersect.aabbFrustum(model.worldBounds, _dirLightFrustum)) {
                  dirShadowObjects.push(getDirShadowRenderObject(model, camera));
                }
              }

              if (model.worldBounds && !intersect.aabbFrustum(model.worldBounds, camera.frustum)) {
                continue;
              }

              renderObjects.push(getRenderObject(model, camera));
            }
          }
        }
      }

      var _samplerLinearInfo = new SamplerInfo(Filter.LINEAR, Filter.LINEAR, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP);

      var _samplerPointInfo = new SamplerInfo(Filter.POINT, Filter.POINT, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP);

      var GlobalDSManager = function () {
        function GlobalDSManager(pipeline) {
          this._device = void 0;
          this._descriptorSetMap = new Map();
          this._globalDescriptorSet = void 0;
          this._descriptorSetLayout = void 0;
          this._linearSampler = void 0;
          this._pointSampler = void 0;
          this._device = pipeline.device;
          this._linearSampler = this._device.getSampler(_samplerLinearInfo);
          this._pointSampler = this._device.getSampler(_samplerPointInfo);
          var layoutInfo = new DescriptorSetLayoutInfo(globalDescriptorSetLayout.bindings);
          this._descriptorSetLayout = this._device.createDescriptorSetLayout(layoutInfo);
          this._globalDescriptorSet = this._device.createDescriptorSet(new DescriptorSetInfo(this._descriptorSetLayout));
        }

        var _proto = GlobalDSManager.prototype;

        _proto.bindBuffer = function bindBuffer(binding, buffer) {
          this._globalDescriptorSet.bindBuffer(binding, buffer);

          var it = this._descriptorSetMap.values();

          var res = it.next();

          while (!res.done) {
            var descriptorSet = res.value;
            descriptorSet.bindBuffer(binding, buffer);
            res = it.next();
          }
        };

        _proto.bindSampler = function bindSampler(binding, sampler) {
          this._globalDescriptorSet.bindSampler(binding, sampler);

          var it = this._descriptorSetMap.values();

          var res = it.next();

          while (!res.done) {
            var descriptorSet = res.value;
            descriptorSet.bindSampler(binding, sampler);
            res = it.next();
          }
        };

        _proto.bindTexture = function bindTexture(binding, texture) {
          this._globalDescriptorSet.bindTexture(binding, texture);

          var it = this._descriptorSetMap.values();

          var res = it.next();

          while (!res.done) {
            var descriptorSet = res.value;
            descriptorSet.bindTexture(binding, texture);
            res = it.next();
          }
        };

        _proto.update = function update() {
          this._globalDescriptorSet.update();

          var it = this._descriptorSetMap.values();

          var res = it.next();

          while (!res.done) {
            var descriptorSet = res.value;
            descriptorSet.update();
            res = it.next();
          }
        };

        _proto.getOrCreateDescriptorSet = function getOrCreateDescriptorSet(idx) {
          var device = this._device;

          if (!this._descriptorSetMap.has(idx)) {
            var globalDescriptorSet = this._globalDescriptorSet;
            var descriptorSet = device.createDescriptorSet(new DescriptorSetInfo(this._descriptorSetLayout));

            this._descriptorSetMap.set(idx, descriptorSet);

            for (var i = PipelineGlobalBindings.UBO_GLOBAL; i < PipelineGlobalBindings.COUNT; i++) {
              descriptorSet.bindBuffer(i, globalDescriptorSet.getBuffer(i));
              descriptorSet.bindSampler(i, globalDescriptorSet.getSampler(i));
              descriptorSet.bindTexture(i, globalDescriptorSet.getTexture(i));
            }

            var shadowUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOShadow.SIZE, UBOShadow.SIZE));
            descriptorSet.bindBuffer(UBOShadow.BINDING, shadowUBO);
            descriptorSet.update();
          }

          return this._descriptorSetMap.get(idx);
        };

        _proto.destroy = function destroy() {
          this._descriptorSetLayout.destroy();
        };

        _createClass(GlobalDSManager, [{
          key: "descriptorSetMap",
          get: function get() {
            return this._descriptorSetMap;
          }
        }, {
          key: "linearSampler",
          get: function get() {
            return this._linearSampler;
          }
        }, {
          key: "pointSampler",
          get: function get() {
            return this._pointSampler;
          }
        }, {
          key: "descriptorSetLayout",
          get: function get() {
            return this._descriptorSetLayout;
          }
        }, {
          key: "globalDescriptorSet",
          get: function get() {
            return this._globalDescriptorSet;
          }
        }]);

        return GlobalDSManager;
      }();

      var _stageOffset = 0;
      var _name2stageID = {};
      var config = {
        addStage: function addStage(name) {
          if (_name2stageID[name] !== undefined) {
            return;
          }

          var stageID = 1 << _stageOffset;
          _name2stageID[name] = stageID;
          _stageOffset += 1;
        },
        stageID: function stageID(name) {
          var id = _name2stageID[name];

          if (id === undefined) {
            return -1;
          }

          return id;
        },
        stageIDs: function stageIDs(nameList) {
          var key = 0;

          for (var _iterator = _createForOfIteratorHelperLoose(nameList), _step; !(_step = _iterator()).done;) {
            var name = _step.value;
            var id = _name2stageID[name];

            if (id !== undefined) {
              key |= id;
            }
          }

          return key;
        }
      };

      var _dsInfo$1 = new DescriptorSetInfo(null);

      var MAX_PASS_COUNT = 8;
      var SubModel = function () {
        function SubModel() {
          this._device = null;
          this._passes = null;
          this._shaders = null;
          this._subMesh = null;
          this._patches = null;
          this._priority = RenderPriority.DEFAULT;
          this._inputAssembler = null;
          this._descriptorSet = null;
          this._worldBoundDescriptorSet = null;
          this._planarInstanceShader = null;
          this._planarShader = null;
          this._reflectionTex = null;
          this._reflectionSampler = null;
        }

        var _proto = SubModel.prototype;

        _proto._destroyDescriptorSet = function _destroyDescriptorSet() {
          this._descriptorSet.destroy();

          this._descriptorSet = null;
        };

        _proto._destroyWorldBoundDescriptorSet = function _destroyWorldBoundDescriptorSet() {
          this._worldBoundDescriptorSet.destroy();

          this._worldBoundDescriptorSet = null;
        };

        _proto._destroyInputAssembler = function _destroyInputAssembler() {
          this._inputAssembler.destroy();

          this._inputAssembler = null;
        };

        _proto._createDescriptorSet = function _createDescriptorSet(descInfo) {
          this._descriptorSet = this._device.createDescriptorSet(descInfo);
        };

        _proto._createWorldBoundDescriptorSet = function _createWorldBoundDescriptorSet(descInfo) {
          this._worldBoundDescriptorSet = this._device.createDescriptorSet(descInfo);
        };

        _proto._setInputAssembler = function _setInputAssembler(iaInfo) {
          this._inputAssembler = this._device.createInputAssembler(iaInfo);
        };

        _proto._setSubMesh = function _setSubMesh(subMesh) {
          this._subMesh = subMesh;
        };

        _proto._init = function _init() {
        };

        _proto.initialize = function initialize(subMesh, passes, patches) {
          if (patches === void 0) {
            patches = null;
          }

          var root = legacyCC.director.root;
          this._device = root.device;
          _dsInfo$1.layout = passes[0].localSetLayout;

          this._init();

          this._setInputAssembler(subMesh.iaInfo);

          this._createDescriptorSet(_dsInfo$1);

          var pipeline = legacyCC.director.root.pipeline;
          var occlusionPass = pipeline.pipelineSceneData.getOcclusionQueryPass();
          var occlusionDSInfo = new DescriptorSetInfo(null);
          occlusionDSInfo.layout = occlusionPass.localSetLayout;

          this._createWorldBoundDescriptorSet(occlusionDSInfo);

          this._setSubMesh(subMesh);

          this._patches = patches;
          this._passes = passes;

          this._flushPassInfo();

          if (passes[0].batchingScheme === BatchingSchemes.VB_MERGING) {
            this.subMesh.genFlatBuffers();

            this._setSubMesh(this.subMesh);
          }

          this.priority = RenderPriority.DEFAULT;

          if (passes[0].phase === getPhaseID('reflection')) {
            var texWidth = root.mainWindow.width;
            var texHeight = root.mainWindow.height;
            var minSize = 512;

            if (texHeight < texWidth) {
              texWidth = minSize * texWidth / texHeight;
              texHeight = minSize;
            } else {
              texWidth = minSize;
              texHeight = minSize * texHeight / texWidth;
            }

            this._reflectionTex = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.STORAGE | TextureUsageBit.TRANSFER_SRC | TextureUsageBit.SAMPLED, Format.RGBA8, texWidth, texHeight));
            this.descriptorSet.bindTexture(UNIFORM_REFLECTION_TEXTURE_BINDING, this._reflectionTex);
            this._reflectionSampler = this._device.getSampler(new SamplerInfo(Filter.LINEAR, Filter.LINEAR, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP));
            this.descriptorSet.bindSampler(UNIFORM_REFLECTION_TEXTURE_BINDING, this._reflectionSampler);
            this.descriptorSet.bindTexture(UNIFORM_REFLECTION_STORAGE_BINDING, this._reflectionTex);
          }
        };

        _proto._initNativePlanarShadowShader = function _initNativePlanarShadowShader(shadowInfo) {
          this._planarShader = shadowInfo.getPlanarShader(this._patches);
        };

        _proto.initPlanarShadowShader = function initPlanarShadowShader() {
          var pipeline = legacyCC.director.root.pipeline;
          var shadowInfo = pipeline.pipelineSceneData.shadows;

          this._initNativePlanarShadowShader(shadowInfo);
        };

        _proto._initNativePlanarShadowInstanceShader = function _initNativePlanarShadowInstanceShader(shadowInfo) {
          this._planarInstanceShader = shadowInfo.getPlanarInstanceShader(this._patches);
        };

        _proto.initPlanarShadowInstanceShader = function initPlanarShadowInstanceShader() {
          var pipeline = legacyCC.director.root.pipeline;
          var shadowInfo = pipeline.pipelineSceneData.shadows;

          this._initNativePlanarShadowInstanceShader(shadowInfo);
        };

        _proto._destroy = function _destroy() {
        };

        _proto.destroy = function destroy() {
          this._destroyDescriptorSet();

          this._destroyWorldBoundDescriptorSet();

          this._destroyInputAssembler();

          this.priority = RenderPriority.DEFAULT;
          this._patches = null;
          this._subMesh = null;
          this._passes = null;
          this._shaders = null;
          if (this._reflectionTex) this._reflectionTex.destroy();
          this._reflectionTex = null;
          this._reflectionSampler = null;

          this._destroy();
        };

        _proto.update = function update() {
          for (var i = 0; i < this._passes.length; ++i) {
            var pass = this._passes[i];
            pass.update();
          }

          this._descriptorSet.update();

          this._worldBoundDescriptorSet.update();
        };

        _proto.onPipelineStateChanged = function onPipelineStateChanged() {
          var passes = this._passes;

          if (!passes) {
            return;
          }

          for (var i = 0; i < passes.length; i++) {
            var pass = passes[i];
            pass.beginChangeStatesSilently();
            pass.tryCompile();
            pass.endChangeStatesSilently();
          }

          this._flushPassInfo();
        };

        _proto.onMacroPatchesStateChanged = function onMacroPatchesStateChanged(patches) {
          this._patches = patches;
          var passes = this._passes;

          if (!passes) {
            return;
          }

          for (var i = 0; i < passes.length; i++) {
            var pass = passes[i];
            pass.beginChangeStatesSilently();
            pass.tryCompile();
            pass.endChangeStatesSilently();
          }

          this._flushPassInfo();
        };

        _proto._flushPassInfo = function _flushPassInfo() {
          var passes = this._passes;

          if (!passes) {
            return;
          }

          if (!this._shaders) {
            this._shaders = [];
          }

          this._shaders.length = passes.length;

          for (var i = 0, len = passes.length; i < len; i++) {
            this._shaders[i] = passes[i].getShaderVariant(this.patches);
          }
        };

        _createClass(SubModel, [{
          key: "passes",
          get: function get() {
            return this._passes;
          },
          set: function set(passes) {
            var passLengh = passes.length;

            if (passLengh > MAX_PASS_COUNT) {
              errorID(12004, MAX_PASS_COUNT);
              return;
            }

            this._passes = passes;

            this._flushPassInfo();

            if (this._passes[0].batchingScheme === BatchingSchemes.VB_MERGING) {
              this.subMesh.genFlatBuffers();

              this._setSubMesh(this.subMesh);
            }

            if (this._descriptorSet) {
              this._destroyDescriptorSet();

              _dsInfo$1.layout = passes[0].localSetLayout;

              this._createDescriptorSet(_dsInfo$1);
            }
          }
        }, {
          key: "shaders",
          get: function get() {
            return this._shaders;
          }
        }, {
          key: "subMesh",
          get: function get() {
            return this._subMesh;
          },
          set: function set(subMesh) {
            this._inputAssembler.destroy();

            this._inputAssembler.initialize(subMesh.iaInfo);

            if (this._passes[0].batchingScheme === BatchingSchemes.VB_MERGING) {
              this.subMesh.genFlatBuffers();
            }

            this._setSubMesh(subMesh);
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(val) {
            this._priority = val;
          }
        }, {
          key: "inputAssembler",
          get: function get() {
            return this._inputAssembler;
          }
        }, {
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          }
        }, {
          key: "worldBoundDescriptorSet",
          get: function get() {
            return this._worldBoundDescriptorSet;
          }
        }, {
          key: "patches",
          get: function get() {
            return this._patches;
          }
        }, {
          key: "planarInstanceShader",
          get: function get() {
            return this._planarInstanceShader;
          }
        }, {
          key: "planarShader",
          get: function get() {
            return this._planarShader;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return SubModel;
      }();

      var m4_1 = new Mat4();
      var shadowMapPatches = [{
        name: 'CC_RECEIVE_SHADOW',
        value: true
      }];
      var lightMapPatches = [{
        name: 'CC_USE_LIGHTMAP',
        value: true
      }];
      var ModelType;

      (function (ModelType) {
        ModelType[ModelType["DEFAULT"] = 0] = "DEFAULT";
        ModelType[ModelType["SKINNING"] = 1] = "SKINNING";
        ModelType[ModelType["BAKED_SKINNING"] = 2] = "BAKED_SKINNING";
        ModelType[ModelType["BATCH_2D"] = 3] = "BATCH_2D";
        ModelType[ModelType["PARTICLE_BATCH"] = 4] = "PARTICLE_BATCH";
        ModelType[ModelType["LINE"] = 5] = "LINE";
      })(ModelType || (ModelType = {}));

      function uploadMat4AsVec4x3(mat, v1, v2, v3) {
        v1[0] = mat.m00;
        v1[1] = mat.m01;
        v1[2] = mat.m02;
        v1[3] = mat.m12;
        v2[0] = mat.m04;
        v2[1] = mat.m05;
        v2[2] = mat.m06;
        v2[3] = mat.m13;
        v3[0] = mat.m08;
        v3[1] = mat.m09;
        v3[2] = mat.m10;
        v3[3] = mat.m14;
      }

      var lightmapSamplerHash = new SamplerInfo(Filter.LINEAR, Filter.LINEAR, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP);
      var lightmapSamplerWithMipHash = new SamplerInfo(Filter.LINEAR, Filter.LINEAR, Filter.LINEAR, Address.CLAMP, Address.CLAMP, Address.CLAMP);
      var Model = function () {
        function Model() {
          this.type = ModelType.DEFAULT;
          this.scene = null;
          this.isDynamicBatching = false;
          this.instancedAttributes = {
            buffer: null,
            views: [],
            attributes: []
          };
          this._worldBounds = null;
          this._modelBounds = null;
          this._subModels = [];
          this._node = null;
          this._transform = null;
          this._device = void 0;
          this._inited = false;
          this._descriptorSetCount = 1;
          this._updateStamp = -1;
          this._localDataUpdated = true;
          this._localData = new Float32Array(UBOLocal.COUNT);
          this._localBuffer = null;
          this._instMatWorldIdx = -1;
          this._lightmap = null;
          this._lightmapUVParam = new Vec4();
          this._worldBoundBuffer = null;
          this._receiveShadow = false;
          this._castShadow = false;
          this._shadowBias = 0;
          this._shadowNormalBias = 0;
          this._enabled = true;
          this._visFlags = Layers.Enum.NONE;
          this._device = legacyCC.director.root.device;
        }

        var _proto = Model.prototype;

        _proto._setReceiveShadow = function _setReceiveShadow(val) {
          this._receiveShadow = val;
        };

        _proto._init = function _init() {
        };

        _proto.initialize = function initialize() {
          if (this._inited) {
            return;
          }

          this._init();

          this._setReceiveShadow(true);

          this.castShadow = false;
          this.enabled = true;
          this.visFlags = Layers.Enum.NONE;
          this._inited = true;
        };

        _proto._destroySubmodel = function _destroySubmodel(subModel) {
          subModel.destroy();
        };

        _proto._destroy = function _destroy() {
        };

        _proto.destroy = function destroy() {
          var subModels = this._subModels;

          for (var i = 0; i < subModels.length; i++) {
            var subModel = this._subModels[i];

            this._destroySubmodel(subModel);
          }

          if (this._localBuffer) {
            this._localBuffer.destroy();

            this._localBuffer = null;
          }

          if (this._worldBoundBuffer) {
            this._worldBoundBuffer.destroy();

            this._worldBoundBuffer = null;
          }

          this._worldBounds = null;
          this._modelBounds = null;
          this._subModels.length = 0;
          this._inited = false;
          this._localDataUpdated = true;
          this._transform = null;
          this._node = null;
          this.isDynamicBatching = false;

          this._destroy();
        };

        _proto.attachToScene = function attachToScene(scene) {
          this.scene = scene;
          this._localDataUpdated = true;
        };

        _proto.detachFromScene = function detachFromScene() {
          this.scene = null;
        };

        _proto.updateTransform = function updateTransform(stamp) {
          var node = this.transform;

          if (node.hasChangedFlags || node._dirtyFlags) {
            node.updateWorldTransform();
            this._localDataUpdated = true;
            var worldBounds = this._worldBounds;

            if (this._modelBounds && worldBounds) {
              this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
            }
          }
        };

        _proto.updateWorldBound = function updateWorldBound() {
          var node = this.transform;

          if (node !== null) {
            node.updateWorldTransform();
            this._localDataUpdated = true;
            var worldBounds = this._worldBounds;

            if (this._modelBounds && worldBounds) {
              this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
            }
          }
        };

        _proto._applyLocalData = function _applyLocalData() {
        };

        _proto._applyLocalBuffer = function _applyLocalBuffer() {
        };

        _proto._applyWorldBoundBuffer = function _applyWorldBoundBuffer() {
        };

        _proto.updateUBOs = function updateUBOs(stamp) {
          var subModels = this._subModels;

          for (var i = 0; i < subModels.length; i++) {
            subModels[i].update();
          }

          this._updateStamp = stamp;

          if (!this._localDataUpdated) {
            return;
          }

          this._localDataUpdated = false;
          var worldMatrix = this.transform._mat;
          var idx = this._instMatWorldIdx;

          if (idx >= 0) {
            var attrs = this.instancedAttributes.views;
            uploadMat4AsVec4x3(worldMatrix, attrs[idx], attrs[idx + 1], attrs[idx + 2]);
          } else if (this._localBuffer) {
            Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
            Mat4.inverseTranspose(m4_1, worldMatrix);

            {
              var det = Math.abs(Mat4.determinant(m4_1));
              var factor = 1.0 / Math.sqrt(det);
              Mat4.multiplyScalar(m4_1, m4_1, factor);
            }

            Mat4.toArray(this._localData, m4_1, UBOLocal.MAT_WORLD_IT_OFFSET);

            this._localBuffer.update(this._localData);

            this._applyLocalData();

            this._applyLocalBuffer();
          }
        };

        _proto._updateNativeBounds = function _updateNativeBounds() {
        };

        _proto.createBoundingShape = function createBoundingShape(minPos, maxPos) {
          if (!minPos || !maxPos) {
            return;
          }

          this._modelBounds = AABB.fromPoints(AABB.create(), minPos, maxPos);
          this._worldBounds = AABB.clone(this._modelBounds);

          this._updateNativeBounds();
        };

        _proto._createSubModel = function _createSubModel() {
          return new SubModel();
        };

        _proto.initSubModel = function initSubModel(idx, subMeshData, mat) {
          this.initialize();

          if (this._subModels[idx] == null) {
            this._subModels[idx] = this._createSubModel();
          } else {
            this._subModels[idx].destroy();
          }

          this._subModels[idx].initialize(subMeshData, mat.passes, this.getMacroPatches(idx));

          this._subModels[idx].initPlanarShadowShader();

          this._subModels[idx].initPlanarShadowInstanceShader();

          this._updateAttributesAndBinding(idx);
        };

        _proto.setSubModelMesh = function setSubModelMesh(idx, subMesh) {
          if (!this._subModels[idx]) {
            return;
          }

          this._subModels[idx].subMesh = subMesh;
        };

        _proto.setSubModelMaterial = function setSubModelMaterial(idx, mat) {
          if (!this._subModels[idx]) {
            return;
          }

          this._subModels[idx].passes = mat.passes;

          this._updateAttributesAndBinding(idx);
        };

        _proto.onGlobalPipelineStateChanged = function onGlobalPipelineStateChanged() {
          var subModels = this._subModels;

          for (var i = 0; i < subModels.length; i++) {
            subModels[i].onPipelineStateChanged();
          }
        };

        _proto.onMacroPatchesStateChanged = function onMacroPatchesStateChanged() {
          var subModels = this._subModels;

          for (var i = 0; i < subModels.length; i++) {
            subModels[i].onMacroPatchesStateChanged(this.getMacroPatches(i));
          }
        };

        _proto.updateLightingmap = function updateLightingmap(texture, uvParam) {
          Vec4.toArray(this._localData, uvParam, UBOLocal.LIGHTINGMAP_UVPARAM);
          this._localDataUpdated = true;
          this._lightmap = texture;
          this._lightmapUVParam = uvParam;
          this.onMacroPatchesStateChanged();

          if (texture === null) {
            texture = builtinResMgr.get('empty-texture');
          }

          var gfxTexture = texture.getGFXTexture();

          if (gfxTexture) {
            var sampler = this._device.getSampler(texture.mipmaps.length > 1 ? lightmapSamplerWithMipHash : lightmapSamplerHash);

            var subModels = this._subModels;

            for (var i = 0; i < subModels.length; i++) {
              var descriptorSet = subModels[i].descriptorSet;
              descriptorSet.bindTexture(UNIFORM_LIGHTMAP_TEXTURE_BINDING, gfxTexture);
              descriptorSet.bindSampler(UNIFORM_LIGHTMAP_TEXTURE_BINDING, sampler);
              descriptorSet.update();
            }
          }
        };

        _proto.updateLocalShadowBias = function updateLocalShadowBias() {
          var sv = this._localData;
          sv[UBOLocal.LOCAL_SHADOW_BIAS + 0] = this._shadowBias;
          sv[UBOLocal.LOCAL_SHADOW_BIAS + 1] = this._shadowNormalBias;
          sv[UBOLocal.LOCAL_SHADOW_BIAS + 2] = 0;
          sv[UBOLocal.LOCAL_SHADOW_BIAS + 3] = 0;
          this._localDataUpdated = true;
        };

        _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
          var patches = this.receiveShadow ? shadowMapPatches : null;

          if (this._lightmap != null) {
            patches = patches ? patches.concat(lightMapPatches) : lightMapPatches;
          }

          return patches;
        };

        _proto._updateAttributesAndBinding = function _updateAttributesAndBinding(subModelIndex) {
          var subModel = this._subModels[subModelIndex];

          if (!subModel) {
            return;
          }

          this._initLocalDescriptors(subModelIndex);

          this._updateLocalDescriptors(subModelIndex, subModel.descriptorSet);

          this._initWorldBoundDescriptors(subModelIndex);

          this._updateWorldBoundDescriptors(subModelIndex, subModel.worldBoundDescriptorSet);

          var shader = subModel.passes[0].getShaderVariant(subModel.patches);

          this._updateInstancedAttributes(shader.attributes, subModel.passes[0]);
        };

        _proto._getInstancedAttributeIndex = function _getInstancedAttributeIndex(name) {
          var attributes = this.instancedAttributes.attributes;

          for (var i = 0; i < attributes.length; i++) {
            if (attributes[i].name === name) {
              return i;
            }
          }

          return -1;
        };

        _proto._setInstMatWorldIdx = function _setInstMatWorldIdx(idx) {
          this._instMatWorldIdx = idx;
        };

        _proto._updateInstancedAttributes = function _updateInstancedAttributes(attributes, pass) {
          if (!pass.device.hasFeature(Feature.INSTANCED_ARRAYS)) {
            return;
          }

          var size = 0;

          for (var j = 0; j < attributes.length; j++) {
            var attribute = attributes[j];

            if (!attribute.isInstanced) {
              continue;
            }

            size += FormatInfos[attribute.format].size;
          }

          var attrs = this.instancedAttributes;
          attrs.buffer = new Uint8Array(size);
          attrs.views.length = attrs.attributes.length = 0;
          var offset = 0;

          for (var _j = 0; _j < attributes.length; _j++) {
            var _attribute = attributes[_j];

            if (!_attribute.isInstanced) {
              continue;
            }

            var attr = new Attribute();
            attr.format = _attribute.format;
            attr.name = _attribute.name;
            attr.isNormalized = _attribute.isNormalized;
            attr.location = _attribute.location;
            attrs.attributes.push(attr);
            var info = FormatInfos[_attribute.format];
            var typeViewArray = new (getTypedArrayConstructor(info))(attrs.buffer.buffer, offset, info.count);
            attrs.views.push(typeViewArray);
            offset += info.size;
          }

          if (pass.batchingScheme === BatchingSchemes.INSTANCING) {
            pass.getInstancedBuffer().destroy();
          }

          this._setInstMatWorldIdx(this._getInstancedAttributeIndex(INST_MAT_WORLD));

          this._localDataUpdated = true;
        };

        _proto._initLocalDescriptors = function _initLocalDescriptors(subModelIndex) {
          if (!this._localBuffer) {
            this._localBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));

            this._applyLocalBuffer();
          }
        };

        _proto._initWorldBoundDescriptors = function _initWorldBoundDescriptors(subModelIndex) {
          if (!this._worldBoundBuffer) {
            this._worldBoundBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, UBOWorldBound.SIZE, UBOWorldBound.SIZE));

            this._applyWorldBoundBuffer();
          }
        };

        _proto._updateLocalDescriptors = function _updateLocalDescriptors(subModelIndex, descriptorSet) {
          if (this._localBuffer) descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);
        };

        _proto._updateWorldBoundDescriptors = function _updateWorldBoundDescriptors(subModelIndex, descriptorSet) {
          if (this._worldBoundBuffer) descriptorSet.bindBuffer(UBOWorldBound.BINDING, this._worldBoundBuffer);
        };

        _createClass(Model, [{
          key: "subModels",
          get: function get() {
            return this._subModels;
          }
        }, {
          key: "inited",
          get: function get() {
            return this._inited;
          }
        }, {
          key: "worldBounds",
          get: function get() {
            return this._worldBounds;
          }
        }, {
          key: "modelBounds",
          get: function get() {
            return this._modelBounds;
          }
        }, {
          key: "localBuffer",
          get: function get() {
            return this._localBuffer;
          }
        }, {
          key: "worldBoundBuffer",
          get: function get() {
            return this._worldBoundBuffer;
          }
        }, {
          key: "updateStamp",
          get: function get() {
            return this._updateStamp;
          }
        }, {
          key: "isInstancingEnabled",
          get: function get() {
            return this._instMatWorldIdx >= 0;
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(val) {
            this._shadowBias = val;
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(val) {
            this._shadowNormalBias = val;
          }
        }, {
          key: "receiveShadow",
          get: function get() {
            return this._receiveShadow;
          },
          set: function set(val) {
            this._setReceiveShadow(val);

            this.onMacroPatchesStateChanged();
          }
        }, {
          key: "castShadow",
          get: function get() {
            return this._castShadow;
          },
          set: function set(val) {
            this._castShadow = val;
          }
        }, {
          key: "node",
          get: function get() {
            return this._node;
          },
          set: function set(n) {
            this._node = n;
          }
        }, {
          key: "transform",
          get: function get() {
            return this._transform;
          },
          set: function set(n) {
            this._transform = n;
          }
        }, {
          key: "visFlags",
          get: function get() {
            return this._visFlags;
          },
          set: function set(val) {
            this._visFlags = val;
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            this._enabled = val;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return Model;
      }();

      var Ambient = function () {
        function Ambient() {
          this._groundAlbedoHDR = new Vec4(0.2, 0.2, 0.2, 1.0);
          this._skyColorHDR = new Vec4(0.2, 0.5, 0.8, 1.0);
          this._skyIllumHDR = 0;
          this._groundAlbedoLDR = new Vec4(0.2, 0.2, 0.2, 1.0);
          this._skyColorLDR = new Vec4(0.2, 0.5, 0.8, 1.0);
          this._skyIllumLDR = 0;
          this._enabled = false;
        }

        var _proto = Ambient.prototype;

        _proto.initialize = function initialize(ambientInfo) {
          this._skyColorHDR = ambientInfo.skyColorHDR;

          this._groundAlbedoHDR.set(ambientInfo.groundAlbedoHDR);

          this._skyIllumHDR = ambientInfo.skyIllumHDR;
          this._skyColorLDR = ambientInfo.skyColorLDR;

          this._groundAlbedoLDR.set(ambientInfo.groundAlbedoLDR);

          this._skyIllumLDR = ambientInfo.skyIllumLDR;
        };

        _proto._destroy = function _destroy() {
        };

        _proto.destroy = function destroy() {
          this._destroy();
        };

        _createClass(Ambient, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            this._enabled = val;
          }
        }, {
          key: "skyColor",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._skyColorHDR;
            } else {
              return this._skyColorLDR;
            }
          },
          set: function set(color) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this._skyColorHDR.set(color);
            } else {
              this._skyColorLDR.set(color);
            }
          }
        }, {
          key: "skyIllum",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._skyIllumHDR;
            } else {
              return this._skyIllumLDR;
            }
          },
          set: function set(illum) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this._skyIllumHDR = illum;
            } else {
              this._skyIllumLDR = illum;
            }
          }
        }, {
          key: "groundAlbedo",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._groundAlbedoHDR;
            } else {
              return this._groundAlbedoLDR;
            }
          },
          set: function set(color) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this._groundAlbedoHDR.set(color);
            } else {
              this._groundAlbedoLDR.set(color);
            }
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return Ambient;
      }();
      Ambient.SUN_ILLUM = 65000.0;
      Ambient.SKY_ILLUM = 20000.0;
      legacyCC.Ambient = Ambient;

      var PassInstance = function (_Pass) {
        _inheritsLoose(PassInstance, _Pass);

        function PassInstance(parent, owner) {
          var _this;

          _this = _Pass.call(this, parent.root) || this;
          _this._parent = void 0;
          _this._owner = void 0;
          _this._dontNotify = false;
          _this._parent = parent;
          _this._owner = owner;

          _this._doInit(_this._parent, true);

          for (var i = 0; i < _this._shaderInfo.blocks.length; i++) {
            var u = _this._shaderInfo.blocks[i];
            var block = _this._blocks[u.binding];
            var parentBlock = _this._parent.blocks[u.binding];
            block.set(parentBlock);
          }

          _this._setRootBufferDirty(true);

          var paren = _this._parent;

          for (var _i = 0; _i < _this._shaderInfo.samplerTextures.length; _i++) {
            var _u = _this._shaderInfo.samplerTextures[_i];

            for (var j = 0; j < _u.count; j++) {
              var sampler = paren._descriptorSet.getSampler(_u.binding, j);

              var texture = paren._descriptorSet.getTexture(_u.binding, j);

              _this._descriptorSet.bindSampler(_u.binding, sampler, j);

              _this._descriptorSet.bindTexture(_u.binding, texture, j);
            }
          }

          _Pass.prototype.tryCompile.call(_assertThisInitialized(_this));

          return _this;
        }

        var _proto = PassInstance.prototype;

        _proto.overridePipelineStates = function overridePipelineStates(original, overrides) {
          this._bs.reset();

          this._rs.reset();

          this._dss.reset();

          Pass.fillPipelineInfo(this, original);
          Pass.fillPipelineInfo(this, overrides);

          this._onStateChange();
        };

        _proto.tryCompile = function tryCompile(defineOverrides) {
          if (defineOverrides) {
            if (!overrideMacros(this._defines, defineOverrides)) {
              return false;
            }
          }

          var res = _Pass.prototype.tryCompile.call(this);

          this._onStateChange();

          return res;
        };

        _proto.beginChangeStatesSilently = function beginChangeStatesSilently() {
          this._dontNotify = true;
        };

        _proto.endChangeStatesSilently = function endChangeStatesSilently() {
          this._dontNotify = false;
        };

        _proto._syncBatchingScheme = function _syncBatchingScheme() {
          this._defines.USE_BATCHING = this._defines.USE_INSTANCING = false;

          this._setBatchingScheme(BatchingSchemes.NONE);
        };

        _proto._onStateChange = function _onStateChange() {
          this._setHash(Pass.getPassHash(this));

          this._owner.onPassStateChange(this._dontNotify);
        };

        _createClass(PassInstance, [{
          key: "parent",
          get: function get() {
            return this._parent;
          }
        }]);

        return PassInstance;
      }(Pass);

      var MaterialInstance = function (_Material) {
        _inheritsLoose(MaterialInstance, _Material);

        function MaterialInstance(info) {
          var _this;

          _this = _Material.call(this) || this;
          _this._passes = [];
          _this._parent = void 0;
          _this._owner = void 0;
          _this._subModelIdx = 0;
          _this._parent = info.parent;
          _this._owner = info.owner || null;
          _this._subModelIdx = info.subModelIdx || 0;

          _this.copy(_this._parent);

          return _this;
        }

        var _proto = MaterialInstance.prototype;

        _proto.recompileShaders = function recompileShaders(overrides, passIdx) {
          if (!this._passes || !this.effectAsset) {
            return;
          }

          if (passIdx === undefined) {
            for (var _iterator = _createForOfIteratorHelperLoose(this._passes), _step; !(_step = _iterator()).done;) {
              var pass = _step.value;
              pass.tryCompile(overrides);
            }
          } else {
            this._passes[passIdx].tryCompile(overrides);
          }
        };

        _proto.overridePipelineStates = function overridePipelineStates(overrides, passIdx) {
          if (!this._passes || !this.effectAsset) {
            return;
          }

          var passInfos = this.effectAsset.techniques[this.technique].passes;

          if (passIdx === undefined) {
            for (var i = 0; i < this._passes.length; i++) {
              var pass = this._passes[i];
              var state = this._states[i] || (this._states[i] = {});

              for (var key in overrides) {
                state[key] = overrides[key];
              }

              pass.overridePipelineStates(passInfos[pass.passIndex], state);
            }
          } else {
            var _state = this._states[passIdx] || (this._states[passIdx] = {});

            for (var _key in overrides) {
              _state[_key] = overrides[_key];
            }

            this._passes[passIdx].overridePipelineStates(passInfos[passIdx], _state);
          }
        };

        _proto.destroy = function destroy() {
          this._doDestroy();

          return true;
        };

        _proto.onPassStateChange = function onPassStateChange(dontNotify) {
          this._hash = Material.getHash(this);

          if (!dontNotify && this._owner) {
            this._owner._onRebuildPSO(this._subModelIdx, this);
          }
        };

        _proto._createPasses = function _createPasses() {
          var passes = [];
          var parentPasses = this._parent.passes;

          if (!parentPasses) {
            return passes;
          }

          for (var k = 0; k < parentPasses.length; ++k) {
            passes.push(new PassInstance(parentPasses[k], this));
          }

          return passes;
        };

        _createClass(MaterialInstance, [{
          key: "parent",
          get: function get() {
            return this._parent;
          }
        }, {
          key: "owner",
          get: function get() {
            return this._owner;
          }
        }]);

        return MaterialInstance;
      }(Material);

      var skybox_mesh = null;
      var skybox_material = null;
      var EnvironmentLightingType = Enum({
        HEMISPHERE_DIFFUSE: 0,
        AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION: 1,
        DIFFUSEMAP_WITH_REFLECTION: 2
      });
      var Skybox = function () {
        function Skybox() {
          this._envmapLDR = null;
          this._envmapHDR = null;
          this._diffuseMapLDR = null;
          this._diffuseMapHDR = null;
          this._globalDSManager = null;
          this._model = null;
          this._default = null;
          this._enabled = false;
          this._useIBL = false;
          this._useHDR = true;
          this._useDiffuseMap = false;
        }

        var _proto = Skybox.prototype;

        _proto._setEnabled = function _setEnabled(val) {
          this._enabled = val;
        };

        _proto._setUseIBL = function _setUseIBL(val) {
          this._useIBL = val;
        };

        _proto._setUseHDR = function _setUseHDR(val) {
          this._useHDR = val;
        };

        _proto._setUseDiffuseMap = function _setUseDiffuseMap(val) {
          this._useDiffuseMap = val;
        };

        _proto.initialize = function initialize(skyboxInfo) {
          this._setEnabled(skyboxInfo.enabled);

          this._setUseIBL(skyboxInfo.useIBL);

          this._setUseDiffuseMap(skyboxInfo.applyDiffuseMap);

          this._setUseHDR(skyboxInfo.useHDR);
        };

        _proto.setEnvMaps = function setEnvMaps(envmapHDR, envmapLDR) {
          this._envmapHDR = envmapHDR;
          this._envmapLDR = envmapLDR;

          this._updateGlobalBinding();

          this._updatePipeline();
        };

        _proto.setDiffuseMaps = function setDiffuseMaps(diffuseMapHDR, diffuseMapLDR) {
          this._diffuseMapHDR = diffuseMapHDR;
          this._diffuseMapLDR = diffuseMapLDR;

          this._updateGlobalBinding();

          this._updatePipeline();
        };

        _proto.activate = function activate() {
          var pipeline = legacyCC.director.root.pipeline;
          this._globalDSManager = pipeline.globalDSManager;
          this._default = builtinResMgr.get('default-cube-texture');

          if (!this._model) {
            this._model = legacyCC.director.root.createModel(legacyCC.renderer.scene.Model);

            this._model._initLocalDescriptors = function () {};

            this._model._initWorldBoundDescriptors = function () {};
          }

          var isRGBE = this._default.isRGBE;

          if (this.envmap) {
            isRGBE = this.envmap.isRGBE;
          }

          if (!skybox_material) {
            var mat = new Material();
            mat.initialize({
              effectName: 'skybox',
              defines: {
                USE_RGBE_CUBEMAP: isRGBE
              }
            });
            skybox_material = new MaterialInstance({
              parent: mat
            });
          }

          if (this.enabled) {
            if (!skybox_mesh) {
              skybox_mesh = legacyCC.utils.createMesh(legacyCC.primitives.box({
                width: 2,
                height: 2,
                length: 2
              }));
            }

            this._model.initSubModel(0, skybox_mesh.renderingSubMeshes[0], skybox_material);
          }

          if (!this.envmap) {
            this.envmap = this._default;
          }

          if (!this.diffuseMap) {
            this.diffuseMap = this._default;
          }

          this._updateGlobalBinding();

          this._updatePipeline();
        };

        _proto._updatePipeline = function _updatePipeline() {

          var root = legacyCC.director.root;
          var pipeline = root.pipeline;
          var useIBLValue = this.useIBL ? this.isRGBE ? 2 : 1 : 0;
          var useDiffuseMapValue = this.useIBL && this.useDiffuseMap && this.diffuseMap ? this.isRGBE ? 2 : 1 : 0;
          var useHDRValue = this.useHDR;

          if (pipeline.macros.CC_USE_IBL !== useIBLValue || pipeline.macros.CC_USE_DIFFUSEMAP !== useDiffuseMapValue || pipeline.macros.CC_USE_HDR !== useHDRValue) {
            pipeline.macros.CC_USE_IBL = useIBLValue;
            pipeline.macros.CC_USE_DIFFUSEMAP = useDiffuseMapValue;
            pipeline.macros.CC_USE_HDR = useHDRValue;
            root.onGlobalPipelineStateChanged();
          }

          if (this.enabled && skybox_material) {
            skybox_material.recompileShaders({
              USE_RGBE_CUBEMAP: this.isRGBE
            });
          }

          if (this._model) {
            this._model.setSubModelMaterial(0, skybox_material);
          }
        };

        _proto._updateGlobalBinding = function _updateGlobalBinding() {
          if (this._globalDSManager) {
            var device = legacyCC.director.root.device;
            var envmap = this.envmap ? this.envmap : this._default;

            if (envmap) {
              var texture = envmap.getGFXTexture();
              var sampler = device.getSampler(envmap.getSamplerInfo());

              this._globalDSManager.bindSampler(UNIFORM_ENVIRONMENT_BINDING, sampler);

              this._globalDSManager.bindTexture(UNIFORM_ENVIRONMENT_BINDING, texture);
            }

            var diffuseMap = this.diffuseMap ? this.diffuseMap : this._default;

            if (diffuseMap) {
              var _texture = diffuseMap.getGFXTexture();

              var _sampler = device.getSampler(diffuseMap.getSamplerInfo());

              this._globalDSManager.bindSampler(UNIFORM_DIFFUSEMAP_BINDING, _sampler);

              this._globalDSManager.bindTexture(UNIFORM_DIFFUSEMAP_BINDING, _texture);
            }

            this._globalDSManager.update();
          }
        };

        _proto._destroy = function _destroy() {
        };

        _proto.destroy = function destroy() {
          this._destroy();
        };

        _createClass(Skybox, [{
          key: "model",
          get: function get() {
            return this._model;
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            this._setEnabled(val);

            if (val) this.activate();else this._updatePipeline();
          }
        }, {
          key: "useHDR",
          get: function get() {
            return this._useHDR;
          },
          set: function set(val) {
            this._setUseHDR(val);

            this.setEnvMaps(this._envmapHDR, this._envmapLDR);
          }
        }, {
          key: "useIBL",
          get: function get() {
            return this._useIBL;
          },
          set: function set(val) {
            this._setUseIBL(val);

            this._updatePipeline();
          }
        }, {
          key: "useDiffuseMap",
          get: function get() {
            return this._useDiffuseMap;
          },
          set: function set(val) {
            this._useDiffuseMap = val;

            this._updatePipeline();
          }
        }, {
          key: "isRGBE",
          get: function get() {
            if (this.envmap) {
              return this.envmap.isRGBE;
            } else {
              return false;
            }
          }
        }, {
          key: "envmap",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._envmapHDR;
            } else {
              return this._envmapLDR;
            }
          },
          set: function set(val) {
            var root = legacyCC.director.root;
            var isHDR = root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this.setEnvMaps(val, this._envmapLDR);
            } else {
              this.setEnvMaps(this._envmapHDR, val);
            }
          }
        }, {
          key: "diffuseMap",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._diffuseMapHDR;
            } else {
              return this._diffuseMapLDR;
            }
          },
          set: function set(val) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this.setDiffuseMaps(val, this._diffuseMapLDR);
            } else {
              this.setDiffuseMaps(this._diffuseMapHDR, val);
            }
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return Skybox;
      }();
      legacyCC.Skybox = Skybox;

      var _v4 = new Vec4();

      var FogType = Enum({
        LINEAR: 0,
        EXP: 1,
        EXP_SQUARED: 2,
        LAYERED: 3
      });
      var FOG_TYPE_NONE = FogType.LAYERED + 1;
      var Fog = function () {
        function Fog() {
          this._fogColor = new Color('#C8C8C8');
          this._colorArray = new Vec4(0.2, 0.2, 0.2, 1.0);
          this._enabled = false;
          this._accurate = false;
          this._type = 0;
          this._fogDensity = 0.3;
          this._fogStart = 0.5;
          this._fogEnd = 300;
          this._fogAtten = 5;
          this._fogTop = 1.5;
          this._fogRange = 1.2;
        }

        var _proto = Fog.prototype;

        _proto._setType = function _setType(val) {
          this._type = this.enabled ? val : FOG_TYPE_NONE;
        };

        _proto._setEnable = function _setEnable(val) {
          this._enabled = val;
        };

        _proto._setAccurate = function _setAccurate(val) {
          this._accurate = val;
        };

        _proto.initialize = function initialize(fogInfo) {
          this.fogColor = fogInfo.fogColor;

          this._setEnable(fogInfo.enabled);

          this._setAccurate(fogInfo.accurate);

          this._setType(fogInfo.type);

          this.fogDensity = fogInfo.fogDensity;
          this.fogStart = fogInfo.fogStart;
          this.fogEnd = fogInfo.fogEnd;
          this.fogAtten = fogInfo.fogAtten;
          this.fogTop = fogInfo.fogTop;
          this.fogRange = fogInfo.fogRange;
        };

        _proto.activate = function activate() {
          this._updatePipeline();
        };

        _proto._updatePipeline = function _updatePipeline() {
          var root = legacyCC.director.root;
          var value = this.enabled ? this.type : FOG_TYPE_NONE;
          var accurateValue = this.accurate ? 1 : 0;
          var pipeline = root.pipeline;

          if (pipeline.macros.CC_USE_FOG === value && pipeline.macros.CC_USE_ACCURATE_FOG === accurateValue) {
            return;
          }

          pipeline.macros.CC_USE_FOG = value;
          pipeline.macros.CC_USE_ACCURATE_FOG = accurateValue;
          root.onGlobalPipelineStateChanged();
        };

        _proto._destroy = function _destroy() {
        };

        _proto.destroy = function destroy() {
          this._destroy();
        };

        _createClass(Fog, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            this._setEnable(val);

            if (!val) {
              this._type = FOG_TYPE_NONE;

              this._updatePipeline();
            } else {
              this.activate();
            }
          }
        }, {
          key: "accurate",
          get: function get() {
            return this._accurate;
          },
          set: function set(val) {
            this._setAccurate(val);

            this._updatePipeline();
          }
        }, {
          key: "fogColor",
          get: function get() {
            return this._fogColor;
          },
          set: function set(val) {
            this._fogColor.set(val);

            _v4.set(val.x, val.y, val.z, val.w);

            SRGBToLinear(this._colorArray, _v4);
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(val) {
            this._setType(val);

            if (this.enabled) this._updatePipeline();
          }
        }, {
          key: "fogDensity",
          get: function get() {
            return this._fogDensity;
          },
          set: function set(val) {
            this._fogDensity = val;
          }
        }, {
          key: "fogStart",
          get: function get() {
            return this._fogStart;
          },
          set: function set(val) {
            this._fogStart = val;
          }
        }, {
          key: "fogEnd",
          get: function get() {
            return this._fogEnd;
          },
          set: function set(val) {
            this._fogEnd = val;
          }
        }, {
          key: "fogAtten",
          get: function get() {
            return this._fogAtten;
          },
          set: function set(val) {
            this._fogAtten = val;
          }
        }, {
          key: "fogTop",
          get: function get() {
            return this._fogTop;
          },
          set: function set(val) {
            this._fogTop = val;
          }
        }, {
          key: "fogRange",
          get: function get() {
            return this._fogRange;
          },
          set: function set(val) {
            this._fogRange = val;
          }
        }, {
          key: "colorArray",
          get: function get() {
            return this._colorArray;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return Fog;
      }();
      legacyCC.Fog = Fog;

      var Octree = function () {
        function Octree() {
          this._enabled = false;
          this._minPos = new Vec3(0, 0, 0);
          this._maxPos = new Vec3(0, 0, 0);
          this._depth = 0;
        }

        var _proto = Octree.prototype;

        _proto.initialize = function initialize(octreeInfo) {
          this._enabled = octreeInfo.enabled;
          this._minPos = octreeInfo.minPos;
          this._maxPos = octreeInfo.maxPos;
          this._depth = octreeInfo.depth;
        };

        _proto._destroy = function _destroy() {
        };

        _proto.destroy = function destroy() {
          this._destroy();
        };

        _createClass(Octree, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            this._enabled = val;
          }
        }, {
          key: "minPos",
          get: function get() {
            return this._minPos;
          },
          set: function set(val) {
            this._minPos = val;
          }
        }, {
          key: "maxPos",
          get: function get() {
            return this._maxPos;
          },
          set: function set(val) {
            this._maxPos = val;
          }
        }, {
          key: "depth",
          get: function get() {
            return this._depth;
          },
          set: function set(val) {
            this._depth = val;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return Octree;
      }();

      var NodeSpace;

      (function (NodeSpace) {
        NodeSpace[NodeSpace["LOCAL"] = 0] = "LOCAL";
        NodeSpace[NodeSpace["WORLD"] = 1] = "WORLD";
      })(NodeSpace || (NodeSpace = exports('NodeSpace', {})));

      var TransformBit;

      (function (TransformBit) {
        TransformBit[TransformBit["NONE"] = 0] = "NONE";
        TransformBit[TransformBit["POSITION"] = 1] = "POSITION";
        TransformBit[TransformBit["ROTATION"] = 2] = "ROTATION";
        TransformBit[TransformBit["SCALE"] = 4] = "SCALE";
        TransformBit[TransformBit["RS"] = TransformBit.ROTATION | TransformBit.SCALE] = "RS";
        TransformBit[TransformBit["TRS"] = TransformBit.POSITION | TransformBit.ROTATION | TransformBit.SCALE] = "TRS";
        TransformBit[TransformBit["TRS_MASK"] = ~TransformBit.TRS] = "TRS_MASK";
      })(TransformBit || (TransformBit = exports('TransformBit', {})));

      legacyCC.internal.TransformBit = TransformBit;

      function ColorTemperatureToRGB(rgb, kelvin) {
        if (kelvin < 1000.0) {
          kelvin = 1000.0;
        } else if (kelvin > 15000.0) {
          kelvin = 15000.0;
        }

        var kSqr = kelvin * kelvin;
        var u = (0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kSqr) / (1.0 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kSqr);
        var v = (0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kSqr) / (1.0 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kSqr);
        var d = 2.0 * u - 8.0 * v + 4.0;
        var x = 3.0 * u / d;
        var y = 2.0 * v / d;
        var z = 1.0 - x - y;
        var X = 1.0 / y * x;
        var Z = 1.0 / y * z;
        rgb.x = 3.2404542 * X + -1.5371385 + -0.4985314 * Z;
        rgb.y = -0.9692660 * X + 1.8760108 + 0.0415560 * Z;
        rgb.z = 0.0556434 * X + -0.2040259 + 1.0572252 * Z;
      }
      var LightType;

      (function (LightType) {
        LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
        LightType[LightType["SPHERE"] = 1] = "SPHERE";
        LightType[LightType["SPOT"] = 2] = "SPOT";
        LightType[LightType["UNKNOWN"] = 3] = "UNKNOWN";
      })(LightType || (LightType = {}));

      var nt2lm = function nt2lm(size) {
        return 4 * Math.PI * Math.PI * size * size;
      };
      var Light = function () {
        function Light() {
          this._baked = false;
          this._color = new Vec3(1, 1, 1);
          this._colorTemp = 6550.0;
          this._colorTempRGB = new Vec3(1, 1, 1);
          this._scene = null;
          this._node = null;
          this._name = null;
          this._useColorTemperature = false;
          this._type = LightType.UNKNOWN;
        }

        var _proto = Light.prototype;

        _proto._init = function _init() {
        };

        _proto._destroy = function _destroy() {
        };

        _proto.initialize = function initialize() {
          this._init();

          this.color = new Vec3(1, 1, 1);
          this.colorTemperature = 6550.0;
        };

        _proto.attachToScene = function attachToScene(scene) {
          this._scene = scene;
        };

        _proto.detachFromScene = function detachFromScene() {
          this._scene = null;
        };

        _proto.destroy = function destroy() {
          this._name = null;
          this._node = null;

          this._destroy();
        };

        _proto.update = function update() {};

        _createClass(Light, [{
          key: "baked",
          get: function get() {
            return this._baked;
          },
          set: function set(val) {
            this._baked = val;
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(color) {
            this._color.set(color);
          }
        }, {
          key: "useColorTemperature",
          get: function get() {
            return this._useColorTemperature;
          },
          set: function set(enable) {
            this._useColorTemperature = enable;
          }
        }, {
          key: "colorTemperature",
          get: function get() {
            return this._colorTemp;
          },
          set: function set(val) {
            this._colorTemp = val;
            ColorTemperatureToRGB(this._colorTempRGB, this._colorTemp);
          }
        }, {
          key: "colorTemperatureRGB",
          get: function get() {
            return this._colorTempRGB;
          }
        }, {
          key: "node",
          get: function get() {
            return this._node;
          },
          set: function set(n) {
            this._node = n;

            if (this._node) {
              this._node.hasChangedFlags |= TransformBit.ROTATION;
            }
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          }
        }, {
          key: "name",
          get: function get() {
            return this._name;
          },
          set: function set(n) {
            this._name = n;
          }
        }, {
          key: "scene",
          get: function get() {
            return this._scene;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return Light;
      }();

      var _forward = new Vec3(0, 0, -1);

      var _v3 = new Vec3();

      var DirectionalLight = function (_Light) {
        _inheritsLoose(DirectionalLight, _Light);

        function DirectionalLight() {
          var _this;

          _this = _Light.call(this) || this;
          _this._dir = new Vec3(1.0, -1.0, -1.0);
          _this._illuminanceHDR = Ambient.SUN_ILLUM;
          _this._illuminanceLDR = 1.0;
          _this._shadowEnabled = false;
          _this._shadowPcf = PCFType.HARD;
          _this._shadowBias = 0.00001;
          _this._shadowNormalBias = 0.0;
          _this._shadowSaturation = 1.0;
          _this._shadowDistance = 100;
          _this._shadowInvisibleOcclusionRange = 200;
          _this._shadowFixedArea = false;
          _this._shadowNear = 0.1;
          _this._shadowFar = 10.0;
          _this._shadowOrthoSize = 5;
          _this._type = LightType.DIRECTIONAL;
          return _this;
        }

        var _proto = DirectionalLight.prototype;

        _proto.initialize = function initialize() {
          _Light.prototype.initialize.call(this);

          this.illuminance = Ambient.SUN_ILLUM;
          this.direction = new Vec3(1.0, -1.0, -1.0);
        };

        _proto.update = function update() {
          if (this._node && this._node.hasChangedFlags) {
            this.direction = Vec3.transformQuat(_v3, _forward, this._node.worldRotation);
          }
        };

        _createClass(DirectionalLight, [{
          key: "direction",
          get: function get() {
            return this._dir;
          },
          set: function set(dir) {
            Vec3.normalize(this._dir, dir);
          }
        }, {
          key: "illuminance",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._illuminanceHDR;
            } else {
              return this._illuminanceLDR;
            }
          },
          set: function set(value) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this.illuminanceHDR = value;
            } else {
              this.illuminanceLDR = value;
            }
          }
        }, {
          key: "illuminanceHDR",
          get: function get() {
            return this._illuminanceHDR;
          },
          set: function set(value) {
            this._illuminanceHDR = value;
          }
        }, {
          key: "illuminanceLDR",
          get: function get() {
            return this._illuminanceLDR;
          },
          set: function set(value) {
            this._illuminanceLDR = value;
          }
        }, {
          key: "shadowEnabled",
          get: function get() {
            return this._shadowEnabled;
          },
          set: function set(val) {
            this._shadowEnabled = val;
          }
        }, {
          key: "shadowPcf",
          get: function get() {
            return this._shadowPcf;
          },
          set: function set(val) {
            this._shadowPcf = val;
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(val) {
            this._shadowBias = val;
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(val) {
            this._shadowNormalBias = val;
          }
        }, {
          key: "shadowSaturation",
          get: function get() {
            return this._shadowSaturation;
          },
          set: function set(val) {
            this._shadowSaturation = val;
          }
        }, {
          key: "shadowDistance",
          get: function get() {
            return this._shadowDistance;
          },
          set: function set(val) {
            this._shadowDistance = Math.min(val, Shadows.MAX_FAR);
          }
        }, {
          key: "shadowInvisibleOcclusionRange",
          get: function get() {
            return this._shadowInvisibleOcclusionRange;
          },
          set: function set(val) {
            this._shadowInvisibleOcclusionRange = Math.min(val, Shadows.MAX_FAR);
          }
        }, {
          key: "shadowFixedArea",
          get: function get() {
            return this._shadowFixedArea;
          },
          set: function set(val) {
            this._shadowFixedArea = val;
          }
        }, {
          key: "shadowNear",
          get: function get() {
            return this._shadowNear;
          },
          set: function set(val) {
            this._shadowNear = val;
          }
        }, {
          key: "shadowFar",
          get: function get() {
            return this._shadowFar;
          },
          set: function set(val) {
            this._shadowFar = Math.min(val, Shadows.MAX_FAR);
          }
        }, {
          key: "shadowOrthoSize",
          get: function get() {
            return this._shadowOrthoSize;
          },
          set: function set(val) {
            this._shadowOrthoSize = val;
          }
        }]);

        return DirectionalLight;
      }(Light);

      var SphereLight = function (_Light) {
        _inheritsLoose(SphereLight, _Light);

        var _proto = SphereLight.prototype;

        _proto._init = function _init() {
          _Light.prototype._init.call(this);
        };

        _proto._destroy = function _destroy() {
          _Light.prototype._destroy.call(this);
        };

        function SphereLight() {
          var _this;

          _this = _Light.call(this) || this;
          _this._needUpdate = false;
          _this._size = 0.15;
          _this._range = 1.0;
          _this._luminanceHDR = 0;
          _this._luminanceLDR = 0;
          _this._pos = void 0;
          _this._aabb = void 0;
          _this._aabb = AABB.create();
          _this._pos = new Vec3();
          _this._type = LightType.SPHERE;
          return _this;
        }

        _proto.initialize = function initialize() {
          _Light.prototype.initialize.call(this);

          var size = 0.15;
          this.size = size;
          this.range = 1.0;
          this.luminanceHDR = 1700 / nt2lm(size);
          this.luminanceLDR = 1.0;
        };

        _proto.update = function update() {
          if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
            this._node.getWorldPosition(this._pos);

            var range = this._range;
            AABB.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, range, range, range);
            this._needUpdate = false;
          }
        };

        _createClass(SphereLight, [{
          key: "position",
          get: function get() {
            return this._pos;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(size) {
            this._size = size;
          }
        }, {
          key: "range",
          get: function get() {
            return this._range;
          },
          set: function set(range) {
            this._range = range;

            this._needUpdate = true;
          }
        }, {
          key: "luminance",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._luminanceHDR;
            } else {
              return this._luminanceLDR;
            }
          },
          set: function set(value) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this.luminanceHDR = value;
            } else {
              this.luminanceLDR = value;
            }
          }
        }, {
          key: "luminanceHDR",
          get: function get() {
            return this._luminanceHDR;
          },
          set: function set(value) {
            this._luminanceHDR = value;
          }
        }, {
          key: "luminanceLDR",
          set: function set(value) {
            this._luminanceLDR = value;
          }
        }, {
          key: "aabb",
          get: function get() {
            return this._aabb;
          }
        }]);

        return SphereLight;
      }(Light);

      var _forward$1 = new Vec3(0, 0, -1);

      var _qt = new Quat();

      var _matView = new Mat4();

      var _matProj = new Mat4();

      var _matViewProj = new Mat4();

      var _matViewProjInv = new Mat4();

      var SpotLight = function (_Light) {
        _inheritsLoose(SpotLight, _Light);

        var _proto = SpotLight.prototype;

        _proto._init = function _init() {
          _Light.prototype._init.call(this);
        };

        _proto._destroy = function _destroy() {
          _Light.prototype._destroy.call(this);
        };

        _proto._setDirection = function _setDirection(dir) {
          this._dir.set(dir);
        };

        function SpotLight() {
          var _this;

          _this = _Light.call(this) || this;
          _this._dir = new Vec3(1.0, -1.0, -1.0);
          _this._range = 5.0;
          _this._spotAngle = Math.cos(Math.PI / 6);
          _this._pos = void 0;
          _this._aabb = void 0;
          _this._frustum = void 0;
          _this._angle = 0;
          _this._needUpdate = false;
          _this._size = 0.15;
          _this._luminanceHDR = 0;
          _this._luminanceLDR = 0;
          _this._shadowEnabled = false;
          _this._shadowPcf = PCFType.HARD;
          _this._shadowBias = 0.00001;
          _this._shadowNormalBias = 0.0;
          _this._aabb = AABB.create();
          _this._frustum = Frustum.create();
          _this._pos = new Vec3();
          _this._type = LightType.SPOT;
          return _this;
        }

        _proto.initialize = function initialize() {
          _Light.prototype.initialize.call(this);

          var size = 0.15;
          this.size = size;
          this.luminanceHDR = 1700 / nt2lm(size);
          this.luminanceLDR = 1.0;
          this.range = Math.cos(Math.PI / 6);

          this._setDirection(new Vec3(1.0, -1.0, -1.0));
        };

        _proto.update = function update() {
          if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
            this._node.getWorldPosition(this._pos);

            Vec3.transformQuat(this._dir, _forward$1, this._node.getWorldRotation(_qt));
            Vec3.normalize(this._dir, this._dir);
            AABB.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range);

            this._node.getWorldRT(_matView);

            Mat4.invert(_matView, _matView);
            Mat4.perspective(_matProj, this._angle, 1.0, 0.001, this._range);
            Mat4.multiply(_matViewProj, _matProj, _matView);

            this._frustum.update(_matViewProj, _matViewProjInv);

            this._needUpdate = false;
          }
        };

        _createClass(SpotLight, [{
          key: "position",
          get: function get() {
            return this._pos;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(size) {
            this._size = size;
          }
        }, {
          key: "range",
          get: function get() {
            return this._range;
          },
          set: function set(range) {
            this._range = range;

            this._needUpdate = true;
          }
        }, {
          key: "luminance",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._luminanceHDR;
            } else {
              return this._luminanceLDR;
            }
          },
          set: function set(value) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this.luminanceHDR = value;
            } else {
              this.luminanceLDR = value;
            }
          }
        }, {
          key: "luminanceHDR",
          get: function get() {
            return this._luminanceHDR;
          },
          set: function set(value) {
            this._luminanceHDR = value;
          }
        }, {
          key: "luminanceLDR",
          get: function get() {
            return this._luminanceLDR;
          },
          set: function set(value) {
            this._luminanceLDR = value;
          }
        }, {
          key: "direction",
          get: function get() {
            return this._dir;
          }
        }, {
          key: "spotAngle",
          get: function get() {
            return this._spotAngle;
          },
          set: function set(val) {
            this._angle = val;
            this._spotAngle = Math.cos(val * 0.5);

            this._needUpdate = true;
          }
        }, {
          key: "angle",
          get: function get() {
            return this._angle;
          }
        }, {
          key: "aabb",
          get: function get() {
            return this._aabb;
          }
        }, {
          key: "frustum",
          get: function get() {
            return this._frustum;
          }
        }, {
          key: "shadowEnabled",
          get: function get() {
            return this._shadowEnabled;
          },
          set: function set(val) {
            this._shadowEnabled = val;
          }
        }, {
          key: "shadowPcf",
          get: function get() {
            return this._shadowPcf;
          },
          set: function set(val) {
            this._shadowPcf = val;
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(val) {
            this._shadowBias = val;
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(val) {
            this._shadowNormalBias = val;
          }
        }]);

        return SpotLight;
      }(Light);

      var RenderScene = function () {
        RenderScene.registerCreateFunc = function registerCreateFunc(root) {
          root._createSceneFun = function (_root) {
            return new RenderScene(_root);
          };
        };

        function RenderScene(root) {
          this._root = void 0;
          this._name = '';
          this._cameras = [];
          this._models = [];
          this._batches = [];
          this._directionalLights = [];
          this._sphereLights = [];
          this._spotLights = [];
          this._mainLight = null;
          this._modelId = 0;
          this._root = root;

          this._createNativeObject();
        }

        var _proto = RenderScene.prototype;

        _proto.initialize = function initialize(info) {
          this._name = info.name;
          return true;
        };

        _proto.activate = function activate() {
        };

        _proto.update = function update(stamp) {

          var mainLight = this._mainLight;

          if (mainLight) {
            mainLight.update();
          }

          var sphereLights = this._sphereLights;

          for (var _i = 0; _i < sphereLights.length; _i++) {
            var light = sphereLights[_i];
            light.update();
          }

          var spotLights = this._spotLights;

          for (var _i2 = 0; _i2 < spotLights.length; _i2++) {
            var _light = spotLights[_i2];

            _light.update();
          }

          var models = this._models;

          for (var _i3 = 0; _i3 < models.length; _i3++) {
            var model = models[_i3];

            if (model.enabled) {
              model.updateTransform(stamp);
              model.updateUBOs(stamp);
            }
          }
        };

        _proto.destroy = function destroy() {
          this.removeCameras();
          this.removeSphereLights();
          this.removeSpotLights();
          this.removeModels();

          this._destroy();
        };

        _proto.addCamera = function addCamera(cam) {
          cam.attachToScene(this);

          this._cameras.push(cam);
        };

        _proto.removeCamera = function removeCamera(camera) {
          for (var i = 0; i < this._cameras.length; ++i) {
            if (this._cameras[i] === camera) {
              this._cameras.splice(i, 1);

              camera.detachFromScene();
              return;
            }
          }
        };

        _proto.removeCameras = function removeCameras() {
          for (var _iterator = _createForOfIteratorHelperLoose(this._cameras), _step; !(_step = _iterator()).done;) {
            var camera = _step.value;
            camera.detachFromScene();
          }

          this._cameras.splice(0);
        };

        _proto.setMainLight = function setMainLight(dl) {
          this._mainLight = dl;
        };

        _proto.unsetMainLight = function unsetMainLight(dl) {
          if (this._mainLight === dl) {
            var dlList = this._directionalLights;

            if (dlList.length) {
              this.setMainLight(dlList[dlList.length - 1]);

              if (this._mainLight.node) {
                this._mainLight.node.hasChangedFlags |= TransformBit.ROTATION;
              }

              return;
            }

            this.setMainLight(null);
          }
        };

        _proto.addDirectionalLight = function addDirectionalLight(dl) {
          dl.attachToScene(this);

          this._directionalLights.push(dl);
        };

        _proto.removeDirectionalLight = function removeDirectionalLight(dl) {
          for (var i = 0; i < this._directionalLights.length; ++i) {
            if (this._directionalLights[i] === dl) {
              dl.detachFromScene();

              this._directionalLights.splice(i, 1);

              return;
            }
          }
        };

        _proto.addSphereLight = function addSphereLight(pl) {
          pl.attachToScene(this);

          this._sphereLights.push(pl);
        };

        _proto.removeSphereLight = function removeSphereLight(pl) {
          for (var i = 0; i < this._sphereLights.length; ++i) {
            if (this._sphereLights[i] === pl) {
              pl.detachFromScene();

              this._sphereLights.splice(i, 1);

              return;
            }
          }
        };

        _proto.addSpotLight = function addSpotLight(sl) {
          sl.attachToScene(this);

          this._spotLights.push(sl);
        };

        _proto.removeSpotLight = function removeSpotLight(sl) {
          for (var i = 0; i < this._spotLights.length; ++i) {
            if (this._spotLights[i] === sl) {
              sl.detachFromScene();

              this._spotLights.splice(i, 1);

              return;
            }
          }
        };

        _proto.removeSphereLights = function removeSphereLights() {
          for (var i = 0; i < this._sphereLights.length; ++i) {
            this._sphereLights[i].detachFromScene();
          }

          this._sphereLights.length = 0;
        };

        _proto.removeSpotLights = function removeSpotLights() {
          for (var i = 0; i < this._spotLights.length; ++i) {
            this._spotLights[i].detachFromScene();
          }

          this._spotLights = [];
        };

        _proto.addModel = function addModel(m) {
          m.attachToScene(this);

          this._models.push(m);
        };

        _proto.removeModel = function removeModel(model) {
          for (var i = 0; i < this._models.length; ++i) {
            if (this._models[i] === model) {
              model.detachFromScene();

              this._models.splice(i, 1);

              return;
            }
          }
        };

        _proto.removeModels = function removeModels() {
          for (var _iterator2 = _createForOfIteratorHelperLoose(this._models), _step2; !(_step2 = _iterator2()).done;) {
            var m = _step2.value;
            m.detachFromScene();
            m.destroy();
          }

          this._models.length = 0;
        };

        _proto.addBatch = function addBatch(batch) {
          this._batches.push(batch);
        };

        _proto.removeBatch = function removeBatch(batch) {
          for (var i = 0; i < this._batches.length; ++i) {
            if (this._batches[i] === batch) {
              this._batches.splice(i, 1);

              return;
            }
          }
        };

        _proto.removeBatches = function removeBatches() {
          this._batches.length = 0;
        };

        _proto.onGlobalPipelineStateChanged = function onGlobalPipelineStateChanged() {
          for (var _iterator3 = _createForOfIteratorHelperLoose(this._models), _step3; !(_step3 = _iterator3()).done;) {
            var m = _step3.value;
            m.onGlobalPipelineStateChanged();
          }
        };

        _proto.generateModelId = function generateModelId() {
          return this._modelId++;
        };

        _proto._destroy = function _destroy() {
        };

        _proto._createNativeObject = function _createNativeObject() {
        };

        _createClass(RenderScene, [{
          key: "root",
          get: function get() {
            return this._root;
          }
        }, {
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "cameras",
          get: function get() {
            return this._cameras;
          }
        }, {
          key: "mainLight",
          get: function get() {
            return this._mainLight;
          }
        }, {
          key: "sphereLights",
          get: function get() {
            return this._sphereLights;
          }
        }, {
          key: "spotLights",
          get: function get() {
            return this._spotLights;
          }
        }, {
          key: "models",
          get: function get() {
            return this._models;
          }
        }, {
          key: "batches",
          get: function get() {
            return this._batches;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return RenderScene;
      }();

      var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get CameraFOVAxis () { return CameraFOVAxis; },
        get CameraProjection () { return CameraProjection; },
        get CameraAperture () { return CameraAperture; },
        get CameraISO () { return CameraISO; },
        get CameraShutter () { return CameraShutter; },
        SKYBOX_FLAG: SKYBOX_FLAG,
        Camera: Camera,
        get ModelType () { return ModelType; },
        Model: Model,
        SubModel: SubModel,
        Ambient: Ambient,
        EnvironmentLightingType: EnvironmentLightingType,
        Skybox: Skybox,
        ShadowSize: ShadowSize,
        ShadowType: ShadowType,
        PCFType: PCFType,
        Shadows: Shadows,
        FogType: FogType,
        Fog: Fog,
        Octree: Octree,
        ColorTemperatureToRGB: ColorTemperatureToRGB,
        get LightType () { return LightType; },
        nt2lm: nt2lm,
        Light: Light,
        DirectionalLight: DirectionalLight,
        SphereLight: SphereLight,
        SpotLight: SpotLight,
        RenderScene: RenderScene
      });

      function createIA(device, data) {
        if (!data.positions) {
          console.error('The data must have positions field');
          return null;
        }

        var verts = [];
        var vcount = data.positions.length / 3;

        for (var i = 0; i < vcount; ++i) {
          verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);

          if (data.normals) {
            verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
          }

          if (data.uvs) {
            verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
          }

          if (data.colors) {
            verts.push(data.colors[3 * i], data.colors[3 * i + 1], data.colors[3 * i + 2]);
          }
        }

        var vfmt = [];
        vfmt.push(new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F));

        if (data.normals) {
          vfmt.push(new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F));
        }

        if (data.uvs) {
          vfmt.push(new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F));
        }

        if (data.colors) {
          vfmt.push(new Attribute(AttributeName.ATTR_COLOR, Format.RGB32F));
        }

        var vb = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, verts.length * 4, verts.length * 4 / vcount));
        vb.update(new Float32Array(verts));
        var ib = null;

        if (data.indices) {
          ib = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, data.indices.length * 2, 2));
          ib.update(new Uint16Array(data.indices));
        }

        return device.createInputAssembler(new InputAssemblerInfo(vfmt, [vb], ib));
      }

      var RenderQueue;

      (function (RenderQueue) {
        RenderQueue[RenderQueue["OPAQUE"] = 0] = "OPAQUE";
        RenderQueue[RenderQueue["TRANSPARENT"] = 1] = "TRANSPARENT";
        RenderQueue[RenderQueue["OVERLAY"] = 2] = "OVERLAY";
      })(RenderQueue || (RenderQueue = {}));

      var PassStage;

      (function (PassStage) {
        PassStage[PassStage["DEFAULT"] = 1] = "DEFAULT";
        PassStage[PassStage["FORWARD"] = 2] = "FORWARD";
        PassStage[PassStage["SHADOWCAST"] = 4] = "SHADOWCAST";
      })(PassStage || (PassStage = {}));

      function nearestPOT(num) {
        --num;
        num |= num >> 16;
        num |= num >> 8;
        num |= num >> 4;
        num |= num >> 2;
        num |= num >> 1;
        ++num;
        return num;
      }

      function roundUp(n, alignment) {
        return Math.ceil(n / alignment) * alignment;
      }

      var TextureBufferPool = function () {
        function TextureBufferPool(device) {
          this._device = void 0;
          this._format = Format.UNKNOWN;
          this._formatSize = 0;
          this._chunks = [];
          this._chunkCount = 0;
          this._handles = [];
          this._region0 = new BufferTextureCopy();
          this._region1 = new BufferTextureCopy();
          this._region2 = new BufferTextureCopy();
          this._roundUpFn = null;
          this._bufferViewCtor = Uint8Array;
          this._channels = 4;
          this._alignment = 1;
          this._device = device;
        }

        var _proto = TextureBufferPool.prototype;

        _proto.initialize = function initialize(info) {
          var formatInfo = FormatInfos[info.format];
          this._format = info.format;
          this._formatSize = formatInfo.size;
          this._channels = formatInfo.count;
          this._bufferViewCtor = getTypedArrayConstructor(formatInfo);
          this._roundUpFn = info.roundUpFn || null;
          this._alignment = info.alignment || 1;

          if (info.inOrderFree) {
            this.alloc = this._McDonaldAlloc;
          }
        };

        _proto.destroy = function destroy() {
          for (var i = 0; i < this._chunkCount; ++i) {
            var chunk = this._chunks[i];
            chunk.texture.destroy();
          }

          this._chunks.length = 0;
          this._handles.length = 0;
        };

        _proto.alloc = function alloc(size, chunkIdx) {
          size = roundUp(size, this._alignment);
          var index = -1;
          var start = -1;

          if (chunkIdx !== undefined) {
            index = chunkIdx;
            start = this._findAvailableSpace(size, index);
          }

          if (start < 0) {
            for (var i = 0; i < this._chunkCount; ++i) {
              index = i;
              start = this._findAvailableSpace(size, index);

              if (start >= 0) {
                break;
              }
            }
          }

          if (start >= 0) {
            var chunk = this._chunks[index];
            chunk.start += size;
            var handle = {
              chunkIdx: index,
              start: start,
              end: start + size,
              texture: chunk.texture
            };

            this._handles.push(handle);

            return handle;
          }

          var targetSize = Math.sqrt(size / this._formatSize);
          var texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

          var newChunk = this._chunks[this.createChunk(texLength)];

          newChunk.start += size;
          var texHandle = {
            chunkIdx: this._chunkCount - 1,
            start: 0,
            end: size,
            texture: newChunk.texture
          };

          this._handles.push(texHandle);

          return texHandle;
        };

        _proto.free = function free(handle) {
          for (var i = 0; i < this._handles.length; ++i) {
            if (this._handles[i] === handle) {
              this._chunks[handle.chunkIdx].end = handle.end;

              this._handles.splice(i, 1);

              return;
            }
          }
        };

        _proto.createChunk = function createChunk(length) {
          var texSize = length * length * this._formatSize;
          debug("TextureBufferPool: Allocate chunk " + this._chunkCount + ", size: " + texSize + ", format: " + this._format);

          var texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, this._format, length, length));

          var chunk = {
            texture: texture,
            size: texSize,
            start: 0,
            end: texSize
          };
          this._chunks[this._chunkCount] = chunk;
          return this._chunkCount++;
        };

        _proto.update = function update(handle, buffer) {
          var buffers = [];
          var regions = [];
          var start = handle.start / this._formatSize;
          var remainSize = buffer.byteLength / this._formatSize;
          var offsetX = start % handle.texture.width;
          var offsetY = Math.floor(start / handle.texture.width);
          var copySize = Math.min(handle.texture.width - offsetX, remainSize);
          var begin = 0;

          if (offsetX > 0) {
            this._region0.texOffset.x = offsetX;
            this._region0.texOffset.y = offsetY;
            this._region0.texExtent.width = copySize;
            this._region0.texExtent.height = 1;
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
            regions.push(this._region0);
            offsetX = 0;
            offsetY += 1;
            remainSize -= copySize;
            begin += copySize;
          }

          if (remainSize > 0) {
            this._region1.texOffset.x = offsetX;
            this._region1.texOffset.y = offsetY;

            if (remainSize > handle.texture.width) {
              this._region1.texExtent.width = handle.texture.width;
              this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width);
              copySize = this._region1.texExtent.width * this._region1.texExtent.height;
            } else {
              copySize = remainSize;
              this._region1.texExtent.width = copySize;
              this._region1.texExtent.height = 1;
            }

            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
            regions.push(this._region1);
            offsetX = 0;
            offsetY += this._region1.texExtent.height;
            remainSize -= copySize;
            begin += copySize;
          }

          if (remainSize > 0) {
            this._region2.texOffset.x = offsetX;
            this._region2.texOffset.y = offsetY;
            this._region2.texExtent.width = remainSize;
            this._region2.texExtent.height = 1;
            buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels));
            regions.push(this._region2);
          }

          this._device.copyBuffersToTexture(buffers, handle.texture, regions);
        };

        _proto._findAvailableSpace = function _findAvailableSpace(size, chunkIdx) {
          var chunk = this._chunks[chunkIdx];
          var isFound = false;
          var start = chunk.start;

          if (start + size <= chunk.size) {
            isFound = true;
          } else {
            start = 0;

            var handles = this._handles.filter(function (h) {
              return h.chunkIdx === chunkIdx;
            }).sort(function (a, b) {
              return a.start - b.start;
            });

            for (var i = 0; i < handles.length; i++) {
              var handle = handles[i];

              if (start + size <= handle.start) {
                isFound = true;
                break;
              }

              start = handle.end;
            }

            if (!isFound && start + size <= chunk.size) {
              isFound = true;
            }
          }

          return isFound ? start : -1;
        };

        _proto._McDonaldAlloc = function _McDonaldAlloc(size) {
          size = roundUp(size, this._alignment);

          for (var i = 0; i < this._chunkCount; ++i) {
            var chunk = this._chunks[i];
            var isFound = false;
            var start = chunk.start;

            if (start + size <= chunk.end) {
              isFound = true;
            } else if (start > chunk.end) {
              if (start + size <= chunk.size) {
                isFound = true;
              } else if (size <= chunk.end) {
                chunk.start = start = 0;
                isFound = true;
              }
            } else if (start === chunk.end) {
              chunk.start = start = 0;
              chunk.end = chunk.size;

              if (size <= chunk.end) {
                isFound = true;
              }
            }

            if (isFound) {
              chunk.start += size;
              var handle = {
                chunkIdx: i,
                start: start,
                end: start + size,
                texture: chunk.texture
              };

              this._handles.push(handle);

              return handle;
            }
          }

          var targetSize = Math.sqrt(size / this._formatSize);
          var texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

          var newChunk = this._chunks[this.createChunk(texLength)];

          newChunk.start += size;
          var texHandle = {
            chunkIdx: this._chunkCount,
            start: 0,
            end: size,
            texture: newChunk.texture
          };

          this._handles.push(texHandle);

          return texHandle;
        };

        return TextureBufferPool;
      }();

      removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
        name: 'raycastUI2DNode'
      }, {
        name: 'raycastUINode'
      }]);
      removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
        name: 'raycastAll',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastAllModels',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastSingleModel',
        suggest: 'using intersect.rayModel in geometry'
      }, {
        name: 'raycastAllCanvas',
        suggest: 'using intersect.rayAABB in geometry'
      }, {
        name: 'rayResultCanvas'
      }, {
        name: 'rayResultModels'
      }, {
        name: 'rayResultAll'
      }, {
        name: 'rayResultSingleModel'
      }]);
      var CameraVisFlags = {};
      removeProperty(CameraVisFlags, 'CameraVisFlags', [{
        name: 'GENERAL'
      }]);
      replaceProperty(CameraVisFlags, 'CameraVisFlags', [{
        name: 'PROFILER',
        newName: 'PROFILER',
        target: Layers.BitMask,
        targetName: 'PROFILER'
      }, {
        name: 'GIZMOS',
        newName: 'GIZMOS',
        target: Layers.BitMask,
        targetName: 'GIZMOS'
      }, {
        name: 'EDITOR',
        newName: 'EDITOR',
        target: Layers.BitMask,
        targetName: 'EDITOR'
      }, {
        name: 'UI',
        newName: 'UI',
        target: Layers.BitMask,
        targetName: 'UI_3D'
      }, {
        name: 'UI2D',
        newName: 'UI2D',
        target: Layers.BitMask,
        targetName: 'UI_2D'
      }]);
      legacyCC.CameraVisFlags = CameraVisFlags;
      var VisibilityFlags = {};
      removeProperty(VisibilityFlags, 'VisibilityFlags', [{
        name: 'GENERAL'
      }]);
      replaceProperty(VisibilityFlags, 'VisibilityFlags', [{
        name: 'ALWALS',
        newName: 'ALWALS',
        target: Layers.Enum,
        targetName: 'ALWALS'
      }, {
        name: 'PROFILER',
        newName: 'PROFILER',
        target: Layers.Enum,
        targetName: 'PROFILER'
      }, {
        name: 'GIZMOS',
        newName: 'GIZMOS',
        target: Layers.Enum,
        targetName: 'GIZMOS'
      }, {
        name: 'EDITOR',
        newName: 'EDITOR',
        target: Layers.Enum,
        targetName: 'EDITOR'
      }, {
        name: 'UI',
        newName: 'UI',
        target: Layers.Enum,
        targetName: 'UI_3D'
      }, {
        name: 'UI2D',
        newName: 'UI2D',
        target: Layers.Enum,
        targetName: 'UI_2D'
      }]);
      legacyCC.VisibilityFlags = VisibilityFlags;
      replaceProperty(Pass.prototype, 'Pass.prototype', [{
        name: 'getBindingTypeFromHandle',
        newName: 'getDescriptorTypeFromHandle'
      }]);
      removeProperty(Camera.prototype, 'Camera.prototype', [{
        name: 'getSplitFrustum'
      }, {
        name: 'setMatView'
      }, {
        name: 'setMatViewInv'
      }, {
        name: 'setMatProjInv'
      }, {
        name: 'setMatViewProjInv'
      }, {
        name: 'setMatProj'
      }, {
        name: 'setMatViewProj'
      }, {
        name: 'getMatViewInv'
      }]);
      removeProperty(Shadows.prototype, 'Shadows.prototype', [{
        name: 'aspect'
      }, {
        name: 'selfShadow'
      }, {
        name: 'linear'
      }, {
        name: 'packing'
      }, {
        name: 'autoAdapt'
      }, {
        name: 'fixedArea'
      }, {
        name: 'pcf'
      }, {
        name: 'bias'
      }, {
        name: 'normalBias'
      }, {
        name: 'near'
      }, {
        name: 'far'
      }, {
        name: 'shadowDistance'
      }, {
        name: 'invisibleOcclusionRange'
      }, {
        name: 'orthoSize'
      }, {
        name: 'saturation'
      }]);
      removeProperty(SpotLight.prototype, 'SpotLight.prototype', [{
        name: 'aspect'
      }]);

      var addStage = config.addStage;

      var renderer = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addStage: addStage,
        scene: index$2,
        createIA: createIA,
        get RenderQueue () { return RenderQueue; },
        get PassStage () { return PassStage; },
        genHandle: genHandle,
        getTypeFromHandle: getTypeFromHandle,
        getBindingFromHandle: getBindingFromHandle,
        getCountFromHandle: getCountFromHandle,
        getOffsetFromHandle: getOffsetFromHandle,
        customizeType: customizeType,
        type2reader: type2reader,
        type2writer: type2writer,
        getDefaultFromType: getDefaultFromType,
        overrideMacros: overrideMacros,
        get BatchingSchemes () { return BatchingSchemes; },
        Pass: Pass,
        getDeviceShaderVersion: getDeviceShaderVersion,
        programLib: programLib,
        nearestPOT: nearestPOT,
        TextureBufferPool: TextureBufferPool,
        MaterialInstance: MaterialInstance,
        PassInstance: PassInstance,
        get PoolType () { return PoolType; },
        NULL_HANDLE: NULL_HANDLE,
        get NodeView () { return NodeView; },
        NodePool: NodePool,
        get PassView () { return PassView; },
        PassPool: PassPool,
        get AABBView () { return AABBView; },
        AABBPool: AABBPool,
        RenderScene: RenderScene,
        NativeNode: NativeNode,
        NativeScene: NativeScene,
        NativeAABB: NativeAABB,
        NativeModel: NativeModel,
        NativeSkinningModel: NativeSkinningModel,
        NativeBakedAnimInfo: NativeBakedAnimInfo,
        NativeBakedJointInfo: NativeBakedJointInfo,
        NativeBakedSkinningModel: NativeBakedSkinningModel,
        NativeLight: NativeLight,
        NativeDirectionalLight: NativeDirectionalLight,
        NativeSphereLight: NativeSphereLight,
        NativeSpotLight: NativeSpotLight,
        NaitveSkybox: NaitveSkybox,
        NativeFog: NativeFog,
        NativeRenderWindow: NativeRenderWindow,
        NativeCamera: NativeCamera,
        NativePass: NativePass,
        NativeSubModel: NativeSubModel,
        NativeDrawBatch2D: NativeDrawBatch2D,
        NativeRenderScene: NativeRenderScene,
        NativeOctree: NativeOctree,
        NativeAmbient: NativeAmbient,
        NativeShadow: NativeShadow,
        NativeRoot: NativeRoot,
        NativeJointTransform: NativeJointTransform,
        NativeJointInfo: NativeJointInfo,
        NativePipelineSharedSceneData: NativePipelineSharedSceneData,
        NativeGeometryRenderer: NativeGeometryRenderer,
        CameraVisFlags: CameraVisFlags,
        VisibilityFlags: VisibilityFlags
      });
      exports('renderer', renderer);

      var _min$1 = new Vec3();

      var _max$1 = new Vec3();

      var _v0 = new Vec3();

      var _v1 = new Vec3();

      var _v2 = new Vec3();

      var _v3$1 = new Vec3();

      var _v4$1 = new Vec3();

      var _v5 = new Vec3();

      var _v6 = new Vec3();

      var _v7 = new Vec3();

      var GEOMETRY_DEPTH_TYPE_COUNT = 2;
      var GEOMETRY_NO_DEPTH_TEST_PASS_NUM = 1;
      var GEOMETRY_DEPTH_TEST_PASS_NUM = 2;
      var GEOMETRY_VERTICES_PER_LINE = 2;
      var GEOMETRY_VERTICES_PER_TRIANGLE = 3;
      var GEOMETRY_MAX_LINES = 100000;
      var GEOMETRY_MAX_DASHED_LINES = 10000;
      var GEOMETRY_MAX_TRIANGLES = 10000;
      var GeometryType;

      (function (GeometryType) {
        GeometryType[GeometryType["LINE"] = 0] = "LINE";
        GeometryType[GeometryType["DASHED_LINE"] = 1] = "DASHED_LINE";
        GeometryType[GeometryType["TRIANGLE"] = 2] = "TRIANGLE";
      })(GeometryType || (GeometryType = {}));

      var GeometryVertexBuffer = function () {
        function GeometryVertexBuffer() {
          this._maxVertices = 0;
          this._vertexCount = 0;
          this._stride = 0;
        }

        var _proto = GeometryVertexBuffer.prototype;

        _proto.init = function init(device, maxVertices, stride, attributes) {
          this._maxVertices = maxVertices;
          this._vertexCount = 0;
          this._stride = stride;
          this._vertices = new Float32Array(maxVertices * stride / Float32Array.BYTES_PER_ELEMENT);

          {
            this._buffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, maxVertices * stride, stride));
            this._inputAssembler = device.createInputAssembler(new InputAssemblerInfo(attributes, [this._buffer], null));
          }
        };

        _proto.empty = function empty() {
          return this._vertexCount === 0;
        };

        _proto.reset = function reset() {
          this._vertexCount = 0;
        };

        _proto.update = function update() {
          if (!this.empty()) {
            var count = Math.min(this._vertexCount, this._maxVertices);
            var size = count * this._stride;

            this._buffer.update(this._vertices, size);
          }
        };

        _proto.destroy = function destroy() {
          if (this._inputAssembler) {
            this._inputAssembler.destroy();
          }

          if (this._buffer) {
            this._buffer.destroy();
          }
        };

        return GeometryVertexBuffer;
      }();

      var GeometryVertexBuffers = function GeometryVertexBuffers() {
        this.lines = [];
        this.dashedLines = [];
        this.triangles = [];

        for (var i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
          this.lines[i] = new GeometryVertexBuffer();
          this.dashedLines[i] = new GeometryVertexBuffer();
          this.triangles[i] = new GeometryVertexBuffer();
        }
      };

      var GeometryRenderer = function () {
        function GeometryRenderer() {
          this._device = null;
          this._pipeline = null;
          this._buffers = void 0;
          this._nativeObj = null;
          this._buffers = new GeometryVertexBuffers();
        }

        var _proto2 = GeometryRenderer.prototype;

        _proto2.activate = function activate(device, pipeline, config) {
          this._device = device;
          this._pipeline = pipeline;
          var posColorAttributes = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
          var posNormColorAttributes = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
          var maxLines = config ? config.maxLines : GEOMETRY_MAX_LINES;
          var maxDashedLines = config ? config.maxDashedLines : GEOMETRY_MAX_DASHED_LINES;
          var maxTriangles = config ? config.maxTriangles : GEOMETRY_MAX_TRIANGLES;
          var lineStride = Float32Array.BYTES_PER_ELEMENT * (Vec3.length + Color.length);
          var triangleStride = Float32Array.BYTES_PER_ELEMENT * (Vec3.length + Vec4.length + Color.length);

          for (var i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
            this._buffers.lines[i].init(this._device, maxLines * GEOMETRY_VERTICES_PER_LINE, lineStride, posColorAttributes);

            this._buffers.dashedLines[i].init(this._device, maxDashedLines * GEOMETRY_VERTICES_PER_LINE, lineStride, posColorAttributes);

            this._buffers.triangles[i].init(this._device, maxTriangles * GEOMETRY_VERTICES_PER_TRIANGLE, triangleStride, posNormColorAttributes);
          }
        };

        _proto2.flush = function flush() {
        };

        _proto2.render = function render(renderPass, cmdBuff) {
          this.update();
          var passes = this._pipeline.pipelineSceneData.geometryRendererPasses;
          var shaders = this._pipeline.pipelineSceneData.geometryRendererShaders;
          var offset = 0;
          var passCount = [GEOMETRY_NO_DEPTH_TEST_PASS_NUM, GEOMETRY_DEPTH_TEST_PASS_NUM];

          for (var i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
            var lines = this._buffers.lines[i];

            if (!lines.empty()) {
              var drawInfo = new DrawInfo();
              drawInfo.vertexCount = lines._vertexCount;

              for (var p = 0; p < passCount[i]; p++) {
                var pass = passes[offset + p];
                var shader = shaders[offset + p];
                var pso = PipelineStateManager.getOrCreatePipelineState(this._device, pass, shader, renderPass, lines._inputAssembler);
                cmdBuff.bindPipelineState(pso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
                cmdBuff.bindInputAssembler(lines._inputAssembler);
                cmdBuff.draw(drawInfo);
              }
            }

            offset += passCount[i];
          }

          for (var _i = 0; _i < GEOMETRY_DEPTH_TYPE_COUNT; _i++) {
            var dashedLines = this._buffers.dashedLines[_i];

            if (!dashedLines.empty()) {
              var _drawInfo = new DrawInfo();

              _drawInfo.vertexCount = dashedLines._vertexCount;

              for (var _p = 0; _p < passCount[_i]; _p++) {
                var _pass = passes[offset + _p];
                var _shader = shaders[offset + _p];

                var _pso = PipelineStateManager.getOrCreatePipelineState(this._device, _pass, _shader, renderPass, dashedLines._inputAssembler);

                cmdBuff.bindPipelineState(_pso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, _pass.descriptorSet);
                cmdBuff.bindInputAssembler(dashedLines._inputAssembler);
                cmdBuff.draw(_drawInfo);
              }
            }

            offset += passCount[_i];
          }

          for (var _i2 = 0; _i2 < GEOMETRY_DEPTH_TYPE_COUNT; _i2++) {
            var triangles = this._buffers.triangles[_i2];

            if (!triangles.empty()) {
              var _drawInfo2 = new DrawInfo();

              _drawInfo2.vertexCount = triangles._vertexCount;

              for (var _p2 = 0; _p2 < passCount[_i2]; _p2++) {
                var _pass2 = passes[offset + _p2];
                var _shader2 = shaders[offset + _p2];

                var _pso2 = PipelineStateManager.getOrCreatePipelineState(this._device, _pass2, _shader2, renderPass, triangles._inputAssembler);

                cmdBuff.bindPipelineState(_pso2);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, _pass2.descriptorSet);
                cmdBuff.bindInputAssembler(triangles._inputAssembler);
                cmdBuff.draw(_drawInfo2);
              }
            }

            offset += passCount[_i2];
          }

          this.reset();
        };

        _proto2.destroy = function destroy() {

          for (var i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
            this._buffers.lines[i].destroy();

            this._buffers.dashedLines[i].destroy();

            this._buffers.triangles[i].destroy();
          }
        };

        _proto2.empty = function empty() {
          for (var i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
            if (!this._buffers.lines[i].empty() || !this._buffers.dashedLines[i].empty() || !this._buffers.triangles[i].empty()) {
              return false;
            }
          }

          return true;
        };

        _proto2.update = function update() {
          for (var i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
            this._buffers.lines[i].update();

            this._buffers.dashedLines[i].update();

            this._buffers.triangles[i].update();
          }
        };

        _proto2.reset = function reset() {
          for (var i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
            this._buffers.lines[i].reset();

            this._buffers.dashedLines[i].reset();

            this._buffers.triangles[i].reset();
          }
        };

        _proto2.addDashedLine = function addDashedLine(v0, v1, color, depthTest) {
          if (depthTest === void 0) {
            depthTest = true;
          }

          var dashedLines = this._buffers.dashedLines[depthTest ? 1 : 0];

          if (dashedLines._vertexCount + GEOMETRY_VERTICES_PER_LINE > dashedLines._maxVertices) {
            warnID(12008);
            return;
          }

          var offset = dashedLines._vertexCount * (Vec3.length + Color.length);
          Vec3.toArray(dashedLines._vertices, v0, offset);
          offset += Vec3.length;
          Color.toArray(dashedLines._vertices, color, offset);
          offset += Color.length;
          Vec3.toArray(dashedLines._vertices, v1, offset);
          offset += Vec3.length;
          Color.toArray(dashedLines._vertices, color, offset);
          dashedLines._vertexCount += GEOMETRY_VERTICES_PER_LINE;
        };

        _proto2.addLine = function addLine(v0, v1, color, depthTest) {
          if (depthTest === void 0) {
            depthTest = true;
          }

          var lines = this._buffers.lines[depthTest ? 1 : 0];

          if (lines._vertexCount + GEOMETRY_VERTICES_PER_LINE > lines._maxVertices) {
            warnID(12008);
            return;
          }

          var offset = lines._vertexCount * (Vec3.length + Color.length);
          Vec3.toArray(lines._vertices, v0, offset);
          offset += Vec3.length;
          Color.toArray(lines._vertices, color, offset);
          offset += Color.length;
          Vec3.toArray(lines._vertices, v1, offset);
          offset += Vec3.length;
          Color.toArray(lines._vertices, color, offset);
          lines._vertexCount += GEOMETRY_VERTICES_PER_LINE;
        };

        _proto2.addTriangle = function addTriangle(v0, v1, v2, color, wireframe, depthTest, unlit) {
          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (wireframe) {
            this.addLine(v0, v1, color, depthTest);
            this.addLine(v1, v2, color, depthTest);
            this.addLine(v2, v0, color, depthTest);
            return;
          }

          var triangles = this._buffers.triangles[depthTest ? 1 : 0];

          if (triangles._vertexCount + GEOMETRY_VERTICES_PER_TRIANGLE > triangles._maxVertices) {
            warnID(12009);
            return;
          }

          var normal = new Vec4(Vec4.ZERO);

          if (!unlit) {
            var dist1 = new Vec3(v1.x - v0.x, v1.y - v0.y, v1.z - v0.z);
            var dist2 = new Vec3(v2.x - v0.x, v2.y - v0.y, v2.z - v0.z);
            var norm = new Vec3();
            Vec3.normalize(norm, Vec3.cross(norm, dist1, dist2));
            normal.set(norm.x, norm.y, norm.z, 1.0);
          }

          var offset = triangles._vertexCount * (Vec3.length + Vec4.length + Color.length);
          Vec3.toArray(triangles._vertices, v0, offset);
          offset += Vec3.length;
          Vec4.toArray(triangles._vertices, normal, offset);
          offset += Vec4.length;
          Color.toArray(triangles._vertices, color, offset);
          offset += Color.length;
          Vec3.toArray(triangles._vertices, v1, offset);
          offset += Vec3.length;
          Vec4.toArray(triangles._vertices, normal, offset);
          offset += Vec4.length;
          Color.toArray(triangles._vertices, color, offset);
          offset += Color.length;
          Vec3.toArray(triangles._vertices, v2, offset);
          offset += Vec3.length;
          Vec4.toArray(triangles._vertices, normal, offset);
          offset += Vec4.length;
          Color.toArray(triangles._vertices, color, offset);
          triangles._vertexCount += GEOMETRY_VERTICES_PER_TRIANGLE;
        };

        _proto2.addQuad = function addQuad(v0, v1, v2, v3, color, wireframe, depthTest, unlit) {
          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (wireframe) {
            this.addLine(v0, v1, color, depthTest);
            this.addLine(v1, v2, color, depthTest);
            this.addLine(v2, v3, color, depthTest);
            this.addLine(v3, v0, color, depthTest);
          } else {
            this.addTriangle(v0, v1, v2, color, wireframe, depthTest, unlit);
            this.addTriangle(v0, v2, v3, color, wireframe, depthTest, unlit);
          }
        };

        _proto2.addBoundingBox = function addBoundingBox(aabb, color, wireframe, depthTest, unlit, useTransform, transform) {
          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          _min$1.set(aabb.center.x - aabb.halfExtents.x, aabb.center.y - aabb.halfExtents.y, aabb.center.z - aabb.halfExtents.z);

          _max$1.set(aabb.center.x + aabb.halfExtents.x, aabb.center.y + aabb.halfExtents.y, aabb.center.z + aabb.halfExtents.z);

          _v0.set(_min$1.x, _min$1.y, _min$1.z);

          _v1.set(_max$1.x, _min$1.y, _min$1.z);

          _v2.set(_min$1.x, _max$1.y, _min$1.z);

          _v3$1.set(_max$1.x, _max$1.y, _min$1.z);

          _v4$1.set(_min$1.x, _min$1.y, _max$1.z);

          _v5.set(_max$1.x, _min$1.y, _max$1.z);

          _v6.set(_min$1.x, _max$1.y, _max$1.z);

          _v7.set(_max$1.x, _max$1.y, _max$1.z);

          if (useTransform) {
            Vec3.transformMat4(_v0, _v0, transform);
            Vec3.transformMat4(_v1, _v1, transform);
            Vec3.transformMat4(_v2, _v2, transform);
            Vec3.transformMat4(_v3$1, _v3$1, transform);
            Vec3.transformMat4(_v4$1, _v4$1, transform);
            Vec3.transformMat4(_v5, _v5, transform);
            Vec3.transformMat4(_v6, _v6, transform);
            Vec3.transformMat4(_v7, _v7, transform);
          }

          if (wireframe) {
            this.addLine(_v6, _v7, color, depthTest);
            this.addLine(_v7, _v3$1, color, depthTest);
            this.addLine(_v3$1, _v2, color, depthTest);
            this.addLine(_v2, _v6, color, depthTest);
            this.addLine(_v4$1, _v5, color, depthTest);
            this.addLine(_v5, _v1, color, depthTest);
            this.addLine(_v1, _v0, color, depthTest);
            this.addLine(_v0, _v4$1, color, depthTest);
            this.addLine(_v6, _v4$1, color, depthTest);
            this.addLine(_v7, _v5, color, depthTest);
            this.addLine(_v3$1, _v1, color, depthTest);
            this.addLine(_v2, _v0, color, depthTest);
          } else {
            this.addQuad(_v4$1, _v5, _v7, _v6, color, wireframe, depthTest, unlit);
            this.addQuad(_v5, _v1, _v3$1, _v7, color, wireframe, depthTest, unlit);
            this.addQuad(_v1, _v0, _v2, _v3$1, color, wireframe, depthTest, unlit);
            this.addQuad(_v0, _v4$1, _v6, _v2, color, wireframe, depthTest, unlit);
            this.addQuad(_v6, _v7, _v3$1, _v2, color, wireframe, depthTest, unlit);
            this.addQuad(_v0, _v1, _v5, _v4$1, color, wireframe, depthTest, unlit);
          }
        };

        _proto2.addCross = function addCross(position, size, color, depthTest) {
          if (depthTest === void 0) {
            depthTest = true;
          }

          var halfSize = size * 0.5;
          var v0 = new Vec3(position.x - halfSize, position.y, position.z);
          var v1 = new Vec3(position.x + halfSize, position.y, position.z);
          this.addLine(v0, v1, color, depthTest);
          v0.set(position.x, position.y - halfSize, position.z);
          v1.set(position.x, position.y + halfSize, position.z);
          this.addLine(v0, v1, color, depthTest);
          v0.set(position.x, position.y, position.z - halfSize);
          v1.set(position.x, position.y, position.z + halfSize);
          this.addLine(v0, v1, color, depthTest);
        };

        _proto2.addFrustum = function addFrustum(frustum, color, depthTest) {
          if (depthTest === void 0) {
            depthTest = true;
          }

          var vertices = frustum.vertices;
          this.addLine(vertices[0], vertices[1], color, depthTest);
          this.addLine(vertices[1], vertices[2], color, depthTest);
          this.addLine(vertices[2], vertices[3], color, depthTest);
          this.addLine(vertices[3], vertices[0], color, depthTest);
          this.addLine(vertices[4], vertices[5], color, depthTest);
          this.addLine(vertices[5], vertices[6], color, depthTest);
          this.addLine(vertices[6], vertices[7], color, depthTest);
          this.addLine(vertices[7], vertices[4], color, depthTest);
          this.addLine(vertices[0], vertices[4], color, depthTest);
          this.addLine(vertices[1], vertices[5], color, depthTest);
          this.addLine(vertices[2], vertices[6], color, depthTest);
          this.addLine(vertices[3], vertices[7], color, depthTest);
        };

        _proto2.addCapsule = function addCapsule(center, radius, height, color, segmentsU, hemiSegmentsV, wireframe, depthTest, unlit, useTransform, transform) {
          if (segmentsU === void 0) {
            segmentsU = 32;
          }

          if (hemiSegmentsV === void 0) {
            hemiSegmentsV = 8;
          }

          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var deltaPhi = Math.PI * 2.0 / segmentsU;
          var deltaTheta = Math.PI / 2.0 / hemiSegmentsV;
          var bottomCenter = new Vec3(center.x, center.y - height / 2.0, center.z);
          var topCenter = new Vec3(center.x, center.y + height / 2.0, center.z);
          var bottomPoints = new Array();
          var topPoints = new Array();

          for (var i = 0; i < hemiSegmentsV + 1; i++) {
            var bottomList = new Array();
            var topList = new Array();
            var theta = i * deltaTheta;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var j = 0; j < segmentsU + 1; j++) {
              var phi = j * deltaPhi;
              var sinPhi = Math.sin(phi);
              var cosPhi = Math.cos(phi);
              var p = new Vec3(radius * sinTheta * cosPhi, radius * cosTheta, radius * sinTheta * sinPhi);
              var p0 = new Vec3(bottomCenter.x + p.x, bottomCenter.y - p.y, bottomCenter.z + p.z);
              var p1 = new Vec3(topCenter.x + p.x, topCenter.y + p.y, topCenter.z + p.z);
              bottomList.push(p0);
              topList.push(p1);
            }

            bottomPoints.push(bottomList);
            topPoints.push(topList);
          }

          if (useTransform) {
            for (var _i3 = 0; _i3 < hemiSegmentsV + 1; _i3++) {
              for (var _j = 0; _j < segmentsU + 1; _j++) {
                Vec3.transformMat4(bottomPoints[_i3][_j], bottomPoints[_i3][_j], transform);
                Vec3.transformMat4(topPoints[_i3][_j], topPoints[_i3][_j], transform);
              }
            }
          }

          for (var _i4 = 0; _i4 < hemiSegmentsV; _i4++) {
            for (var _j2 = 0; _j2 < segmentsU; _j2++) {
              this.addTriangle(bottomPoints[_i4 + 1][_j2], bottomPoints[_i4][_j2 + 1], bottomPoints[_i4][_j2], color, wireframe, depthTest, unlit);
              this.addTriangle(bottomPoints[_i4 + 1][_j2], bottomPoints[_i4 + 1][_j2 + 1], bottomPoints[_i4][_j2 + 1], color, wireframe, depthTest, unlit);
              this.addTriangle(topPoints[_i4][_j2], topPoints[_i4 + 1][_j2 + 1], topPoints[_i4 + 1][_j2], color, wireframe, depthTest, unlit);
              this.addTriangle(topPoints[_i4][_j2], topPoints[_i4][_j2 + 1], topPoints[_i4 + 1][_j2 + 1], color, wireframe, depthTest, unlit);
            }
          }

          var bottomCircle = bottomPoints[hemiSegmentsV];
          var topCircle = topPoints[hemiSegmentsV];

          for (var _j3 = 0; _j3 < segmentsU; _j3++) {
            this.addTriangle(topCircle[_j3], bottomCircle[_j3 + 1], bottomCircle[_j3], color, wireframe, depthTest, unlit);
            this.addTriangle(topCircle[_j3], topCircle[_j3 + 1], bottomCircle[_j3 + 1], color, wireframe, depthTest, unlit);
          }
        };

        _proto2.addCylinder = function addCylinder(center, radius, height, color, segments, wireframe, depthTest, unlit, useTransform, transform) {
          if (segments === void 0) {
            segments = 32;
          }

          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var deltaPhi = Math.PI * 2.0 / segments;
          var bottomCenter = new Vec3(center.x, center.y - height / 2.0, center.z);
          var topCenter = new Vec3(center.x, center.y + height / 2.0, center.z);
          var bottomPoints = new Array();
          var topPoints = new Array();

          for (var i = 0; i < segments + 1; i++) {
            var phi = i * deltaPhi;
            var p = new Vec3(radius * Math.cos(phi), 0.0, radius * Math.sin(phi));
            var p0 = new Vec3(p.x + bottomCenter.x, p.y + bottomCenter.y, p.z + bottomCenter.z);
            var p1 = new Vec3(p.x + topCenter.x, p.y + topCenter.y, p.z + topCenter.z);
            bottomPoints.push(p0);
            topPoints.push(p1);
          }

          if (useTransform) {
            Vec3.transformMat4(bottomCenter, bottomCenter, transform);
            Vec3.transformMat4(topCenter, topCenter, transform);

            for (var _i5 = 0; _i5 < segments + 1; _i5++) {
              Vec3.transformMat4(bottomPoints[_i5], bottomPoints[_i5], transform);
              Vec3.transformMat4(topPoints[_i5], topPoints[_i5], transform);
            }
          }

          for (var _i6 = 0; _i6 < segments; _i6++) {
            this.addTriangle(topCenter, topPoints[_i6 + 1], topPoints[_i6], color, wireframe, depthTest, unlit);
            this.addTriangle(bottomCenter, bottomPoints[_i6], bottomPoints[_i6 + 1], color, wireframe, depthTest, unlit);
            this.addTriangle(topPoints[_i6], bottomPoints[_i6 + 1], bottomPoints[_i6], color, wireframe, depthTest, unlit);
            this.addTriangle(topPoints[_i6], topPoints[_i6 + 1], bottomPoints[_i6 + 1], color, wireframe, depthTest, unlit);
          }
        };

        _proto2.addCone = function addCone(center, radius, height, color, segments, wireframe, depthTest, unlit, useTransform, transform) {
          if (segments === void 0) {
            segments = 32;
          }

          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var deltaPhi = Math.PI * 2.0 / segments;
          var bottomCenter = new Vec3(center.x, center.y - height / 2.0, center.z);
          var topCenter = new Vec3(center.x, center.y + height / 2.0, center.z);
          var bottomPoints = new Array();

          for (var i = 0; i < segments + 1; i++) {
            var point = new Vec3(radius * Math.cos(i * deltaPhi), 0.0, radius * Math.sin(i * deltaPhi));
            var p0 = new Vec3(point.x + bottomCenter.x, point.y + bottomCenter.y, point.z + bottomCenter.z);
            bottomPoints.push(p0);
          }

          if (useTransform) {
            Vec3.transformMat4(bottomCenter, bottomCenter, transform);
            Vec3.transformMat4(topCenter, topCenter, transform);

            for (var _i7 = 0; _i7 < segments + 1; _i7++) {
              Vec3.transformMat4(bottomPoints[_i7], bottomPoints[_i7], transform);
            }
          }

          for (var _i8 = 0; _i8 < segments; _i8++) {
            this.addTriangle(topCenter, bottomPoints[_i8 + 1], bottomPoints[_i8], color, wireframe, depthTest, unlit);
            this.addTriangle(bottomCenter, bottomPoints[_i8], bottomPoints[_i8 + 1], color, wireframe, depthTest, unlit);
          }
        };

        _proto2.addCircle = function addCircle(center, radius, color, segments, depthTest, useTransform, transform) {
          if (segments === void 0) {
            segments = 32;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var deltaPhi = Math.PI * 2.0 / segments;
          var points = new Array();

          for (var i = 0; i < segments + 1; i++) {
            var point = new Vec3(radius * Math.cos(i * deltaPhi), 0.0, radius * Math.sin(i * deltaPhi));
            var p0 = new Vec3(point.x + center.x, point.y + center.y, point.z + center.z);
            points.push(p0);
          }

          if (useTransform) {
            for (var _i9 = 0; _i9 < segments + 1; _i9++) {
              Vec3.transformMat4(points[_i9], points[_i9], transform);
            }
          }

          for (var _i10 = 0; _i10 < segments; _i10++) {
            this.addLine(points[_i10], points[_i10 + 1], color, depthTest);
          }
        };

        _proto2.addArc = function addArc(center, radius, color, startAngle, endAngle, segments, depthTest, useTransform, transform) {
          if (segments === void 0) {
            segments = 32;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var startRadian = toRadian(startAngle);
          var endRadian = toRadian(endAngle);
          var deltaPhi = (endRadian - startRadian) / segments;
          var points = new Array();

          for (var i = 0; i < segments + 1; i++) {
            var point = new Vec3(radius * Math.cos(i * deltaPhi + startRadian), 0.0, radius * Math.sin(i * deltaPhi + startRadian));
            var p0 = new Vec3(point.x + center.x, point.y + center.y, point.z + center.z);
            points.push(p0);
          }

          if (useTransform) {
            for (var _i11 = 0; _i11 < segments + 1; _i11++) {
              Vec3.transformMat4(points[_i11], points[_i11], transform);
            }
          }

          for (var _i12 = 0; _i12 < segments; _i12++) {
            this.addLine(points[_i12], points[_i12 + 1], color, depthTest);
          }
        };

        _proto2.addPolygon = function addPolygon(center, radius, color, segments, wireframe, depthTest, unlit, useTransform, transform) {
          if (segments === void 0) {
            segments = 6;
          }

          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          if (wireframe) {
            this.addCircle(center, radius, color, segments, depthTest, useTransform, transform);
          } else {
            this.addDisc(center, radius, color, segments, wireframe, depthTest, unlit, useTransform, transform);
          }
        };

        _proto2.addDisc = function addDisc(center, radius, color, segments, wireframe, depthTest, unlit, useTransform, transform) {
          if (segments === void 0) {
            segments = 32;
          }

          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var deltaPhi = Math.PI * 2.0 / segments;
          var points = new Array();
          var newCenter = new Vec3(center);

          for (var i = 0; i < segments + 1; i++) {
            var point = new Vec3(radius * Math.cos(i * deltaPhi), 0.0, radius * Math.sin(i * deltaPhi));
            var p0 = new Vec3(point.x + newCenter.x, point.y + newCenter.y, point.z + newCenter.z);
            points.push(p0);
          }

          if (useTransform) {
            Vec3.transformMat4(newCenter, newCenter, transform);

            for (var _i13 = 0; _i13 < segments + 1; _i13++) {
              Vec3.transformMat4(points[_i13], points[_i13], transform);
            }
          }

          for (var _i14 = 0; _i14 < segments; _i14++) {
            this.addTriangle(newCenter, points[_i14], points[_i14 + 1], color, wireframe, depthTest, unlit);
          }

          if (!wireframe) {
            for (var _i15 = 0; _i15 < segments; _i15++) {
              this.addTriangle(newCenter, points[_i15 + 1], points[_i15], color, wireframe, depthTest, unlit);
            }
          }
        };

        _proto2.addSector = function addSector(center, radius, color, startAngle, endAngle, segments, wireframe, depthTest, unlit, useTransform, transform) {
          if (segments === void 0) {
            segments = 32;
          }

          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var startRadian = toRadian(startAngle);
          var endRadian = toRadian(endAngle);
          var deltaPhi = (endRadian - startRadian) / segments;
          var points = new Array();
          var newCenter = new Vec3(center);

          for (var i = 0; i < segments + 1; i++) {
            var point = new Vec3(radius * Math.cos(i * deltaPhi), 0.0, radius * Math.sin(i * deltaPhi));
            var p0 = new Vec3(point.x + newCenter.x, point.y + newCenter.y, point.z + newCenter.z);
            points.push(p0);
          }

          if (useTransform) {
            Vec3.transformMat4(newCenter, newCenter, transform);

            for (var _i16 = 0; _i16 < segments + 1; _i16++) {
              Vec3.transformMat4(points[_i16], points[_i16], transform);
            }
          }

          for (var _i17 = 0; _i17 < segments; _i17++) {
            this.addTriangle(newCenter, points[_i17], points[_i17 + 1], color, wireframe, depthTest, unlit);
          }

          if (!wireframe) {
            for (var _i18 = 0; _i18 < segments; _i18++) {
              this.addTriangle(newCenter, points[_i18 + 1], points[_i18], color, wireframe, depthTest, unlit);
            }
          }
        };

        _proto2.addSphere = function addSphere(center, radius, color, segmentsU, segmentsV, wireframe, depthTest, unlit, useTransform, transform) {
          if (segmentsU === void 0) {
            segmentsU = 32;
          }

          if (segmentsV === void 0) {
            segmentsV = 16;
          }

          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var deltaPhi = Math.PI * 2.0 / segmentsU;
          var deltaTheta = Math.PI / segmentsV;
          var points = new Array();

          for (var i = 0; i < segmentsV + 1; i++) {
            var list = new Array();
            var theta = i * deltaTheta;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var j = 0; j < segmentsU + 1; j++) {
              var phi = j * deltaPhi;
              var sinPhi = Math.sin(phi);
              var cosPhi = Math.cos(phi);
              var p = new Vec3(radius * sinTheta * cosPhi, radius * cosTheta, radius * sinTheta * sinPhi);
              var p0 = new Vec3(center.x + p.x, center.y + p.y, center.z + p.z);
              list.push(p0);
            }

            points.push(list);
          }

          if (useTransform) {
            for (var _i19 = 0; _i19 < segmentsV + 1; _i19++) {
              for (var _j4 = 0; _j4 < segmentsU + 1; _j4++) {
                Vec3.transformMat4(points[_i19][_j4], points[_i19][_j4], transform);
              }
            }
          }

          for (var _i20 = 0; _i20 < segmentsV; _i20++) {
            for (var _j5 = 0; _j5 < segmentsU; _j5++) {
              this.addTriangle(points[_i20][_j5], points[_i20 + 1][_j5 + 1], points[_i20 + 1][_j5], color, wireframe, depthTest, unlit);
              this.addTriangle(points[_i20][_j5], points[_i20][_j5 + 1], points[_i20 + 1][_j5 + 1], color, wireframe, depthTest, unlit);
            }
          }
        };

        _proto2.addTorus = function addTorus(center, bigRadius, radius, color, segmentsU, segmentsV, wireframe, depthTest, unlit, useTransform, transform) {
          if (segmentsU === void 0) {
            segmentsU = 32;
          }

          if (segmentsV === void 0) {
            segmentsV = 16;
          }

          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var deltaPhi = Math.PI * 2.0 / segmentsU;
          var deltaTheta = Math.PI * 2.0 / segmentsV;
          var points = new Array();

          for (var i = 0; i < segmentsU + 1; i++) {
            var list = new Array();
            var phi = i * deltaPhi;
            var sinPhi = Math.sin(phi);
            var cosPhi = Math.cos(phi);

            for (var j = 0; j < segmentsV + 1; j++) {
              var theta = j * deltaTheta;
              var sinTheta = Math.sin(theta);
              var cosTheta = Math.cos(theta);
              var p = new Vec3((bigRadius + radius * cosTheta) * cosPhi, radius * sinTheta, (bigRadius + radius * cosTheta) * sinPhi);
              var p0 = new Vec3(center.x + p.x, center.y + p.y, center.z + p.z);
              list.push(p0);
            }

            points.push(list);
          }

          if (useTransform) {
            for (var _i21 = 0; _i21 < segmentsU + 1; _i21++) {
              for (var _j6 = 0; _j6 < segmentsV + 1; _j6++) {
                Vec3.transformMat4(points[_i21][_j6], points[_i21][_j6], transform);
              }
            }
          }

          for (var _i22 = 0; _i22 < segmentsU; _i22++) {
            for (var _j7 = 0; _j7 < segmentsV; _j7++) {
              this.addTriangle(points[_i22][_j7 + 1], points[_i22 + 1][_j7], points[_i22][_j7], color, wireframe, depthTest, unlit);
              this.addTriangle(points[_i22][_j7 + 1], points[_i22 + 1][_j7 + 1], points[_i22 + 1][_j7], color, wireframe, depthTest, unlit);
            }
          }
        };

        _proto2.addOctahedron = function addOctahedron(center, radius, color, wireframe, depthTest, unlit, useTransform, transform) {
          if (wireframe === void 0) {
            wireframe = true;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (unlit === void 0) {
            unlit = false;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var points = new Array();
          points.push(new Vec3(radius + center.x, center.y, center.z));
          points.push(new Vec3(center.x, center.y, center.z - radius));
          points.push(new Vec3(-radius + center.x, center.y, center.z));
          points.push(new Vec3(center.x, center.y, center.z + radius));
          points.push(new Vec3(center.x, center.y + radius, center.z));
          points.push(new Vec3(center.x, center.y - radius, center.z));

          if (useTransform) {
            for (var i = 0; i < points.length; i++) {
              Vec3.transformMat4(points[i], points[i], transform);
            }
          }

          if (wireframe) {
            this.addLine(points[0], points[1], color, depthTest);
            this.addLine(points[1], points[2], color, depthTest);
            this.addLine(points[2], points[3], color, depthTest);
            this.addLine(points[3], points[0], color, depthTest);
            this.addLine(points[0], points[4], color, depthTest);
            this.addLine(points[1], points[4], color, depthTest);
            this.addLine(points[2], points[4], color, depthTest);
            this.addLine(points[3], points[4], color, depthTest);
            this.addLine(points[0], points[5], color, depthTest);
            this.addLine(points[1], points[5], color, depthTest);
            this.addLine(points[2], points[5], color, depthTest);
            this.addLine(points[3], points[5], color, depthTest);
          } else {
            this.addTriangle(points[0], points[1], points[4], color, wireframe, depthTest, unlit);
            this.addTriangle(points[1], points[2], points[4], color, wireframe, depthTest, unlit);
            this.addTriangle(points[2], points[3], points[4], color, wireframe, depthTest, unlit);
            this.addTriangle(points[3], points[0], points[4], color, wireframe, depthTest, unlit);
            this.addTriangle(points[0], points[3], points[5], color, wireframe, depthTest, unlit);
            this.addTriangle(points[3], points[2], points[5], color, wireframe, depthTest, unlit);
            this.addTriangle(points[2], points[1], points[5], color, wireframe, depthTest, unlit);
            this.addTriangle(points[1], points[0], points[5], color, wireframe, depthTest, unlit);
          }
        };

        _proto2.addBezier = function addBezier(v0, v1, v2, v3, color, segments, depthTest, useTransform, transform) {
          if (segments === void 0) {
            segments = 32;
          }

          if (depthTest === void 0) {
            depthTest = true;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          var deltaT = 1.0 / segments;
          var points = new Array();
          var newV0 = new Vec3(v0);
          var newV1 = new Vec3(v1);
          var newV2 = new Vec3(v2);
          var newV3 = new Vec3(v3);

          if (useTransform) {
            Vec3.transformMat4(newV0, newV0, transform);
            Vec3.transformMat4(newV1, newV1, transform);
            Vec3.transformMat4(newV2, newV2, transform);
            Vec3.transformMat4(newV3, newV3, transform);
          }

          for (var i = 0; i < segments + 1; i++) {
            var t = i * deltaT;
            var a = (1.0 - t) * (1.0 - t) * (1.0 - t);
            var b = 3.0 * t * (1.0 - t) * (1.0 - t);
            var c = 3.0 * t * t * (1.0 - t);
            var d = t * t * t;
            var p0 = new Vec3(a * newV0.x + b * newV1.x + c * newV2.x + d * newV3.x, a * newV0.y + b * newV1.y + c * newV2.y + d * newV3.y, a * newV0.z + b * newV1.z + c * newV2.z + d * newV3.z);
            points.push(p0);
          }

          for (var _i23 = 0; _i23 < segments; _i23++) {
            this.addLine(points[_i23], points[_i23 + 1], color, depthTest);
          }
        };

        _proto2.addMesh = function addMesh(center, vertices, color, depthTest, useTransform, transform) {
          if (depthTest === void 0) {
            depthTest = true;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          for (var i = 0; i < vertices.length; i += 3) {
            var v0 = new Vec3(center.x + vertices[i].x, center.y + vertices[i].y, center.z + vertices[i].z);
            var v1 = new Vec3(center.x + vertices[i + 1].x, center.y + vertices[i + 1].y, center.z + vertices[i + 1].z);
            var v2 = new Vec3(center.x + vertices[i + 2].x, center.y + vertices[i + 2].y, center.z + vertices[i + 2].z);

            if (useTransform) {
              Vec3.transformMat4(v0, v0, transform);
              Vec3.transformMat4(v1, v1, transform);
              Vec3.transformMat4(v2, v2, transform);
            }

            this.addLine(v0, v1, color, depthTest);
            this.addLine(v1, v2, color, depthTest);
            this.addLine(v2, v0, color, depthTest);
          }
        };

        _proto2.addIndexedMesh = function addIndexedMesh(center, vertices, indices, color, depthTest, useTransform, transform) {
          if (depthTest === void 0) {
            depthTest = true;
          }

          if (useTransform === void 0) {
            useTransform = false;
          }

          if (transform === void 0) {
            transform = new Mat4();
          }

          for (var i = 0; i < indices.length; i += 3) {
            var v0 = new Vec3(center.x + vertices[indices[i]].x, center.y + vertices[indices[i]].y, center.z + vertices[indices[i]].z);
            var v1 = new Vec3(center.x + vertices[indices[i + 1]].x, center.y + vertices[indices[i + 1]].y, center.z + vertices[indices[i + 1]].z);
            var v2 = new Vec3(center.x + vertices[indices[i + 2]].x, center.y + vertices[indices[i + 2]].y, center.z + vertices[indices[i + 2]].z);

            if (useTransform) {
              Vec3.transformMat4(v0, v0, transform);
              Vec3.transformMat4(v1, v1, transform);
              Vec3.transformMat4(v2, v2, transform);
            }

            this.addLine(v0, v1, color, depthTest);
            this.addLine(v1, v2, color, depthTest);
            this.addLine(v2, v0, color, depthTest);
          }
        };

        _createClass(GeometryRenderer, [{
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return GeometryRenderer;
      }();

      var _matShadowView$1 = new Mat4();

      var _matShadowProj$1 = new Mat4();

      var _matShadowViewProj$1 = new Mat4();

      var _vec4ShadowInfo = new Vec4();

      var _lightDir = new Vec4(0.0, 0.0, 1.0, 0.0);

      var PipelineUBO = function () {
        function PipelineUBO() {
          this._globalUBO = new Float32Array(UBOGlobal.COUNT);
          this._cameraUBO = new Float32Array(UBOCamera.COUNT);
          this._shadowUBO = new Float32Array(UBOShadow.COUNT);
        }

        PipelineUBO.updateGlobalUBOView = function updateGlobalUBOView(window, bufferView) {
          var root = legacyCC.director.root;
          var fv = bufferView;
          var shadingWidth = Math.floor(window.width);
          var shadingHeight = Math.floor(window.height);
          fv[UBOGlobal.TIME_OFFSET] = root.cumulativeTime;
          fv[UBOGlobal.TIME_OFFSET + 1] = root.frameTime;
          fv[UBOGlobal.TIME_OFFSET + 2] = legacyCC.director.getTotalFrames();
          fv[UBOGlobal.SCREEN_SIZE_OFFSET] = shadingWidth;
          fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1] = shadingHeight;
          fv[UBOGlobal.SCREEN_SIZE_OFFSET + 2] = 1.0 / shadingWidth;
          fv[UBOGlobal.SCREEN_SIZE_OFFSET + 3] = 1.0 / shadingHeight;
          fv[UBOGlobal.NATIVE_SIZE_OFFSET] = shadingWidth;
          fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1] = shadingHeight;
          fv[UBOGlobal.NATIVE_SIZE_OFFSET + 2] = 1.0 / fv[UBOGlobal.NATIVE_SIZE_OFFSET];
          fv[UBOGlobal.NATIVE_SIZE_OFFSET + 3] = 1.0 / fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1];
        };

        PipelineUBO.updateCameraUBOView = function updateCameraUBOView(pipeline, bufferView, camera) {
          var _skybox$envmap;

          var scene = camera.scene ? camera.scene : legacyCC.director.getScene().renderScene;
          var mainLight = scene.mainLight;
          var sceneData = pipeline.pipelineSceneData;
          var ambient = sceneData.ambient;
          var skybox = sceneData.skybox;
          var fog = sceneData.fog;
          var shadowInfo = sceneData.shadows;
          var cv = bufferView;
          var exposure = camera.exposure;
          var isHDR = sceneData.isHDR;
          cv[UBOCamera.SCREEN_SCALE_OFFSET] = sceneData.shadingScale;
          cv[UBOCamera.SCREEN_SCALE_OFFSET + 1] = sceneData.shadingScale;
          cv[UBOCamera.SCREEN_SCALE_OFFSET + 2] = 1.0 / cv[UBOCamera.SCREEN_SCALE_OFFSET];
          cv[UBOCamera.SCREEN_SCALE_OFFSET + 3] = 1.0 / cv[UBOCamera.SCREEN_SCALE_OFFSET + 1];
          cv[UBOCamera.EXPOSURE_OFFSET] = exposure;
          cv[UBOCamera.EXPOSURE_OFFSET + 1] = 1.0 / exposure;
          cv[UBOCamera.EXPOSURE_OFFSET + 2] = isHDR ? 1.0 : 0.0;
          cv[UBOCamera.EXPOSURE_OFFSET + 3] = 1.0 / Camera.standardExposureValue;

          if (mainLight) {
            var shadowEnable = mainLight.shadowEnabled && shadowInfo.type === ShadowType.ShadowMap ? 1.0 : 0.0;
            var mainLightDir = mainLight.direction;

            _lightDir.set(mainLightDir.x, mainLightDir.y, mainLightDir.z, shadowEnable);

            Vec4.toArray(cv, _lightDir, UBOCamera.MAIN_LIT_DIR_OFFSET);
            Vec3.toArray(cv, mainLight.color, UBOCamera.MAIN_LIT_COLOR_OFFSET);

            if (mainLight.useColorTemperature) {
              var _colorTempRGB = mainLight.colorTemperatureRGB;
              cv[UBOCamera.MAIN_LIT_COLOR_OFFSET] *= _colorTempRGB.x;
              cv[UBOCamera.MAIN_LIT_COLOR_OFFSET + 1] *= _colorTempRGB.y;
              cv[UBOCamera.MAIN_LIT_COLOR_OFFSET + 2] *= _colorTempRGB.z;
            }

            if (isHDR) {
              cv[UBOCamera.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * exposure;
            } else {
              cv[UBOCamera.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance;
            }
          } else {
            _lightDir.set(0, 0, 1, 0);

            Vec4.toArray(cv, _lightDir, UBOCamera.MAIN_LIT_DIR_OFFSET);
            Vec4.toArray(cv, Vec4.ZERO, UBOCamera.MAIN_LIT_COLOR_OFFSET);
          }

          var skyColor = ambient.skyColor;

          if (isHDR) {
            skyColor.w = ambient.skyIllum * exposure;
          } else {
            skyColor.w = ambient.skyIllum;
          }

          cv[UBOCamera.AMBIENT_SKY_OFFSET + 0] = skyColor.x;
          cv[UBOCamera.AMBIENT_SKY_OFFSET + 1] = skyColor.y;
          cv[UBOCamera.AMBIENT_SKY_OFFSET + 2] = skyColor.z;
          cv[UBOCamera.AMBIENT_SKY_OFFSET + 3] = skyColor.w;
          cv[UBOCamera.AMBIENT_GROUND_OFFSET + 0] = ambient.groundAlbedo.x;
          cv[UBOCamera.AMBIENT_GROUND_OFFSET + 1] = ambient.groundAlbedo.y;
          cv[UBOCamera.AMBIENT_GROUND_OFFSET + 2] = ambient.groundAlbedo.z;
          cv[UBOCamera.AMBIENT_GROUND_OFFSET + 3] = skybox.envmap ? (_skybox$envmap = skybox.envmap) === null || _skybox$envmap === void 0 ? void 0 : _skybox$envmap.mipmapLevel : 1.0;
          Mat4.toArray(cv, camera.matView, UBOCamera.MAT_VIEW_OFFSET);
          Mat4.toArray(cv, camera.node.worldMatrix, UBOCamera.MAT_VIEW_INV_OFFSET);
          Vec3.toArray(cv, camera.position, UBOCamera.CAMERA_POS_OFFSET);
          Mat4.toArray(cv, camera.matProj, UBOCamera.MAT_PROJ_OFFSET);
          Mat4.toArray(cv, camera.matProjInv, UBOCamera.MAT_PROJ_INV_OFFSET);
          Mat4.toArray(cv, camera.matViewProj, UBOCamera.MAT_VIEW_PROJ_OFFSET);
          Mat4.toArray(cv, camera.matViewProjInv, UBOCamera.MAT_VIEW_PROJ_INV_OFFSET);
          cv[UBOCamera.CAMERA_POS_OFFSET + 3] = this.getCombineSignY();
          var colorTempRGB = fog.colorArray;
          cv[UBOCamera.GLOBAL_FOG_COLOR_OFFSET] = colorTempRGB.x;
          cv[UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 1] = colorTempRGB.y;
          cv[UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 2] = colorTempRGB.z;
          cv[UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 3] = colorTempRGB.z;
          cv[UBOCamera.GLOBAL_FOG_BASE_OFFSET] = fog.fogStart;
          cv[UBOCamera.GLOBAL_FOG_BASE_OFFSET + 1] = fog.fogEnd;
          cv[UBOCamera.GLOBAL_FOG_BASE_OFFSET + 2] = fog.fogDensity;
          cv[UBOCamera.GLOBAL_FOG_ADD_OFFSET] = fog.fogTop;
          cv[UBOCamera.GLOBAL_FOG_ADD_OFFSET + 1] = fog.fogRange;
          cv[UBOCamera.GLOBAL_FOG_ADD_OFFSET + 2] = fog.fogAtten;
          cv[UBOCamera.NEAR_FAR_OFFSET] = camera.nearClip;
          cv[UBOCamera.NEAR_FAR_OFFSET + 1] = camera.farClip;
          cv[UBOCamera.VIEW_PORT_OFFSET] = sceneData.shadingScale * camera.window.width * camera.viewport.x;
          cv[UBOCamera.VIEW_PORT_OFFSET + 1] = sceneData.shadingScale * camera.window.height * camera.viewport.y;
          cv[UBOCamera.VIEW_PORT_OFFSET + 2] = sceneData.shadingScale * camera.window.width * camera.viewport.z;
          cv[UBOCamera.VIEW_PORT_OFFSET + 3] = sceneData.shadingScale * camera.window.height * camera.viewport.w;
        };

        PipelineUBO.updateShadowUBOView = function updateShadowUBOView(pipeline, bufferView, camera) {
          var device = pipeline.device;
          var mainLight = camera.scene.mainLight;
          var sceneData = pipeline.pipelineSceneData;
          var shadowInfo = sceneData.shadows;
          var sv = bufferView;

          if (shadowInfo.enabled) {
            if (mainLight && mainLight.shadowEnabled && shadowInfo.type === ShadowType.ShadowMap) {
              var near = 0.1;
              var far = 0;
              var matShadowView = shadowInfo.matShadowView;
              var matShadowProj = shadowInfo.matShadowProj;
              var matShadowViewProj = shadowInfo.matShadowViewProj;

              if (mainLight.shadowFixedArea) {
                near = mainLight.shadowNear;
                far = mainLight.shadowFar;
              } else {
                near = 0.1;
                far = shadowInfo.shadowCameraFar;
              }

              Mat4.toArray(bufferView, matShadowView, UBOShadow.MAT_LIGHT_VIEW_OFFSET);
              sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 0] = matShadowProj.m10;
              sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 1] = matShadowProj.m14;
              sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 2] = matShadowProj.m11;
              sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 3] = matShadowProj.m15;
              sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 0] = matShadowProj.m00;
              sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 1] = matShadowProj.m05;
              sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 2] = 1.0 / matShadowProj.m00;
              sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 3] = 1.0 / matShadowProj.m05;
              Mat4.toArray(bufferView, matShadowViewProj, UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET);
              var linear = 0.0;
              var packing = supportsR32FloatTexture(device) ? 0.0 : 1.0;
              sv[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 0] = near;
              sv[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 1] = far;
              sv[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 2] = linear;
              sv[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 3] = 1.0 - mainLight.shadowSaturation;
              sv[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = shadowInfo.size.x;
              sv[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = shadowInfo.size.y;
              sv[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = mainLight.shadowPcf;
              sv[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = mainLight.shadowBias;
              sv[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 0.0;
              sv[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = packing;
              sv[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = mainLight.shadowNormalBias;
              sv[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0.0;
            } else if (mainLight && shadowInfo.type === ShadowType.Planar) {
              updatePlanarPROJ(shadowInfo, mainLight, sv);
              updatePlanarNormalAndDistance(shadowInfo, sv);
            }

            Color.toArray(sv, shadowInfo.shadowColor, UBOShadow.SHADOW_COLOR_OFFSET);
          }
        };

        PipelineUBO.updateShadowUBOLightView = function updateShadowUBOLightView(pipeline, bufferView, light) {
          var device = pipeline.device;
          var shadowInfo = pipeline.pipelineSceneData.shadows;
          var sv = bufferView;
          var linear = 0.0;
          var packing = supportsR32FloatTexture(device) ? 0.0 : 1.0;
          var near = 0.1;
          var far = 0;
          var matShadowView = shadowInfo.matShadowView;
          var matShadowProj = shadowInfo.matShadowProj;
          var matShadowViewProj = shadowInfo.matShadowViewProj;

          switch (light.type) {
            case LightType.DIRECTIONAL:
              {
                var mainLight = light;

                if (mainLight.shadowFixedArea) {
                  near = mainLight.shadowNear;
                  far = mainLight.shadowFar;
                } else {
                  near = 0.1;
                  far = shadowInfo.shadowCameraFar;
                }

                Mat4.toArray(bufferView, matShadowView, UBOShadow.MAT_LIGHT_VIEW_OFFSET);
                sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 0] = matShadowProj.m10;
                sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 1] = matShadowProj.m14;
                sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 2] = matShadowProj.m11;
                sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 3] = matShadowProj.m15;
                sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 0] = matShadowProj.m00;
                sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 1] = matShadowProj.m05;
                sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 2] = 1.0 / matShadowProj.m00;
                sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 3] = 1.0 / matShadowProj.m05;
                Mat4.toArray(bufferView, matShadowViewProj, UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET);

                _vec4ShadowInfo.set(near, far, linear, 1.0 - mainLight.shadowSaturation);

                Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET);

                _vec4ShadowInfo.set(0.0, packing, mainLight.shadowNormalBias, 0.0);

                Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET);

                _vec4ShadowInfo.set(shadowInfo.size.x, shadowInfo.size.y, mainLight.shadowPcf, mainLight.shadowBias);

                Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET);
                break;
              }

            case LightType.SPOT:
              {
                var spotLight = light;
                Mat4.invert(_matShadowView$1, light.node.getWorldMatrix());
                Mat4.toArray(sv, _matShadowView$1, UBOShadow.MAT_LIGHT_VIEW_OFFSET);
                Mat4.perspective(_matShadowProj$1, light.angle, 1.0, 0.001, light.range);
                Mat4.multiply(_matShadowViewProj$1, _matShadowProj$1, _matShadowView$1);
                Mat4.toArray(sv, _matShadowViewProj$1, UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET);

                _vec4ShadowInfo.set(0.01, light.range, linear, 0.0);

                Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET);

                _vec4ShadowInfo.set(1.0, packing, spotLight.shadowNormalBias, 0.0);

                Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET);

                _vec4ShadowInfo.set(shadowInfo.size.x, shadowInfo.size.y, spotLight.shadowPcf, spotLight.shadowBias);

                Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET);
                break;
              }
          }

          Color.toArray(sv, shadowInfo.shadowColor, UBOShadow.SHADOW_COLOR_OFFSET);
        };

        PipelineUBO.getCombineSignY = function getCombineSignY() {
          return PipelineUBO._combineSignY;
        };

        var _proto = PipelineUBO.prototype;

        _proto._initCombineSignY = function _initCombineSignY() {
          var device = this._device;
          PipelineUBO._combineSignY = device.capabilities.screenSpaceSignY * 0.5 + 0.5 << 1 | device.capabilities.clipSpaceSignY * 0.5 + 0.5;
        };

        _proto.activate = function activate(device, pipeline) {
          this._device = device;
          this._pipeline = pipeline;
          var ds = this._pipeline.descriptorSet;

          this._initCombineSignY();

          var globalUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOGlobal.SIZE, UBOGlobal.SIZE));
          ds.bindBuffer(UBOGlobal.BINDING, globalUBO);
          var cameraUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOCamera.SIZE, UBOCamera.SIZE));
          ds.bindBuffer(UBOCamera.BINDING, cameraUBO);
          var shadowUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOShadow.SIZE, UBOShadow.SIZE));
          ds.bindBuffer(UBOShadow.BINDING, shadowUBO);
        };

        _proto.updateGlobalUBO = function updateGlobalUBO(window) {
          var globalDSManager = this._pipeline.globalDSManager;
          var ds = this._pipeline.descriptorSet;
          var cmdBuffer = this._pipeline.commandBuffers;
          ds.update();
          PipelineUBO.updateGlobalUBOView(window, this._globalUBO);
          cmdBuffer[0].updateBuffer(ds.getBuffer(UBOGlobal.BINDING), this._globalUBO);
          globalDSManager.bindBuffer(UBOGlobal.BINDING, ds.getBuffer(UBOGlobal.BINDING));
          globalDSManager.update();
        };

        _proto.updateCameraUBO = function updateCameraUBO(camera) {
          var globalDSManager = this._pipeline.globalDSManager;
          var ds = this._pipeline.descriptorSet;
          var cmdBuffer = this._pipeline.commandBuffers;
          PipelineUBO.updateCameraUBOView(this._pipeline, this._cameraUBO, camera);
          cmdBuffer[0].updateBuffer(ds.getBuffer(UBOCamera.BINDING), this._cameraUBO);
          globalDSManager.bindBuffer(UBOCamera.BINDING, ds.getBuffer(UBOCamera.BINDING));
          globalDSManager.update();
        };

        _proto.updateShadowUBO = function updateShadowUBO(camera) {
          var sceneData = this._pipeline.pipelineSceneData;
          var shadowInfo = sceneData.shadows;
          if (!shadowInfo.enabled) return;
          var ds = this._pipeline.descriptorSet;
          var cmdBuffer = this._pipeline.commandBuffers;
          var shadowFrameBufferMap = sceneData.shadowFrameBufferMap;
          var mainLight = camera.scene.mainLight;

          if (mainLight && shadowFrameBufferMap.has(mainLight)) {
            ds.bindTexture(UNIFORM_SHADOWMAP_BINDING, shadowFrameBufferMap.get(mainLight).colorTextures[0]);
          }

          PipelineUBO.updateShadowUBOView(this._pipeline, this._shadowUBO, camera);
          ds.update();
          cmdBuffer[0].updateBuffer(ds.getBuffer(UBOShadow.BINDING), this._shadowUBO);
        };

        _proto.updateShadowUBOLight = function updateShadowUBOLight(globalDS, light) {
          PipelineUBO.updateShadowUBOLightView(this._pipeline, this._shadowUBO, light);
          globalDS.bindTexture(UNIFORM_SHADOWMAP_BINDING, builtinResMgr.get('default-texture').getGFXTexture());
          globalDS.bindTexture(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, builtinResMgr.get('default-texture').getGFXTexture());
          globalDS.update();
          globalDS.getBuffer(UBOShadow.BINDING).update(this._shadowUBO);
        };

        _proto.updateShadowUBORange = function updateShadowUBORange(offset, data) {
          if (data instanceof Mat4) {
            Mat4.toArray(this._shadowUBO, data, offset);
          } else if (data instanceof Color) {
            Color.toArray(this._shadowUBO, data, offset);
          }
        };

        _proto.destroy = function destroy() {};

        return PipelineUBO;
      }();
      PipelineUBO._combineSignY = 0;

      var _dec$e, _dec2$6, _dec3$2, _dec4$1, _class$e, _class2$c, _descriptor$a, _descriptor2$7, _descriptor3$6, _temp$c;
      var RenderStage = exports('RenderStage', (_dec$e = ccclass('RenderStage'), _dec2$6 = displayOrder(), _dec3$2 = displayOrder(), _dec4$1 = displayOrder(), _dec$e(_class$e = (_class2$c = (_temp$c = function () {
        function RenderStage() {
          _initializerDefineProperty(this, "_name", _descriptor$a, this);

          _initializerDefineProperty(this, "_priority", _descriptor2$7, this);

          this._enabled = true;

          _initializerDefineProperty(this, "_tag", _descriptor3$6, this);
        }

        var _proto = RenderStage.prototype;

        _proto.initialize = function initialize(info) {
          this._name = info.name;
          this._priority = info.priority;

          if (info.tag) {
            this._tag = info.tag;
          }

          return true;
        };

        _proto.activate = function activate(pipeline, flow) {
          this._pipeline = pipeline;
          this._flow = flow;
        };

        _createClass(RenderStage, [{
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          }
        }, {
          key: "tag",
          get: function get() {
            return this._tag;
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            this._enabled = val;
          }
        }]);

        return RenderStage;
      }(), _temp$c), (_descriptor$a = _applyDecoratedDescriptor(_class2$c.prototype, "_name", [_dec2$6, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor2$7 = _applyDecoratedDescriptor(_class2$c.prototype, "_priority", [_dec3$2, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$c.prototype, "_tag", [_dec4$1, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$c)) || _class$e));
      legacyCC.RenderStage = RenderStage;

      var _dec$f, _dec2$7, _dec3$3, _dec4$2, _dec5, _dec6, _class$f, _class2$d, _descriptor$b, _descriptor2$8, _descriptor3$7, _descriptor4$5, _temp$d;
      var RenderFlow = exports('RenderFlow', (_dec$f = ccclass('RenderFlow'), _dec2$7 = displayOrder(), _dec3$3 = displayOrder(), _dec4$2 = displayOrder(), _dec5 = displayOrder(), _dec6 = type([RenderStage]), _dec$f(_class$f = (_class2$d = (_temp$d = function () {
        function RenderFlow() {
          _initializerDefineProperty(this, "_name", _descriptor$b, this);

          _initializerDefineProperty(this, "_priority", _descriptor2$8, this);

          _initializerDefineProperty(this, "_tag", _descriptor3$7, this);

          _initializerDefineProperty(this, "_stages", _descriptor4$5, this);
        }

        var _proto = RenderFlow.prototype;

        _proto.initialize = function initialize(info) {
          this._name = info.name;
          this._priority = info.priority;
          this._stages = info.stages;

          if (info.tag) {
            this._tag = info.tag;
          }

          return true;
        };

        _proto.activate = function activate(pipeline) {
          this._pipeline = pipeline;

          this._stages.sort(function (a, b) {
            return a.priority - b.priority;
          });

          for (var i = 0, len = this._stages.length; i < len; i++) {
            this._stages[i].activate(pipeline, this);
          }
        };

        _proto.render = function render(camera) {
          for (var i = 0, len = this._stages.length; i < len; i++) {
            if (this._stages[i].enabled) this._stages[i].render(camera);
          }
        };

        _proto.destroy = function destroy() {
          for (var i = 0, len = this._stages.length; i < len; i++) {
            this._stages[i].destroy();
          }

          this._stages.length = 0;
        };

        _createClass(RenderFlow, [{
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          }
        }, {
          key: "tag",
          get: function get() {
            return this._tag;
          }
        }, {
          key: "stages",
          get: function get() {
            return this._stages;
          }
        }, {
          key: "pipeline",
          get: function get() {
            return this._pipeline;
          }
        }]);

        return RenderFlow;
      }(), _temp$d), (_descriptor$b = _applyDecoratedDescriptor(_class2$d.prototype, "_name", [_dec2$7, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$d.prototype, "_priority", [_dec3$3, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor3$7 = _applyDecoratedDescriptor(_class2$d.prototype, "_tag", [_dec4$2, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor4$5 = _applyDecoratedDescriptor(_class2$d.prototype, "_stages", [_dec5, _dec6, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$d)) || _class$f));
      legacyCC.RenderFlow = RenderFlow;

      var PipelineEventType;

      (function (PipelineEventType) {
        PipelineEventType["RENDER_FRAME_BEGIN"] = "render-frame-begin";
        PipelineEventType["RENDER_FRAME_END"] = "render-frame-end";
        PipelineEventType["RENDER_CAMERA_BEGIN"] = "render-camera-begin";
        PipelineEventType["RENDER_CAMERA_END"] = "render-camera-end";
        PipelineEventType["ATTACHMENT_SCALE_CAHNGED"] = "attachment-scale-changed";
      })(PipelineEventType || (PipelineEventType = exports('PipelineEventType', {})));

      var PipelineEventProcessor = exports('PipelineEventProcessor', function (_EventTarget) {
        _inheritsLoose(PipelineEventProcessor, _EventTarget);

        function PipelineEventProcessor() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _EventTarget.call.apply(_EventTarget, [this].concat(args)) || this;
          _this.eventTargetOn = _EventTarget.prototype.on;
          _this.eventTargetOnce = _EventTarget.prototype.once;
          return _this;
        }

        var _proto = PipelineEventProcessor.prototype;

        _proto.on = function on(type, callback, target, once) {
          return this.eventTargetOn(type, callback, target, once);
        };

        _proto.once = function once(type, callback, target) {
          return this.eventTargetOnce(type, callback, target);
        };

        return PipelineEventProcessor;
      }(EventTarget));

      var _dec$g, _dec2$8, _dec3$4, _dec4$3, _class$g, _class2$e, _descriptor$c, _descriptor2$9, _temp$e;
      var MAX_BLOOM_FILTER_PASS_NUM = 6;
      var tmpRect = new Rect$1();
      var tmpViewport = new Viewport();
      var BloomRenderData = function BloomRenderData() {
        this.renderPass = null;
        this.sampler = null;
        this.prefiterTex = null;
        this.downsampleTexs = [];
        this.upsampleTexs = [];
        this.combineTex = null;
        this.prefilterFramebuffer = null;
        this.downsampleFramebuffers = [];
        this.upsampleFramebuffers = [];
        this.combineFramebuffer = null;
      };
      var PipelineRenderData = function PipelineRenderData() {
        this.outputFrameBuffer = null;
        this.outputRenderTargets = [];
        this.outputDepth = null;
        this.sampler = null;
        this.bloom = null;
      };
      var PipelineInputAssemblerData = function PipelineInputAssemblerData() {
        this.quadIB = null;
        this.quadVB = null;
        this.quadIA = null;
      };
      var RenderPipeline = exports('RenderPipeline', (_dec$g = ccclass('cc.RenderPipeline'), _dec2$8 = displayOrder(), _dec3$4 = displayOrder(), _dec4$3 = type([RenderFlow]), _dec$g(_class$g = (_class2$e = (_temp$e = function (_Asset) {
        _inheritsLoose(RenderPipeline, _Asset);

        function RenderPipeline() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_tag", _descriptor$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_flows", _descriptor2$9, _assertThisInitialized(_this));

          _this._quadIB = null;
          _this._quadVBOnscreen = null;
          _this._quadVBOffscreen = null;
          _this._quadIAOnscreen = null;
          _this._quadIAOffscreen = null;
          _this._eventProcessor = new PipelineEventProcessor();
          _this._commandBuffers = [];
          _this._pipelineUBO = new PipelineUBO();
          _this._macros = {};
          _this._constantMacros = '';
          _this._profiler = null;
          _this._geometryRenderer = new GeometryRenderer();
          _this._pipelineRenderData = null;
          _this._renderPasses = new Map();
          _this._width = 0;
          _this._height = 0;
          _this._lastUsedRenderArea = new Rect$1();
          _this._clusterEnabled = false;
          _this._bloomEnabled = false;
          return _this;
        }

        var _proto = RenderPipeline.prototype;

        _proto.getPipelineRenderData = function getPipelineRenderData() {
          return this._pipelineRenderData;
        };

        _proto.initialize = function initialize(info) {
          this._flows = info.flows;

          if (info.tag) {
            this._tag = info.tag;
          }

          return true;
        };

        _proto.createRenderPass = function createRenderPass(clearFlags, colorFmt, depthFmt) {
          var device = this._device;
          var colorAttachment = new ColorAttachment();
          var depthStencilAttachment = new DepthStencilAttachment();
          colorAttachment.format = colorFmt;
          depthStencilAttachment.format = depthFmt;
          depthStencilAttachment.stencilStoreOp = StoreOp.DISCARD;
          depthStencilAttachment.depthStoreOp = StoreOp.DISCARD;

          if (!(clearFlags & ClearFlagBit.COLOR)) {
            if (clearFlags & SKYBOX_FLAG) {
              colorAttachment.loadOp = LoadOp.DISCARD;
            } else {
              colorAttachment.loadOp = LoadOp.LOAD;
              colorAttachment.barrier = device.getGeneralBarrier(new GeneralBarrierInfo(AccessFlagBit.COLOR_ATTACHMENT_WRITE, AccessFlagBit.COLOR_ATTACHMENT_WRITE));
            }
          }

          if ((clearFlags & ClearFlagBit.DEPTH_STENCIL) !== ClearFlagBit.DEPTH_STENCIL) {
            if (!(clearFlags & ClearFlagBit.DEPTH)) depthStencilAttachment.depthLoadOp = LoadOp.LOAD;
            if (!(clearFlags & ClearFlagBit.STENCIL)) depthStencilAttachment.stencilLoadOp = LoadOp.LOAD;
          }

          depthStencilAttachment.barrier = device.getGeneralBarrier(new GeneralBarrierInfo(AccessFlagBit.DEPTH_STENCIL_ATTACHMENT_WRITE, AccessFlagBit.DEPTH_STENCIL_ATTACHMENT_WRITE));
          var renderPassInfo = new RenderPassInfo([colorAttachment], depthStencilAttachment);
          return device.createRenderPass(renderPassInfo);
        };

        _proto.getRenderPass = function getRenderPass(clearFlags, fbo) {
          var renderPass = this._renderPasses.get(clearFlags);

          if (renderPass) {
            return renderPass;
          }

          renderPass = this.createRenderPass(clearFlags, fbo.colorTextures[0].format, fbo.depthStencilTexture.format);

          this._renderPasses.set(clearFlags, renderPass);

          return renderPass;
        };

        _proto.applyFramebufferRatio = function applyFramebufferRatio(framebuffer) {
          var sceneData = this.pipelineSceneData;
          var width = this._width * sceneData.shadingScale;
          var height = this._height * sceneData.shadingScale;
          var colorTexArr = framebuffer.colorTextures;

          for (var i = 0; i < colorTexArr.length; i++) {
            colorTexArr[i].resize(width, height);
          }

          if (framebuffer.depthStencilTexture) {
            framebuffer.depthStencilTexture.resize(width, height);
          }

          framebuffer.destroy();
          framebuffer.initialize(new FramebufferInfo(framebuffer.renderPass, colorTexArr, framebuffer.depthStencilTexture));
        };

        _proto.generateRenderArea = function generateRenderArea(camera, out) {
          var vp = camera.viewport;
          var w = camera.window.width;
          var h = camera.window.height;
          out.x = vp.x * w;
          out.y = vp.y * h;
          out.width = vp.width * w;
          out.height = vp.height * h;
        };

        _proto.generateViewport = function generateViewport(camera, out) {
          this.generateRenderArea(camera, tmpRect);
          if (!out) out = tmpViewport;
          var shadingScale = this.pipelineSceneData.shadingScale;
          out.left = tmpRect.x * shadingScale;
          out.top = tmpRect.y * shadingScale;
          out.width = tmpRect.width * shadingScale;
          out.height = tmpRect.height * shadingScale;
          return out;
        };

        _proto.generateScissor = function generateScissor(camera, out) {
          if (!out) out = tmpRect;
          this.generateRenderArea(camera, out);
          var shadingScale = this.pipelineSceneData.shadingScale;
          out.x *= shadingScale;
          out.y *= shadingScale;
          out.width *= shadingScale;
          out.height *= shadingScale;
          return out;
        };

        _proto.activate = function activate(swapchain) {
          var root = legacyCC.director.root;
          this._device = root.device;

          this._generateConstantMacros();

          this._globalDSManager = new GlobalDSManager(this);
          this._descriptorSet = this._globalDSManager.globalDescriptorSet;

          this._pipelineUBO.activate(this._device, this);

          this._macros.CC_USE_HDR = this._pipelineSceneData.isHDR;

          this._generateConstantMacros();

          this._pipelineSceneData.activate(this._device, this);

          this._geometryRenderer.activate(this._device, this);

          for (var i = 0; i < this._flows.length; i++) {
            this._flows[i].activate(this);
          }

          return true;
        };

        _proto._ensureEnoughSize = function _ensureEnoughSize(cameras) {};

        _proto.render = function render(cameras) {
          if (cameras.length === 0) {
            return;
          }

          this._commandBuffers[0].begin();

          this.emit(PipelineEventType.RENDER_FRAME_BEGIN, cameras);

          this._ensureEnoughSize(cameras);

          decideProfilerCamera(cameras);

          for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];

            if (camera.scene) {
              this.emit(PipelineEventType.RENDER_CAMERA_BEGIN, camera);
              validPunctualLightsCulling(this, camera);
              sceneCulling(this, camera);

              this._pipelineUBO.updateGlobalUBO(camera.window);

              this._pipelineUBO.updateCameraUBO(camera);

              for (var j = 0; j < this._flows.length; j++) {
                this._flows[j].render(camera);
              }

              this.emit(PipelineEventType.RENDER_CAMERA_END, camera);
            }
          }

          this.emit(PipelineEventType.RENDER_FRAME_END, cameras);

          this._commandBuffers[0].end();

          this._device.queue.submit(this._commandBuffers);
        };

        _proto._destroyQuadInputAssembler = function _destroyQuadInputAssembler() {
          if (this._quadIB) {
            this._quadIB.destroy();

            this._quadIB = null;
          }

          if (this._quadVBOnscreen) {
            this._quadVBOnscreen.destroy();

            this._quadVBOnscreen = null;
          }

          if (this._quadVBOffscreen) {
            this._quadVBOffscreen.destroy();

            this._quadVBOffscreen = null;
          }

          if (this._quadIAOnscreen) {
            this._quadIAOnscreen.destroy();

            this._quadIAOnscreen = null;
          }

          if (this._quadIAOffscreen) {
            this._quadIAOffscreen.destroy();

            this._quadIAOffscreen = null;
          }
        };

        _proto._destroyBloomData = function _destroyBloomData() {
          var _bloom$renderPass;

          var bloom = this._pipelineRenderData.bloom;
          if (bloom === null) return;
          if (bloom.prefiterTex) bloom.prefiterTex.destroy();
          if (bloom.prefilterFramebuffer) bloom.prefilterFramebuffer.destroy();

          for (var i = 0; i < bloom.downsampleTexs.length; ++i) {
            bloom.downsampleTexs[i].destroy();
            bloom.downsampleFramebuffers[i].destroy();
          }

          bloom.downsampleTexs.length = 0;
          bloom.downsampleFramebuffers.length = 0;

          for (var _i = 0; _i < bloom.upsampleTexs.length; ++_i) {
            bloom.upsampleTexs[_i].destroy();

            bloom.upsampleFramebuffers[_i].destroy();
          }

          bloom.upsampleTexs.length = 0;
          bloom.upsampleFramebuffers.length = 0;
          if (bloom.combineTex) bloom.combineTex.destroy();
          if (bloom.combineFramebuffer) bloom.combineFramebuffer.destroy();
          (_bloom$renderPass = bloom.renderPass) === null || _bloom$renderPass === void 0 ? void 0 : _bloom$renderPass.destroy();
          this._pipelineRenderData.bloom = null;
        };

        _proto._genQuadVertexData = function _genQuadVertexData(surfaceTransform, renderArea) {
          var vbData = new Float32Array(4 * 4);
          var minX = renderArea.x / this._width;
          var maxX = (renderArea.x + renderArea.width) / this._width;
          var minY = renderArea.y / this._height;
          var maxY = (renderArea.y + renderArea.height) / this._height;

          if (this.device.capabilities.screenSpaceSignY > 0) {
            var temp = maxY;
            maxY = minY;
            minY = temp;
          }

          var n = 0;

          switch (surfaceTransform) {
            case SurfaceTransform.IDENTITY:
              n = 0;
              vbData[n++] = -1.0;
              vbData[n++] = -1.0;
              vbData[n++] = minX;
              vbData[n++] = maxY;
              vbData[n++] = 1.0;
              vbData[n++] = -1.0;
              vbData[n++] = maxX;
              vbData[n++] = maxY;
              vbData[n++] = -1.0;
              vbData[n++] = 1.0;
              vbData[n++] = minX;
              vbData[n++] = minY;
              vbData[n++] = 1.0;
              vbData[n++] = 1.0;
              vbData[n++] = maxX;
              vbData[n++] = minY;
              break;

            case SurfaceTransform.ROTATE_90:
              n = 0;
              vbData[n++] = -1.0;
              vbData[n++] = -1.0;
              vbData[n++] = maxX;
              vbData[n++] = maxY;
              vbData[n++] = 1.0;
              vbData[n++] = -1.0;
              vbData[n++] = maxX;
              vbData[n++] = minY;
              vbData[n++] = -1.0;
              vbData[n++] = 1.0;
              vbData[n++] = minX;
              vbData[n++] = maxY;
              vbData[n++] = 1.0;
              vbData[n++] = 1.0;
              vbData[n++] = minX;
              vbData[n++] = minY;
              break;

            case SurfaceTransform.ROTATE_180:
              n = 0;
              vbData[n++] = -1.0;
              vbData[n++] = -1.0;
              vbData[n++] = minX;
              vbData[n++] = minY;
              vbData[n++] = 1.0;
              vbData[n++] = -1.0;
              vbData[n++] = maxX;
              vbData[n++] = minY;
              vbData[n++] = -1.0;
              vbData[n++] = 1.0;
              vbData[n++] = minX;
              vbData[n++] = maxY;
              vbData[n++] = 1.0;
              vbData[n++] = 1.0;
              vbData[n++] = maxX;
              vbData[n++] = maxY;
              break;

            case SurfaceTransform.ROTATE_270:
              n = 0;
              vbData[n++] = -1.0;
              vbData[n++] = -1.0;
              vbData[n++] = minX;
              vbData[n++] = minY;
              vbData[n++] = 1.0;
              vbData[n++] = -1.0;
              vbData[n++] = minX;
              vbData[n++] = maxY;
              vbData[n++] = -1.0;
              vbData[n++] = 1.0;
              vbData[n++] = maxX;
              vbData[n++] = minY;
              vbData[n++] = 1.0;
              vbData[n++] = 1.0;
              vbData[n++] = maxX;
              vbData[n++] = maxY;
              break;
          }

          return vbData;
        };

        _proto._createQuadInputAssembler = function _createQuadInputAssembler() {
          var inputAssemblerData = new PipelineInputAssemblerData();
          var vbStride = Float32Array.BYTES_PER_ELEMENT * 4;
          var vbSize = vbStride * 4;

          var quadVB = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE | MemoryUsageBit.HOST, vbSize, vbStride));

          if (!quadVB) {
            return inputAssemblerData;
          }

          var ibStride = Uint8Array.BYTES_PER_ELEMENT;
          var ibSize = ibStride * 6;

          var quadIB = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibSize, ibStride));

          if (!quadIB) {
            return inputAssemblerData;
          }

          var indices = new Uint8Array(6);
          indices[0] = 0;
          indices[1] = 1;
          indices[2] = 2;
          indices[3] = 1;
          indices[4] = 3;
          indices[5] = 2;
          quadIB.update(indices);
          var attributes = new Array(2);
          attributes[0] = new Attribute('a_position', Format.RG32F);
          attributes[1] = new Attribute('a_texCoord', Format.RG32F);

          var quadIA = this._device.createInputAssembler(new InputAssemblerInfo(attributes, [quadVB], quadIB));

          inputAssemblerData.quadIB = quadIB;
          inputAssemblerData.quadVB = quadVB;
          inputAssemblerData.quadIA = quadIA;
          return inputAssemblerData;
        };

        _proto.updateQuadVertexData = function updateQuadVertexData(renderArea, window) {
          var cachedArea = this._lastUsedRenderArea;

          if (cachedArea.x === renderArea.x && cachedArea.y === renderArea.y && cachedArea.width === renderArea.width && cachedArea.height === renderArea.height) {
            return;
          }

          var offData = this._genQuadVertexData(SurfaceTransform.IDENTITY, renderArea);

          this._quadVBOffscreen.update(offData);

          var onData = this._genQuadVertexData(window.swapchain && window.swapchain.surfaceTransform || SurfaceTransform.IDENTITY, renderArea);

          this._quadVBOnscreen.update(onData);

          cachedArea.copy(renderArea);
        };

        _proto.destroy = function destroy() {
          var _this$_globalDSManage, _this$_pipelineSceneD;

          for (var i = 0; i < this._flows.length; i++) {
            this._flows[i].destroy();
          }

          this._flows.length = 0;

          if (this._descriptorSet) {
            this._descriptorSet.destroy();
          }

          (_this$_globalDSManage = this._globalDSManager) === null || _this$_globalDSManage === void 0 ? void 0 : _this$_globalDSManage.destroy();

          for (var _i2 = 0; _i2 < this._commandBuffers.length; _i2++) {
            this._commandBuffers[_i2].destroy();
          }

          this._commandBuffers.length = 0;

          this._pipelineUBO.destroy();

          (_this$_pipelineSceneD = this._pipelineSceneData) === null || _this$_pipelineSceneD === void 0 ? void 0 : _this$_pipelineSceneD.destroy();

          this._geometryRenderer.destroy();

          return _Asset.prototype.destroy.call(this);
        };

        _proto._generateConstantMacros = function _generateConstantMacros() {
          var str = '';
          str += "#define CC_DEVICE_SUPPORT_FLOAT_TEXTURE " + (this.device.getFormatFeatures(Format.RGBA32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE) ? 1 : 0) + "\n";
          str += "#define CC_ENABLE_CLUSTERED_LIGHT_CULLING " + (this._clusterEnabled ? 1 : 0) + "\n";
          str += "#define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS " + this.device.capabilities.maxVertexUniformVectors + "\n";
          str += "#define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS " + this.device.capabilities.maxFragmentUniformVectors + "\n";
          str += "#define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT " + (this.device.hasFeature(Feature.INPUT_ATTACHMENT_BENEFIT) ? 1 : 0) + "\n";
          str += "#define CC_PLATFORM_ANDROID_AND_WEBGL " + (systemInfo.os === OS.ANDROID && systemInfo.isBrowser ? 1 : 0) + "\n";
          str += "#define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES " + (macro.ENABLE_WEBGL_HIGHP_STRUCT_VALUES ? 1 : 0) + "\n";
          this._constantMacros = str;
        };

        _proto.generateBloomRenderData = function generateBloomRenderData() {
          if (this._pipelineRenderData.bloom != null) return;
          var bloom = this._pipelineRenderData.bloom = new BloomRenderData();
          var device = this.device;
          var colorAttachment = new ColorAttachment();
          colorAttachment.format = Format.RGBA8;
          colorAttachment.loadOp = LoadOp.CLEAR;
          colorAttachment.storeOp = StoreOp.STORE;
          colorAttachment.barrier = device.getGeneralBarrier(new GeneralBarrierInfo(AccessFlagBit.NONE, AccessFlagBit.COLOR_ATTACHMENT_WRITE));
          bloom.renderPass = device.createRenderPass(new RenderPassInfo([colorAttachment]));
          var curWidth = this._width;
          var curHeight = this._height;
          bloom.prefiterTex = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA8, curWidth >> 1, curHeight >> 1));
          bloom.prefilterFramebuffer = device.createFramebuffer(new FramebufferInfo(bloom.renderPass, [bloom.prefiterTex]));
          curWidth >>= 1;
          curHeight >>= 1;

          for (var i = 0; i < MAX_BLOOM_FILTER_PASS_NUM; ++i) {
            bloom.downsampleTexs.push(device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA8, curWidth >> 1, curHeight >> 1)));
            bloom.downsampleFramebuffers[i] = device.createFramebuffer(new FramebufferInfo(bloom.renderPass, [bloom.downsampleTexs[i]]));
            bloom.upsampleTexs.push(device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA8, curWidth, curHeight)));
            bloom.upsampleFramebuffers[i] = device.createFramebuffer(new FramebufferInfo(bloom.renderPass, [bloom.upsampleTexs[i]]));
            curWidth >>= 1;
            curHeight >>= 1;
          }

          bloom.combineTex = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA8, this._width, this._height));
          bloom.combineFramebuffer = device.createFramebuffer(new FramebufferInfo(bloom.renderPass, [bloom.combineTex]));
          bloom.sampler = this.globalDSManager.linearSampler;
        };

        _proto.on = function on(type, callback, target, once) {
          return this._eventProcessor.on(type, callback, target, once);
        };

        _proto.once = function once(type, callback, target) {
          return this._eventProcessor.once(type, callback, target);
        };

        _proto.off = function off(type, callback, target) {
          this._eventProcessor.off(type, callback, target);
        };

        _proto.emit = function emit(type, arg0, arg1, arg2, arg3, arg4) {
          this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
        };

        _proto.targetOff = function targetOff(typeOrTarget) {
          this._eventProcessor.targetOff(typeOrTarget);
        };

        _proto.removeAll = function removeAll(typeOrTarget) {
          this._eventProcessor.removeAll(typeOrTarget);
        };

        _proto.hasEventListener = function hasEventListener(type, callback, target) {
          return this._eventProcessor.hasEventListener(type, callback, target);
        };

        _createClass(RenderPipeline, [{
          key: "tag",
          get: function get() {
            return this._tag;
          }
        }, {
          key: "flows",
          get: function get() {
            return this._flows;
          }
        }, {
          key: "quadIAOnscreen",
          get: function get() {
            return this._quadIAOnscreen;
          }
        }, {
          key: "quadIAOffscreen",
          get: function get() {
            return this._quadIAOffscreen;
          }
        }, {
          key: "constantMacros",
          get: function get() {
            return this._constantMacros;
          }
        }, {
          key: "macros",
          get: function get() {
            return this._macros;
          }
        }, {
          key: "device",
          get: function get() {
            return this._device;
          }
        }, {
          key: "globalDSManager",
          get: function get() {
            return this._globalDSManager;
          }
        }, {
          key: "descriptorSetLayout",
          get: function get() {
            return this._globalDSManager.descriptorSetLayout;
          }
        }, {
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          }
        }, {
          key: "commandBuffers",
          get: function get() {
            return this._commandBuffers;
          }
        }, {
          key: "pipelineUBO",
          get: function get() {
            return this._pipelineUBO;
          }
        }, {
          key: "pipelineSceneData",
          get: function get() {
            return this._pipelineSceneData;
          }
        }, {
          key: "profiler",
          get: function get() {
            return this._profiler;
          },
          set: function set(value) {
            this._profiler = value;
          }
        }, {
          key: "geometryRenderer",
          get: function get() {
            return this._geometryRenderer;
          }
        }, {
          key: "clusterEnabled",
          get: function get() {
            return this._clusterEnabled;
          },
          set: function set(value) {
            this._clusterEnabled = value;
          }
        }, {
          key: "bloomEnabled",
          get: function get() {
            return this._bloomEnabled;
          },
          set: function set(value) {
            this._bloomEnabled = value;
          }
        }]);

        return RenderPipeline;
      }(Asset), _temp$e), (_descriptor$c = _applyDecoratedDescriptor(_class2$e.prototype, "_tag", [_dec2$8, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2$9 = _applyDecoratedDescriptor(_class2$e.prototype, "_flows", [_dec3$4, _dec4$3, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$e)) || _class$g));
      legacyCC.RenderPipeline = RenderPipeline;

      var CommonStagePriority;

      (function (CommonStagePriority) {
        CommonStagePriority[CommonStagePriority["BLOOM"] = 18] = "BLOOM";
        CommonStagePriority[CommonStagePriority["POST_PROCESS"] = 19] = "POST_PROCESS";
        CommonStagePriority[CommonStagePriority["UI"] = 20] = "UI";
      })(CommonStagePriority || (CommonStagePriority = {}));

      var ForwardStagePriority;

      (function (ForwardStagePriority) {
        ForwardStagePriority[ForwardStagePriority["FORWARD"] = 10] = "FORWARD";
      })(ForwardStagePriority || (ForwardStagePriority = {}));

      var ForwardFlowPriority;

      (function (ForwardFlowPriority) {
        ForwardFlowPriority[ForwardFlowPriority["SHADOW"] = 0] = "SHADOW";
        ForwardFlowPriority[ForwardFlowPriority["FORWARD"] = 1] = "FORWARD";
        ForwardFlowPriority[ForwardFlowPriority["UI"] = 10] = "UI";
      })(ForwardFlowPriority || (ForwardFlowPriority = {}));

      var DeferredStagePriority;

      (function (DeferredStagePriority) {
        DeferredStagePriority[DeferredStagePriority["GBUFFER"] = 10] = "GBUFFER";
        DeferredStagePriority[DeferredStagePriority["LIGHTING"] = 15] = "LIGHTING";
        DeferredStagePriority[DeferredStagePriority["TRANSPARENT"] = 18] = "TRANSPARENT";
      })(DeferredStagePriority || (DeferredStagePriority = {}));

      var DeferredFlowPriority;

      (function (DeferredFlowPriority) {
        DeferredFlowPriority[DeferredFlowPriority["SHADOW"] = 0] = "SHADOW";
        DeferredFlowPriority[DeferredFlowPriority["MAIN"] = 1] = "MAIN";
        DeferredFlowPriority[DeferredFlowPriority["UI"] = 10] = "UI";
      })(DeferredFlowPriority || (DeferredFlowPriority = {}));

      var _dec$h, _class$h, _temp$f;

      var _colorAttachment = new ColorAttachment();

      _colorAttachment.format = Format.RGBA8;

      var _depthStencilAttachment = new DepthStencilAttachment();

      _depthStencilAttachment.format = Format.DEPTH_STENCIL;
      var passInfo = new RenderPassInfo([_colorAttachment], _depthStencilAttachment);
      var _windowInfo = {
        width: 1,
        height: 1,
        renderPassInfo: passInfo
      };
      var RenderTexture = exports('RenderTexture', (_dec$h = ccclass('cc.RenderTexture'), _dec$h(_class$h = (_temp$f = function (_TextureBase) {
        _inheritsLoose(RenderTexture, _TextureBase);

        function RenderTexture() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _TextureBase.call.apply(_TextureBase, [this].concat(args)) || this;
          _this._window = null;
          return _this;
        }

        var _proto = RenderTexture.prototype;

        _proto.initialize = function initialize(info) {
          this._name = info.name || '';
          this._width = info.width;
          this._height = info.height;

          this._initWindow(info);
        };

        _proto.reset = function reset(info) {
          this.initialize(info);
        };

        _proto.destroy = function destroy() {
          if (this._window) {
            var root = legacyCC.director.root;
            root === null || root === void 0 ? void 0 : root.destroyWindow(this._window);
            this._window = null;
          }

          return _TextureBase.prototype.destroy.call(this);
        };

        _proto.resize = function resize(width, height) {
          this._width = Math.floor(clamp(width, 1, 2048));
          this._height = Math.floor(clamp(height, 1, 2048));

          if (this._window) {
            this._window.resize(this._width, this._height);
          }

          this.emit('resize', this._window);
        };

        _proto._serialize = function _serialize(ctxForExporting) {

          return {};
        };

        _proto._deserialize = function _deserialize(serializedData, handle) {
          var data = serializedData;
          this._width = data.w;
          this._height = data.h;
          this._name = data.n;

          _TextureBase.prototype._deserialize.call(this, data.base, handle);
        };

        _proto.getGFXTexture = function getGFXTexture() {
          return this._window && this._window.framebuffer.colorTextures[0];
        };

        _proto.onLoaded = function onLoaded() {
          this._initWindow();
        };

        _proto._initWindow = function _initWindow(info) {
          var root = legacyCC.director.root;
          _windowInfo.title = this._name;
          _windowInfo.width = this._width;
          _windowInfo.height = this._height;
          _windowInfo.renderPassInfo = info && info.passInfo ? info.passInfo : passInfo;
          _colorAttachment.barrier = root.device.getGeneralBarrier(new GeneralBarrierInfo(AccessFlagBit.FRAGMENT_SHADER_READ_TEXTURE, AccessFlagBit.FRAGMENT_SHADER_READ_TEXTURE));

          if (this._window) {
            this._window.destroy();

            this._window.initialize(root.device, _windowInfo);
          } else {
            this._window = root.createWindow(_windowInfo);
          }
        };

        _proto.initDefault = function initDefault(uuid) {
          _TextureBase.prototype.initDefault.call(this, uuid);

          this._width = this._height = 1;

          this._initWindow();
        };

        _proto.validate = function validate() {
          return this.width >= 1 && this.width <= 2048 && this.height >= 1 && this.height <= 2048;
        };

        _proto.readPixels = function readPixels(x, y, width, height, buffer) {
          if (x === void 0) {
            x = 0;
          }

          if (y === void 0) {
            y = 0;
          }

          width = width || this.width;
          height = height || this.height;
          var gfxTexture = this.getGFXTexture();

          if (!gfxTexture) {
            errorID(7606);
            return null;
          }

          var needSize = 4 * width * height;

          if (buffer === undefined) {
            buffer = new Uint8Array(needSize);
          } else if (buffer.length < needSize) {
            errorID(7607, needSize);
            return null;
          }

          var gfxDevice = this._getGFXDevice();

          var bufferViews = [];
          var regions = [];
          var region0 = new BufferTextureCopy();
          region0.texOffset.x = x;
          region0.texOffset.y = y;
          region0.texExtent.width = width;
          region0.texExtent.height = height;
          regions.push(region0);
          bufferViews.push(buffer);
          gfxDevice === null || gfxDevice === void 0 ? void 0 : gfxDevice.copyTextureToBuffers(gfxTexture, bufferViews, regions);
          return buffer;
        };

        _createClass(RenderTexture, [{
          key: "window",
          get: function get() {
            return this._window;
          }
        }]);

        return RenderTexture;
      }(TextureBase), _temp$f)) || _class$h));
      legacyCC.RenderTexture = RenderTexture;

      var _dec$i, _dec2$9, _dec3$5, _dec4$4, _class$i, _class2$f, _descriptor$d, _descriptor2$a, _descriptor3$8, _descriptor4$6, _descriptor5$3, _descriptor6$1, _temp$g, _dec5$1, _dec6$1, _class4$1, _class5$1, _descriptor7$1, _descriptor8$1, _temp2, _dec7, _dec8, _class7, _class8, _descriptor9, _descriptor10, _temp3$1, _dec9, _dec10, _dec11, _class10, _class11, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _temp4, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _class13, _class14, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _temp5, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _class16, _class17, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _temp6, _dec26, _dec27, _dec28, _class19, _class20, _descriptor30, _descriptor31, _descriptor32, _temp7, _dec29, _dec30, _dec31, _class22, _class23, _descriptor33, _descriptor34, _descriptor35, _temp8;
      ccenum(TextureType);
      ccenum(TextureUsageBit);
      ccenum(StoreOp);
      ccenum(LoadOp);
      ccenum(AccessFlagBit);
      var RenderFlowTag;

      (function (RenderFlowTag) {
        RenderFlowTag[RenderFlowTag["SCENE"] = 0] = "SCENE";
        RenderFlowTag[RenderFlowTag["POSTPROCESS"] = 1] = "POSTPROCESS";
        RenderFlowTag[RenderFlowTag["UI"] = 2] = "UI";
      })(RenderFlowTag || (RenderFlowTag = {}));

      ccenum(RenderFlowTag);
      var RenderTextureDesc = (_dec$i = ccclass('RenderTextureDesc'), _dec2$9 = type(TextureType), _dec3$5 = type(TextureUsageBit), _dec4$4 = type(Format), _dec$i(_class$i = (_class2$f = (_temp$g = function RenderTextureDesc() {
        _initializerDefineProperty(this, "name", _descriptor$d, this);

        _initializerDefineProperty(this, "type", _descriptor2$a, this);

        _initializerDefineProperty(this, "usage", _descriptor3$8, this);

        _initializerDefineProperty(this, "format", _descriptor4$6, this);

        _initializerDefineProperty(this, "width", _descriptor5$3, this);

        _initializerDefineProperty(this, "height", _descriptor6$1, this);
      }, _temp$g), (_descriptor$d = _applyDecoratedDescriptor(_class2$f.prototype, "name", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor2$a = _applyDecoratedDescriptor(_class2$f.prototype, "type", [_dec2$9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return TextureType.TEX2D;
        }
      }), _descriptor3$8 = _applyDecoratedDescriptor(_class2$f.prototype, "usage", [_dec3$5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return TextureUsageBit.COLOR_ATTACHMENT;
        }
      }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$f.prototype, "format", [_dec4$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Format.UNKNOWN;
        }
      }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$f.prototype, "width", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -1;
        }
      }), _descriptor6$1 = _applyDecoratedDescriptor(_class2$f.prototype, "height", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -1;
        }
      })), _class2$f)) || _class$i);
      var RenderTextureConfig = (_dec5$1 = ccclass('RenderTextureConfig'), _dec6$1 = type(RenderTexture), _dec5$1(_class4$1 = (_class5$1 = (_temp2 = function RenderTextureConfig() {
        _initializerDefineProperty(this, "name", _descriptor7$1, this);

        _initializerDefineProperty(this, "texture", _descriptor8$1, this);
      }, _temp2), (_descriptor7$1 = _applyDecoratedDescriptor(_class5$1.prototype, "name", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor8$1 = _applyDecoratedDescriptor(_class5$1.prototype, "texture", [_dec6$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class5$1)) || _class4$1);
      var MaterialConfig = (_dec7 = ccclass('MaterialConfig'), _dec8 = type(Material), _dec7(_class7 = (_class8 = (_temp3$1 = function MaterialConfig() {
        _initializerDefineProperty(this, "name", _descriptor9, this);

        _initializerDefineProperty(this, "material", _descriptor10, this);
      }, _temp3$1), (_descriptor9 = _applyDecoratedDescriptor(_class8.prototype, "name", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class8.prototype, "material", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class8)) || _class7);
      var FrameBufferDesc = (_dec9 = ccclass('FrameBufferDesc'), _dec10 = type([CCString]), _dec11 = type(RenderTexture), _dec9(_class10 = (_class11 = (_temp4 = function FrameBufferDesc() {
        _initializerDefineProperty(this, "name", _descriptor11, this);

        _initializerDefineProperty(this, "renderPass", _descriptor12, this);

        _initializerDefineProperty(this, "colorTextures", _descriptor13, this);

        _initializerDefineProperty(this, "depthStencilTexture", _descriptor14, this);

        _initializerDefineProperty(this, "texture", _descriptor15, this);
      }, _temp4), (_descriptor11 = _applyDecoratedDescriptor(_class11.prototype, "name", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class11.prototype, "renderPass", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class11.prototype, "colorTextures", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class11.prototype, "depthStencilTexture", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class11.prototype, "texture", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class11)) || _class10);
      var ColorDesc = (_dec12 = ccclass('ColorDesc'), _dec13 = type(Format), _dec14 = type(LoadOp), _dec15 = type(StoreOp), _dec16 = type([AccessFlagBit]), _dec17 = type([AccessFlagBit]), _dec12(_class13 = (_class14 = (_temp5 = function ColorDesc() {
        _initializerDefineProperty(this, "format", _descriptor16, this);

        _initializerDefineProperty(this, "loadOp", _descriptor17, this);

        _initializerDefineProperty(this, "storeOp", _descriptor18, this);

        _initializerDefineProperty(this, "sampleCount", _descriptor19, this);

        _initializerDefineProperty(this, "beginAccesses", _descriptor20, this);

        _initializerDefineProperty(this, "endAccesses", _descriptor21, this);
      }, _temp5), (_descriptor16 = _applyDecoratedDescriptor(_class14.prototype, "format", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Format.UNKNOWN;
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class14.prototype, "loadOp", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return LoadOp.CLEAR;
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class14.prototype, "storeOp", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return StoreOp.STORE;
        }
      }), _descriptor19 = _applyDecoratedDescriptor(_class14.prototype, "sampleCount", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor20 = _applyDecoratedDescriptor(_class14.prototype, "beginAccesses", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return AccessFlagBit.NONE;
        }
      }), _descriptor21 = _applyDecoratedDescriptor(_class14.prototype, "endAccesses", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return AccessFlagBit.COLOR_ATTACHMENT_WRITE;
        }
      })), _class14)) || _class13);
      var DepthStencilDesc = (_dec18 = ccclass('DepthStencilDesc'), _dec19 = type(Format), _dec20 = type(LoadOp), _dec21 = type(StoreOp), _dec22 = type(LoadOp), _dec23 = type(StoreOp), _dec24 = type(AccessFlagBit), _dec25 = type(AccessFlagBit), _dec18(_class16 = (_class17 = (_temp6 = function DepthStencilDesc() {
        _initializerDefineProperty(this, "format", _descriptor22, this);

        _initializerDefineProperty(this, "depthLoadOp", _descriptor23, this);

        _initializerDefineProperty(this, "depthStoreOp", _descriptor24, this);

        _initializerDefineProperty(this, "stencilLoadOp", _descriptor25, this);

        _initializerDefineProperty(this, "stencilStoreOp", _descriptor26, this);

        _initializerDefineProperty(this, "sampleCount", _descriptor27, this);

        _initializerDefineProperty(this, "beginAccesses", _descriptor28, this);

        _initializerDefineProperty(this, "endAccesses", _descriptor29, this);
      }, _temp6), (_descriptor22 = _applyDecoratedDescriptor(_class17.prototype, "format", [_dec19], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Format.UNKNOWN;
        }
      }), _descriptor23 = _applyDecoratedDescriptor(_class17.prototype, "depthLoadOp", [_dec20], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return LoadOp.CLEAR;
        }
      }), _descriptor24 = _applyDecoratedDescriptor(_class17.prototype, "depthStoreOp", [_dec21], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return StoreOp.STORE;
        }
      }), _descriptor25 = _applyDecoratedDescriptor(_class17.prototype, "stencilLoadOp", [_dec22], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return LoadOp.CLEAR;
        }
      }), _descriptor26 = _applyDecoratedDescriptor(_class17.prototype, "stencilStoreOp", [_dec23], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return StoreOp.STORE;
        }
      }), _descriptor27 = _applyDecoratedDescriptor(_class17.prototype, "sampleCount", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor28 = _applyDecoratedDescriptor(_class17.prototype, "beginAccesses", [_dec24], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return AccessFlagBit.NONE;
        }
      }), _descriptor29 = _applyDecoratedDescriptor(_class17.prototype, "endAccesses", [_dec25], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return AccessFlagBit.DEPTH_STENCIL_ATTACHMENT_WRITE;
        }
      })), _class17)) || _class16);
      var RenderPassDesc = (_dec26 = ccclass('RenderPassDesc'), _dec27 = type([ColorDesc]), _dec28 = type(DepthStencilDesc), _dec26(_class19 = (_class20 = (_temp7 = function RenderPassDesc() {
        _initializerDefineProperty(this, "index", _descriptor30, this);

        _initializerDefineProperty(this, "colorAttachments", _descriptor31, this);

        _initializerDefineProperty(this, "depthStencilAttachment", _descriptor32, this);
      }, _temp7), (_descriptor30 = _applyDecoratedDescriptor(_class20.prototype, "index", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -1;
        }
      }), _descriptor31 = _applyDecoratedDescriptor(_class20.prototype, "colorAttachments", [_dec27], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor32 = _applyDecoratedDescriptor(_class20.prototype, "depthStencilAttachment", [_dec28], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new DepthStencilDesc();
        }
      })), _class20)) || _class19);
      var RenderQueueSortMode;

      (function (RenderQueueSortMode) {
        RenderQueueSortMode[RenderQueueSortMode["FRONT_TO_BACK"] = 0] = "FRONT_TO_BACK";
        RenderQueueSortMode[RenderQueueSortMode["BACK_TO_FRONT"] = 1] = "BACK_TO_FRONT";
      })(RenderQueueSortMode || (RenderQueueSortMode = {}));

      ccenum(RenderQueueSortMode);
      var RenderQueueDesc = (_dec29 = ccclass('RenderQueueDesc'), _dec30 = type(RenderQueueSortMode), _dec31 = type([CCString]), _dec29(_class22 = (_class23 = (_temp8 = function RenderQueueDesc() {
        _initializerDefineProperty(this, "isTransparent", _descriptor33, this);

        _initializerDefineProperty(this, "sortMode", _descriptor34, this);

        _initializerDefineProperty(this, "stages", _descriptor35, this);
      }, _temp8), (_descriptor33 = _applyDecoratedDescriptor(_class23.prototype, "isTransparent", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor34 = _applyDecoratedDescriptor(_class23.prototype, "sortMode", [_dec30], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return RenderQueueSortMode.FRONT_TO_BACK;
        }
      }), _descriptor35 = _applyDecoratedDescriptor(_class23.prototype, "stages", [_dec31], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class23)) || _class22);

      function opaqueCompareFn(a, b) {
        return a.hash - b.hash || a.depth - b.depth || a.shaderId - b.shaderId;
      }
      function transparentCompareFn(a, b) {
        return a.hash - b.hash || b.depth - a.depth || a.shaderId - b.shaderId;
      }
      var RenderQueue$1 = function () {
        function RenderQueue(desc) {
          this.queue = void 0;
          this._passDesc = void 0;
          this._passPool = void 0;
          this._passDesc = desc;
          this._passPool = new RecyclePool(function () {
            return {
              hash: 0,
              depth: 0,
              shaderId: 0,
              subModel: null,
              passIdx: 0
            };
          }, 64);
          this.queue = new CachedArray(64, this._passDesc.sortFunc);
        }

        var _proto = RenderQueue.prototype;

        _proto.clear = function clear() {
          this.queue.clear();

          this._passPool.reset();
        };

        _proto.insertRenderPass = function insertRenderPass(renderObj, subModelIdx, passIdx) {
          var subModel = renderObj.model.subModels[subModelIdx];
          var pass = subModel.passes[passIdx];
          var shader = subModel.shaders[passIdx];
          var isTransparent = pass.blendState.targets[0].blend;

          if (isTransparent !== this._passDesc.isTransparent || !(pass.phase & this._passDesc.phases)) {
            return false;
          }

          var hash = 0 << 30 | pass.priority << 16 | subModel.priority << 8 | passIdx;

          var rp = this._passPool.add();

          rp.hash = hash;
          rp.depth = renderObj.depth || 0;
          rp.shaderId = shader.typedID;
          rp.subModel = subModel;
          rp.passIdx = passIdx;
          this.queue.push(rp);
          return true;
        };

        _proto.sort = function sort() {
          this.queue.sort();
        };

        _proto.recordCommandBuffer = function recordCommandBuffer(device, renderPass, cmdBuff) {
          for (var i = 0; i < this.queue.length; ++i) {
            var _this$queue$array$i = this.queue.array[i],
                subModel = _this$queue$array$i.subModel,
                passIdx = _this$queue$array$i.passIdx;
            var inputAssembler = subModel.inputAssembler;
            var pass = subModel.passes[passIdx];
            var shader = subModel.shaders[passIdx];
            var pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, renderPass, inputAssembler);
            cmdBuff.bindPipelineState(pso);
            cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
            cmdBuff.bindDescriptorSet(SetIndex.LOCAL, subModel.descriptorSet);
            cmdBuff.bindInputAssembler(inputAssembler);
            cmdBuff.draw(inputAssembler);
          }
        };

        return RenderQueue;
      }();
      function convertRenderQueue(desc) {
        var phase = 0;

        for (var j = 0; j < desc.stages.length; j++) {
          phase |= getPhaseID(desc.stages[j]);
        }

        var sortFunc = opaqueCompareFn;

        switch (desc.sortMode) {
          case RenderQueueSortMode.BACK_TO_FRONT:
            sortFunc = transparentCompareFn;
            break;

          case RenderQueueSortMode.FRONT_TO_BACK:
            sortFunc = opaqueCompareFn;
            break;
        }

        return new RenderQueue$1({
          isTransparent: desc.isTransparent,
          phases: phase,
          sortFunc: sortFunc
        });
      }
      function renderQueueClearFunc(rq) {
        rq.clear();
      }
      function renderQueueSortFunc(rq) {
        rq.sort();
      }

      var RenderBatchedQueue = function () {
        function RenderBatchedQueue() {
          this.queue = new Set();
        }

        var _proto = RenderBatchedQueue.prototype;

        _proto.clear = function clear() {
          var it = this.queue.values();
          var res = it.next();

          while (!res.done) {
            res.value.clear();
            res = it.next();
          }

          this.queue.clear();
        };

        _proto.uploadBuffers = function uploadBuffers(cmdBuff) {
          var it = this.queue.values();
          var res = it.next();

          while (!res.done) {
            for (var b = 0; b < res.value.batches.length; ++b) {
              var batch = res.value.batches[b];

              if (!batch.mergeCount) {
                continue;
              }

              for (var v = 0; v < batch.vbs.length; ++v) {
                batch.vbs[v].update(batch.vbDatas[v]);
              }

              cmdBuff.updateBuffer(batch.vbIdx, batch.vbIdxData.buffer);
              cmdBuff.updateBuffer(batch.ubo, batch.uboData);
            }

            res = it.next();
          }
        };

        _proto.recordCommandBuffer = function recordCommandBuffer(device, renderPass, cmdBuff, descriptorSet) {
          if (descriptorSet === void 0) {
            descriptorSet = null;
          }

          var it = this.queue.values();
          var res = it.next();

          while (!res.done) {
            var boundPSO = false;

            for (var b = 0; b < res.value.batches.length; ++b) {
              var batch = res.value.batches[b];

              if (!batch.mergeCount) {
                continue;
              }

              if (!boundPSO) {
                var shader = batch.shader;
                var pso = PipelineStateManager.getOrCreatePipelineState(device, batch.pass, shader, renderPass, batch.ia);
                cmdBuff.bindPipelineState(pso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, batch.pass.descriptorSet);
                boundPSO = true;
              }

              if (descriptorSet) cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, descriptorSet);
              cmdBuff.bindDescriptorSet(SetIndex.LOCAL, batch.descriptorSet, res.value.dynamicOffsets);
              cmdBuff.bindInputAssembler(batch.ia);
              cmdBuff.draw(batch.ia);
            }

            res = it.next();
          }
        };

        return RenderBatchedQueue;
      }();

      var RenderInstancedQueue = function () {
        function RenderInstancedQueue() {
          this.queue = new Set();
        }

        var _proto = RenderInstancedQueue.prototype;

        _proto.clear = function clear() {
          var it = this.queue.values();
          var res = it.next();

          while (!res.done) {
            res.value.clear();
            res = it.next();
          }

          this.queue.clear();
        };

        _proto.uploadBuffers = function uploadBuffers(cmdBuff) {
          var it = this.queue.values();
          var res = it.next();

          while (!res.done) {
            if (res.value.hasPendingModels) res.value.uploadBuffers(cmdBuff);
            res = it.next();
          }
        };

        _proto.recordCommandBuffer = function recordCommandBuffer(device, renderPass, cmdBuff, descriptorSet) {
          if (descriptorSet === void 0) {
            descriptorSet = null;
          }

          var it = this.queue.values();
          var res = it.next();

          while (!res.done) {
            var _res$value = res.value,
                instances = _res$value.instances,
                pass = _res$value.pass,
                hasPendingModels = _res$value.hasPendingModels;

            if (hasPendingModels) {
              cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
              var lastPSO = null;

              for (var b = 0; b < instances.length; ++b) {
                var instance = instances[b];

                if (!instance.count) {
                  continue;
                }

                var shader = instance.shader;
                var pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, renderPass, instance.ia);

                if (lastPSO !== pso) {
                  cmdBuff.bindPipelineState(pso);
                  lastPSO = pso;
                }

                if (descriptorSet) cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, descriptorSet);
                cmdBuff.bindDescriptorSet(SetIndex.LOCAL, instance.descriptorSet, res.value.dynamicOffsets);
                cmdBuff.bindInputAssembler(instance.ia);
                cmdBuff.draw(instance.ia);
              }
            }

            res = it.next();
          }
        };

        return RenderInstancedQueue;
      }();

      var _lightPassPool = new Pool$1(function () {
        return {
          subModel: null,
          passIdx: -1,
          dynamicOffsets: [],
          lights: []
        };
      }, 16);

      var _vec4Array = new Float32Array(4);

      var _dynamicOffsets = [];
      var _lightIndices = [];

      var _matShadowView$2 = new Mat4();

      var _matShadowViewProj$2 = new Mat4();

      function cullSphereLight(light, model) {
        return !!(model.worldBounds && !intersect.aabbWithAABB(model.worldBounds, light.aabb));
      }

      function cullSpotLight(light, model) {
        return !!(model.worldBounds && (!intersect.aabbWithAABB(model.worldBounds, light.aabb) || !intersect.aabbFrustum(model.worldBounds, light.frustum)));
      }

      var _phaseID = getPhaseID('forward-add');

      var _lightPassIndices = [];

      function getLightPassIndices(subModels, lightPassIndices) {
        lightPassIndices.length = 0;
        var hasValidLightPass = false;

        for (var j = 0; j < subModels.length; j++) {
          var passes = subModels[j].passes;
          var lightPassIndex = -1;

          for (var k = 0; k < passes.length; k++) {
            if (passes[k].phase === _phaseID) {
              lightPassIndex = k;
              hasValidLightPass = true;
              break;
            }
          }

          lightPassIndices.push(lightPassIndex);
        }

        return hasValidLightPass;
      }

      function isInstancedOrBatched(model) {
        var subModels = model.subModels;

        for (var m = 0; m < subModels.length; ++m) {
          var passes = subModels[m].passes;

          for (var p = 0; p < passes.length; ++p) {
            var pass = passes[p];
            var batchingScheme = pass.batchingScheme;

            if (batchingScheme === BatchingSchemes.INSTANCING) {
              return true;
            }

            if (batchingScheme === BatchingSchemes.VB_MERGING) {
              return true;
            }
          }
        }

        return false;
      }

      var RenderAdditiveLightQueue = function () {
        function RenderAdditiveLightQueue(pipeline) {
          this._pipeline = void 0;
          this._device = void 0;
          this._lightPasses = [];
          this._shadowUBO = new Float32Array(UBOShadow.COUNT);
          this._lightBufferCount = 16;
          this._lightBufferStride = void 0;
          this._lightBufferElementCount = void 0;
          this._lightBuffer = void 0;
          this._firstLightBufferView = void 0;
          this._lightBufferData = void 0;
          this._instancedQueue = void 0;
          this._batchedQueue = void 0;
          this._lightMeterScale = 10000.0;
          this._pipeline = pipeline;
          this._device = pipeline.device;
          this._instancedQueue = new RenderInstancedQueue();
          this._batchedQueue = new RenderBatchedQueue();
          var alignment = this._device.capabilities.uboOffsetAlignment;
          this._lightBufferStride = Math.ceil(UBOForwardLight.SIZE / alignment) * alignment;
          this._lightBufferElementCount = this._lightBufferStride / Float32Array.BYTES_PER_ELEMENT;
          this._lightBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._lightBufferStride * this._lightBufferCount, this._lightBufferStride));
          this._firstLightBufferView = this._device.createBuffer(new BufferViewInfo(this._lightBuffer, 0, UBOForwardLight.SIZE));
          this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._lightBufferCount);
        }

        var _proto = RenderAdditiveLightQueue.prototype;

        _proto.clear = function clear() {
          this._instancedQueue.clear();

          this._batchedQueue.clear();

          for (var i = 0; i < this._lightPasses.length; i++) {
            var lp = this._lightPasses[i];
            lp.dynamicOffsets.length = 0;
            lp.lights.length = 0;
          }

          _lightPassPool.freeArray(this._lightPasses);

          this._lightPasses.length = 0;
        };

        _proto.destroy = function destroy() {
          var descriptorSetMap = this._pipeline.globalDSManager.descriptorSetMap;
          var keys = descriptorSetMap.keys;

          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var descriptorSet = descriptorSetMap.get(key);

            if (descriptorSet) {
              descriptorSet.getBuffer(UBOShadow.BINDING).destroy();
              descriptorSet.getTexture(UNIFORM_SHADOWMAP_BINDING).destroy();
              descriptorSet.getTexture(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING).destroy();
              descriptorSet.destroy();
            }

            descriptorSetMap["delete"](key);
          }
        };

        _proto.gatherLightPasses = function gatherLightPasses(camera, cmdBuff) {
          this.clear();
          var validPunctualLights = this._pipeline.pipelineSceneData.validPunctualLights;

          if (!validPunctualLights.length) {
            return;
          }

          this._updateUBOs(camera, cmdBuff);

          this._updateLightDescriptorSet(camera, cmdBuff);

          var renderObjects = this._pipeline.pipelineSceneData.renderObjects;

          for (var i = 0; i < renderObjects.length; i++) {
            var ro = renderObjects[i];
            var model = ro.model;
            var subModels = model.subModels;

            if (!getLightPassIndices(subModels, _lightPassIndices)) {
              continue;
            }

            _lightIndices.length = 0;

            this._lightCulling(model, validPunctualLights);

            if (!_lightIndices.length) {
              continue;
            }

            for (var j = 0; j < subModels.length; j++) {
              var lightPassIdx = _lightPassIndices[j];

              if (lightPassIdx < 0) {
                continue;
              }

              var subModel = subModels[j];
              var pass = subModel.passes[lightPassIdx];
              var isTransparent = subModel.passes[0].blendState.targets[0].blend;

              if (isTransparent) {
                continue;
              }

              subModel.descriptorSet.bindBuffer(UBOForwardLight.BINDING, this._firstLightBufferView);
              subModel.descriptorSet.update();

              this._addRenderQueue(pass, subModel, model, lightPassIdx);
            }
          }

          this._instancedQueue.uploadBuffers(cmdBuff);

          this._batchedQueue.uploadBuffers(cmdBuff);
        };

        _proto.recordCommandBuffer = function recordCommandBuffer(device, renderPass, cmdBuff) {
          var globalDSManager = this._pipeline.globalDSManager;

          for (var i = 0; i < _lightIndices.length; i++) {
            var light = _lightIndices[i];
            var descriptorSet = globalDSManager.getOrCreateDescriptorSet(light);

            this._instancedQueue.recordCommandBuffer(device, renderPass, cmdBuff, descriptorSet);

            this._batchedQueue.recordCommandBuffer(device, renderPass, cmdBuff, descriptorSet);
          }

          for (var _i = 0; _i < this._lightPasses.length; _i++) {
            var _this$_lightPasses$_i = this._lightPasses[_i],
                subModel = _this$_lightPasses$_i.subModel,
                passIdx = _this$_lightPasses$_i.passIdx,
                dynamicOffsets = _this$_lightPasses$_i.dynamicOffsets,
                lights = _this$_lightPasses$_i.lights;
            var pass = subModel.passes[passIdx];
            var shader = subModel.shaders[passIdx];
            var ia = subModel.inputAssembler;
            var pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, renderPass, ia);
            var matDS = pass.descriptorSet;
            var localDS = subModel.descriptorSet;
            cmdBuff.bindPipelineState(pso);
            cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, matDS);
            cmdBuff.bindInputAssembler(ia);

            for (var j = 0; j < dynamicOffsets.length; ++j) {
              var _light = lights[j];

              var _descriptorSet = globalDSManager.getOrCreateDescriptorSet(_light);

              _dynamicOffsets[0] = dynamicOffsets[j];
              cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, _descriptorSet);
              cmdBuff.bindDescriptorSet(SetIndex.LOCAL, localDS, _dynamicOffsets);
              cmdBuff.draw(ia);
            }
          }
        };

        _proto._lightCulling = function _lightCulling(model, validPunctualLights) {
          var isCulled = false;
          var isNeedCulling = !isInstancedOrBatched(model);

          for (var l = 0; l < validPunctualLights.length; l++) {
            var light = validPunctualLights[l];

            switch (light.type) {
              case LightType.SPHERE:
                if (isNeedCulling) {
                  isCulled = cullSphereLight(light, model);
                }

                break;

              case LightType.SPOT:
                if (isNeedCulling) {
                  isCulled = cullSpotLight(light, model);
                }

                break;
            }

            if (!isCulled) {
              _lightIndices.push(l);
            }
          }
        };

        _proto._addRenderQueue = function _addRenderQueue(pass, subModel, model, lightPassIdx) {
          var batchingScheme = pass.batchingScheme;

          if (batchingScheme === BatchingSchemes.INSTANCING) {
            for (var l = 0; l < _lightIndices.length; l++) {
              var idx = _lightIndices[l];
              var buffer = pass.getInstancedBuffer(idx);
              buffer.merge(subModel, model.instancedAttributes, lightPassIdx);
              buffer.dynamicOffsets[0] = this._lightBufferStride * idx;

              this._instancedQueue.queue.add(buffer);
            }
          } else if (batchingScheme === BatchingSchemes.VB_MERGING) {
            for (var _l = 0; _l < _lightIndices.length; _l++) {
              var _idx = _lightIndices[_l];

              var _buffer = pass.getBatchedBuffer(_idx);

              _buffer.merge(subModel, lightPassIdx, model);

              _buffer.dynamicOffsets[0] = this._lightBufferStride * _idx;

              this._batchedQueue.queue.add(_buffer);
            }
          } else {
            var lp = _lightPassPool.alloc();

            lp.subModel = subModel;
            lp.passIdx = lightPassIdx;

            for (var _l2 = 0; _l2 < _lightIndices.length; _l2++) {
              var _idx2 = _lightIndices[_l2];
              lp.lights.push(_idx2);
              lp.dynamicOffsets.push(this._lightBufferStride * _idx2);
            }

            this._lightPasses.push(lp);
          }
        };

        _proto._updateLightDescriptorSet = function _updateLightDescriptorSet(camera, cmdBuff) {
          var device = this._pipeline.device;
          var sceneData = this._pipeline.pipelineSceneData;
          var shadowInfo = sceneData.shadows;
          var shadowFrameBufferMap = sceneData.shadowFrameBufferMap;
          var mainLight = camera.scene.mainLight;
          var linear = 0.0;
          var packing = supportsR32FloatTexture(device) ? 0.0 : 1.0;
          var globalDSManager = this._pipeline.globalDSManager;
          var validPunctualLights = sceneData.validPunctualLights;

          for (var i = 0; i < validPunctualLights.length; i++) {
            var light = validPunctualLights[i];
            var descriptorSet = globalDSManager.getOrCreateDescriptorSet(i);

            if (!descriptorSet) {
              continue;
            }

            var matShadowProj = void 0;
            var matShadowInvProj = void 0;

            switch (light.type) {
              case LightType.SPHERE:
                {
                  if (mainLight) {
                    updatePlanarPROJ(shadowInfo, mainLight, this._shadowUBO);
                    updatePlanarNormalAndDistance(shadowInfo, this._shadowUBO);
                  }

                  this._shadowUBO[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = shadowInfo.size.x;
                  this._shadowUBO[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = shadowInfo.size.y;
                  this._shadowUBO[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = 1.0;
                  this._shadowUBO[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = 0.0;
                  this._shadowUBO[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 2.0;
                  this._shadowUBO[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = packing;
                  this._shadowUBO[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = 0.0;
                  this._shadowUBO[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0.0;
                  Color.toArray(this._shadowUBO, shadowInfo.shadowColor, UBOShadow.SHADOW_COLOR_OFFSET);
                  break;
                }

              case LightType.SPOT:
                {
                  var spotLight = light;

                  if (mainLight) {
                    updatePlanarPROJ(shadowInfo, mainLight, this._shadowUBO);
                    updatePlanarNormalAndDistance(shadowInfo, this._shadowUBO);
                  }

                  Mat4.invert(_matShadowView$2, light.node.getWorldMatrix());
                  Mat4.perspective(_matShadowViewProj$2, light.angle, 1.0, 0.001, light.range);
                  matShadowProj = _matShadowViewProj$2.clone();
                  matShadowInvProj = _matShadowViewProj$2.clone().invert();
                  Mat4.multiply(_matShadowViewProj$2, _matShadowViewProj$2, _matShadowView$2);
                  Mat4.toArray(this._shadowUBO, _matShadowView$2, UBOShadow.MAT_LIGHT_VIEW_OFFSET);
                  Mat4.toArray(this._shadowUBO, _matShadowViewProj$2, UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET);
                  this._shadowUBO[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 0] = 0.01;
                  this._shadowUBO[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 1] = light.range;
                  this._shadowUBO[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 2] = linear;
                  this._shadowUBO[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 3] = 0.0;
                  this._shadowUBO[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = shadowInfo.size.x;
                  this._shadowUBO[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = shadowInfo.size.y;
                  this._shadowUBO[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = spotLight.shadowPcf;
                  this._shadowUBO[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = spotLight.shadowBias;
                  this._shadowUBO[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 1.0;
                  this._shadowUBO[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = packing;
                  this._shadowUBO[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = spotLight.shadowNormalBias;
                  this._shadowUBO[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0.0;
                  this._shadowUBO[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 0] = matShadowProj.m10;
                  this._shadowUBO[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 1] = matShadowProj.m14;
                  this._shadowUBO[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 2] = matShadowProj.m11;
                  this._shadowUBO[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 3] = matShadowProj.m15;
                  this._shadowUBO[UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 0] = matShadowInvProj.m10;
                  this._shadowUBO[UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 1] = matShadowInvProj.m14;
                  this._shadowUBO[UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 2] = matShadowInvProj.m11;
                  this._shadowUBO[UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 3] = matShadowInvProj.m15;
                  this._shadowUBO[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 0] = matShadowProj.m00;
                  this._shadowUBO[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 1] = matShadowProj.m05;
                  this._shadowUBO[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 2] = 1.0 / matShadowProj.m00;
                  this._shadowUBO[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 3] = 1.0 / matShadowProj.m05;
                  Color.toArray(this._shadowUBO, shadowInfo.shadowColor, UBOShadow.SHADOW_COLOR_OFFSET);

                  if (shadowFrameBufferMap.has(light)) {
                    var _shadowFrameBufferMap;

                    var texture = (_shadowFrameBufferMap = shadowFrameBufferMap.get(light)) === null || _shadowFrameBufferMap === void 0 ? void 0 : _shadowFrameBufferMap.colorTextures[0];

                    if (texture) {
                      descriptorSet.bindTexture(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, texture);
                    }
                  }

                  break;
                }
            }

            descriptorSet.update();
            cmdBuff.updateBuffer(descriptorSet.getBuffer(UBOShadow.BINDING), this._shadowUBO);
          }
        };

        _proto._updateUBOs = function _updateUBOs(camera, cmdBuff) {
          var exposure = camera.exposure;
          var sceneData = this._pipeline.pipelineSceneData;
          var isHDR = sceneData.isHDR;
          var shadowInfo = sceneData.shadows;
          var validPunctualLights = sceneData.validPunctualLights;

          if (validPunctualLights.length > this._lightBufferCount) {
            this._firstLightBufferView.destroy();

            this._lightBufferCount = nextPow2$1(validPunctualLights.length);

            this._lightBuffer.resize(this._lightBufferStride * this._lightBufferCount);

            this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._lightBufferCount);

            this._firstLightBufferView.initialize(new BufferViewInfo(this._lightBuffer, 0, UBOForwardLight.SIZE));
          }

          for (var l = 0, offset = 0; l < validPunctualLights.length; l++, offset += this._lightBufferElementCount) {
            var light = validPunctualLights[l];

            switch (light.type) {
              case LightType.SPHERE:
                Vec3.toArray(_vec4Array, light.position);
                _vec4Array[3] = 0;

                this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_POS_OFFSET);

                _vec4Array[0] = light.size;
                _vec4Array[1] = light.range;
                _vec4Array[2] = 0.0;
                _vec4Array[3] = 0.0;

                this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET);

                Vec3.toArray(_vec4Array, light.color);

                if (light.useColorTemperature) {
                  var tempRGB = light.colorTemperatureRGB;
                  _vec4Array[0] *= tempRGB.x;
                  _vec4Array[1] *= tempRGB.y;
                  _vec4Array[2] *= tempRGB.z;
                }

                if (isHDR) {
                  _vec4Array[3] = light.luminance * exposure * this._lightMeterScale;
                } else {
                  _vec4Array[3] = light.luminance;
                }

                this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_COLOR_OFFSET);

                break;

              case LightType.SPOT:
                Vec3.toArray(_vec4Array, light.position);
                _vec4Array[3] = 1;

                this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_POS_OFFSET);

                _vec4Array[0] = light.size;
                _vec4Array[1] = light.range;
                _vec4Array[2] = light.spotAngle;
                _vec4Array[3] = shadowInfo.enabled && light.shadowEnabled && shadowInfo.type === ShadowType.ShadowMap ? 1 : 0;

                this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET);

                Vec3.toArray(_vec4Array, light.direction);

                this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_DIR_OFFSET);

                Vec3.toArray(_vec4Array, light.color);

                if (light.useColorTemperature) {
                  var _tempRGB = light.colorTemperatureRGB;
                  _vec4Array[0] *= _tempRGB.x;
                  _vec4Array[1] *= _tempRGB.y;
                  _vec4Array[2] *= _tempRGB.z;
                }

                if (isHDR) {
                  _vec4Array[3] = light.luminance * exposure * this._lightMeterScale;
                } else {
                  _vec4Array[3] = light.luminance;
                }

                this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_COLOR_OFFSET);

                break;
            }
          }

          cmdBuff.updateBuffer(this._lightBuffer, this._lightBufferData);
        };

        return RenderAdditiveLightQueue;
      }();

      var _ab$1 = new AABB();

      var PlanarShadowQueue = function () {
        function PlanarShadowQueue(pipeline) {
          this._pendingModels = [];
          this._castModels = [];
          this._instancedQueue = new RenderInstancedQueue();
          this._pipeline = void 0;
          this._pipeline = pipeline;
        }

        var _proto = PlanarShadowQueue.prototype;

        _proto.gatherShadowPasses = function gatherShadowPasses(camera, cmdBuff) {
          var pipelineSceneData = this._pipeline.pipelineSceneData;
          var pipelineUBO = this._pipeline.pipelineUBO;
          var shadows = pipelineSceneData.shadows;

          this._instancedQueue.clear();

          this._pendingModels.length = 0;
          this._castModels.length = 0;

          if (!shadows.enabled || shadows.type !== ShadowType.Planar || shadows.normal.length() < 0.000001) {
            return;
          }

          var scene = camera.scene;
          var frustum = camera.frustum;
          var shadowVisible = (camera.visibility & Layers.BitMask.DEFAULT) !== 0;

          if (!scene.mainLight || !shadowVisible) {
            return;
          }

          var models = scene.models;

          for (var i = 0; i < models.length; i++) {
            var model = models[i];

            if (model.enabled && model.node && model.castShadow) {
              this._castModels.push(model);
            }
          }

          var instancedBuffer = shadows.instancingMaterial.passes[0].getInstancedBuffer();

          this._instancedQueue.queue.add(instancedBuffer);

          for (var _i = 0; _i < this._castModels.length; _i++) {
            var _model = this._castModels[_i];

            if (_model.worldBounds) {
              AABB.transform(_ab$1, _model.worldBounds, shadows.matLight);

              if (!intersect.aabbFrustum(_ab$1, frustum)) {
                continue;
              }
            }

            if (_model.isInstancingEnabled) {
              var subModels = _model.subModels;

              for (var m = 0; m < subModels.length; m++) {
                var subModel = subModels[m];
                instancedBuffer.merge(subModel, _model.instancedAttributes, 0, subModel.planarInstanceShader);
              }
            } else {
              this._pendingModels.push(_model);
            }
          }

          this._instancedQueue.uploadBuffers(cmdBuff);
        };

        _proto.recordCommandBuffer = function recordCommandBuffer(device, renderPass, cmdBuff) {
          var shadows = this._pipeline.pipelineSceneData.shadows;

          if (!shadows.enabled || shadows.type !== ShadowType.Planar) {
            return;
          }

          this._instancedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          if (!this._pendingModels.length) {
            return;
          }

          var pass = shadows.material.passes[0];
          var descriptorSet = pass.descriptorSet;
          cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, descriptorSet);
          var modelCount = this._pendingModels.length;

          for (var i = 0; i < modelCount; i++) {
            var model = this._pendingModels[i];

            for (var j = 0; j < model.subModels.length; j++) {
              var subModel = model.subModels[j];
              var shader = subModel.planarShader;
              var ia = subModel.inputAssembler;
              var pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, renderPass, ia);
              cmdBuff.bindPipelineState(pso);
              cmdBuff.bindDescriptorSet(SetIndex.LOCAL, subModel.descriptorSet);
              cmdBuff.bindInputAssembler(ia);
              cmdBuff.draw(ia);
            }
          }
        };

        return PlanarShadowQueue;
      }();

      var UIPhase = function () {
        function UIPhase() {
          this._phaseID = getPhaseID('default');
        }

        var _proto = UIPhase.prototype;

        _proto.activate = function activate(pipeline) {
          this._pipeline = pipeline;
        };

        _proto.render = function render(camera, renderPass) {
          var pipeline = this._pipeline;
          var device = pipeline.device;
          var cmdBuff = pipeline.commandBuffers[0];
          var scene = camera.scene;
          var batches = scene.batches;

          for (var i = 0; i < batches.length; i++) {
            var batch = batches[i];
            var visible = false;

            if (camera.visibility & batch.visFlags) {
              visible = true;
            }

            if (!visible) continue;
            var count = batch.shaders.length;

            for (var j = 0; j < count; j++) {
              var pass = batch.passes[j];
              if (pass.phase !== this._phaseID) continue;
              var shader = batch.shaders[j];
              var inputAssembler = batch.inputAssembler;
              var pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, renderPass, inputAssembler);
              cmdBuff.bindPipelineState(pso);
              cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
              var ds = batch.descriptorSet;
              cmdBuff.bindDescriptorSet(SetIndex.LOCAL, ds);
              cmdBuff.bindInputAssembler(inputAssembler);
              cmdBuff.draw(inputAssembler);
            }
          }
        };

        return UIPhase;
      }();

      var _dec$j, _dec2$a, _dec3$6, _class$j, _class2$g, _descriptor$e, _class3$7, _temp$h;
      var colors = [new Color$1(0, 0, 0, 1)];
      var ForwardStage = exports('ForwardStage', (_dec$j = ccclass('ForwardStage'), _dec2$a = type([RenderQueueDesc]), _dec3$6 = displayOrder(), _dec$j(_class$j = (_class2$g = (_temp$h = _class3$7 = function (_RenderStage) {
        _inheritsLoose(ForwardStage, _RenderStage);

        function ForwardStage() {
          var _this;

          _this = _RenderStage.call(this) || this;

          _initializerDefineProperty(_this, "renderQueues", _descriptor$e, _assertThisInitialized(_this));

          _this._renderQueues = [];
          _this._renderArea = new Rect$1();
          _this._batchedQueue = void 0;
          _this._instancedQueue = void 0;
          _this._phaseID = getPhaseID('default');
          _this._clearFlag = 0xffffffff;
          _this._batchedQueue = new RenderBatchedQueue();
          _this._instancedQueue = new RenderInstancedQueue();
          _this._uiPhase = new UIPhase();
          return _this;
        }

        var _proto = ForwardStage.prototype;

        _proto.initialize = function initialize(info) {
          _RenderStage.prototype.initialize.call(this, info);

          if (info.renderQueues) {
            this.renderQueues = info.renderQueues;
          }

          return true;
        };

        _proto.activate = function activate(pipeline, flow) {
          _RenderStage.prototype.activate.call(this, pipeline, flow);

          for (var i = 0; i < this.renderQueues.length; i++) {
            this._renderQueues[i] = convertRenderQueue(this.renderQueues[i]);
          }

          this._additiveLightQueue = new RenderAdditiveLightQueue(this._pipeline);
          this._planarQueue = new PlanarShadowQueue(this._pipeline);

          this._uiPhase.activate(pipeline);
        };

        _proto.destroy = function destroy() {};

        _proto.render = function render(camera) {
          this._instancedQueue.clear();

          this._batchedQueue.clear();

          var pipeline = this._pipeline;
          var device = pipeline.device;

          this._renderQueues.forEach(renderQueueClearFunc);

          var renderObjects = pipeline.pipelineSceneData.renderObjects;
          var m = 0;
          var p = 0;
          var k = 0;

          for (var i = 0; i < renderObjects.length; ++i) {
            var ro = renderObjects[i];
            var subModels = ro.model.subModels;

            for (m = 0; m < subModels.length; ++m) {
              var subModel = subModels[m];
              var passes = subModel.passes;

              for (p = 0; p < passes.length; ++p) {
                var pass = passes[p];
                if (pass.phase !== this._phaseID) continue;
                var batchingScheme = pass.batchingScheme;

                if (batchingScheme === BatchingSchemes.INSTANCING) {
                  var instancedBuffer = pass.getInstancedBuffer();
                  instancedBuffer.merge(subModel, ro.model.instancedAttributes, p);

                  this._instancedQueue.queue.add(instancedBuffer);
                } else if (batchingScheme === BatchingSchemes.VB_MERGING) {
                  var batchedBuffer = pass.getBatchedBuffer();
                  batchedBuffer.merge(subModel, p, ro.model);

                  this._batchedQueue.queue.add(batchedBuffer);
                } else {
                  for (k = 0; k < this._renderQueues.length; k++) {
                    this._renderQueues[k].insertRenderPass(ro, m, p);
                  }
                }
              }
            }
          }

          this._renderQueues.forEach(renderQueueSortFunc);

          var cmdBuff = pipeline.commandBuffers[0];
          pipeline.pipelineUBO.updateShadowUBO(camera);

          this._instancedQueue.uploadBuffers(cmdBuff);

          this._batchedQueue.uploadBuffers(cmdBuff);

          this._additiveLightQueue.gatherLightPasses(camera, cmdBuff);

          this._planarQueue.gatherShadowPasses(camera, cmdBuff);

          if (camera.clearFlag & ClearFlagBit.COLOR) {
            colors[0].x = camera.clearColor.x;
            colors[0].y = camera.clearColor.y;
            colors[0].z = camera.clearColor.z;
            colors[0].w = camera.clearColor.w;
          }

          pipeline.generateRenderArea(camera, this._renderArea);
          var framebuffer = camera.window.framebuffer;
          var renderPass = pipeline.getRenderPass(camera.clearFlag & this._clearFlag, framebuffer);
          cmdBuff.beginRenderPass(renderPass, framebuffer, this._renderArea, colors, camera.clearDepth, camera.clearStencil);
          cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);

          this._renderQueues[0].recordCommandBuffer(device, renderPass, cmdBuff);

          this._instancedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          this._batchedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          this._additiveLightQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);

          this._planarQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          this._renderQueues[1].recordCommandBuffer(device, renderPass, cmdBuff);

          this._pipeline.geometryRenderer.render(renderPass, cmdBuff);

          this._uiPhase.render(camera, renderPass);

          renderProfiler(device, renderPass, cmdBuff, pipeline.profiler, camera);
          cmdBuff.endRenderPass();
        };

        return ForwardStage;
      }(RenderStage), _class3$7.initInfo = {
        name: 'ForwardStage',
        priority: ForwardStagePriority.FORWARD,
        tag: 0,
        renderQueues: [{
          isTransparent: false,
          sortMode: RenderQueueSortMode.FRONT_TO_BACK,
          stages: ['default']
        }, {
          isTransparent: true,
          sortMode: RenderQueueSortMode.BACK_TO_FRONT,
          stages: ['default', 'planarShadow']
        }]
      }, _temp$h), (_descriptor$e = _applyDecoratedDescriptor(_class2$g.prototype, "renderQueues", [_dec2$a, serializable, _dec3$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$g)) || _class$j));

      var _dec$k, _class$k, _class2$h, _temp$i;
      var ForwardFlow = exports('ForwardFlow', (_dec$k = ccclass('ForwardFlow'), _dec$k(_class$k = (_temp$i = _class2$h = function (_RenderFlow) {
        _inheritsLoose(ForwardFlow, _RenderFlow);

        function ForwardFlow() {
          return _RenderFlow.apply(this, arguments) || this;
        }

        var _proto = ForwardFlow.prototype;

        _proto.initialize = function initialize(info) {
          _RenderFlow.prototype.initialize.call(this, info);

          if (this._stages.length === 0) {
            var forwardStage = new ForwardStage();
            forwardStage.initialize(ForwardStage.initInfo);

            this._stages.push(forwardStage);
          }

          return true;
        };

        _proto.activate = function activate(pipeline) {
          _RenderFlow.prototype.activate.call(this, pipeline);
        };

        _proto.render = function render(camera) {
          _RenderFlow.prototype.render.call(this, camera);
        };

        _proto.destroy = function destroy() {
          _RenderFlow.prototype.destroy.call(this);
        };

        return ForwardFlow;
      }(RenderFlow), _class2$h.initInfo = {
        name: PIPELINE_FLOW_FORWARD,
        priority: ForwardFlowPriority.FORWARD,
        stages: []
      }, _temp$i)) || _class$k));

      var _matShadowView$3 = new Mat4();

      var _matShadowProj$2 = new Mat4();

      var _matShadowViewProj$3 = new Mat4();

      var _ab$2 = new AABB();

      var _phaseID$1 = getPhaseID('shadow-caster');

      var _shadowPassIndices = [];

      function getShadowPassIndex(subModels, shadowPassIndices) {
        shadowPassIndices.length = 0;
        var hasShadowPass = false;

        for (var j = 0; j < subModels.length; j++) {
          var passes = subModels[j].passes;
          var shadowPassIndex = -1;

          for (var k = 0; k < passes.length; k++) {
            if (passes[k].phase === _phaseID$1) {
              shadowPassIndex = k;
              hasShadowPass = true;
              break;
            }
          }

          shadowPassIndices.push(shadowPassIndex);
        }

        return hasShadowPass;
      }

      var RenderShadowMapBatchedQueue = function () {
        function RenderShadowMapBatchedQueue(pipeline) {
          this._pipeline = void 0;
          this._subModelsArray = [];
          this._passArray = [];
          this._shaderArray = [];
          this._instancedQueue = void 0;
          this._batchedQueue = void 0;
          this._pipeline = pipeline;
          this._instancedQueue = new RenderInstancedQueue();
          this._batchedQueue = new RenderBatchedQueue();
        }

        var _proto = RenderShadowMapBatchedQueue.prototype;

        _proto.gatherLightPasses = function gatherLightPasses(globalDS, camera, light, cmdBuff) {
          this.clear();
          var pipelineSceneData = this._pipeline.pipelineSceneData;
          var shadowInfo = pipelineSceneData.shadows;

          if (light && shadowInfo.enabled && shadowInfo.type === ShadowType.ShadowMap) {
            var dirShadowObjects = pipelineSceneData.dirShadowObjects;
            var castShadowObjects = pipelineSceneData.castShadowObjects;

            switch (light.type) {
              case LightType.DIRECTIONAL:
                for (var i = 0; i < dirShadowObjects.length; i++) {
                  var ro = dirShadowObjects[i];
                  var model = ro.model;

                  if (!getShadowPassIndex(model.subModels, _shadowPassIndices)) {
                    continue;
                  }

                  this.add(model, _shadowPassIndices);
                }

                break;

              case LightType.SPOT:
                Mat4.invert(_matShadowView$3, light.node.getWorldMatrix());
                Mat4.perspective(_matShadowProj$2, light.angle, 1.0, 0.001, light.range);
                Mat4.multiply(_matShadowViewProj$3, _matShadowProj$2, _matShadowView$3);

                for (var _i = 0; _i < castShadowObjects.length; _i++) {
                  var _ro = castShadowObjects[_i];
                  var _model = _ro.model;

                  if (!getShadowPassIndex(_model.subModels, _shadowPassIndices)) {
                    continue;
                  }

                  if (_model.worldBounds) {
                    AABB.transform(_ab$2, _model.worldBounds, _matShadowViewProj$3);

                    if (!intersect.aabbFrustum(_ab$2, camera.frustum)) {
                      continue;
                    }
                  }

                  this.add(_model, _shadowPassIndices);
                }

                break;
            }

            this._instancedQueue.uploadBuffers(cmdBuff);

            this._batchedQueue.uploadBuffers(cmdBuff);
          }
        };

        _proto.clear = function clear() {
          this._subModelsArray.length = 0;
          this._shaderArray.length = 0;
          this._passArray.length = 0;

          this._instancedQueue.clear();

          this._batchedQueue.clear();
        };

        _proto.add = function add(model, _shadowPassIndices) {
          var subModels = model.subModels;

          for (var j = 0; j < subModels.length; j++) {
            var subModel = subModels[j];
            var shadowPassIdx = _shadowPassIndices[j];
            var pass = subModel.passes[shadowPassIdx];
            var batchingScheme = pass.batchingScheme;

            if (batchingScheme === BatchingSchemes.INSTANCING) {
              var buffer = pass.getInstancedBuffer();
              buffer.merge(subModel, model.instancedAttributes, shadowPassIdx);

              this._instancedQueue.queue.add(buffer);
            } else if (pass.batchingScheme === BatchingSchemes.VB_MERGING) {
              var _buffer = pass.getBatchedBuffer();

              _buffer.merge(subModel, shadowPassIdx, model);

              this._batchedQueue.queue.add(_buffer);
            } else {
              var shader = subModel.shaders[shadowPassIdx];

              this._subModelsArray.push(subModel);

              if (shader) this._shaderArray.push(shader);

              this._passArray.push(pass);
            }
          }
        };

        _proto.recordCommandBuffer = function recordCommandBuffer(device, renderPass, cmdBuff) {
          this._instancedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          this._batchedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          for (var i = 0; i < this._subModelsArray.length; ++i) {
            var subModel = this._subModelsArray[i];
            var shader = this._shaderArray[i];
            var pass = this._passArray[i];
            var ia = subModel.inputAssembler;
            var pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, renderPass, ia);
            var descriptorSet = pass.descriptorSet;
            cmdBuff.bindPipelineState(pso);
            cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, descriptorSet);
            cmdBuff.bindDescriptorSet(SetIndex.LOCAL, subModel.descriptorSet);
            cmdBuff.bindInputAssembler(ia);
            cmdBuff.draw(ia);
          }
        };

        return RenderShadowMapBatchedQueue;
      }();

      var _dec$l, _class$l, _class2$i, _temp$j;
      var colors$1 = [new Color$1(1, 1, 1, 1)];
      var ShadowStage = exports('ShadowStage', (_dec$l = ccclass('ShadowStage'), _dec$l(_class$l = (_temp$j = _class2$i = function (_RenderStage) {
        _inheritsLoose(ShadowStage, _RenderStage);

        function ShadowStage() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _RenderStage.call.apply(_RenderStage, [this].concat(args)) || this;
          _this._shadowFrameBuffer = null;
          _this._renderArea = new Rect$1();
          _this._light = null;
          _this._globalDS = null;
          return _this;
        }

        var _proto = ShadowStage.prototype;

        _proto.setUsage = function setUsage(globalDS, light, shadowFrameBuffer) {
          this._globalDS = globalDS;
          this._light = light;
          this._shadowFrameBuffer = shadowFrameBuffer;
        };

        _proto.destroy = function destroy() {
          var _this$_additiveShadow;

          this._shadowFrameBuffer = null;
          this._globalDS = null;
          this._light = null;
          (_this$_additiveShadow = this._additiveShadowQueue) === null || _this$_additiveShadow === void 0 ? void 0 : _this$_additiveShadow.clear();
        };

        _proto.clearFramebuffer = function clearFramebuffer(camera) {
          if (!this._light || !this._shadowFrameBuffer) {
            return;
          }

          colors$1[0].w = camera.clearColor.w;
          var pipeline = this._pipeline;
          var cmdBuff = pipeline.commandBuffers[0];
          var renderPass = this._shadowFrameBuffer.renderPass;
          cmdBuff.beginRenderPass(renderPass, this._shadowFrameBuffer, this._renderArea, colors$1, camera.clearDepth, camera.clearStencil);
          cmdBuff.endRenderPass();
        };

        _proto.render = function render(camera) {
          var pipeline = this._pipeline;
          var pipelineSceneData = pipeline.pipelineSceneData;
          var shadowInfo = pipelineSceneData.shadows;
          var shadingScale = pipelineSceneData.shadingScale;
          var descriptorSet = this._globalDS;
          var cmdBuff = pipeline.commandBuffers[0];

          if (!this._light || !this._shadowFrameBuffer) {
            return;
          }

          this._pipeline.pipelineUBO.updateShadowUBOLight(descriptorSet, this._light);

          this._additiveShadowQueue.gatherLightPasses(descriptorSet, camera, this._light, cmdBuff);

          var vp = camera.viewport;
          var shadowMapSize = shadowInfo.size;
          this._renderArea.x = vp.x * shadowMapSize.x;
          this._renderArea.y = vp.y * shadowMapSize.y;
          this._renderArea.width = vp.width * shadowMapSize.x * shadingScale;
          this._renderArea.height = vp.height * shadowMapSize.y * shadingScale;
          var device = pipeline.device;
          var renderPass = this._shadowFrameBuffer.renderPass;
          cmdBuff.beginRenderPass(renderPass, this._shadowFrameBuffer, this._renderArea, colors$1, camera.clearDepth, camera.clearStencil);
          cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, descriptorSet);

          this._additiveShadowQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          cmdBuff.endRenderPass();
        };

        _proto.activate = function activate(pipeline, flow) {
          _RenderStage.prototype.activate.call(this, pipeline, flow);

          this._additiveShadowQueue = new RenderShadowMapBatchedQueue(pipeline);
        };

        return ShadowStage;
      }(RenderStage), _class2$i.initInfo = {
        name: 'ShadowStage',
        priority: ForwardStagePriority.FORWARD,
        tag: 0
      }, _temp$j)) || _class$l));

      var _dec$m, _class$m, _class2$j, _temp$k;
      var _validLights = [];
      var ShadowFlow = exports('ShadowFlow', (_dec$m = ccclass('ShadowFlow'), _dec$m(_class$m = (_temp$k = _class2$j = function (_RenderFlow) {
        _inheritsLoose(ShadowFlow, _RenderFlow);

        function ShadowFlow() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _RenderFlow.call.apply(_RenderFlow, [this].concat(args)) || this;
          _this._shadowRenderPass = null;
          return _this;
        }

        var _proto = ShadowFlow.prototype;

        _proto.initialize = function initialize(info) {
          _RenderFlow.prototype.initialize.call(this, info);

          if (this._stages.length === 0) {
            var shadowMapStage = new ShadowStage();
            shadowMapStage.initialize(ShadowStage.initInfo);

            this._stages.push(shadowMapStage);
          }

          return true;
        };

        _proto.render = function render(camera) {
          var pipeline = this._pipeline;
          var shadowInfo = pipeline.pipelineSceneData.shadows;
          var shadowFrameBufferMap = pipeline.pipelineSceneData.shadowFrameBufferMap;
          var castShadowObjects = pipeline.pipelineSceneData.castShadowObjects;
          var validPunctualLights = this._pipeline.pipelineSceneData.validPunctualLights;

          if (!shadowInfo.enabled || shadowInfo.type !== ShadowType.ShadowMap) {
            return;
          }

          var n = 0;
          var m = 0;

          for (; n < shadowInfo.maxReceived && m < validPunctualLights.length;) {
            var light = validPunctualLights[m];

            if (light.type === LightType.SPOT) {
              _validLights.push(light);

              n++;
            }

            m++;
          }

          if (castShadowObjects.length === 0) {
            this.clearShadowMap(_validLights, camera);
            return;
          }

          if (shadowInfo.shadowMapDirty) {
            this.resizeShadowMap();
          }

          var _ref = camera.scene,
              mainLight = _ref.mainLight;

          if (mainLight) {
            var globalDS = pipeline.descriptorSet;

            if (!shadowFrameBufferMap.has(mainLight)) {
              this._initShadowFrameBuffer(pipeline, mainLight, camera.window.swapchain);
            }

            var shadowFrameBuffer = shadowFrameBufferMap.get(mainLight);

            for (var i = 0; i < this._stages.length; i++) {
              var shadowStage = this._stages[i];
              shadowStage.setUsage(globalDS, mainLight, shadowFrameBuffer);
              shadowStage.render(camera);
            }
          }

          for (var l = 0; l < _validLights.length; l++) {
            var _light = _validLights[l];

            var _globalDS = pipeline.globalDSManager.getOrCreateDescriptorSet(l);

            if (!shadowFrameBufferMap.has(_light)) {
              this._initShadowFrameBuffer(pipeline, _light, camera.window.swapchain);
            }

            var _shadowFrameBuffer = shadowFrameBufferMap.get(_light);

            for (var _i = 0; _i < this._stages.length; _i++) {
              var _shadowStage = this._stages[_i];

              _shadowStage.setUsage(_globalDS, _light, _shadowFrameBuffer);

              _shadowStage.render(camera);
            }
          }

          _validLights.length = 0;
        };

        _proto.destroy = function destroy() {
          _RenderFlow.prototype.destroy.call(this);

          if (this._pipeline) {
            var shadowFrameBufferMap = this._pipeline.pipelineSceneData.shadowFrameBufferMap;
            var shadowFrameBuffers = Array.from(shadowFrameBufferMap.values());

            for (var i = 0; i < shadowFrameBuffers.length; i++) {
              var frameBuffer = shadowFrameBuffers[i];

              if (!frameBuffer) {
                continue;
              }

              var renderTargets = frameBuffer.colorTextures;

              for (var j = 0; j < renderTargets.length; j++) {
                var renderTarget = renderTargets[i];

                if (renderTarget) {
                  renderTarget.destroy();
                }
              }

              renderTargets.length = 0;
              var depth = frameBuffer.depthStencilTexture;

              if (depth) {
                depth.destroy();
              }

              frameBuffer.destroy();
            }

            shadowFrameBufferMap.clear();
          }

          if (this._shadowRenderPass) {
            this._shadowRenderPass.destroy();
          }
        };

        _proto._initShadowFrameBuffer = function _initShadowFrameBuffer(pipeline, light, swapchain) {
          var device = pipeline.device;
          var shadows = pipeline.pipelineSceneData.shadows;
          var shadowMapSize = shadows.size;
          var shadowFrameBufferMap = pipeline.pipelineSceneData.shadowFrameBufferMap;
          var format = supportsR32FloatTexture(device) ? Format.R32F : Format.RGBA8;

          if (!this._shadowRenderPass) {
            var colorAttachment = new ColorAttachment();
            colorAttachment.format = format;
            colorAttachment.loadOp = LoadOp.CLEAR;
            colorAttachment.storeOp = StoreOp.STORE;
            colorAttachment.sampleCount = 1;
            var depthStencilAttachment = new DepthStencilAttachment();
            depthStencilAttachment.format = Format.DEPTH_STENCIL;
            depthStencilAttachment.depthLoadOp = LoadOp.CLEAR;
            depthStencilAttachment.depthStoreOp = StoreOp.DISCARD;
            depthStencilAttachment.stencilLoadOp = LoadOp.CLEAR;
            depthStencilAttachment.stencilStoreOp = StoreOp.DISCARD;
            depthStencilAttachment.sampleCount = 1;
            var renderPassInfo = new RenderPassInfo([colorAttachment], depthStencilAttachment);
            this._shadowRenderPass = device.createRenderPass(renderPassInfo);
          }

          var shadowRenderTargets = [];
          shadowRenderTargets.push(device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, format, shadowMapSize.x, shadowMapSize.y)));
          var depth = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.DEPTH_STENCIL_ATTACHMENT, Format.DEPTH_STENCIL, shadowMapSize.x, shadowMapSize.y));
          var shadowFrameBuffer = device.createFramebuffer(new FramebufferInfo(this._shadowRenderPass, shadowRenderTargets, depth));
          shadowFrameBufferMap.set(light, shadowFrameBuffer);
        };

        _proto.clearShadowMap = function clearShadowMap(validLights, camera) {
          var pipeline = this._pipeline;
          var scene = pipeline.pipelineSceneData;
          var _ref2 = camera.scene,
              mainLight = _ref2.mainLight;

          if (mainLight) {
            var globalDS = this._pipeline.descriptorSet;

            if (!scene.shadowFrameBufferMap.has(mainLight)) {
              this._initShadowFrameBuffer(this._pipeline, mainLight, camera.window.swapchain);
            }

            var shadowFrameBuffer = scene.shadowFrameBufferMap.get(mainLight);

            for (var i = 0; i < this._stages.length; i++) {
              var shadowStage = this._stages[i];
              shadowStage.setUsage(globalDS, mainLight, shadowFrameBuffer);
              shadowStage.render(camera);
            }
          }

          for (var l = 0; l < validLights.length; l++) {
            var light = validLights[l];

            var _shadowFrameBuffer2 = scene.shadowFrameBufferMap.get(light);

            var _globalDS2 = pipeline.globalDSManager.getOrCreateDescriptorSet(l);

            if (!scene.shadowFrameBufferMap.has(light)) {
              continue;
            }

            for (var _i2 = 0; _i2 < this._stages.length; _i2++) {
              var _shadowStage2 = this._stages[_i2];

              _shadowStage2.setUsage(_globalDS2, light, _shadowFrameBuffer2);

              _shadowStage2.clearFramebuffer(camera);
            }
          }
        };

        _proto.resizeShadowMap = function resizeShadowMap() {
          var shadows = this._pipeline.pipelineSceneData.shadows;
          var shadowMapSize = shadows.size;
          var pipeline = this._pipeline;
          var device = pipeline.device;
          var shadowFrameBufferMap = pipeline.pipelineSceneData.shadowFrameBufferMap;
          var format = supportsR32FloatTexture(device) ? Format.R32F : Format.RGBA8;
          var it = shadowFrameBufferMap.values();
          var res = it.next();

          while (!res.done) {
            var frameBuffer = res.value;

            if (!frameBuffer) {
              res = it.next();
              continue;
            }

            var renderTargets = [];
            renderTargets.push(pipeline.device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, format, shadowMapSize.x, shadowMapSize.y)));
            var depth = frameBuffer.depthStencilTexture;

            if (depth) {
              depth.resize(shadowMapSize.x, shadowMapSize.y);
            }

            var shadowRenderPass = frameBuffer.renderPass;
            frameBuffer.destroy();
            frameBuffer.initialize(new FramebufferInfo(shadowRenderPass, renderTargets, depth));
            res = it.next();
          }

          shadows.shadowMapDirty = false;
        };

        return ShadowFlow;
      }(RenderFlow), _class2$j.initInfo = {
        name: PIPELINE_FLOW_SHADOW,
        priority: ForwardFlowPriority.SHADOW,
        tag: RenderFlowTag.SCENE,
        stages: []
      }, _temp$k)) || _class$m));

      function deepFlatten(strList, array) {
        for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done;) {
          var item = _step.value;

          if (Array.isArray(item)) {
            deepFlatten(strList, item);
          } else {
              strList.push(item);
            }
        }
      }

      function flattenCodeArray(array) {
        var separator =  '';
        var strList = [];
        deepFlatten(strList, array);
        return strList.join(separator);
      }

      var Destroyed$2 = CCObject.Flags.Destroyed;
      var PersistentMask$2 = CCObject.Flags.PersistentMask;
      var DEFAULT = DELIMETER + "default";
      var IDENTIFIER_RE$1 = CCClass.IDENTIFIER_RE;
      var VAR = 'var ';
      var LOCAL_OBJ = 'o';
      var LOCAL_TEMP_OBJ = 't';
      var LOCAL_ARRAY = 'a';
      var LINE_INDEX_OF_NEW_OBJ = 0;
      var DEFAULT_MODULE_CACHE = {
        'cc.ClickEvent': false,
        'cc.PrefabInfo': false
      };
      var escapeForJS$1 = CCClass.escapeForJS;

      var Declaration = function () {
        function Declaration(varName, expression) {
          this.varName = void 0;
          this.expression = void 0;
          this.varName = varName;
          this.expression = expression;
        }

        var _proto = Declaration.prototype;

        _proto.toString = function toString() {
          return VAR + this.varName + "=" + this.expression + ";";
        };

        return Declaration;
      }();

      function mergeDeclaration(statement, expression) {
        if (expression instanceof Declaration) {
          return new Declaration(expression.varName, statement + expression.expression);
        } else {
          return statement + expression;
        }
      }

      function writeAssignment(codeArray, statement, expression) {
        if (Array.isArray(expression)) {
          expression[0] = mergeDeclaration(statement, expression[0]);
          codeArray.push(expression);
        } else {
          codeArray.push(mergeDeclaration(statement, expression) + ";");
        }
      }

      var Assignments = function () {
        function Assignments(targetExpression) {
          this._exps = void 0;
          this._targetExp = void 0;
          this._exps = [];
          this._targetExp = targetExpression;
        }

        var _proto2 = Assignments.prototype;

        _proto2.append = function append(key, expression) {
          this._exps.push([key, expression]);
        };

        _proto2.writeCode = function writeCode(codeArray) {
          var targetVar;

          if (this._exps.length > 1) {
            codeArray.push(LOCAL_TEMP_OBJ + "=" + this._targetExp + ";");
            targetVar = LOCAL_TEMP_OBJ;
          } else if (this._exps.length === 1) {
            targetVar = this._targetExp;
          } else {
            return;
          }

          for (var i = 0; i < this._exps.length; i++) {
            var pair = this._exps[i];
            writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
          }
        };

        return Assignments;
      }();

      Assignments.pool = void 0;
      Assignments.pool = new Pool(function (obj) {
        obj._exps.length = 0;
        obj._targetExp = null;
      }, 1);

      Assignments.pool.get = function (targetExpression) {
        var cache = this._get() || new Assignments();
        cache._targetExp = targetExpression;
        return cache;
      };

      function getPropAccessor(key) {
        return IDENTIFIER_RE$1.test(key) ? "." + key : "[" + escapeForJS$1(key) + "]";
      }

      var Parser = function () {
        function Parser(obj, parent) {
          this.parent = void 0;
          this.objsToClear_iN$t = void 0;
          this.codeArray = void 0;
          this.objs = void 0;
          this.funcs = void 0;
          this.funcModuleCache = void 0;
          this.globalVariables = void 0;
          this.globalVariableId = void 0;
          this.localVariableId = void 0;
          this.result = void 0;
          this.parent = parent;
          this.objsToClear_iN$t = [];
          this.codeArray = [];
          this.objs = [];
          this.funcs = [];
          this.funcModuleCache = createMap();
          mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
          this.globalVariables = [];
          this.globalVariableId = 0;
          this.localVariableId = 0;
          this.codeArray.push(VAR + LOCAL_OBJ + "," + LOCAL_TEMP_OBJ + ";", 'if(R){', LOCAL_OBJ + "=R;", '}else{', LOCAL_OBJ + "=R=new " + this.getFuncModule(obj.constructor, true) + "();", '}');
          obj._iN$t = {
            globalVar: 'R'
          };
          this.objsToClear_iN$t.push(obj);
          this.enumerateObject(this.codeArray, obj);
          var globalVariablesDeclaration;

          if (this.globalVariables.length > 0) {
            globalVariablesDeclaration = VAR + this.globalVariables.join(',') + ";";
          }

          var code = flattenCodeArray(['return (function(R){', globalVariablesDeclaration || [], this.codeArray, 'return o;', '})']);
          this.result = Function('O', 'F', code)(this.objs, this.funcs);

          for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) {
            this.objsToClear_iN$t[i]._iN$t = null;
          }

          this.objsToClear_iN$t.length = 0;
        }

        var _proto3 = Parser.prototype;

        _proto3.getFuncModule = function getFuncModule(func, usedInNew) {
          var clsName = getClassName(func);

          if (clsName) {
            var cache = this.funcModuleCache[clsName];

            if (cache) {
              return cache;
            } else if (cache === undefined) {
              var clsNameIsModule = clsName.indexOf('.') !== -1;

              if (clsNameIsModule) {
                try {
                  clsNameIsModule = func === Function("return " + clsName)();

                  if (clsNameIsModule) {
                    this.funcModuleCache[clsName] = clsName;
                    return clsName;
                  }
                } catch (e) {}
              }
            }
          }

          var index = this.funcs.indexOf(func);

          if (index < 0) {
            index = this.funcs.length;
            this.funcs.push(func);
          }

          var res = "F[" + index + "]";

          if (usedInNew) {
            res = "(" + res + ")";
          }

          this.funcModuleCache[clsName] = res;
          return res;
        };

        _proto3.getObjRef = function getObjRef(obj) {
          var index = this.objs.indexOf(obj);

          if (index < 0) {
            index = this.objs.length;
            this.objs.push(obj);
          }

          return "O[" + index + "]";
        };

        _proto3.setValueType = function setValueType(codeArray, defaultValue, srcValue, targetExpression) {
          var assignments = Assignments.pool.get(targetExpression);
          var fastDefinedProps = defaultValue.constructor.__props__;

          if (!fastDefinedProps) {
            fastDefinedProps = Object.keys(defaultValue);
          }

          for (var i = 0; i < fastDefinedProps.length; i++) {
            var propName = fastDefinedProps[i];
            var prop = srcValue[propName];

            if (defaultValue[propName] === prop) {
              continue;
            }

            var expression = this.enumerateField(srcValue, propName, prop);
            assignments.append(propName, expression);
          }

          assignments.writeCode(codeArray);
          Assignments.pool.put(assignments);
        };

        _proto3.enumerateCCClass = function enumerateCCClass(codeArray, obj, klass) {
          var props = klass.__values__;
          var attrs = getClassAttrs(klass);

          for (var p = 0; p < props.length; p++) {
            var key = props[p];
            var val = obj[key];
            var defaultValue = attrs[key + DEFAULT];

            if (equalsToDefault(defaultValue, val)) {
              continue;
            }

            if (typeof val === 'object' && val instanceof legacyCC.ValueType) {
              defaultValue = CCClass.getDefault(defaultValue);

              if (defaultValue && defaultValue.constructor === val.constructor) {
                var targetExpression = LOCAL_OBJ + getPropAccessor(key);
                this.setValueType(codeArray, defaultValue, val, targetExpression);
                continue;
              }
            }

            this.setObjProp(codeArray, obj, key, val);
          }
        };

        _proto3.instantiateArray = function instantiateArray(value) {
          if (value.length === 0) {
            return '[]';
          }

          var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
          var declaration = new Declaration(arrayVar, "new Array(" + value.length + ")");
          var codeArray = [declaration];
          value._iN$t = {
            globalVar: '',
            source: codeArray
          };
          this.objsToClear_iN$t.push(value);

          for (var i = 0; i < value.length; ++i) {
            var statement = arrayVar + "[" + i + "]=";
            var expression = this.enumerateField(value, i, value[i]);
            writeAssignment(codeArray, statement, expression);
          }

          return codeArray;
        };

        _proto3.instantiateTypedArray = function instantiateTypedArray(value) {
          var type = value.constructor.name;

          if (value.length === 0) {
            return "new " + type;
          }

          var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
          var declaration = new Declaration(arrayVar, "new " + type + "(" + value.length + ")");
          var codeArray = [declaration];
          value._iN$t = {
            globalVar: '',
            source: codeArray
          };
          this.objsToClear_iN$t.push(value);

          for (var i = 0; i < value.length; ++i) {
            if (value[i] !== 0) {
              var statement = arrayVar + "[" + i + "]=";
              writeAssignment(codeArray, statement, value[i]);
            }
          }

          return codeArray;
        };

        _proto3.enumerateField = function enumerateField(obj, key, value) {
          if (typeof value === 'object' && value) {
            var _iN$t = value._iN$t;

            if (_iN$t) {
              var globalVar = _iN$t.globalVar;

              if (!globalVar) {
                globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId;
                this.globalVariables.push(globalVar);
                var line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
                _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(globalVar + "=", line);
              }

              return globalVar;
            } else if (ArrayBuffer.isView(value)) {
              return this.instantiateTypedArray(value);
            } else if (Array.isArray(value)) {
              return this.instantiateArray(value);
            } else {
              return this.instantiateObj(value);
            }
          } else if (typeof value === 'function') {
            return this.getFuncModule(value);
          } else if (typeof value === 'string') {
            return escapeForJS$1(value);
          } else {
            if (key === '_objFlags' && obj instanceof CCObject) {
              value &= PersistentMask$2;
            }

            return value;
          }
        };

        _proto3.setObjProp = function setObjProp(codeArray, obj, key, value) {
          var statement = LOCAL_OBJ + getPropAccessor(key) + "=";
          var expression = this.enumerateField(obj, key, value);
          writeAssignment(codeArray, statement, expression);
        };

        _proto3.enumerateObject = function enumerateObject(codeArray, obj) {
          var klass = obj.constructor;

          if (isCCClassOrFastDefined(klass)) {
            this.enumerateCCClass(codeArray, obj, klass);
          } else {
            for (var key in obj) {
              if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__') {
                continue;
              }

              var value = obj[key];

              if (typeof value === 'object' && value && value === obj._iN$t) {
                continue;
              }

              this.setObjProp(codeArray, obj, key, value);
            }
          }
        };

        _proto3.instantiateObj = function instantiateObj(obj) {
          if (obj instanceof legacyCC.ValueType) {
            return CCClass.getNewValueTypeCode(obj);
          }

          if (obj instanceof legacyCC.Asset) {
            return this.getObjRef(obj);
          }

          if (obj._objFlags & Destroyed$2) {
            return null;
          }

          var createCode;
          var ctor = obj.constructor;

          if (isCCClassOrFastDefined(ctor)) {
            if (this.parent) {
              if (this.parent instanceof legacyCC.Component) {
                if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
                  return this.getObjRef(obj);
                }
              } else if (this.parent instanceof legacyCC._BaseNode) {
                if (obj instanceof legacyCC._BaseNode) {
                  if (!obj.isChildOf(this.parent)) {
                    return this.getObjRef(obj);
                  }
                } else if (obj instanceof legacyCC.Component) {
                  var _obj$node;

                  if (!((_obj$node = obj.node) === null || _obj$node === void 0 ? void 0 : _obj$node.isChildOf(this.parent))) {
                    return this.getObjRef(obj);
                  }
                }
              }
            }

            createCode = new Declaration(LOCAL_OBJ, "new " + this.getFuncModule(ctor, true) + "()");
          } else if (ctor === Object) {
            createCode = new Declaration(LOCAL_OBJ, '{}');
          } else if (!ctor) {
            createCode = new Declaration(LOCAL_OBJ, 'Object.create(null)');
          } else {
            return this.getObjRef(obj);
          }

          var codeArray = [createCode];
          obj._iN$t = {
            globalVar: '',
            source: codeArray
          };
          this.objsToClear_iN$t.push(obj);
          this.enumerateObject(codeArray, obj);
          return ['(function(){', codeArray, 'return o;})();'];
        };

        return Parser;
      }();

      function equalsToDefault(def, value) {
        if (typeof def === 'function') {
          try {
            def = def();
          } catch (e) {
            return false;
          }
        }

        if (def === value) {
          return true;
        }

        if (def && value && typeof def === 'object' && typeof value === 'object' && def.constructor === value.constructor) {
          if (def instanceof legacyCC.ValueType) {
            if (def.equals(value)) {
              return true;
            }
          } else if (Array.isArray(def)) {
            return def.length === 0 && value.length === 0;
          } else if (def.constructor === Object) {
            return isEmptyObject(def) && isEmptyObject(value);
          }
        }

        return false;
      }
      function compile(node) {
        var root = node instanceof legacyCC._BaseNode && node;
        var parser = new Parser(node, root);
        return parser.result;
      }

      var NodeUIProperties = function () {
        function NodeUIProperties(node) {
          this._uiComp = null;
          this._opacity = 1;
          this._localOpacity = 1;
          this.colorDirty = true;
          this._uiTransformComp = null;
          this._node = void 0;
          this._node = node;
        }

        var _proto = NodeUIProperties.prototype;

        _proto.applyOpacity = function applyOpacity(effectOpacity) {
          this._opacity = this._localOpacity * effectOpacity;
        };

        NodeUIProperties.markOpacityTree = function markOpacityTree(node, isDirty) {
        };

        _createClass(NodeUIProperties, [{
          key: "uiTransformComp",
          get: function get() {
            if (!this._uiTransformComp) {
              this._uiTransformComp = this._node.getComponent('cc.UITransform');
            }

            return this._uiTransformComp;
          },
          set: function set(value) {
            this._uiTransformComp = value;
          }
        }, {
          key: "uiComp",
          get: function get() {
            return this._uiComp;
          },
          set: function set(comp) {
            if (this._uiComp && comp) {
              warnID(12002);
              return;
            }

            this._uiComp = comp;
          }
        }, {
          key: "opacity",
          get: function get() {
            return this._opacity;
          }
        }, {
          key: "localOpacity",
          get: function get() {
            return this._localOpacity;
          },
          set: function set(val) {
            this._localOpacity = val;
            this.colorDirty = true;
          }
        }]);

        return NodeUIProperties;
      }();

      var Destroying$1 = CCObject.Flags.Destroying;

      var NodeEventType;

      (function (NodeEventType) {
        NodeEventType["TOUCH_START"] = "touch-start";
        NodeEventType["TOUCH_MOVE"] = "touch-move";
        NodeEventType["TOUCH_END"] = "touch-end";
        NodeEventType["TOUCH_CANCEL"] = "touch-cancel";
        NodeEventType["MOUSE_DOWN"] = "mouse-down";
        NodeEventType["MOUSE_MOVE"] = "mouse-move";
        NodeEventType["MOUSE_UP"] = "mouse-up";
        NodeEventType["MOUSE_WHEEL"] = "mouse-wheel";
        NodeEventType["MOUSE_ENTER"] = "mouse-enter";
        NodeEventType["MOUSE_LEAVE"] = "mouse-leave";
        NodeEventType["KEY_DOWN"] = "keydown";
        NodeEventType["KEY_UP"] = "keyup";
        NodeEventType["DEVICEMOTION"] = "devicemotion";
        NodeEventType["TRANSFORM_CHANGED"] = "transform-changed";
        NodeEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
        NodeEventType["SIZE_CHANGED"] = "size-changed";
        NodeEventType["ANCHOR_CHANGED"] = "anchor-changed";
        NodeEventType["COLOR_CHANGED"] = "color-changed";
        NodeEventType["CHILD_ADDED"] = "child-added";
        NodeEventType["CHILD_REMOVED"] = "child-removed";
        NodeEventType["PARENT_CHANGED"] = "parent-changed";
        NodeEventType["NODE_DESTROYED"] = "node-destroyed";
        NodeEventType["LAYER_CHANGED"] = "layer-changed";
        NodeEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
        NodeEventType["ACTIVE_IN_HIERARCHY_CHANGED"] = "active-in-hierarchy-changed";
      })(NodeEventType || (NodeEventType = exports('NodeEventType', {})));

      var _dec$n, _class$n, _class2$k, _descriptor$f, _descriptor2$b, _descriptor3$9, _descriptor4$7, _descriptor5$4, _class3$8, _temp$l;
      var Destroying$2 = CCObject.Flags.Destroying;
      var DontDestroy$1 = CCObject.Flags.DontDestroy;
      var Deactivating$1 = CCObject.Flags.Deactivating;
      var TRANSFORM_ON = 1 << 0;
      var idGenerator$2 = new IDGenerator('Node');

      function getConstructor(typeOrClassName) {
        if (!typeOrClassName) {
          errorID(3804);
          return null;
        }

        if (typeof typeOrClassName === 'string') {
          return getClassByName(typeOrClassName);
        }

        return typeOrClassName;
      }

      var BaseNode = exports('BaseNode', (_dec$n = ccclass('cc.BaseNode'), _dec$n(_class$n = (_class2$k = (_temp$l = _class3$8 = function (_CCObject) {
        _inheritsLoose(BaseNode, _CCObject);

        BaseNode._setScene = function _setScene(node) {
          node._updateScene();
        };

        BaseNode._findComponent = function _findComponent(node, constructor) {
          var cls = constructor;
          var comps = node._components;

          if (cls._sealed) {
            for (var i = 0; i < comps.length; ++i) {
              var comp = comps[i];

              if (comp.constructor === constructor) {
                return comp;
              }
            }
          } else {
            for (var _i = 0; _i < comps.length; ++_i) {
              var _comp = comps[_i];

              if (_comp instanceof constructor) {
                return _comp;
              }
            }
          }

          return null;
        };

        BaseNode._findComponents = function _findComponents(node, constructor, components) {
          var cls = constructor;
          var comps = node._components;

          if (cls._sealed) {
            for (var i = 0; i < comps.length; ++i) {
              var comp = comps[i];

              if (comp.constructor === constructor) {
                components.push(comp);
              }
            }
          } else {
            for (var _i2 = 0; _i2 < comps.length; ++_i2) {
              var _comp2 = comps[_i2];

              if (_comp2 instanceof constructor) {
                components.push(_comp2);
              }
            }
          }
        };

        BaseNode._findChildComponent = function _findChildComponent(children, constructor) {
          for (var i = 0; i < children.length; ++i) {
            var node = children[i];

            var comp = BaseNode._findComponent(node, constructor);

            if (comp) {
              return comp;
            }

            if (node._children.length > 0) {
              comp = BaseNode._findChildComponent(node._children, constructor);

              if (comp) {
                return comp;
              }
            }
          }

          return null;
        };

        BaseNode._findChildComponents = function _findChildComponents(children, constructor, components) {
          for (var i = 0; i < children.length; ++i) {
            var node = children[i];

            BaseNode._findComponents(node, constructor, components);

            if (node._children.length > 0) {
              BaseNode._findChildComponents(node._children, constructor, components);
            }
          }
        };

        var _proto = BaseNode.prototype;

        _proto._updateScene = function _updateScene() {
          if (this._parent == null) {
            error('Node %s(%s) has not attached to a scene.', this.name, this.uuid);
          } else {
            this._scene = this._parent._scene;
          }
        };

        function BaseNode(name) {
          var _this;

          _this = _CCObject.call(this, name) || this;

          _initializerDefineProperty(_this, "_parent", _descriptor$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_children", _descriptor2$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_active", _descriptor3$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_components", _descriptor4$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_prefab", _descriptor5$4, _assertThisInitialized(_this));

          _this._scene = null;
          _this._activeInHierarchy = false;
          _this._id = idGenerator$2.getNewId();
          _this._name = void 0;
          _this._eventProcessor = new legacyCC.NodeEventProcessor(_assertThisInitialized(_this));
          _this._eventMask = 0;
          _this._siblingIndex = 0;
          _this._originalSceneId = '';
          _this._registerIfAttached =  undefined ;
          _this._name = name !== undefined ? name : 'New Node';
          return _this;
        }

        _proto.attr = function attr(attrs) {
          mixin(this, attrs);
        };

        _proto.getParent = function getParent() {
          return this._parent;
        };

        _proto.setParent = function setParent(value, keepWorldTransform) {
          if (keepWorldTransform === void 0) {
            keepWorldTransform = false;
          }

          if (this._parent === value) {
            return;
          }

          var oldParent = this._parent;
          var newParent = value;

          if ( oldParent && oldParent._objFlags & Deactivating$1) {
            errorID(3821);
          }

          this._parent = newParent;
          this._siblingIndex = 0;

          this._onSetParent(oldParent, keepWorldTransform);

          if (this.emit) {
            this.emit(NodeEventType.PARENT_CHANGED, oldParent);
          }

          if (oldParent) {
            if (!(oldParent._objFlags & Destroying$2)) {
              var removeAt = oldParent._children.indexOf(this);

              oldParent._children.splice(removeAt, 1);

              oldParent._updateSiblingIndex();

              if (oldParent.emit) {
                oldParent.emit(NodeEventType.CHILD_REMOVED, this);
              }
            }
          }

          if (newParent) {
            if ( newParent._objFlags & Deactivating$1) {
              errorID(3821);
            }

            newParent._children.push(this);

            this._siblingIndex = newParent._children.length - 1;

            if (newParent.emit) {
              newParent.emit(NodeEventType.CHILD_ADDED, this);
            }
          }

          this._onHierarchyChanged(oldParent);
        };

        _proto.getChildByUuid = function getChildByUuid(uuid) {
          if (!uuid) {
            log('Invalid uuid');
            return null;
          }

          var locChildren = this._children;

          for (var i = 0, len = locChildren.length; i < len; i++) {
            if (locChildren[i]._id === uuid) {
              return locChildren[i];
            }
          }

          return null;
        };

        _proto.getChildByName = function getChildByName(name) {
          if (!name) {
            log('Invalid name');
            return null;
          }

          var locChildren = this._children;

          for (var i = 0, len = locChildren.length; i < len; i++) {
            if (locChildren[i]._name === name) {
              return locChildren[i];
            }
          }

          return null;
        };

        _proto.getChildByPath = function getChildByPath(path) {
          var segments = path.split('/');
          var lastNode = this;

          var _loop = function _loop(i) {
            var segment = segments[i];

            if (segment.length === 0) {
              return "continue";
            }

            var next = lastNode.children.find(function (childNode) {
              return childNode.name === segment;
            });

            if (!next) {
              return {
                v: null
              };
            }

            lastNode = next;
          };

          for (var i = 0; i < segments.length; ++i) {
            var _ret = _loop(i);

            if (_ret === "continue") continue;
            if (typeof _ret === "object") return _ret.v;
          }

          return lastNode;
        };

        _proto.addChild = function addChild(child) {
          child.setParent(this);
        };

        _proto.insertChild = function insertChild(child, siblingIndex) {
          child.parent = this;
          child.setSiblingIndex(siblingIndex);
        };

        _proto.getSiblingIndex = function getSiblingIndex() {
          return this._siblingIndex;
        };

        _proto.setSiblingIndex = function setSiblingIndex(index) {
          if (!this._parent) {
            return;
          }

          if (this._parent._objFlags & Deactivating$1) {
            errorID(3821);
            return;
          }

          var siblings = this._parent._children;
          index = index !== -1 ? index : siblings.length - 1;
          var oldIndex = siblings.indexOf(this);

          if (index !== oldIndex) {
            siblings.splice(oldIndex, 1);

            if (index < siblings.length) {
              siblings.splice(index, 0, this);
            } else {
              siblings.push(this);
            }

            this._parent._updateSiblingIndex();

            if (this._onSiblingIndexChanged) {
              this._onSiblingIndexChanged(index);
            }
          }
        };

        _proto.walk = function walk(preFunc, postFunc) {
          var index = 1;
          var children = null;
          var curr = null;
          var i = 0;
          var stack = BaseNode._stacks[BaseNode._stackId];

          if (!stack) {
            stack = [];

            BaseNode._stacks.push(stack);
          }

          BaseNode._stackId++;
          stack.length = 0;
          stack[0] = this;
          var parent = null;
          var afterChildren = false;

          while (index) {
            index--;
            curr = stack[index];

            if (!curr) {
              continue;
            }

            if (!afterChildren && preFunc) {
              preFunc(curr);
            } else if (afterChildren && postFunc) {
              postFunc(curr);
            }

            stack[index] = null;

            if (afterChildren) {
              if (parent === this._parent) break;
              afterChildren = false;
            } else {
              if (curr._children.length > 0) {
                parent = curr;
                children = curr._children;
                i = 0;
                stack[index] = children[i];
                index++;
              } else {
                stack[index] = curr;
                index++;
                afterChildren = true;
              }

              continue;
            }

            if (children) {
              i++;

              if (children[i]) {
                stack[index] = children[i];
                index++;
              } else if (parent) {
                stack[index] = parent;
                index++;
                afterChildren = true;

                if (parent._parent) {
                  children = parent._parent._children;
                  i = children.indexOf(parent);
                  parent = parent._parent;
                } else {
                  parent = null;
                  children = null;
                }

                if (i < 0) {
                  break;
                }
              }
            }
          }

          stack.length = 0;
          BaseNode._stackId--;
        };

        _proto.removeFromParent = function removeFromParent() {
          if (this._parent) {
            this._parent.removeChild(this);
          }
        };

        _proto.removeChild = function removeChild(child) {
          if (this._children.indexOf(child) > -1) {
            child.parent = null;
          }
        };

        _proto.removeAllChildren = function removeAllChildren() {
          var children = this._children;

          for (var i = children.length - 1; i >= 0; i--) {
            var node = children[i];

            if (node) {
              node.parent = null;
            }
          }

          this._children.length = 0;
        };

        _proto.isChildOf = function isChildOf(parent) {
          var child = this;

          do {
            if (child === parent) {
              return true;
            }

            child = child._parent;
          } while (child);

          return false;
        };

        _proto.getComponent = function getComponent(typeOrClassName) {
          var constructor = getConstructor(typeOrClassName);

          if (constructor) {
            return BaseNode._findComponent(this, constructor);
          }

          return null;
        };

        _proto.getComponents = function getComponents(typeOrClassName) {
          var constructor = getConstructor(typeOrClassName);
          var components = [];

          if (constructor) {
            BaseNode._findComponents(this, constructor, components);
          }

          return components;
        };

        _proto.getComponentInChildren = function getComponentInChildren(typeOrClassName) {
          var constructor = getConstructor(typeOrClassName);

          if (constructor) {
            return BaseNode._findChildComponent(this._children, constructor);
          }

          return null;
        };

        _proto.getComponentsInChildren = function getComponentsInChildren(typeOrClassName) {
          var constructor = getConstructor(typeOrClassName);
          var components = [];

          if (constructor) {
            BaseNode._findComponents(this, constructor, components);

            BaseNode._findChildComponents(this._children, constructor, components);
          }

          return components;
        };

        _proto.addComponent = function addComponent(typeOrClassName) {

          var constructor;

          if (typeof typeOrClassName === 'string') {
            constructor = getClassByName(typeOrClassName);

            if (!constructor) {
              if (legacyCC._RF.peek()) {
                errorID(3808, typeOrClassName);
              }

              throw TypeError(getError(3807, typeOrClassName));
            }
          } else {
            if (!typeOrClassName) {
              throw TypeError(getError(3804));
            }

            constructor = typeOrClassName;
          }

          if (typeof constructor !== 'function') {
            throw TypeError(getError(3809));
          }

          if (!isChildClassOf(constructor, legacyCC.Component)) {
            throw TypeError(getError(3810));
          }

          var reqComps = constructor._requireComponent;

          if (reqComps) {
            if (Array.isArray(reqComps)) {
              for (var i = 0; i < reqComps.length; i++) {
                var reqComp = reqComps[i];

                if (!this.getComponent(reqComp)) {
                  this.addComponent(reqComp);
                }
              }
            } else {
              var _reqComp = reqComps;

              if (!this.getComponent(_reqComp)) {
                this.addComponent(_reqComp);
              }
            }
          }

          var component = new constructor();
          component.node = this;

          this._components.push(component);

          if (this._activeInHierarchy) {
            legacyCC.director._nodeActivator.activateComp(component);
          }

          return component;
        };

        _proto.removeComponent = function removeComponent(component) {
          if (!component) {
            errorID(3813);
            return;
          }

          var componentInstance = null;

          if (component instanceof Component) {
            componentInstance = component;
          } else {
            componentInstance = this.getComponent(component);
          }

          if (componentInstance) {
            componentInstance.destroy();
          }
        };

        _proto.on = function on(type, callback, target, useCapture) {
          if (useCapture === void 0) {
            useCapture = false;
          }

          switch (type) {
            case NodeEventType.TRANSFORM_CHANGED:
              this._eventMask |= TRANSFORM_ON;
              break;
          }

          this._eventProcessor.on(type, callback, target, useCapture);
        };

        _proto.off = function off(type, callback, target, useCapture) {
          if (useCapture === void 0) {
            useCapture = false;
          }

          this._eventProcessor.off(type, callback, target, useCapture);

          var hasListeners = this._eventProcessor.hasEventListener(type);

          if (!hasListeners) {
            switch (type) {
              case NodeEventType.TRANSFORM_CHANGED:
                this._eventMask &= ~TRANSFORM_ON;
                break;
            }
          }
        };

        _proto.once = function once(type, callback, target, useCapture) {
          this._eventProcessor.once(type, callback, target, useCapture);
        };

        _proto.emit = function emit(type, arg0, arg1, arg2, arg3, arg4) {
          this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
        };

        _proto.dispatchEvent = function dispatchEvent(event) {
          this._eventProcessor.dispatchEvent(event);
        };

        _proto.hasEventListener = function hasEventListener(type, callback, target) {
          return this._eventProcessor.hasEventListener(type, callback, target);
        };

        _proto.targetOff = function targetOff(target) {
          this._eventProcessor.targetOff(target);

          if (this._eventMask & TRANSFORM_ON && !this._eventProcessor.hasEventListener(NodeEventType.TRANSFORM_CHANGED)) {
            this._eventMask &= ~TRANSFORM_ON;
          }
        };

        _proto.destroy = function destroy() {
          if (_CCObject.prototype.destroy.call(this)) {
            this.active = false;
            return true;
          }

          return false;
        };

        _proto.destroyAllChildren = function destroyAllChildren() {
          var children = this._children;

          for (var i = 0; i < children.length; ++i) {
            children[i].destroy();
          }
        };

        _proto._removeComponent = function _removeComponent(component) {
          if (!component) {
            errorID(3814);
            return;
          }

          if (!(this._objFlags & Destroying$2)) {
            var i = this._components.indexOf(component);

            if (i !== -1) {
              this._components.splice(i, 1);
            } else if (component.node !== this) {
              errorID(3815);
            }
          }
        };

        _proto._updateSiblingIndex = function _updateSiblingIndex() {
          for (var i = 0; i < this._children.length; ++i) {
            this._children[i]._siblingIndex = i;
          }

          this.emit(NodeEventType.SIBLING_ORDER_CHANGED);
        };

        _proto._onSetParent = function _onSetParent(oldParent, keepWorldTransform) {

          if (this._parent) {
            if ((oldParent == null || oldParent._scene !== this._parent._scene) && this._parent._scene != null) {
              this.walk(BaseNode._setScene);
            }
          }
        };

        _proto._onPostActivated = function _onPostActivated(active) {};

        _proto._onBatchCreated = function _onBatchCreated(dontSyncChildPrefab) {
          if (this._parent) {
            this._siblingIndex = this._parent.children.indexOf(this);
          }
        };

        _proto._onPreDestroy = function _onPreDestroy() {
          this._onPreDestroyBase();
        };

        _proto._onHierarchyChanged = function _onHierarchyChanged(oldParent) {
          return this._onHierarchyChangedBase(oldParent);
        };

        _proto._instantiate = function _instantiate(cloned, isSyncedNode) {
          if (!cloned) {
            cloned = legacyCC.instantiate._clone(this, this);
          }

          var newPrefabInfo = cloned._prefab;

          cloned._parent = null;

          cloned._onBatchCreated(isSyncedNode);

          return cloned;
        };

        _proto._onHierarchyChangedBase = function _onHierarchyChangedBase(oldParent) {
          var newParent = this._parent;

          if (this._persistNode && !(newParent instanceof legacyCC.Scene)) {
            legacyCC.game.removePersistRootNode(this);
          }

          var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);

          if (this._activeInHierarchy !== shouldActiveNow) {
            legacyCC.director._nodeActivator.activateNode(this, shouldActiveNow);
          }
        };

        _proto._onPreDestroyBase = function _onPreDestroyBase() {
          this._objFlags |= Destroying$2;
          var parent = this._parent;
          var destroyByParent = !!parent && (parent._objFlags & Destroying$2) !== 0;

          if (!destroyByParent && EDITOR) {
            this._registerIfAttached(false);
          }

          if (this._persistNode) {
            legacyCC.game.removePersistRootNode(this);
          }

          if (!destroyByParent) {
            if (parent) {
              this.emit(NodeEventType.PARENT_CHANGED, this);

              var childIndex = parent._children.indexOf(this);

              parent._children.splice(childIndex, 1);

              this._siblingIndex = 0;

              parent._updateSiblingIndex();

              if (parent.emit) {
                parent.emit(NodeEventType.CHILD_REMOVED, this);
              }
            }
          }

          this.emit(NodeEventType.NODE_DESTROYED, this);

          this._eventProcessor.destroy();

          var children = this._children;

          for (var i = 0; i < children.length; ++i) {
            children[i]._destroyImmediate();
          }

          var comps = this._components;

          for (var _i5 = 0; _i5 < comps.length; ++_i5) {
            comps[_i5]._destroyImmediate();
          }

          return destroyByParent;
        };

        _createClass(BaseNode, [{
          key: "components",
          get: function get() {
            return this._components;
          }
        }, {
          key: "_persistNode",
          get: function get() {
            return (this._objFlags & DontDestroy$1) > 0;
          },
          set: function set(value) {
            if (value) {
              this._objFlags |= DontDestroy$1;
            } else {
              this._objFlags &= ~DontDestroy$1;
            }
          }
        }, {
          key: "name",
          get: function get() {
            return this._name;
          },
          set: function set(value) {

            this._name = value;
          }
        }, {
          key: "uuid",
          get: function get() {
            return this._id;
          }
        }, {
          key: "children",
          get: function get() {
            return this._children;
          }
        }, {
          key: "active",
          get: function get() {
            return this._active;
          },
          set: function set(isActive) {
            isActive = !!isActive;

            if (this._active !== isActive) {
              this._active = isActive;
              var parent = this._parent;

              if (parent) {
                var couldActiveInScene = parent._activeInHierarchy;

                if (couldActiveInScene) {
                  legacyCC.director._nodeActivator.activateNode(this, isActive);
                }
              }
            }
          }
        }, {
          key: "activeInHierarchy",
          get: function get() {
            return this._activeInHierarchy;
          }
        }, {
          key: "parent",
          get: function get() {
            return this._parent;
          },
          set: function set(value) {
            this.setParent(value);
          }
        }, {
          key: "scene",
          get: function get() {
            return this._scene;
          }
        }, {
          key: "eventProcessor",
          get: function get() {
            return this._eventProcessor;
          }
        }]);

        return BaseNode;
      }(CCObject), _class3$8.idGenerator = idGenerator$2, _class3$8._stacks = [[]], _class3$8._stackId = 0, _temp$l), (_applyDecoratedDescriptor(_class2$k.prototype, "_persistNode", [property], Object.getOwnPropertyDescriptor(_class2$k.prototype, "_persistNode"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "name", [editable], Object.getOwnPropertyDescriptor(_class2$k.prototype, "name"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "children", [editable], Object.getOwnPropertyDescriptor(_class2$k.prototype, "children"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "active", [editable], Object.getOwnPropertyDescriptor(_class2$k.prototype, "active"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "activeInHierarchy", [editable], Object.getOwnPropertyDescriptor(_class2$k.prototype, "activeInHierarchy"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "parent", [editable], Object.getOwnPropertyDescriptor(_class2$k.prototype, "parent"), _class2$k.prototype), _descriptor$f = _applyDecoratedDescriptor(_class2$k.prototype, "_parent", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$b = _applyDecoratedDescriptor(_class2$k.prototype, "_children", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3$9 = _applyDecoratedDescriptor(_class2$k.prototype, "_active", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor4$7 = _applyDecoratedDescriptor(_class2$k.prototype, "_components", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$k.prototype, "_prefab", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$k)) || _class$n));
      legacyCC._BaseNode = BaseNode;

      var _dec$o, _dec2$b, _class$o, _class2$l, _descriptor$g, _descriptor2$c, _descriptor3$a, _descriptor4$8, _descriptor5$5, _class3$9, _temp$m;
      var v3_a = new Vec3();
      var q_a = new Quat();
      var q_b = new Quat();
      var qt_1$1 = new Quat();
      var m3_1$2 = new Mat3();
      var m3_scaling = new Mat3();
      var m4_1$1 = new Mat4();
      var dirtyNodes = [];
      var nativeDirtyNodes = [];
      var view_tmp = [];

      var BookOfChange = function () {
        function BookOfChange() {
          this._chunks = [];
          this._freelists = [];

          this._createChunk();
        }

        var _proto = BookOfChange.prototype;

        _proto.alloc = function alloc() {
          var chunkCount = this._freelists.length;

          for (var i = 0; i < chunkCount; ++i) {
            if (!this._freelists[i].length) continue;
            return this._createView(i);
          }

          this._createChunk();

          return this._createView(chunkCount);
        };

        _proto.free = function free(view, idx) {
          var chunkCount = this._freelists.length;

          for (var i = 0; i < chunkCount; ++i) {
            if (this._chunks[i] !== view) continue;

            this._freelists[i].push(idx);

            return;
          }
        };

        _proto.clear = function clear() {
          var chunkCount = this._chunks.length;

          for (var i = 0; i < chunkCount; ++i) {
            this._chunks[i].fill(0);
          }
        };

        _proto._createChunk = function _createChunk() {
          this._chunks.push(new Uint32Array(BookOfChange.CAPACITY_PER_CHUNK));

          var freelist = [];

          for (var i = BookOfChange.CAPACITY_PER_CHUNK - 1; i >= 0; i--) {
            freelist.push(i);
          }

          this._freelists.push(freelist);
        };

        _proto._createView = function _createView(chunkIdx) {
          view_tmp[0] = this._chunks[chunkIdx];
          view_tmp[1] = this._freelists[chunkIdx].pop();
          return view_tmp;
        };

        return BookOfChange;
      }();

      BookOfChange.CAPACITY_PER_CHUNK = 256;
      var bookOfChange = new BookOfChange();
      var reserveContentsForAllSyncablePrefabTag = Symbol('ReserveContentsForAllSyncablePrefab');
      var Node$1 = exports('Node', (_dec$o = ccclass('cc.Node'), _dec2$b = type(Vec3), _dec$o(_class$o = (_class2$l = (_temp$m = _class3$9 = function (_BaseNode) {
        _inheritsLoose(Node, _BaseNode);

        var _proto2 = Node.prototype;

        _proto2._init = function _init() {
          var _bookOfChange$alloc = bookOfChange.alloc(),
              chunk = _bookOfChange$alloc[0],
              offset = _bookOfChange$alloc[1];

          this._hasChangedFlagsChunk = chunk;
          this._hasChangedFlagsOffset = offset;
          var flagBuffer = new Uint32Array(chunk.buffer, chunk.byteOffset + offset * 4, 1);
          this._hasChangedFlags = flagBuffer;

          {
            this._pos = new Vec3();
            this._rot = new Quat();
            this._scale = new Vec3(1, 1, 1);
            this._mat = new Mat4();
          }
        };

        function Node(name) {
          var _this;

          _this = _BaseNode.call(this, name) || this;
          _this._uiProps = new NodeUIProperties(_assertThisInitialized(_this));
          _this._static = false;

          _initializerDefineProperty(_this, "_lpos", _descriptor$g, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lrot", _descriptor2$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lscale", _descriptor3$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_layer", _descriptor4$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_euler", _descriptor5$5, _assertThisInitialized(_this));

          _this._dirtyFlagsPri = TransformBit.NONE;
          _this._eulerDirty = false;
          _this._nodeHandle = NULL_HANDLE;

          _this._init();

          return _this;
        }

        Node.isNode = function isNode(obj) {
          return obj instanceof Node && (obj.constructor === Node || !(obj instanceof legacyCC.Scene));
        };

        _proto2._onPreDestroy = function _onPreDestroy() {
          var result = this._onPreDestroyBase();

          bookOfChange.free(this._hasChangedFlagsChunk, this._hasChangedFlagsOffset);
          return result;
        };

        _proto2[serializeTag] = function (serializationOutput, context) {

          {
            serializationOutput.writeThis();
            return;
          }
        };

        _proto2.setParent = function setParent(value, keepWorldTransform) {
          if (keepWorldTransform === void 0) {
            keepWorldTransform = false;
          }

          if (keepWorldTransform) {
            this.updateWorldTransform();
          }

          _BaseNode.prototype.setParent.call(this, value, keepWorldTransform);
        };

        _proto2._onSetParent = function _onSetParent(oldParent, keepWorldTransform) {
          _BaseNode.prototype._onSetParent.call(this, oldParent, keepWorldTransform);

          if (keepWorldTransform) {
            var parent = this._parent;

            if (parent) {
              parent.updateWorldTransform();

              if (approx(Mat4.determinant(parent._mat), 0, EPSILON)) {
                warnID(14200);
                this._dirtyFlags |= TransformBit.TRS;
                this.updateWorldTransform();
              } else {
                Mat4.multiply(m4_1$1, Mat4.invert(m4_1$1, parent._mat), this._mat);
                Mat4.toRTS(m4_1$1, this._lrot, this._lpos, this._lscale);
              }
            } else {
              Vec3.copy(this._lpos, this._pos);
              Quat.copy(this._lrot, this._rot);
              Vec3.copy(this._lscale, this._scale);
            }

            this._eulerDirty = true;
          }

          this.invalidateChildren(TransformBit.TRS);
        };

        _proto2._onHierarchyChanged = function _onHierarchyChanged(oldParent) {
          this.eventProcessor.reattach();

          _BaseNode.prototype._onHierarchyChangedBase.call(this, oldParent);
        };

        _proto2._onBatchCreated = function _onBatchCreated(dontSyncChildPrefab) {

          this.hasChangedFlags = TransformBit.TRS;
          this._dirtyFlags |= TransformBit.TRS;
          var len = this._children.length;

          for (var i = 0; i < len; ++i) {
            this._children[i]._siblingIndex = i;

            this._children[i]._onBatchCreated(dontSyncChildPrefab);
          }
        };

        _proto2._onBeforeSerialize = function _onBeforeSerialize() {
          this.eulerAngles;
        };

        _proto2._onPostActivated = function _onPostActivated(active) {
          if (active) {
            this._eventProcessor.setEnabled(true);

            this.invalidateChildren(TransformBit.TRS);

            if (this._uiProps && this._uiProps.uiComp) {
              this._uiProps.uiComp.setNodeDirty();

              this._uiProps.uiComp.setTextureDirty();

              this._uiProps.uiComp.markForUpdateRenderData();
            }
          } else {
            this._eventProcessor.setEnabled(false);
          }
        };

        _proto2.translate = function translate(trans, ns) {
          var space = ns || NodeSpace.LOCAL;

          if (space === NodeSpace.LOCAL) {
            Vec3.transformQuat(v3_a, trans, this._lrot);
            this._lpos.x += v3_a.x;
            this._lpos.y += v3_a.y;
            this._lpos.z += v3_a.z;
          } else if (space === NodeSpace.WORLD) {
            if (this._parent) {
              Quat.invert(q_a, this._parent.worldRotation);
              Vec3.transformQuat(v3_a, trans, q_a);
              var _scale = this.worldScale;
              this._lpos.x += v3_a.x / _scale.x;
              this._lpos.y += v3_a.y / _scale.y;
              this._lpos.z += v3_a.z / _scale.z;
            } else {
              this._lpos.x += trans.x;
              this._lpos.y += trans.y;
              this._lpos.z += trans.z;
            }
          }

          this.invalidateChildren(TransformBit.POSITION);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
          }
        };

        _proto2.rotate = function rotate(rot, ns) {
          var space = ns || NodeSpace.LOCAL;
          Quat.normalize(q_a, rot);

          if (space === NodeSpace.LOCAL) {
            Quat.multiply(this._lrot, this._lrot, q_a);
          } else if (space === NodeSpace.WORLD) {
            var worldRot = this.worldRotation;
            Quat.multiply(q_b, q_a, worldRot);
            Quat.invert(q_a, worldRot);
            Quat.multiply(q_b, q_a, q_b);
            Quat.multiply(this._lrot, this._lrot, q_b);
          }

          this._eulerDirty = true;
          this.invalidateChildren(TransformBit.ROTATION);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
          }
        };

        _proto2.lookAt = function lookAt(pos, up) {
          this.getWorldPosition(v3_a);
          Vec3.subtract(v3_a, v3_a, pos);
          Vec3.normalize(v3_a, v3_a);
          Quat.fromViewUp(q_a, v3_a, up);
          this.setWorldRotation(q_a);
        };

        _proto2._setDirtyNode = function _setDirtyNode(idx, currNode) {
          dirtyNodes[idx] = currNode;
        };

        _proto2.invalidateChildren = function invalidateChildren(dirtyBit) {
          var i = 0;
          var j = 0;
          var l = 0;
          var cur;
          var c;
          var flag = 0;
          var children;
          var hasChangedFlags = 0;
          var childDirtyBit = dirtyBit | TransformBit.POSITION;
          dirtyNodes[0] = this;

          while (i >= 0) {
            cur = dirtyNodes[i--];
            hasChangedFlags = cur._hasChangedFlags[0];
            flag = cur._dirtyFlagsPri;

            if (cur.isValid && (flag & hasChangedFlags & dirtyBit) !== dirtyBit) {
              flag |= dirtyBit;
              cur._dirtyFlagsPri = flag;

              cur._hasChangedFlags[0] = hasChangedFlags | dirtyBit;
              children = cur._children;
              l = children.length;

              for (j = 0; j < l; j++) {
                c = children[j];
                dirtyNodes[++i] = c;
              }
            }

            dirtyBit = childDirtyBit;
          }
        };

        _proto2.updateWorldTransform = function updateWorldTransform() {
          if (!this._dirtyFlags) {
            return;
          }

          var cur = this;
          var i = 0;

          while (cur && cur._dirtyFlags) {
            this._setDirtyNode(i++, cur);

            cur = cur._parent;
          }

          var child;
          var dirtyBits = 0;

          while (i) {
            child = dirtyNodes[--i];
            dirtyBits |= child._dirtyFlags;

            if (cur) {
              if (dirtyBits & TransformBit.POSITION) {
                Vec3.transformMat4(child._pos, child._lpos, cur._mat);
                child._mat.m12 = child._pos.x;
                child._mat.m13 = child._pos.y;
                child._mat.m14 = child._pos.z;
              }

              if (dirtyBits & TransformBit.RS) {
                Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale);
                Mat4.multiply(child._mat, cur._mat, child._mat);

                if (dirtyBits & TransformBit.ROTATION) {
                  Quat.multiply(child._rot, cur._rot, child._lrot);
                }

                Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, child._rot));
                Mat3.multiplyMat4(m3_1$2, m3_1$2, child._mat);
                child._scale.x = m3_1$2.m00;
                child._scale.y = m3_1$2.m04;
                child._scale.z = m3_1$2.m08;
              }
            } else {
              if (dirtyBits & TransformBit.POSITION) {
                Vec3.copy(child._pos, child._lpos);
                child._mat.m12 = child._pos.x;
                child._mat.m13 = child._pos.y;
                child._mat.m14 = child._pos.z;
              }

              if (dirtyBits & TransformBit.RS) {
                if (dirtyBits & TransformBit.ROTATION) {
                  Quat.copy(child._rot, child._lrot);
                }

                if (dirtyBits & TransformBit.SCALE) {
                  Vec3.copy(child._scale, child._lscale);
                  Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale);
                }
              }
            }

            child._dirtyFlags = TransformBit.NONE;
            cur = child;
          }
        };

        _proto2.setPosition = function setPosition(val, y, z) {
          if (y === undefined && z === undefined) {
            Vec3.copy(this._lpos, val);
          } else if (z === undefined) {
            Vec3.set(this._lpos, val, y, this._lpos.z);
          } else {
            Vec3.set(this._lpos, val, y, z);
          }

          this.invalidateChildren(TransformBit.POSITION);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
          }
        };

        _proto2.getPosition = function getPosition(out) {
          if (out) {
            return Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z);
          }

          return Vec3.copy(new Vec3(), this._lpos);
        };

        _proto2.setRotation = function setRotation(val, y, z, w) {
          if (y === undefined || z === undefined || w === undefined) {
            Quat.copy(this._lrot, val);
          } else {
            Quat.set(this._lrot, val, y, z, w);
          }

          this._eulerDirty = true;
          this.invalidateChildren(TransformBit.ROTATION);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
          }
        };

        _proto2.setRotationFromEuler = function setRotationFromEuler(val, y, zOpt) {
          var z = zOpt === undefined ? this._euler.z : zOpt;

          if (y === undefined) {
            Vec3.copy(this._euler, val);
            Quat.fromEuler(this._lrot, val.x, val.y, val.z);
          } else {
            Vec3.set(this._euler, val, y, z);
            Quat.fromEuler(this._lrot, val, y, z);
          }

          this._eulerDirty = false;
          this.invalidateChildren(TransformBit.ROTATION);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
          }
        };

        _proto2.getRotation = function getRotation(out) {
          if (out) {
            return Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w);
          }

          return Quat.copy(new Quat(), this._lrot);
        };

        _proto2.setScale = function setScale(val, y, z) {
          if (y === undefined && z === undefined) {
            Vec3.copy(this._lscale, val);
          } else if (z === undefined) {
            Vec3.set(this._lscale, val, y, this._lscale.z);
          } else {
            Vec3.set(this._lscale, val, y, z);
          }

          this.invalidateChildren(TransformBit.SCALE);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
          }
        };

        _proto2.getScale = function getScale(out) {
          if (out) {
            return Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z);
          }

          return Vec3.copy(new Vec3(), this._lscale);
        };

        _proto2.inverseTransformPoint = function inverseTransformPoint(out, p) {
          Vec3.copy(out, p);
          var cur = this;
          var i = 0;

          while (cur._parent) {
            this._setDirtyNode(i++, cur);

            cur = cur._parent;
          }

          while (i >= 0) {
            Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale);
            cur = dirtyNodes[--i];
          }

          return out;
        };

        _proto2.setWorldPosition = function setWorldPosition(val, y, z) {
          if (y === undefined || z === undefined) {
            Vec3.copy(this._pos, val);
          } else {
            Vec3.set(this._pos, val, y, z);
          }

          var parent = this._parent;
          var local = this._lpos;

          if (parent) {
            parent.updateWorldTransform();
            Vec3.transformMat4(local, this._pos, Mat4.invert(m4_1$1, parent._mat));
          } else {
            Vec3.copy(local, this._pos);
          }

          this.invalidateChildren(TransformBit.POSITION);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
          }
        };

        _proto2.getWorldPosition = function getWorldPosition(out) {
          this.updateWorldTransform();

          if (out) {
            return Vec3.copy(out, this._pos);
          }

          return Vec3.copy(new Vec3(), this._pos);
        };

        _proto2.setWorldRotation = function setWorldRotation(val, y, z, w) {
          if (y === undefined || z === undefined || w === undefined) {
            Quat.copy(this._rot, val);
          } else {
            Quat.set(this._rot, val, y, z, w);
          }

          if (this._parent) {
            this._parent.updateWorldTransform();

            Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
          } else {
            Quat.copy(this._lrot, this._rot);
          }

          this._eulerDirty = true;
          this.invalidateChildren(TransformBit.ROTATION);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
          }
        };

        _proto2.setWorldRotationFromEuler = function setWorldRotationFromEuler(x, y, z) {
          Quat.fromEuler(this._rot, x, y, z);

          if (this._parent) {
            this._parent.updateWorldTransform();

            Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
          } else {
            Quat.copy(this._lrot, this._rot);
          }

          this._eulerDirty = true;
          this.invalidateChildren(TransformBit.ROTATION);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
          }
        };

        _proto2.getWorldRotation = function getWorldRotation(out) {
          this.updateWorldTransform();

          if (out) {
            return Quat.copy(out, this._rot);
          }

          return Quat.copy(new Quat(), this._rot);
        };

        _proto2.setWorldScale = function setWorldScale(val, y, z) {
          if (y === undefined || z === undefined) {
            Vec3.copy(this._scale, val);
          } else {
            Vec3.set(this._scale, val, y, z);
          }

          var parent = this._parent;

          if (parent) {
            parent.updateWorldTransform();
            Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, parent._rot));
            Mat3.multiplyMat4(m3_1$2, m3_1$2, parent._mat);
            m3_scaling.m00 = this._scale.x;
            m3_scaling.m04 = this._scale.y;
            m3_scaling.m08 = this._scale.z;
            Mat3.multiply(m3_1$2, m3_scaling, Mat3.invert(m3_1$2, m3_1$2));
            this._lscale.x = Vec3.set(v3_a, m3_1$2.m00, m3_1$2.m01, m3_1$2.m02).length();
            this._lscale.y = Vec3.set(v3_a, m3_1$2.m03, m3_1$2.m04, m3_1$2.m05).length();
            this._lscale.z = Vec3.set(v3_a, m3_1$2.m06, m3_1$2.m07, m3_1$2.m08).length();
          } else {
            Vec3.copy(this._lscale, this._scale);
          }

          this.invalidateChildren(TransformBit.SCALE);

          if (this._eventMask & TRANSFORM_ON) {
            this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
          }
        };

        _proto2.getWorldScale = function getWorldScale(out) {
          this.updateWorldTransform();

          if (out) {
            return Vec3.copy(out, this._scale);
          }

          return Vec3.copy(new Vec3(), this._scale);
        };

        _proto2.getWorldMatrix = function getWorldMatrix(out) {
          this.updateWorldTransform();
          var target = out || new Mat4();
          return Mat4.copy(target, this._mat);
        };

        _proto2.getWorldRS = function getWorldRS(out) {
          this.updateWorldTransform();
          var target = out || new Mat4();
          Mat4.copy(target, this._mat);
          target.m12 = 0;
          target.m13 = 0;
          target.m14 = 0;
          return target;
        };

        _proto2.getWorldRT = function getWorldRT(out) {
          this.updateWorldTransform();
          var target = out || new Mat4();
          return Mat4.fromRT(target, this._rot, this._pos);
        };

        _proto2.setRTS = function setRTS(rot, pos, scale) {
          var dirtyBit = 0;

          if (rot) {
            dirtyBit |= TransformBit.ROTATION;

            if (rot.w !== undefined) {
              Quat.copy(this._lrot, rot);
              this._eulerDirty = true;
            } else {
              Vec3.copy(this._euler, rot);
              Quat.fromEuler(this._lrot, rot.x, rot.y, rot.z);
              this._eulerDirty = false;
            }
          }

          if (pos) {
            Vec3.copy(this._lpos, pos);
            dirtyBit |= TransformBit.POSITION;
          }

          if (scale) {
            Vec3.copy(this._lscale, scale);
            dirtyBit |= TransformBit.SCALE;
          }

          if (dirtyBit) {
            this.invalidateChildren(dirtyBit);

            if (this._eventMask & TRANSFORM_ON) {
              this.emit(NodeEventType.TRANSFORM_CHANGED, dirtyBit);
            }
          }
        };

        _proto2.pauseSystemEvents = function pauseSystemEvents(recursive) {
          this._eventProcessor.setEnabled(false, recursive);
        };

        _proto2.resumeSystemEvents = function resumeSystemEvents(recursive) {
          this._eventProcessor.setEnabled(true, recursive);
        };

        Node.resetHasChangedFlags = function resetHasChangedFlags() {
          bookOfChange.clear();
        };

        Node.clearNodeArray = function clearNodeArray() {
          if (Node.ClearFrame < Node.ClearRound && !EDITOR) {
            Node.ClearFrame++;
          } else {
            Node.ClearFrame = 0;
            dirtyNodes.length = 0;
            nativeDirtyNodes.length = 0;
          }
        };

        _proto2.getPathInHierarchy = function getPathInHierarchy() {
          var result = this.name;
          var curNode = this.parent;

          while (curNode && curNode instanceof Node) {
            result = curNode.name + "/" + result;
            curNode = curNode.parent;
          }

          return result;
        };

        _createClass(Node, [{
          key: "_dirtyFlags",
          get: function get() {

            return this._dirtyFlagsPri;
          },
          set: function set(flags) {
            this._dirtyFlagsPri = flags;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "position",
          get: function get() {
            return this._lpos;
          },
          set: function set(val) {
            this.setPosition(val);
          }
        }, {
          key: "worldPosition",
          get: function get() {
            this.updateWorldTransform();
            return this._pos;
          },
          set: function set(val) {
            this.setWorldPosition(val);
          }
        }, {
          key: "rotation",
          get: function get() {
            return this._lrot;
          },
          set: function set(val) {
            this.setRotation(val);
          }
        }, {
          key: "eulerAngles",
          get: function get() {
            if (this._eulerDirty) {
              Quat.toEuler(this._euler, this._lrot);
              this._eulerDirty = false;
            }

            return this._euler;
          },
          set: function set(val) {
            this.setRotationFromEuler(val.x, val.y, val.z);
          }
        }, {
          key: "angle",
          get: function get() {
            return this._euler.z;
          },
          set: function set(val) {
            Vec3.set(this._euler, 0, 0, val);
            Quat.fromAngleZ(this._lrot, val);
            this._eulerDirty = false;
            this.invalidateChildren(TransformBit.ROTATION);

            if (this._eventMask & TRANSFORM_ON) {
              this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
            }
          }
        }, {
          key: "worldRotation",
          get: function get() {
            this.updateWorldTransform();
            return this._rot;
          },
          set: function set(val) {
            this.setWorldRotation(val);
          }
        }, {
          key: "scale",
          get: function get() {
            return this._lscale;
          },
          set: function set(val) {
            this.setScale(val);
          }
        }, {
          key: "worldScale",
          get: function get() {
            this.updateWorldTransform();
            return this._scale;
          },
          set: function set(val) {
            this.setWorldScale(val);
          }
        }, {
          key: "matrix",
          set: function set(val) {
            Mat4.toRTS(val, this._lrot, this._lpos, this._lscale);
            this.invalidateChildren(TransformBit.TRS);
            this._eulerDirty = true;

            if (this._eventMask & TRANSFORM_ON) {
              this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.TRS);
            }
          }
        }, {
          key: "worldMatrix",
          get: function get() {
            this.updateWorldTransform();
            return this._mat;
          }
        }, {
          key: "forward",
          get: function get() {
            return Vec3.transformQuat(new Vec3(), Vec3.FORWARD, this.worldRotation);
          },
          set: function set(dir) {
            var len = dir.length();
            Vec3.multiplyScalar(v3_a, dir, -1 / len);
            Quat.fromViewUp(q_a, v3_a);
            this.setWorldRotation(q_a);
          }
        }, {
          key: "up",
          get: function get() {
            return Vec3.transformQuat(new Vec3(), Vec3.UP, this.worldRotation);
          }
        }, {
          key: "right",
          get: function get() {
            return Vec3.transformQuat(new Vec3(), Vec3.RIGHT, this.worldRotation);
          }
        }, {
          key: "layer",
          get: function get() {
            return this._layer;
          },
          set: function set(l) {
            this._layer = l;

            if (this._uiProps && this._uiProps.uiComp) {
              this._uiProps.uiComp.setNodeDirty();

              this._uiProps.uiComp.markForUpdateRenderData();
            }

            this.emit(NodeEventType.LAYER_CHANGED, this._layer);
          }
        }, {
          key: "hasChangedFlags",
          get: function get() {
            return this._hasChangedFlagsChunk[this._hasChangedFlagsOffset];
          },
          set: function set(val) {
            this._hasChangedFlagsChunk[this._hasChangedFlagsOffset] = val;
          }
        }]);

        return Node;
      }(BaseNode), _class3$9.EventType = NodeEventType, _class3$9.NodeSpace = NodeSpace, _class3$9.TransformDirtyBit = TransformBit, _class3$9.TransformBit = TransformBit, _class3$9.reserveContentsForAllSyncablePrefabTag = reserveContentsForAllSyncablePrefabTag, _class3$9.ClearFrame = 0, _class3$9.ClearRound = 1000, _temp$m), (_descriptor$g = _applyDecoratedDescriptor(_class2$l.prototype, "_lpos", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      }), _descriptor2$c = _applyDecoratedDescriptor(_class2$l.prototype, "_lrot", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Quat();
        }
      }), _descriptor3$a = _applyDecoratedDescriptor(_class2$l.prototype, "_lscale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(1, 1, 1);
        }
      }), _descriptor4$8 = _applyDecoratedDescriptor(_class2$l.prototype, "_layer", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Layers.Enum.DEFAULT;
        }
      }), _descriptor5$5 = _applyDecoratedDescriptor(_class2$l.prototype, "_euler", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3();
        }
      }), _applyDecoratedDescriptor(_class2$l.prototype, "eulerAngles", [_dec2$b], Object.getOwnPropertyDescriptor(_class2$l.prototype, "eulerAngles"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "angle", [editable], Object.getOwnPropertyDescriptor(_class2$l.prototype, "angle"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "layer", [editable], Object.getOwnPropertyDescriptor(_class2$l.prototype, "layer"), _class2$l.prototype)), _class2$l)) || _class$o));
      legacyCC.Node = Node$1;

      var _dec$p, _class$p, _class2$m, _descriptor$h, _temp$n, _dec2$c, _dec3$7, _dec4$5, _dec5$2, _dec6$2, _class4$2, _class5$2, _descriptor2$d, _descriptor3$b, _descriptor4$9, _descriptor5$6, _descriptor6$2, _temp2$1, _dec7$1, _class7$1, _class8$1, _descriptor7$2, _temp3$2, _dec8$1, _dec9$1, _class10$1, _class11$1, _descriptor8$2, _descriptor9$1, _descriptor10$1, _temp4$1, _dec10$1, _dec11$1, _dec12$1, _class13$1, _class14$1, _descriptor11$1, _descriptor12$1, _temp5$1, _dec13$1, _dec14$1, _dec15$1, _class16$1, _class17$1, _descriptor13$1, _descriptor14$1, _temp6$1, _dec16$1, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _dec21$1, _class19$1, _class20$1, _descriptor15$1, _descriptor16$1, _descriptor17$1, _descriptor18$1, _descriptor19$1, _descriptor20$1, _temp7$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _class22$1, _class23$1, _descriptor21$1, _descriptor22$1, _descriptor23$1, _descriptor24$1, _descriptor25$1, _descriptor26$1, _temp8$1;

      var TargetInfo = (_dec$p = ccclass('cc.TargetInfo'), _dec$p(_class$p = (_class2$m = (_temp$n = function TargetInfo() {
        _initializerDefineProperty(this, "localID", _descriptor$h, this);
      }, _temp$n), (_descriptor$h = _applyDecoratedDescriptor(_class2$m.prototype, "localID", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$m)) || _class$p);
      var TargetOverrideInfo = (_dec2$c = ccclass('cc.TargetOverrideInfo'), _dec3$7 = type(CCObject), _dec4$5 = type(TargetInfo), _dec5$2 = type(Node$1), _dec6$2 = type(TargetInfo), _dec2$c(_class4$2 = (_class5$2 = (_temp2$1 = function TargetOverrideInfo() {
        _initializerDefineProperty(this, "source", _descriptor2$d, this);

        _initializerDefineProperty(this, "sourceInfo", _descriptor3$b, this);

        _initializerDefineProperty(this, "propertyPath", _descriptor4$9, this);

        _initializerDefineProperty(this, "target", _descriptor5$6, this);

        _initializerDefineProperty(this, "targetInfo", _descriptor6$2, this);
      }, _temp2$1), (_descriptor2$d = _applyDecoratedDescriptor(_class5$2.prototype, "source", [serializable, _dec3$7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$b = _applyDecoratedDescriptor(_class5$2.prototype, "sourceInfo", [serializable, _dec4$5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4$9 = _applyDecoratedDescriptor(_class5$2.prototype, "propertyPath", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor5$6 = _applyDecoratedDescriptor(_class5$2.prototype, "target", [serializable, _dec5$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6$2 = _applyDecoratedDescriptor(_class5$2.prototype, "targetInfo", [serializable, _dec6$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class5$2)) || _class4$2);
      var CompPrefabInfo = (_dec7$1 = ccclass('cc.CompPrefabInfo'), _dec7$1(_class7$1 = (_class8$1 = (_temp3$2 = function CompPrefabInfo() {
        _initializerDefineProperty(this, "fileId", _descriptor7$2, this);
      }, _temp3$2), (_descriptor7$2 = _applyDecoratedDescriptor(_class8$1.prototype, "fileId", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      })), _class8$1)) || _class7$1);
      var PropertyOverrideInfo = (_dec8$1 = ccclass('CCPropertyOverrideInfo'), _dec9$1 = type(TargetInfo), _dec8$1(_class10$1 = (_class11$1 = (_temp4$1 = function () {
        function PropertyOverrideInfo() {
          _initializerDefineProperty(this, "targetInfo", _descriptor8$2, this);

          _initializerDefineProperty(this, "propertyPath", _descriptor9$1, this);

          _initializerDefineProperty(this, "value", _descriptor10$1, this);
        }

        var _proto = PropertyOverrideInfo.prototype;

        _proto.isTarget = function isTarget(localID, propPath) {
        };

        return PropertyOverrideInfo;
      }(), _temp4$1), (_descriptor8$2 = _applyDecoratedDescriptor(_class11$1.prototype, "targetInfo", [serializable, _dec9$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9$1 = _applyDecoratedDescriptor(_class11$1.prototype, "propertyPath", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor10$1 = _applyDecoratedDescriptor(_class11$1.prototype, "value", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class11$1)) || _class10$1);
      var MountedChildrenInfo = (_dec10$1 = ccclass('cc.MountedChildrenInfo'), _dec11$1 = type(TargetInfo), _dec12$1 = type([Node$1]), _dec10$1(_class13$1 = (_class14$1 = (_temp5$1 = function () {
        function MountedChildrenInfo() {
          _initializerDefineProperty(this, "targetInfo", _descriptor11$1, this);

          _initializerDefineProperty(this, "nodes", _descriptor12$1, this);
        }

        var _proto2 = MountedChildrenInfo.prototype;

        _proto2.isTarget = function isTarget(localID) {
        };

        return MountedChildrenInfo;
      }(), _temp5$1), (_descriptor11$1 = _applyDecoratedDescriptor(_class14$1.prototype, "targetInfo", [serializable, _dec11$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12$1 = _applyDecoratedDescriptor(_class14$1.prototype, "nodes", [serializable, _dec12$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class14$1)) || _class13$1);
      var MountedComponentsInfo = (_dec13$1 = ccclass('cc.MountedComponentsInfo'), _dec14$1 = type(TargetInfo), _dec15$1 = type([Component]), _dec13$1(_class16$1 = (_class17$1 = (_temp6$1 = function () {
        function MountedComponentsInfo() {
          _initializerDefineProperty(this, "targetInfo", _descriptor13$1, this);

          _initializerDefineProperty(this, "components", _descriptor14$1, this);
        }

        var _proto3 = MountedComponentsInfo.prototype;

        _proto3.isTarget = function isTarget(localID) {
        };

        return MountedComponentsInfo;
      }(), _temp6$1), (_descriptor13$1 = _applyDecoratedDescriptor(_class17$1.prototype, "targetInfo", [serializable, _dec14$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor14$1 = _applyDecoratedDescriptor(_class17$1.prototype, "components", [serializable, _dec15$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class17$1)) || _class16$1);
      var PrefabInstance = (_dec16$1 = ccclass('cc.PrefabInstance'), _dec17$1 = type(Node$1), _dec18$1 = type([MountedChildrenInfo]), _dec19$1 = type([MountedComponentsInfo]), _dec20$1 = type([PropertyOverrideInfo]), _dec21$1 = type([TargetInfo]), _dec16$1(_class19$1 = (_class20$1 = (_temp7$1 = function () {
        function PrefabInstance() {
          _initializerDefineProperty(this, "fileId", _descriptor15$1, this);

          _initializerDefineProperty(this, "prefabRootNode", _descriptor16$1, this);

          _initializerDefineProperty(this, "mountedChildren", _descriptor17$1, this);

          _initializerDefineProperty(this, "mountedComponents", _descriptor18$1, this);

          _initializerDefineProperty(this, "propertyOverrides", _descriptor19$1, this);

          _initializerDefineProperty(this, "removedComponents", _descriptor20$1, this);

          this.targetMap = {};
        }

        var _proto4 = PrefabInstance.prototype;

        _proto4.findPropertyOverride = function findPropertyOverride(localID, propPath) {
        };

        _proto4.removePropertyOverride = function removePropertyOverride(localID, propPath) {
        };

        return PrefabInstance;
      }(), _temp7$1), (_descriptor15$1 = _applyDecoratedDescriptor(_class20$1.prototype, "fileId", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor16$1 = _applyDecoratedDescriptor(_class20$1.prototype, "prefabRootNode", [serializable, _dec17$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor17$1 = _applyDecoratedDescriptor(_class20$1.prototype, "mountedChildren", [serializable, _dec18$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor18$1 = _applyDecoratedDescriptor(_class20$1.prototype, "mountedComponents", [serializable, _dec19$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor19$1 = _applyDecoratedDescriptor(_class20$1.prototype, "propertyOverrides", [serializable, _dec20$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor20$1 = _applyDecoratedDescriptor(_class20$1.prototype, "removedComponents", [serializable, _dec21$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class20$1)) || _class19$1);
      var PrefabInfo = (_dec22$1 = ccclass('cc.PrefabInfo'), _dec23$1 = type(Node$1), _dec24$1 = type(PrefabInstance), _dec25$1 = type([TargetOverrideInfo]), _dec22$1(_class22$1 = (_class23$1 = (_temp8$1 = function PrefabInfo() {
        _initializerDefineProperty(this, "root", _descriptor21$1, this);

        _initializerDefineProperty(this, "asset", _descriptor22$1, this);

        _initializerDefineProperty(this, "fileId", _descriptor23$1, this);

        _initializerDefineProperty(this, "instance", _descriptor24$1, this);

        _initializerDefineProperty(this, "targetOverrides", _descriptor25$1, this);

        _initializerDefineProperty(this, "nestedPrefabInstanceRoots", _descriptor26$1, this);
      }, _temp8$1), (_descriptor21$1 = _applyDecoratedDescriptor(_class23$1.prototype, "root", [serializable, _dec23$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor22$1 = _applyDecoratedDescriptor(_class23$1.prototype, "asset", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor23$1 = _applyDecoratedDescriptor(_class23$1.prototype, "fileId", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor24$1 = _applyDecoratedDescriptor(_class23$1.prototype, "instance", [serializable, _dec24$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor25$1 = _applyDecoratedDescriptor(_class23$1.prototype, "targetOverrides", [serializable, _dec25$1], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      }), _descriptor26$1 = _applyDecoratedDescriptor(_class23$1.prototype, "nestedPrefabInstanceRoots", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: null
      })), _class23$1)) || _class22$1);
      legacyCC._PrefabInfo = PrefabInfo;

      function createNodeWithPrefab(node) {
        var prefabInfo = node._prefab;

        if (!prefabInfo) {
          return;
        }

        var prefabInstance = prefabInfo.instance;

        if (!prefabInstance) {
          return;
        }

        if (!prefabInfo.asset) {
          {
            errorID(3701, node.name);
          }

          prefabInfo.instance = undefined;
          return;
        }

        var _objFlags = node._objFlags;
        var _parent = node._parent;
        var _id = node._id;
        var _prefab = node._prefab;
        var editorExtras = node[editorExtrasTag];
        legacyCC.game._isCloning = true;

        {
          prefabInfo.asset._doInstantiate(node);
        }

        legacyCC.game._isCloning = false;
        node._objFlags = _objFlags;
        node._parent = _parent;
        node._id = _id;

        if (node._prefab) {
          node._prefab.instance = _prefab === null || _prefab === void 0 ? void 0 : _prefab.instance;
        }
      }
      function generateTargetMap(node, targetMap, isRoot) {
        var _node$_prefab;

        if (!targetMap) {
          return;
        }

        if (!node) {
          return;
        }

        var curTargetMap = targetMap;
        var prefabInstance = (_node$_prefab = node._prefab) === null || _node$_prefab === void 0 ? void 0 : _node$_prefab.instance;

        if (!isRoot && prefabInstance) {
          targetMap[prefabInstance.fileId] = {};
          curTargetMap = targetMap[prefabInstance.fileId];
        }

        var prefabInfo = node._prefab;

        if (prefabInfo) {
          curTargetMap[prefabInfo.fileId] = node;
        }

        var components = node.components;

        for (var i = 0; i < components.length; i++) {
          var comp = components[i];

          if (comp.__prefab) {
            curTargetMap[comp.__prefab.fileId] = comp;
          }
        }

        for (var _i = 0; _i < node.children.length; _i++) {
          var childNode = node.children[_i];
          generateTargetMap(childNode, curTargetMap, false);
        }
      }
      function getTarget(localID, targetMap) {
        if (!localID) {
          return null;
        }

        var target = null;
        var targetIter = targetMap;

        for (var i = 0; i < localID.length; i++) {
          if (!targetIter) {
            return null;
          }

          targetIter = targetIter[localID[i]];
        }

        target = targetIter;
        return target;
      }
      function applyMountedChildren(node, mountedChildren, targetMap) {
        if (!mountedChildren) {
          return;
        }

        for (var i = 0; i < mountedChildren.length; i++) {
          var childInfo = mountedChildren[i];

          if (childInfo && childInfo.targetInfo) {
            var target = getTarget(childInfo.targetInfo.localID, targetMap);

            if (!target) {
              continue;
            }

            var curTargetMap = targetMap;
            var localID = childInfo.targetInfo.localID;

            if (localID.length > 0) {
              for (var _i2 = 0; _i2 < localID.length - 1; _i2++) {
                curTargetMap = curTargetMap[localID[_i2]];
              }
            }

            if (childInfo.nodes) {
              for (var _i3 = 0; _i3 < childInfo.nodes.length; _i3++) {
                var childNode = childInfo.nodes[_i3];

                if (!childNode || target._children.includes(childNode)) {
                  continue;
                }

                target._children.push(childNode);

                childNode._parent = target;

                generateTargetMap(childNode, curTargetMap, false);
                childNode._siblingIndex = target._children.length - 1;
                expandPrefabInstanceNode(childNode, true);
              }
            }
          }
        }
      }
      function applyMountedComponents(node, mountedComponents, targetMap) {
        if (!mountedComponents) {
          return;
        }

        for (var i = 0; i < mountedComponents.length; i++) {
          var componentsInfo = mountedComponents[i];

          if (componentsInfo && componentsInfo.targetInfo) {
            var target = getTarget(componentsInfo.targetInfo.localID, targetMap);

            if (!target) {
              continue;
            }

            if (componentsInfo.components) {
              for (var _i4 = 0; _i4 < componentsInfo.components.length; _i4++) {
                var comp = componentsInfo.components[_i4];

                if (!comp) {
                  continue;
                }

                comp.node = target;

                target._components.push(comp);
              }
            }
          }
        }
      }
      function applyRemovedComponents(node, removedComponents, targetMap) {
        if (!removedComponents) {
          return;
        }

        for (var i = 0; i < removedComponents.length; i++) {
          var targetInfo = removedComponents[i];

          if (targetInfo) {
            var target = getTarget(targetInfo.localID, targetMap);

            if (!target || !target.node) {
              continue;
            }

            var index = target.node.components.indexOf(target);

            if (index >= 0) {
              target.node._components.splice(index, 1);
            }
          }
        }
      }
      function applyPropertyOverrides(node, propertyOverrides, targetMap) {
        if (propertyOverrides.length <= 0) {
          return;
        }

        var target = null;

        for (var i = 0; i < propertyOverrides.length; i++) {
          var propOverride = propertyOverrides[i];

          if (propOverride && propOverride.targetInfo) {
            var targetInfo = propOverride.targetInfo;
            target = getTarget(targetInfo.localID, targetMap);

            if (!target) {
              continue;
            }

            var targetPropOwner = target;
            var propertyPath = propOverride.propertyPath.slice();

            if (propertyPath.length > 0) {
              var targetPropName = propertyPath.pop();

              if (!targetPropName) {
                continue;
              }

              for (var _i5 = 0; _i5 < propertyPath.length; _i5++) {
                var propName = propertyPath[_i5];
                targetPropOwner = targetPropOwner[propName];

                if (!targetPropOwner) {
                  break;
                }
              }

              if (!targetPropOwner) {
                continue;
              }

              if (Array.isArray(targetPropOwner)) {
                if (targetPropName === 'length') {
                  targetPropOwner[targetPropName] = propOverride.value;
                } else {
                  var index = Number.parseInt(targetPropName);

                  if (Number.isInteger(index) && index < targetPropOwner.length) {
                    targetPropOwner[targetPropName] = propOverride.value;
                  }
                }
              } else if (targetPropOwner[targetPropName] instanceof ValueType) {
                targetPropOwner[targetPropName].set(propOverride.value);
              } else {
                targetPropOwner[targetPropName] = propOverride.value;
              }
            }
          }
        }
      }
      function applyTargetOverrides(node) {
        var _node$_prefab2;

        var targetOverrides = (_node$_prefab2 = node._prefab) === null || _node$_prefab2 === void 0 ? void 0 : _node$_prefab2.targetOverrides;

        if (targetOverrides) {
          for (var i = 0; i < targetOverrides.length; i++) {
            var _targetOverride$targe, _targetOverride$targe2;

            var targetOverride = targetOverrides[i];
            var source = targetOverride.source;
            var sourceInfo = targetOverride.sourceInfo;

            if (sourceInfo) {
              var _targetOverride$sourc, _targetOverride$sourc2;

              var sourceInstance = (_targetOverride$sourc = targetOverride.source) === null || _targetOverride$sourc === void 0 ? void 0 : (_targetOverride$sourc2 = _targetOverride$sourc._prefab) === null || _targetOverride$sourc2 === void 0 ? void 0 : _targetOverride$sourc2.instance;

              if (sourceInstance && sourceInstance.targetMap) {
                source = getTarget(sourceInfo.localID, sourceInstance.targetMap);
              }
            }

            if (!source) {
              continue;
            }

            var target = null;
            var targetInfo = targetOverride.targetInfo;

            if (!targetInfo) {
              continue;
            }

            var targetInstance = (_targetOverride$targe = targetOverride.target) === null || _targetOverride$targe === void 0 ? void 0 : (_targetOverride$targe2 = _targetOverride$targe._prefab) === null || _targetOverride$targe2 === void 0 ? void 0 : _targetOverride$targe2.instance;

            if (!targetInstance || !targetInstance.targetMap) {
              continue;
            }

            target = getTarget(targetInfo.localID, targetInstance.targetMap);

            if (!target) {
              continue;
            }

            var propertyPath = targetOverride.propertyPath.slice();
            var targetPropOwner = source;

            if (propertyPath.length > 0) {
              var targetPropName = propertyPath.pop();

              if (!targetPropName) {
                return;
              }

              for (var _i6 = 0; _i6 < propertyPath.length; _i6++) {
                var propName = propertyPath[_i6];
                targetPropOwner = targetPropOwner[propName];

                if (!targetPropOwner) {
                  break;
                }
              }

              if (!targetPropOwner) {
                continue;
              }

              targetPropOwner[targetPropName] = target;
            }
          }
        }
      }
      function expandPrefabInstanceNode(node, recursively) {
        if (recursively === void 0) {
          recursively = false;
        }

        var prefabInfo = node._prefab;
        var prefabInstance = prefabInfo === null || prefabInfo === void 0 ? void 0 : prefabInfo.instance;

        if (prefabInstance) {
          createNodeWithPrefab(node);
          var targetMap = {};
          prefabInstance.targetMap = targetMap;
          generateTargetMap(node, targetMap, true);
          applyMountedChildren(node, prefabInstance.mountedChildren, targetMap);
          applyRemovedComponents(node, prefabInstance.removedComponents, targetMap);
          applyMountedComponents(node, prefabInstance.mountedComponents, targetMap);
          applyPropertyOverrides(node, prefabInstance.propertyOverrides, targetMap);
        }

        if (recursively) {
          if (node && node.children) {
            node.children.forEach(function (child) {
              expandPrefabInstanceNode(child, true);
            });
          }
        }
      }
      function expandNestedPrefabInstanceNode(node) {
        var prefabInfo = node._prefab;

        if (prefabInfo && prefabInfo.nestedPrefabInstanceRoots) {
          prefabInfo.nestedPrefabInstanceRoots.forEach(function (instanceNode) {
            expandPrefabInstanceNode(instanceNode);
          });
        }
      }

      var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        TargetInfo: TargetInfo,
        TargetOverrideInfo: TargetOverrideInfo,
        CompPrefabInfo: CompPrefabInfo,
        PropertyOverrideInfo: PropertyOverrideInfo,
        MountedChildrenInfo: MountedChildrenInfo,
        MountedComponentsInfo: MountedComponentsInfo,
        PrefabInstance: PrefabInstance,
        PrefabInfo: PrefabInfo,
        createNodeWithPrefab: createNodeWithPrefab,
        generateTargetMap: generateTargetMap,
        getTarget: getTarget,
        applyMountedChildren: applyMountedChildren,
        applyMountedComponents: applyMountedComponents,
        applyRemovedComponents: applyRemovedComponents,
        applyPropertyOverrides: applyPropertyOverrides,
        applyTargetOverrides: applyTargetOverrides,
        expandPrefabInstanceNode: expandPrefabInstanceNode,
        expandNestedPrefabInstanceNode: expandNestedPrefabInstanceNode
      });

      var _dec$q, _class$q, _class2$n, _descriptor$i, _descriptor2$e, _descriptor3$c, _class3$a, _temp$o;
      var OptimizationPolicy = Enum({
        AUTO: 0,
        SINGLE_INSTANCE: 1,
        MULTI_INSTANCE: 2
      });
      var Prefab = exports('Prefab', (_dec$q = ccclass('cc.Prefab'), _dec$q(_class$q = (_class2$n = (_temp$o = _class3$a = function (_Asset) {
        _inheritsLoose(Prefab, _Asset);

        function Prefab() {
          var _this;

          _this = _Asset.call(this) || this;

          _initializerDefineProperty(_this, "data", _descriptor$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "optimizationPolicy", _descriptor2$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "persistent", _descriptor3$c, _assertThisInitialized(_this));

          _this._createFunction = void 0;
          _this._instantiatedTimes = void 0;
          _this._createFunction = null;
          _this._instantiatedTimes = 0;
          return _this;
        }

        var _proto = Prefab.prototype;

        _proto.createNode = function createNode(cb) {
          var node = legacyCC.instantiate(this);
          node.name = this.name;
          cb(null, node);
        };

        _proto.compileCreateFunction = function compileCreateFunction() {
          this._createFunction = compile(this.data);
        };

        _proto._doInstantiate = function _doInstantiate(rootToRedirect) {
          if (!this.data._prefab) {
            warnID(3700);
          }

          if (!this._createFunction) {
            this.compileCreateFunction();
          }

          return this._createFunction(rootToRedirect);
        };

        _proto._instantiate = function _instantiate() {
          var node;
          var useJit = false;

          {
            if (this.optimizationPolicy === OptimizationPolicy.SINGLE_INSTANCE) {
              useJit = false;
            } else if (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE) {
              useJit = true;
            } else {
              useJit = this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold;
            }
          }

          if (useJit) {
            node = this._doInstantiate();

            this.data._instantiate(node);
          } else {
            node = this.data._instantiate();
          }

          ++this._instantiatedTimes;
          return node;
        };

        _proto.initDefault = function initDefault(uuid) {
          _Asset.prototype.initDefault.call(this, uuid);

          this.data = new Node$1();
          this.data.name = '(Missing Node)';
          var prefabInfo = new legacyCC._PrefabInfo();
          prefabInfo.asset = this;
          prefabInfo.root = this.data;
          this.data._prefab = prefabInfo;
        };

        _proto.validate = function validate() {
          return !!this.data;
        };

        _proto.onLoaded = function onLoaded() {
          var rootNode = this.data;
          expandNestedPrefabInstanceNode(rootNode);
          applyTargetOverrides(rootNode);
        };

        return Prefab;
      }(Asset), _class3$a.OptimizationPolicy = OptimizationPolicy, _class3$a.OptimizationPolicyThreshold = 3, _temp$o), (_descriptor$i = _applyDecoratedDescriptor(_class2$n.prototype, "data", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$e = _applyDecoratedDescriptor(_class2$n.prototype, "optimizationPolicy", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return OptimizationPolicy.AUTO;
        }
      }), _descriptor3$c = _applyDecoratedDescriptor(_class2$n.prototype, "persistent", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2$n)) || _class$q));
      js.value(Prefab, '_utils', utils);
      legacyCC.Prefab = Prefab;

      {
        obsolete(legacyCC, 'cc._Prefab', 'Prefab');
      }

      var _dec$r, _dec2$d, _dec3$8, _class$r, _class2$o, _descriptor$j, _temp$p;
      var PrefabLink = exports('PrefabLink', (_dec$r = ccclass('cc.PrefabLink'), _dec2$d = type(Prefab), _dec3$8 = visible(), _dec$r(_class$r = (_class2$o = (_temp$p = function (_Component) {
        _inheritsLoose(PrefabLink, _Component);

        function PrefabLink() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "prefab", _descriptor$j, _assertThisInitialized(_this));

          return _this;
        }

        return PrefabLink;
      }(Component), _temp$p), (_descriptor$j = _applyDecoratedDescriptor(_class2$o.prototype, "prefab", [_dec2$d, serializable, _dec3$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$o)) || _class$r));

      var _vec3 = new Vec3();

      function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
        if (!out) {
          out = new Vec3();
        }

        mainCamera.convertToUINode(wpos, uiNode, out);
        var pos = uiNode.position;
        out.add(pos);
        return out;
      }
      function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
        if (!out) {
          out = new Vec3();
        }

        mainCamera.worldToScreen(wpos, out);
        out.x /= legacyCC.view.getScaleX();
        out.y /= legacyCC.view.getScaleY();
        return out;
      }
      var convertUtils = exports('convertUtils', {
        WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
        WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI
      });
      legacyCC.pipelineUtils = convertUtils;
      replaceProperty(legacyCC.pipelineUtils, 'cc.pipelineUtils', [{
        name: 'WorldNode3DToLocalNodeUI',
        newName: 'convertToUINode',
        targetName: 'cc.Camera.prototype',
        customFunction: function customFunction() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var camera = args[0];
          var out = args[3] || _vec3;
          camera.convertToUINode(args[1], args[2], out);
          out.add(args[2].position);
          return args[3] || out.clone();
        }
      }]);

      removeProperty(TextureBase.prototype, 'TextureBase.prototype', [{
        name: 'hasPremultipliedAlpha'
      }, {
        name: 'setPremultiplyAlpha'
      }, {
        name: 'setFlipY'
      }]);
      replaceProperty(RenderTexture.prototype, 'RenderTexture.prototype', [{
        name: 'getGFXWindow',
        customFunction: function customFunction() {
          return this._window;
        }
      }]);

      var _dec$s, _class$s, _class2$p, _temp$q;
      var BufferAsset = exports('BufferAsset', (_dec$s = ccclass('cc.BufferAsset'), _dec$s(_class$s = (_class2$p = (_temp$q = function (_Asset) {
        _inheritsLoose(BufferAsset, _Asset);

        function BufferAsset() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;
          _this._buffer = null;
          return _this;
        }

        var _proto = BufferAsset.prototype;

        _proto.buffer = function buffer() {
          return this._buffer;
        };

        _proto.validate = function validate() {
          return !!this.buffer;
        };

        _createClass(BufferAsset, [{
          key: "_nativeAsset",
          get: function get() {
            return this._buffer;
          },
          set: function set(bin) {
            if (bin instanceof ArrayBuffer) {
              this._buffer = bin;
            } else {
              this._buffer = bin.buffer;
            }
          }
        }]);

        return BufferAsset;
      }(Asset), _temp$q), (_applyDecoratedDescriptor(_class2$p.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$p.prototype, "_nativeAsset"), _class2$p.prototype)), _class2$p)) || _class$s));
      legacyCC.BufferAsset = BufferAsset;

      var _typeMap2;

      var _typeMap = (_typeMap2 = {}, _typeMap2[FormatType.UNORM] = 'Uint', _typeMap2[FormatType.SNORM] = 'Int', _typeMap2[FormatType.UINT] = 'Uint', _typeMap2[FormatType.INT] = 'Int', _typeMap2[FormatType.UFLOAT] = 'Float', _typeMap2[FormatType.FLOAT] = 'Float', _typeMap2["default"] = 'Uint', _typeMap2);

      function _getDataViewType(info) {
        var type = _typeMap[info.type] || _typeMap["default"];
        var bytes = info.size / info.count * 8;
        return "" + type + bytes;
      }
      function mapBuffer(target, callback, format, offset, length, stride, out) {
        if (format === void 0) {
          format = Format.R32F;
        }

        if (offset === void 0) {
          offset = 0;
        }

        if (length === void 0) {
          length = target.byteLength - offset;
        }

        if (stride === void 0) {
          stride = 0;
        }

        if (!out) {
          out = new DataView(target.buffer.slice(target.byteOffset, target.byteOffset + target.byteLength));
        }

        var info = FormatInfos[format];

        if (!stride) {
          stride = info.size;
        }

        var writer = "set" + _getDataViewType(info);

        var reader = "get" + _getDataViewType(info);

        var componentBytesLength = info.size / info.count;
        var nSeg = Math.floor(length / stride);
        var isLittleEndian = sys.isLittleEndian;

        for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
          var x = offset + stride * iSeg;

          for (var iComponent = 0; iComponent < info.count; ++iComponent) {
            var y = x + componentBytesLength * iComponent;

            var _cur = target[reader](y, isLittleEndian);

            out[writer](y, callback(_cur, iComponent, target), isLittleEndian);
          }
        }

        return out;
      }

      var RenderingSubMesh = exports('RenderingSubMesh', function () {
        var _proto = RenderingSubMesh.prototype;

        _proto._init = function _init() {};

        function RenderingSubMesh(vertexBuffers, attributes, primitiveMode, indexBuffer, indirectBuffer, isOwnerOfIndexBuffer) {
          if (indexBuffer === void 0) {
            indexBuffer = null;
          }

          if (indirectBuffer === void 0) {
            indirectBuffer = null;
          }

          if (isOwnerOfIndexBuffer === void 0) {
            isOwnerOfIndexBuffer = true;
          }

          this.mesh = void 0;
          this.subMeshIdx = void 0;
          this._flatBuffers = [];
          this._jointMappedBuffers = void 0;
          this._jointMappedBufferIndices = void 0;
          this._vertexIdChannel = void 0;
          this._geometricInfo = void 0;
          this._vertexBuffers = void 0;
          this._attributes = void 0;
          this._indexBuffer = null;
          this._indirectBuffer = null;
          this._primitiveMode = void 0;
          this._iaInfo = void 0;
          this._isOwnerOfIndexBuffer = true;
          this._attributes = attributes;
          this._vertexBuffers = vertexBuffers;
          this._indexBuffer = indexBuffer;
          this._indirectBuffer = indirectBuffer;
          this._primitiveMode = primitiveMode;
          this._iaInfo = new InputAssemblerInfo(attributes, vertexBuffers, indexBuffer, indirectBuffer);
          this._isOwnerOfIndexBuffer = isOwnerOfIndexBuffer;

          this._init();
        }

        _proto.genFlatBuffers = function genFlatBuffers() {
          if (this._flatBuffers.length || !this.mesh || this.subMeshIdx === undefined) {
            return;
          }

          var mesh = this.mesh;
          var idxCount = 0;
          var prim = mesh.struct.primitives[this.subMeshIdx];

          if (prim.indexView) {
            idxCount = prim.indexView.count;
          }

          for (var i = 0; i < prim.vertexBundelIndices.length; i++) {
            var bundleIdx = prim.vertexBundelIndices[i];
            var vertexBundle = mesh.struct.vertexBundles[bundleIdx];
            var vbCount = prim.indexView ? prim.indexView.count : vertexBundle.view.count;
            var vbStride = vertexBundle.view.stride;
            var vbSize = vbStride * vbCount;
            var view = new Uint8Array(mesh.data.buffer, vertexBundle.view.offset, vertexBundle.view.length);
            var sharedView = new Uint8Array(prim.indexView ? vbSize : vertexBundle.view.length);

            if (!prim.indexView) {
              sharedView.set(mesh.data.subarray(vertexBundle.view.offset, vertexBundle.view.offset + vertexBundle.view.length));

              this._flatBuffers.push({
                stride: vbStride,
                count: vbCount,
                buffer: sharedView
              });

              continue;
            }

            var ibView = mesh.readIndices(this.subMeshIdx);

            for (var n = 0; n < idxCount; ++n) {
              var idx = ibView[n];
              var offset = n * vbStride;
              var srcOffset = idx * vbStride;

              for (var m = 0; m < vbStride; ++m) {
                sharedView[offset + m] = view[srcOffset + m];
              }
            }

            this._flatBuffers.push({
              stride: vbStride,
              count: vbCount,
              buffer: sharedView
            });
          }
        };

        _proto.destroy = function destroy() {
          for (var i = 0; i < this.vertexBuffers.length; i++) {
            this.vertexBuffers[i].destroy();
          }

          this.vertexBuffers.length = 0;

          if (this._indexBuffer) {
            if (this._isOwnerOfIndexBuffer) {
              this._indexBuffer.destroy();
            }

            this._indexBuffer = null;
          }

          if (this._jointMappedBuffers && this._jointMappedBufferIndices) {
            for (var _i = 0; _i < this._jointMappedBufferIndices.length; _i++) {
              this._jointMappedBuffers[this._jointMappedBufferIndices[_i]].destroy();
            }

            this._jointMappedBuffers = undefined;
            this._jointMappedBufferIndices = undefined;
          }

          if (this._indirectBuffer) {
            this._indirectBuffer.destroy();

            this._indirectBuffer = null;
          }
        };

        _proto.enableVertexIdChannel = function enableVertexIdChannel(device) {
          if (this._vertexIdChannel) {
            return;
          }

          var streamIndex = this.vertexBuffers.length;
          var attributeIndex = this.attributes.length;

          var vertexIdBuffer = this._allocVertexIdBuffer(device);

          this._vertexBuffers.push(vertexIdBuffer);

          this._attributes.push(new Attribute('a_vertexId', Format.R32F, false, streamIndex));

          this._iaInfo.attributes = this._attributes;
          this._iaInfo.vertexBuffers = this._vertexBuffers;
          this._vertexIdChannel = {
            stream: streamIndex,
            index: attributeIndex
          };
        };

        _proto._allocVertexIdBuffer = function _allocVertexIdBuffer(device) {
          var vertexCount = this.vertexBuffers.length === 0 || this.vertexBuffers[0].stride === 0 ? 0 : this.vertexBuffers[0].size / this.vertexBuffers[0].stride;
          var vertexIds = new Float32Array(vertexCount);

          for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
            vertexIds[iVertex] = iVertex + 0.5;
          }

          var vertexIdBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vertexIds.byteLength, vertexIds.BYTES_PER_ELEMENT));
          vertexIdBuffer.update(vertexIds);
          return vertexIdBuffer;
        };

        _createClass(RenderingSubMesh, [{
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "vertexBuffers",
          get: function get() {
            return this._vertexBuffers;
          }
        }, {
          key: "indexBuffer",
          get: function get() {
            return this._indexBuffer;
          }
        }, {
          key: "indirectBuffer",
          get: function get() {
            return this._indirectBuffer;
          }
        }, {
          key: "primitiveMode",
          get: function get() {
            return this._primitiveMode;
          }
        }, {
          key: "geometricInfo",
          get: function get() {
            if (this._geometricInfo) {
              return this._geometricInfo;
            }

            if (this.mesh === undefined) {
              return {
                positions: new Float32Array(),
                indices: new Uint8Array(),
                boundingBox: {
                  min: Vec3.ZERO,
                  max: Vec3.ZERO
                }
              };
            }

            if (this.subMeshIdx === undefined) {
              return {
                positions: new Float32Array(),
                indices: new Uint8Array(),
                boundingBox: {
                  min: Vec3.ZERO,
                  max: Vec3.ZERO
                }
              };
            }

            var mesh = this.mesh;
            var index = this.subMeshIdx;
            var positions = mesh.readAttribute(index, AttributeName.ATTR_POSITION);
            var indices = mesh.readIndices(index);
            var max = new Vec3();
            var min = new Vec3();
            var pAttri = this.attributes.find(function (element) {
              return element.name === AttributeName.ATTR_POSITION;
            });

            if (pAttri) {
              var conut = FormatInfos[pAttri.format].count;

              if (conut === 2) {
                max.set(positions[0], positions[1], 0);
                min.set(positions[0], positions[1], 0);
              } else {
                max.set(positions[0], positions[1], positions[2]);
                min.set(positions[0], positions[1], positions[2]);
              }

              for (var i = 0; i < positions.length; i += conut) {
                if (conut === 2) {
                  max.x = positions[i] > max.x ? positions[i] : max.x;
                  max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y;
                  min.x = positions[i] < min.x ? positions[i] : min.x;
                  min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y;
                } else {
                  max.x = positions[i] > max.x ? positions[i] : max.x;
                  max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y;
                  max.z = positions[i + 2] > max.z ? positions[i + 2] : max.z;
                  min.x = positions[i] < min.x ? positions[i] : min.x;
                  min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y;
                  min.z = positions[i + 2] < min.z ? positions[i + 2] : min.z;
                }
              }
            }

            this._geometricInfo = {
              positions: positions,
              indices: indices,
              boundingBox: {
                max: max,
                min: min
              }
            };
            return this._geometricInfo;
          }
        }, {
          key: "flatBuffers",
          get: function get() {
            return this._flatBuffers;
          }
        }, {
          key: "jointMappedBuffers",
          get: function get() {
            var _this = this;

            if (this._jointMappedBuffers) {
              return this._jointMappedBuffers;
            }

            var buffers = this._jointMappedBuffers = [];
            var indices = this._jointMappedBufferIndices = [];

            if (!this.mesh || this.subMeshIdx === undefined) {
              return this._jointMappedBuffers = this.vertexBuffers;
            }

            var struct = this.mesh.struct;
            var prim = struct.primitives[this.subMeshIdx];

            if (!struct.jointMaps || prim.jointMapIndex === undefined || !struct.jointMaps[prim.jointMapIndex]) {
              return this._jointMappedBuffers = this.vertexBuffers;
            }

            var jointFormat;
            var jointOffset;
            var device = legacyCC.director.root.device;

            for (var i = 0; i < prim.vertexBundelIndices.length; i++) {
              var bundle = struct.vertexBundles[prim.vertexBundelIndices[i]];
              jointOffset = 0;
              jointFormat = Format.UNKNOWN;

              for (var j = 0; j < bundle.attributes.length; j++) {
                var attr = bundle.attributes[j];

                if (attr.name === AttributeName.ATTR_JOINTS) {
                  jointFormat = attr.format;
                  break;
                }

                jointOffset += FormatInfos[attr.format].size;
              }

              if (jointFormat) {
                (function () {
                  var data = new Uint8Array(_this.mesh.data.buffer, bundle.view.offset, bundle.view.length);
                  var dataView = new DataView(data.slice().buffer);
                  var idxMap = struct.jointMaps[prim.jointMapIndex];
                  mapBuffer(dataView, function (cur) {
                    return idxMap.indexOf(cur);
                  }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                  var buffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, bundle.view.length, bundle.view.stride));
                  buffer.update(dataView.buffer);
                  buffers.push(buffer);
                  indices.push(i);
                })();
              } else {
                buffers.push(this.vertexBuffers[prim.vertexBundelIndices[i]]);
              }
            }

            if (this._vertexIdChannel) {
              buffers.push(this._allocVertexIdBuffer(device));
            }

            return buffers;
          }
        }, {
          key: "iaInfo",
          get: function get() {
            return this._iaInfo;
          }
        }]);

        return RenderingSubMesh;
      }());

      var SystemEventType;

      (function (SystemEventType) {
        SystemEventType["TOUCH_START"] = "touch-start";
        SystemEventType["TOUCH_MOVE"] = "touch-move";
        SystemEventType["TOUCH_END"] = "touch-end";
        SystemEventType["TOUCH_CANCEL"] = "touch-cancel";
        SystemEventType["MOUSE_DOWN"] = "mouse-down";
        SystemEventType["MOUSE_MOVE"] = "mouse-move";
        SystemEventType["MOUSE_UP"] = "mouse-up";
        SystemEventType["MOUSE_WHEEL"] = "mouse-wheel";
        SystemEventType["MOUSE_ENTER"] = "mouse-enter";
        SystemEventType["MOUSE_LEAVE"] = "mouse-leave";
        SystemEventType["KEY_DOWN"] = "keydown";
        SystemEventType["KEY_UP"] = "keyup";
        SystemEventType["DEVICEMOTION"] = "devicemotion";
        SystemEventType["TRANSFORM_CHANGED"] = "transform-changed";
        SystemEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
        SystemEventType["SIZE_CHANGED"] = "size-changed";
        SystemEventType["ANCHOR_CHANGED"] = "anchor-changed";
        SystemEventType["COLOR_CHANGED"] = "color-changed";
        SystemEventType["CHILD_ADDED"] = "child-added";
        SystemEventType["CHILD_REMOVED"] = "child-removed";
        SystemEventType["PARENT_CHANGED"] = "parent-changed";
        SystemEventType["NODE_DESTROYED"] = "node-destroyed";
        SystemEventType["LAYER_CHANGED"] = "layer-changed";
        SystemEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
      })(SystemEventType || (SystemEventType = exports('SystemEventType', {})));

      var InputEventType;

      (function (InputEventType) {
        InputEventType["TOUCH_START"] = "touch-start";
        InputEventType["TOUCH_MOVE"] = "touch-move";
        InputEventType["TOUCH_END"] = "touch-end";
        InputEventType["TOUCH_CANCEL"] = "touch-cancel";
        InputEventType["MOUSE_DOWN"] = "mouse-down";
        InputEventType["MOUSE_MOVE"] = "mouse-move";
        InputEventType["MOUSE_UP"] = "mouse-up";
        InputEventType["MOUSE_WHEEL"] = "mouse-wheel";
        InputEventType["KEY_DOWN"] = "keydown";
        InputEventType["KEY_PRESSING"] = "key-pressing";
        InputEventType["KEY_UP"] = "keyup";
        InputEventType["DEVICEMOTION"] = "devicemotion";
      })(InputEventType || (InputEventType = {}));

      legacyCC.SystemEventType = SystemEventType;

      var _cachedArray = new Array(16);

      var _currentHovered = null;
      var pos = new Vec2();
      var _touchEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_MOVE, NodeEventType.TOUCH_END, NodeEventType.TOUCH_CANCEL];
      var _mouseEvents = [NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_WHEEL];
      var DispatcherEventType;

      (function (DispatcherEventType) {
        DispatcherEventType[DispatcherEventType["ADD_POINTER_EVENT_PROCESSOR"] = 0] = "ADD_POINTER_EVENT_PROCESSOR";
        DispatcherEventType[DispatcherEventType["REMOVE_POINTER_EVENT_PROCESSOR"] = 1] = "REMOVE_POINTER_EVENT_PROCESSOR";
        DispatcherEventType[DispatcherEventType["MARK_LIST_DIRTY"] = 2] = "MARK_LIST_DIRTY";
      })(DispatcherEventType || (DispatcherEventType = {}));

      var NodeEventProcessor = function () {
        function NodeEventProcessor(node) {
          this.claimedTouchIdList = [];
          this.maskList = null;
          this.cachedCameraPriority = 0;
          this.previousMouseIn = false;
          this.bubblingTarget = null;
          this.capturingTarget = null;
          this.shouldHandleEventMouse = false;
          this.shouldHandleEventTouch = false;
          this._isEnabled = false;
          this._node = void 0;
          this._node = node;
        }

        var _proto = NodeEventProcessor.prototype;

        _proto.setEnabled = function setEnabled(value, recursive) {
          if (recursive === void 0) {
            recursive = false;
          }

          if (this._isEnabled === value) {
            return;
          }

          this._isEnabled = value;
          var node = this.node;
          var children = node.children;

          if (value) {
            this._attachMask();
          }

          NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.MARK_LIST_DIRTY);

          if (recursive && children.length > 0) {
            for (var i = 0; i < children.length; ++i) {
              var child = children[i];

              child._eventProcessor.setEnabled(value, true);
            }
          }
        };

        _proto.reattach = function reattach() {
          var _this = this;

          var currentMaskList;
          this.node.walk(function (node) {
            if (!currentMaskList) {
              currentMaskList = _this._searchComponentsInParent(NodeEventProcessor._maskComp);
            }

            node.eventProcessor.maskList = currentMaskList;
          });
        };

        _proto.destroy = function destroy() {
          if (_currentHovered === this._node) {
            _currentHovered = null;
          }

          if (this.capturingTarget) this.capturingTarget.clear();
          if (this.bubblingTarget) this.bubblingTarget.clear();
          NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
        };

        _proto.on = function on(type, callback, target, useCapture) {
          this._tryEmittingAddEvent(type);

          useCapture = !!useCapture;
          var invoker;

          if (useCapture) {
            var _this$capturingTarget;

            invoker = (_this$capturingTarget = this.capturingTarget) !== null && _this$capturingTarget !== void 0 ? _this$capturingTarget : this.capturingTarget = this._newCallbacksInvoker();
          } else {
            var _this$bubblingTarget;

            invoker = (_this$bubblingTarget = this.bubblingTarget) !== null && _this$bubblingTarget !== void 0 ? _this$bubblingTarget : this.bubblingTarget = this._newCallbacksInvoker();
          }

          invoker.on(type, callback, target);
          return callback;
        };

        _proto.once = function once(type, callback, target, useCapture) {
          this._tryEmittingAddEvent(type);

          useCapture = !!useCapture;
          var invoker;

          if (useCapture) {
            var _this$capturingTarget2;

            invoker = (_this$capturingTarget2 = this.capturingTarget) !== null && _this$capturingTarget2 !== void 0 ? _this$capturingTarget2 : this.capturingTarget = this._newCallbacksInvoker();
          } else {
            var _this$bubblingTarget2;

            invoker = (_this$bubblingTarget2 = this.bubblingTarget) !== null && _this$bubblingTarget2 !== void 0 ? _this$bubblingTarget2 : this.bubblingTarget = this._newCallbacksInvoker();
          }

          invoker.on(type, callback, target, true);
          return callback;
        };

        _proto.off = function off(type, callback, target, useCapture) {
          var _invoker;

          useCapture = !!useCapture;
          var invoker;

          if (useCapture) {
            invoker = this.capturingTarget;
          } else {
            invoker = this.bubblingTarget;
          }

          (_invoker = invoker) === null || _invoker === void 0 ? void 0 : _invoker.off(type, callback, target);
        };

        _proto.targetOff = function targetOff(target) {
          var _this$capturingTarget3, _this$bubblingTarget3;

          (_this$capturingTarget3 = this.capturingTarget) === null || _this$capturingTarget3 === void 0 ? void 0 : _this$capturingTarget3.removeAll(target);
          (_this$bubblingTarget3 = this.bubblingTarget) === null || _this$bubblingTarget3 === void 0 ? void 0 : _this$bubblingTarget3.removeAll(target);

          if (this.shouldHandleEventTouch && !this._hasTouchListeners()) {
            this.shouldHandleEventTouch = false;
          }

          if (this.shouldHandleEventMouse && !this._hasMouseListeners()) {
            this.shouldHandleEventMouse = false;
          }

          if (!this._hasPointerListeners()) {
            NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
          }
        };

        _proto.emit = function emit(type, arg0, arg1, arg2, arg3, arg4) {
          var _this$bubblingTarget4;

          (_this$bubblingTarget4 = this.bubblingTarget) === null || _this$bubblingTarget4 === void 0 ? void 0 : _this$bubblingTarget4.emit(type, arg0, arg1, arg2, arg3, arg4);
        };

        _proto.dispatchEvent = function dispatchEvent(event) {
          var owner = this.node;
          var target;
          var i = 0;
          event.target = owner;
          _cachedArray.length = 0;
          this.getCapturingTargets(event.type, _cachedArray);
          event.eventPhase = 1;

          for (i = _cachedArray.length - 1; i >= 0; --i) {
            target = _cachedArray[i];

            if (target.eventProcessor.capturingTarget) {
              event.currentTarget = target;
              target.eventProcessor.capturingTarget.emit(event.type, event, _cachedArray);

              if (event.propagationStopped) {
                _cachedArray.length = 0;
                return;
              }
            }
          }

          _cachedArray.length = 0;
          event.eventPhase = 2;
          event.currentTarget = owner;

          if (this.capturingTarget) {
            this.capturingTarget.emit(event.type, event);
          }

          if (!event.propagationImmediateStopped && this.bubblingTarget) {
            this.bubblingTarget.emit(event.type, event);
          }

          if (!event.propagationStopped && event.bubbles) {
            this.getBubblingTargets(event.type, _cachedArray);
            event.eventPhase = 3;

            for (i = 0; i < _cachedArray.length; ++i) {
              target = _cachedArray[i];

              if (target.eventProcessor.bubblingTarget) {
                event.currentTarget = target;
                target.eventProcessor.bubblingTarget.emit(event.type, event);

                if (event.propagationStopped) {
                  _cachedArray.length = 0;
                  return;
                }
              }
            }
          }

          _cachedArray.length = 0;
        };

        _proto.hasEventListener = function hasEventListener(type, callback, target) {
          var has = false;

          if (this.bubblingTarget) {
            has = this.bubblingTarget.hasEventListener(type, callback, target);
          }

          if (!has && this.capturingTarget) {
            has = this.capturingTarget.hasEventListener(type, callback, target);
          }

          return has;
        };

        _proto.getCapturingTargets = function getCapturingTargets(type, targets) {
          var parent = this._node.parent;

          while (parent) {
            var _parent$eventProcesso;

            if ((_parent$eventProcesso = parent.eventProcessor.capturingTarget) === null || _parent$eventProcesso === void 0 ? void 0 : _parent$eventProcesso.hasEventListener(type)) {
              targets.push(parent);
            }

            parent = parent.parent;
          }
        };

        _proto.getBubblingTargets = function getBubblingTargets(type, targets) {
          var parent = this._node.parent;

          while (parent) {
            var _parent$eventProcesso2;

            if ((_parent$eventProcesso2 = parent.eventProcessor.bubblingTarget) === null || _parent$eventProcesso2 === void 0 ? void 0 : _parent$eventProcesso2.hasEventListener(type)) {
              targets.push(parent);
            }

            parent = parent.parent;
          }
        };

        _proto._searchComponentsInParent = function _searchComponentsInParent(ctor) {
          var node = this.node;

          if (ctor) {
            var index = 0;
            var list = [];

            for (var curr = node; curr && Node$1.isNode(curr); curr = curr.parent, ++index) {
              var comp = curr.getComponent(ctor);

              if (comp) {
                var next = {
                  index: index,
                  comp: comp
                };

                if (list) {
                  list.push(next);
                } else {
                  list = [next];
                }
              }
            }

            return list.length > 0 ? list : null;
          }

          return null;
        };

        _proto._attachMask = function _attachMask() {
          this.maskList = this._searchComponentsInParent(NodeEventProcessor._maskComp);
        };

        _proto._isTouchEvent = function _isTouchEvent(type) {
          var index = _touchEvents.indexOf(type);

          return index !== -1;
        };

        _proto._isMouseEvent = function _isMouseEvent(type) {
          var index = _mouseEvents.indexOf(type);

          return index !== -1;
        };

        _proto._hasTouchListeners = function _hasTouchListeners() {
          for (var i = 0; i < _touchEvents.length; ++i) {
            var eventType = _touchEvents[i];

            if (this.hasEventListener(eventType)) {
              return true;
            }
          }

          return false;
        };

        _proto._hasMouseListeners = function _hasMouseListeners() {
          for (var i = 0; i < _mouseEvents.length; ++i) {
            var eventType = _mouseEvents[i];

            if (this.hasEventListener(eventType)) {
              return true;
            }
          }

          return false;
        };

        _proto._hasPointerListeners = function _hasPointerListeners() {
          var has = this._hasTouchListeners();

          if (has) {
            return true;
          }

          return this._hasMouseListeners();
        };

        _proto._tryEmittingAddEvent = function _tryEmittingAddEvent(typeToAdd) {
          var isTouchEvent = this._isTouchEvent(typeToAdd);

          var isMouseEvent = this._isMouseEvent(typeToAdd);

          if (isTouchEvent) {
            this.shouldHandleEventTouch = true;
          } else if (isMouseEvent) {
            this.shouldHandleEventMouse = true;
          }

          if ((isTouchEvent || isMouseEvent) && !this._hasPointerListeners()) {
            NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this);
          }
        };

        _proto._newCallbacksInvoker = function _newCallbacksInvoker() {
          var _this2 = this;

          var callbacksInvoker = new CallbacksInvoker();

          callbacksInvoker._registerOffCallback(function () {
            if (_this2.shouldHandleEventTouch && !_this2._hasTouchListeners()) {
              _this2.shouldHandleEventTouch = false;
            }

            if (_this2.shouldHandleEventMouse && !_this2._hasMouseListeners()) {
              _this2.shouldHandleEventMouse = false;
            }

            if (!_this2._hasPointerListeners()) {
              NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, _this2);
            }
          });

          return callbacksInvoker;
        };

        _proto._handleEventMouse = function _handleEventMouse(eventMouse) {
          switch (eventMouse.type) {
            case InputEventType.MOUSE_DOWN:
              return this._handleMouseDown(eventMouse);

            case InputEventType.MOUSE_MOVE:
              return this._handleMouseMove(eventMouse);

            case InputEventType.MOUSE_UP:
              return this._handleMouseUp(eventMouse);

            case InputEventType.MOUSE_WHEEL:
              return this._handleMouseWheel(eventMouse);

            default:
              return false;
          }
        };

        _proto._handleMouseDown = function _handleMouseDown(event) {
          var node = this._node;

          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }

          event.getLocation(pos);

          if (node._uiProps.uiTransformComp.hitTest(pos)) {
            event.type = NodeEventType.MOUSE_DOWN;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          }

          return false;
        };

        _proto._handleMouseMove = function _handleMouseMove(event) {
          var node = this._node;

          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }

          event.getLocation(pos);

          var hit = node._uiProps.uiTransformComp.hitTest(pos);

          if (hit) {
            if (!this.previousMouseIn) {
              if (_currentHovered && _currentHovered !== node) {
                event.type = NodeEventType.MOUSE_LEAVE;

                _currentHovered.dispatchEvent(event);

                _currentHovered.eventProcessor.previousMouseIn = false;
              }

              _currentHovered = node;
              event.type = NodeEventType.MOUSE_ENTER;
              node.dispatchEvent(event);
              this.previousMouseIn = true;
            }

            event.type = NodeEventType.MOUSE_MOVE;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          } else if (this.previousMouseIn) {
            event.type = NodeEventType.MOUSE_LEAVE;
            node.dispatchEvent(event);
            this.previousMouseIn = false;
            _currentHovered = null;
          }

          return false;
        };

        _proto._handleMouseUp = function _handleMouseUp(event) {
          var node = this._node;

          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }

          event.getLocation(pos);

          if (node._uiProps.uiTransformComp.hitTest(pos)) {
            event.type = NodeEventType.MOUSE_UP;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          }

          return false;
        };

        _proto._handleMouseWheel = function _handleMouseWheel(event) {
          var node = this._node;

          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }

          event.getLocation(pos);

          if (node._uiProps.uiTransformComp.hitTest(pos)) {
            event.type = NodeEventType.MOUSE_WHEEL;
            event.bubbles = true;
            node.dispatchEvent(event);
            event.propagationStopped = true;
            return true;
          }

          return false;
        };

        _proto._handleEventTouch = function _handleEventTouch(eventTouch) {
          switch (eventTouch.type) {
            case InputEventType.TOUCH_START:
              return this._handleTouchStart(eventTouch);

            case InputEventType.TOUCH_MOVE:
              return this._handleTouchMove(eventTouch);

            case InputEventType.TOUCH_END:
              return this._handleTouchEnd(eventTouch);

            case InputEventType.TOUCH_CANCEL:
              return this._handleTouchCancel(eventTouch);

            default:
              return false;
          }
        };

        _proto._handleTouchStart = function _handleTouchStart(event) {
          var node = this.node;

          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }

          event.getLocation(pos);

          if (node._uiProps.uiTransformComp.hitTest(pos)) {
            event.type = NodeEventType.TOUCH_START;
            event.bubbles = true;
            node.dispatchEvent(event);
            return true;
          }

          return false;
        };

        _proto._handleTouchMove = function _handleTouchMove(event) {
          var node = this.node;

          if (!node || !node._uiProps.uiTransformComp) {
            return false;
          }

          event.type = NodeEventType.TOUCH_MOVE;
          event.bubbles = true;
          node.dispatchEvent(event);
          return true;
        };

        _proto._handleTouchEnd = function _handleTouchEnd(event) {
          var node = this.node;

          if (!node || !node._uiProps.uiTransformComp) {
            return;
          }

          event.getLocation(pos);

          if (node._uiProps.uiTransformComp.hitTest(pos)) {
            event.type = NodeEventType.TOUCH_END;
          } else {
            event.type = NodeEventType.TOUCH_CANCEL;
          }

          event.bubbles = true;
          node.dispatchEvent(event);
        };

        _proto._handleTouchCancel = function _handleTouchCancel(event) {
          var node = this.node;

          if (!node || !node._uiProps.uiTransformComp) {
            return;
          }

          event.type = NodeEventType.TOUCH_CANCEL;
          event.bubbles = true;
          node.dispatchEvent(event);
        };

        _createClass(NodeEventProcessor, [{
          key: "isEnabled",
          get: function get() {
            return this._isEnabled;
          }
        }, {
          key: "node",
          get: function get() {
            return this._node;
          }
        }]);

        return NodeEventProcessor;
      }();
      NodeEventProcessor._maskComp = null;
      NodeEventProcessor.callbacksInvoker = new CallbacksInvoker();
      legacyCC.NodeEventProcessor = NodeEventProcessor;

      var _dec$t, _dec2$e, _dec3$9, _dec4$6, _dec5$3, _dec6$3, _dec7$2, _dec8$2, _dec9$2, _dec10$2, _class$t, _class2$q, _descriptor$k, _descriptor2$f, _descriptor3$d, _descriptor4$a, _descriptor5$7, _descriptor6$3, _temp$r, _dec11$2, _dec12$2, _dec13$2, _dec14$2, _dec15$2, _dec16$2, _dec17$2, _dec18$2, _dec19$2, _dec20$2, _dec21$2, _dec22$2, _dec23$2, _dec24$2, _dec25$2, _class4$3, _class5$3, _descriptor7$3, _descriptor8$3, _descriptor9$2, _descriptor10$2, _descriptor11$2, _descriptor12$2, _descriptor13$2, _temp2$2, _dec26$1, _dec27$1, _dec28$1, _dec29$1, _dec30$1, _dec31$1, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _dec56, _dec57, _dec58, _dec59, _dec60, _class7$2, _class8$2, _descriptor14$2, _descriptor15$2, _descriptor16$2, _descriptor17$2, _descriptor18$2, _descriptor19$2, _descriptor20$2, _descriptor21$2, _descriptor22$2, _descriptor23$2, _class9, _temp3$3, _dec61, _dec62, _dec63, _dec64, _dec65, _dec66, _dec67, _dec68, _dec69, _dec70, _dec71, _dec72, _dec73, _dec74, _dec75, _class10$2, _class11$2, _descriptor24$2, _descriptor25$2, _descriptor26$2, _descriptor27$1, _descriptor28$1, _descriptor29$1, _descriptor30$1, _temp4$2, _dec76, _dec77, _dec78, _dec79, _dec80, _dec81, _dec82, _dec83, _dec84, _class13$2, _class14$2, _descriptor31$1, _descriptor32$1, _descriptor33$1, _descriptor34$1, _temp5$2, _dec85, _dec86, _class16$2, _class17$2, _descriptor35$1, _descriptor36, _descriptor37, _descriptor38, _descriptor39, _temp6$2;

      var _up = new Vec3(0, 1, 0);

      var _v3$2 = new Vec3();

      var _v4$2 = new Vec4();

      var _col = new Color();

      var _qt$1 = new Quat();

      var normalizeHDRColor = function normalizeHDRColor(color) {
        var intensity = 1.0 / Math.max(Math.max(Math.max(color.x, color.y), color.z), 0.0001);

        if (intensity < 1.0) {
          color.x *= intensity;
          color.y *= intensity;
          color.z *= intensity;
        }
      };

      var AmbientInfo = exports('AmbientInfo', (_dec$t = ccclass('cc.AmbientInfo'), _dec2$e = visible(), _dec3$9 = tooltip(), _dec4$6 = type(CCFloat), _dec5$3 = tooltip(), _dec6$3 = visible(), _dec7$2 = tooltip(), _dec8$2 = formerlySerializedAs('_skyColor'), _dec9$2 = formerlySerializedAs('_skyIllum'), _dec10$2 = formerlySerializedAs('_groundAlbedo'), _dec$t(_class$t = (_class2$q = (_temp$r = function () {
        function AmbientInfo() {
          _initializerDefineProperty(this, "_skyColorHDR", _descriptor$k, this);

          _initializerDefineProperty(this, "_skyIllumHDR", _descriptor2$f, this);

          _initializerDefineProperty(this, "_groundAlbedoHDR", _descriptor3$d, this);

          _initializerDefineProperty(this, "_skyColorLDR", _descriptor4$a, this);

          _initializerDefineProperty(this, "_skyIllumLDR", _descriptor5$7, this);

          _initializerDefineProperty(this, "_groundAlbedoLDR", _descriptor6$3, this);

          this._resource = null;
        }

        var _proto = AmbientInfo.prototype;

        _proto.activate = function activate(resource) {
          this._resource = resource;

          this._resource.initialize(this);
        };

        _createClass(AmbientInfo, [{
          key: "skyColorHDR",
          get: function get() {
            return this._skyColorHDR;
          }
        }, {
          key: "groundAlbedoHDR",
          get: function get() {
            return this._groundAlbedoHDR;
          }
        }, {
          key: "skyIllumHDR",
          get: function get() {
            return this._skyIllumHDR;
          }
        }, {
          key: "skyColorLDR",
          get: function get() {
            return this._skyColorLDR;
          }
        }, {
          key: "groundAlbedoLDR",
          get: function get() {
            return this._groundAlbedoLDR;
          }
        }, {
          key: "skyIllumLDR",
          get: function get() {
            return this._skyIllumLDR;
          }
        }, {
          key: "skyLightingColor",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            _v4$2.set(isHDR ? this._skyColorHDR : this._skyColorLDR);

            normalizeHDRColor(_v4$2);
            return _col.set(_v4$2.x * 255, _v4$2.y * 255, _v4$2.z * 255, 255);
          },
          set: function set(val) {
            _v4$2.set(val.x, val.y, val.z, val.w);

            if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
              this._skyColorHDR.set(_v4$2);
            } else {
              this._skyColorLDR.set(_v4$2);
            }

            if (this._resource) {
              this._resource.skyColor.set(_v4$2);
            }
          }
        }, {
          key: "skyColor",
          set: function set(val) {
            if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
              this._skyColorHDR.set(val);
            } else {
              this._skyColorLDR.set(val);
            }

            if (this._resource) {
              this._resource.skyColor.set(val);
            }
          }
        }, {
          key: "skyIllum",
          get: function get() {
            if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
              return this._skyIllumHDR;
            } else {
              return this._skyIllumLDR;
            }
          },
          set: function set(val) {
            if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
              this._skyIllumHDR = val;
            } else {
              this._skyIllumLDR = val;
            }

            if (this._resource) {
              this._resource.skyIllum = val;
            }
          }
        }, {
          key: "groundLightingColor",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            _v4$2.set(isHDR ? this._groundAlbedoHDR : this._groundAlbedoLDR);

            normalizeHDRColor(_v4$2);
            return _col.set(_v4$2.x * 255, _v4$2.y * 255, _v4$2.z * 255, 255);
          },
          set: function set(val) {
            _v4$2.set(val.x, val.y, val.z, val.w);

            if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
              this._groundAlbedoHDR.set(_v4$2);
            } else {
              this._groundAlbedoLDR.set(_v4$2);
            }

            if (this._resource) {
              this._resource.groundAlbedo.set(_v4$2);
            }
          }
        }, {
          key: "groundAlbedo",
          set: function set(val) {
            if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
              this._groundAlbedoHDR.set(val);
            } else {
              this._groundAlbedoLDR.set(val);
            }

            if (this._resource) {
              this._resource.groundAlbedo.set(val);
            }
          }
        }]);

        return AmbientInfo;
      }(), _temp$r), (_applyDecoratedDescriptor(_class2$q.prototype, "skyLightingColor", [_dec2$e, editable, _dec3$9], Object.getOwnPropertyDescriptor(_class2$q.prototype, "skyLightingColor"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "skyIllum", [editable, _dec4$6, _dec5$3], Object.getOwnPropertyDescriptor(_class2$q.prototype, "skyIllum"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "groundLightingColor", [_dec6$3, editable, _dec7$2], Object.getOwnPropertyDescriptor(_class2$q.prototype, "groundLightingColor"), _class2$q.prototype), _descriptor$k = _applyDecoratedDescriptor(_class2$q.prototype, "_skyColorHDR", [serializable, _dec8$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec4(0.2, 0.5, 0.8, 1.0);
        }
      }), _descriptor2$f = _applyDecoratedDescriptor(_class2$q.prototype, "_skyIllumHDR", [serializable, _dec9$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Ambient.SKY_ILLUM;
        }
      }), _descriptor3$d = _applyDecoratedDescriptor(_class2$q.prototype, "_groundAlbedoHDR", [serializable, _dec10$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec4(0.2, 0.2, 0.2, 1.0);
        }
      }), _descriptor4$a = _applyDecoratedDescriptor(_class2$q.prototype, "_skyColorLDR", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec4(0.2, 0.5, 0.8, 1.0);
        }
      }), _descriptor5$7 = _applyDecoratedDescriptor(_class2$q.prototype, "_skyIllumLDR", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Ambient.SKY_ILLUM;
        }
      }), _descriptor6$3 = _applyDecoratedDescriptor(_class2$q.prototype, "_groundAlbedoLDR", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec4(0.2, 0.2, 0.2, 1.0);
        }
      })), _class2$q)) || _class$t));
      legacyCC.AmbientInfo = AmbientInfo;
      var SkyboxInfo = exports('SkyboxInfo', (_dec11$2 = ccclass('cc.SkyboxInfo'), _dec12$2 = tooltip(), _dec13$2 = type(EnvironmentLightingType), _dec14$2 = tooltip(), _dec15$2 = tooltip(), _dec16$2 = type(TextureCube), _dec17$2 = tooltip(), _dec18$2 = visible(), _dec19$2 = type(TextureCube), _dec20$2 = displayOrder(), _dec21$2 = type(TextureCube), _dec22$2 = formerlySerializedAs('_envmap'), _dec23$2 = type(TextureCube), _dec24$2 = type(TextureCube), _dec25$2 = type(TextureCube), _dec11$2(_class4$3 = (_class5$3 = (_temp2$2 = function () {
        function SkyboxInfo() {
          _initializerDefineProperty(this, "_envLightingType", _descriptor7$3, this);

          _initializerDefineProperty(this, "_envmapHDR", _descriptor8$3, this);

          _initializerDefineProperty(this, "_envmapLDR", _descriptor9$2, this);

          _initializerDefineProperty(this, "_diffuseMapHDR", _descriptor10$2, this);

          _initializerDefineProperty(this, "_diffuseMapLDR", _descriptor11$2, this);

          _initializerDefineProperty(this, "_enabled", _descriptor12$2, this);

          _initializerDefineProperty(this, "_useHDR", _descriptor13$2, this);

          this._resource = null;
        }

        var _proto2 = SkyboxInfo.prototype;

        _proto2.activate = function activate(resource) {
          this.envLightingType = this._envLightingType;
          this._resource = resource;

          this._resource.initialize(this);

          this._resource.setEnvMaps(this._envmapHDR, this._envmapLDR);

          this._resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);

          this._resource.activate();
        };

        _createClass(SkyboxInfo, [{
          key: "applyDiffuseMap",
          get: function get() {
            if (EnvironmentLightingType.DIFFUSEMAP_WITH_REFLECTION === this._envLightingType) {
              return true;
            }

            return false;
          },
          set: function set(val) {
            if (this._resource) {
              this._resource.useDiffuseMap = val;
            }
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            if (this._enabled === val) return;
            this._enabled = val;

            if (this._resource) {
              this._resource.enabled = this._enabled;
            }
          }
        }, {
          key: "envLightingType",
          get: function get() {
            return this._envLightingType;
          },
          set: function set(val) {
            if (!this.envmap && EnvironmentLightingType.HEMISPHERE_DIFFUSE !== val) {
              this.useIBL = false;
              this.applyDiffuseMap = false;
              this._envLightingType = EnvironmentLightingType.HEMISPHERE_DIFFUSE;
              warnID(15001);
            } else {
              if (EnvironmentLightingType.HEMISPHERE_DIFFUSE === val) {
                this.useIBL = false;
                this.applyDiffuseMap = false;
              } else if (EnvironmentLightingType.AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION === val) {
                this.useIBL = true;
                this.applyDiffuseMap = false;
              } else if (EnvironmentLightingType.DIFFUSEMAP_WITH_REFLECTION === val) {
                this.useIBL = true;
                this.applyDiffuseMap = true;
              }

              this._envLightingType = val;
            }
          }
        }, {
          key: "useIBL",
          get: function get() {
            if (EnvironmentLightingType.HEMISPHERE_DIFFUSE !== this._envLightingType) {
              return true;
            }

            return false;
          },
          set: function set(val) {
            if (this._resource) {
              this._resource.useIBL = val;
            }
          }
        }, {
          key: "useHDR",
          get: function get() {
            legacyCC.director.root.pipeline.pipelineSceneData.isHDR = this._useHDR;
            return this._useHDR;
          },
          set: function set(val) {
            legacyCC.director.root.pipeline.pipelineSceneData.isHDR = val;
            this._useHDR = val;

            if (this._resource) {
              this.envmap = this._resource.envmap;
              this.diffuseMap = this._resource.diffuseMap;

              if (this.envLightingType === EnvironmentLightingType.DIFFUSEMAP_WITH_REFLECTION) {
                if (this.diffuseMap === null) {
                  this.envLightingType = EnvironmentLightingType.AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION;
                  warnID(15000);
                } else if (this.diffuseMap.isDefault) {
                  warnID(15002);
                }
              }
            }

            if (this._resource) {
              this._resource.useHDR = this._useHDR;
            }
          }
        }, {
          key: "envmap",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._envmapHDR;
            } else {
              return this._envmapLDR;
            }
          },
          set: function set(val) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this._envmapHDR = val;
            } else {
              this._envmapLDR = val;
            }

            if (!val) {
              if (isHDR) {
                this._diffuseMapHDR = null;
              } else {
                this._diffuseMapLDR = null;
              }

              this.applyDiffuseMap = false;
              this.useIBL = false;
              this.envLightingType = EnvironmentLightingType.HEMISPHERE_DIFFUSE;
              warnID(15001);
            }

            if (this._resource) {
              this._resource.setEnvMaps(this._envmapHDR, this._envmapLDR);

              this._resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);

              this._resource.useDiffuseMap = this.applyDiffuseMap;
              this._resource.envmap = val;
            }
          }
        }, {
          key: "diffuseMap",
          get: function get() {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              return this._diffuseMapHDR;
            } else {
              return this._diffuseMapLDR;
            }
          },
          set: function set(val) {
            var isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

            if (isHDR) {
              this._diffuseMapHDR = val;
            } else {
              this._diffuseMapLDR = val;
            }

            if (this._resource) {
              this._resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);
            }
          }
        }]);

        return SkyboxInfo;
      }(), _temp2$2), (_applyDecoratedDescriptor(_class5$3.prototype, "enabled", [editable, _dec12$2], Object.getOwnPropertyDescriptor(_class5$3.prototype, "enabled"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "envLightingType", [editable, _dec13$2, _dec14$2], Object.getOwnPropertyDescriptor(_class5$3.prototype, "envLightingType"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "useHDR", [editable, _dec15$2], Object.getOwnPropertyDescriptor(_class5$3.prototype, "useHDR"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "envmap", [editable, _dec16$2, _dec17$2], Object.getOwnPropertyDescriptor(_class5$3.prototype, "envmap"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "diffuseMap", [_dec18$2, editable, readOnly, _dec19$2, _dec20$2], Object.getOwnPropertyDescriptor(_class5$3.prototype, "diffuseMap"), _class5$3.prototype), _descriptor7$3 = _applyDecoratedDescriptor(_class5$3.prototype, "_envLightingType", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return EnvironmentLightingType.HEMISPHERE_DIFFUSE;
        }
      }), _descriptor8$3 = _applyDecoratedDescriptor(_class5$3.prototype, "_envmapHDR", [serializable, _dec21$2, _dec22$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9$2 = _applyDecoratedDescriptor(_class5$3.prototype, "_envmapLDR", [serializable, _dec23$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10$2 = _applyDecoratedDescriptor(_class5$3.prototype, "_diffuseMapHDR", [serializable, _dec24$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$2 = _applyDecoratedDescriptor(_class5$3.prototype, "_diffuseMapLDR", [serializable, _dec25$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12$2 = _applyDecoratedDescriptor(_class5$3.prototype, "_enabled", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor13$2 = _applyDecoratedDescriptor(_class5$3.prototype, "_useHDR", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      })), _class5$3)) || _class4$3));
      legacyCC.SkyboxInfo = SkyboxInfo;
      var FogInfo = exports('FogInfo', (_dec26$1 = ccclass('cc.FogInfo'), _dec27$1 = tooltip(), _dec28$1 = displayOrder(), _dec29$1 = tooltip(), _dec30$1 = displayOrder(), _dec31$1 = tooltip(), _dec32 = type(FogType), _dec33 = displayOrder(), _dec34 = tooltip(), _dec35 = visible(), _dec36 = type(CCFloat), _dec37 = range(), _dec38 = rangeStep(), _dec39 = tooltip(), _dec40 = visible(), _dec41 = type(CCFloat), _dec42 = rangeStep(), _dec43 = tooltip(), _dec44 = visible(), _dec45 = type(CCFloat), _dec46 = rangeStep(), _dec47 = tooltip(), _dec48 = visible(), _dec49 = type(CCFloat), _dec50 = rangeMin(), _dec51 = rangeStep(), _dec52 = tooltip(), _dec53 = visible(), _dec54 = type(CCFloat), _dec55 = rangeStep(), _dec56 = tooltip(), _dec57 = visible(), _dec58 = type(CCFloat), _dec59 = rangeStep(), _dec60 = tooltip(), _dec26$1(_class7$2 = (_class8$2 = (_temp3$3 = _class9 = function () {
        function FogInfo() {
          _initializerDefineProperty(this, "_type", _descriptor14$2, this);

          _initializerDefineProperty(this, "_fogColor", _descriptor15$2, this);

          _initializerDefineProperty(this, "_enabled", _descriptor16$2, this);

          _initializerDefineProperty(this, "_fogDensity", _descriptor17$2, this);

          _initializerDefineProperty(this, "_fogStart", _descriptor18$2, this);

          _initializerDefineProperty(this, "_fogEnd", _descriptor19$2, this);

          _initializerDefineProperty(this, "_fogAtten", _descriptor20$2, this);

          _initializerDefineProperty(this, "_fogTop", _descriptor21$2, this);

          _initializerDefineProperty(this, "_fogRange", _descriptor22$2, this);

          _initializerDefineProperty(this, "_accurate", _descriptor23$2, this);

          this._resource = null;
        }

        var _proto3 = FogInfo.prototype;

        _proto3.activate = function activate(resource) {
          this._resource = resource;

          this._resource.initialize(this);

          this._resource.activate();
        };

        _createClass(FogInfo, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            if (this._enabled === val) return;
            this._enabled = val;

            if (this._resource) {
              this._resource.enabled = val;

              if (val) {
                this._resource.type = this._type;
              }
            }
          }
        }, {
          key: "accurate",
          get: function get() {
            return this._accurate;
          },
          set: function set(val) {
            if (this._accurate === val) return;
            this._accurate = val;

            if (this._resource) {
              this._resource.accurate = val;

              if (val) {
                this._resource.type = this._type;
              }
            }
          }
        }, {
          key: "fogColor",
          get: function get() {
            return this._fogColor;
          },
          set: function set(val) {
            this._fogColor.set(val);

            if (this._resource) {
              this._resource.fogColor = this._fogColor;
            }
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(val) {
            this._type = val;

            if (this._resource) {
              this._resource.type = val;
            }
          }
        }, {
          key: "fogDensity",
          get: function get() {
            return this._fogDensity;
          },
          set: function set(val) {
            this._fogDensity = val;

            if (this._resource) {
              this._resource.fogDensity = val;
            }
          }
        }, {
          key: "fogStart",
          get: function get() {
            return this._fogStart;
          },
          set: function set(val) {
            this._fogStart = val;

            if (this._resource) {
              this._resource.fogStart = val;
            }
          }
        }, {
          key: "fogEnd",
          get: function get() {
            return this._fogEnd;
          },
          set: function set(val) {
            this._fogEnd = val;

            if (this._resource) {
              this._resource.fogEnd = val;
            }
          }
        }, {
          key: "fogAtten",
          get: function get() {
            return this._fogAtten;
          },
          set: function set(val) {
            this._fogAtten = val;

            if (this._resource) {
              this._resource.fogAtten = val;
            }
          }
        }, {
          key: "fogTop",
          get: function get() {
            return this._fogTop;
          },
          set: function set(val) {
            this._fogTop = val;

            if (this._resource) {
              this._resource.fogTop = val;
            }
          }
        }, {
          key: "fogRange",
          get: function get() {
            return this._fogRange;
          },
          set: function set(val) {
            this._fogRange = val;

            if (this._resource) {
              this._resource.fogRange = val;
            }
          }
        }]);

        return FogInfo;
      }(), _class9.FogType = FogType, _temp3$3), (_applyDecoratedDescriptor(_class8$2.prototype, "enabled", [editable, _dec27$1, _dec28$1], Object.getOwnPropertyDescriptor(_class8$2.prototype, "enabled"), _class8$2.prototype), _applyDecoratedDescriptor(_class8$2.prototype, "accurate", [editable, _dec29$1, _dec30$1], Object.getOwnPropertyDescriptor(_class8$2.prototype, "accurate"), _class8$2.prototype), _applyDecoratedDescriptor(_class8$2.prototype, "fogColor", [editable, _dec31$1], Object.getOwnPropertyDescriptor(_class8$2.prototype, "fogColor"), _class8$2.prototype), _applyDecoratedDescriptor(_class8$2.prototype, "type", [editable, _dec32, _dec33, _dec34], Object.getOwnPropertyDescriptor(_class8$2.prototype, "type"), _class8$2.prototype), _applyDecoratedDescriptor(_class8$2.prototype, "fogDensity", [_dec35, _dec36, _dec37, _dec38, slide, _dec39], Object.getOwnPropertyDescriptor(_class8$2.prototype, "fogDensity"), _class8$2.prototype), _applyDecoratedDescriptor(_class8$2.prototype, "fogStart", [_dec40, _dec41, _dec42, _dec43], Object.getOwnPropertyDescriptor(_class8$2.prototype, "fogStart"), _class8$2.prototype), _applyDecoratedDescriptor(_class8$2.prototype, "fogEnd", [_dec44, _dec45, _dec46, _dec47], Object.getOwnPropertyDescriptor(_class8$2.prototype, "fogEnd"), _class8$2.prototype), _applyDecoratedDescriptor(_class8$2.prototype, "fogAtten", [_dec48, _dec49, _dec50, _dec51, _dec52], Object.getOwnPropertyDescriptor(_class8$2.prototype, "fogAtten"), _class8$2.prototype), _applyDecoratedDescriptor(_class8$2.prototype, "fogTop", [_dec53, _dec54, _dec55, _dec56], Object.getOwnPropertyDescriptor(_class8$2.prototype, "fogTop"), _class8$2.prototype), _applyDecoratedDescriptor(_class8$2.prototype, "fogRange", [_dec57, _dec58, _dec59, _dec60], Object.getOwnPropertyDescriptor(_class8$2.prototype, "fogRange"), _class8$2.prototype), _descriptor14$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_type", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return FogType.LINEAR;
        }
      }), _descriptor15$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_fogColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color('#C8C8C8');
        }
      }), _descriptor16$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_enabled", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor17$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_fogDensity", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.3;
        }
      }), _descriptor18$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_fogStart", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor19$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_fogEnd", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 300;
        }
      }), _descriptor20$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_fogAtten", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 5;
        }
      }), _descriptor21$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_fogTop", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.5;
        }
      }), _descriptor22$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_fogRange", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.2;
        }
      }), _descriptor23$2 = _applyDecoratedDescriptor(_class8$2.prototype, "_accurate", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class8$2)) || _class7$2));
      var ShadowsInfo = exports('ShadowsInfo', (_dec61 = ccclass('cc.ShadowsInfo'), _dec62 = tooltip(), _dec63 = type(ShadowType), _dec64 = visible(), _dec65 = visible(), _dec66 = tooltip(), _dec67 = type(CCFloat), _dec68 = visible(), _dec69 = tooltip(), _dec70 = type(CCInteger), _dec71 = tooltip(), _dec72 = visible(), _dec73 = type(ShadowSize), _dec74 = tooltip(), _dec75 = visible(), _dec61(_class10$2 = (_class11$2 = (_temp4$2 = function () {
        function ShadowsInfo() {
          _initializerDefineProperty(this, "_enabled", _descriptor24$2, this);

          _initializerDefineProperty(this, "_type", _descriptor25$2, this);

          _initializerDefineProperty(this, "_normal", _descriptor26$2, this);

          _initializerDefineProperty(this, "_distance", _descriptor27$1, this);

          _initializerDefineProperty(this, "_shadowColor", _descriptor28$1, this);

          _initializerDefineProperty(this, "_maxReceived", _descriptor29$1, this);

          _initializerDefineProperty(this, "_size", _descriptor30$1, this);

          this._resource = null;
        }

        var _proto4 = ShadowsInfo.prototype;

        _proto4.setPlaneFromNode = function setPlaneFromNode(node) {
          node.getWorldRotation(_qt$1);
          this.planeDirection = Vec3.transformQuat(_v3$2, _up, _qt$1);
          node.getWorldPosition(_v3$2);
          this.planeHeight = Vec3.dot(this._normal, _v3$2);
        };

        _proto4.activate = function activate(resource) {
          this._resource = resource;

          this._resource.initialize(this);

          this._resource.activate();
        };

        _createClass(ShadowsInfo, [{
          key: "enabled",
          get: function get() {

            return this._enabled;
          },
          set: function set(val) {
            if (this._enabled === val) return;
            this._enabled = val;

            if (this._resource) {
              this._resource.enabled = val;

              if (val) {
                this._resource.type = this._type;
              }
            }
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(val) {
            this._type = val;

            if (this._resource) {
              this._resource.type = val;
            }
          }
        }, {
          key: "shadowColor",
          get: function get() {
            return this._shadowColor;
          },
          set: function set(val) {
            this._shadowColor.set(val);

            if (this._resource) {
              this._resource.shadowColor = val;
            }
          }
        }, {
          key: "planeDirection",
          get: function get() {
            return this._normal;
          },
          set: function set(val) {
            Vec3.copy(this._normal, val);

            if (this._resource) {
              this._resource.normal = val;
            }
          }
        }, {
          key: "planeHeight",
          get: function get() {
            return this._distance;
          },
          set: function set(val) {
            this._distance = val;

            if (this._resource) {
              this._resource.distance = -val;
            }
          }
        }, {
          key: "maxReceived",
          get: function get() {
            return this._maxReceived;
          },
          set: function set(val) {
            this._maxReceived = val;

            if (this._resource) {
              this._resource.maxReceived = val;
            }
          }
        }, {
          key: "shadowMapSize",
          get: function get() {
            return this._size.x;
          },
          set: function set(value) {
            this._size.set(value, value);

            if (this._resource) {
              this._resource.size.set(value, value);

              this._resource.shadowMapDirty = true;
            }
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          }
        }]);

        return ShadowsInfo;
      }(), _temp4$2), (_applyDecoratedDescriptor(_class11$2.prototype, "enabled", [editable, _dec62], Object.getOwnPropertyDescriptor(_class11$2.prototype, "enabled"), _class11$2.prototype), _applyDecoratedDescriptor(_class11$2.prototype, "type", [editable, _dec63], Object.getOwnPropertyDescriptor(_class11$2.prototype, "type"), _class11$2.prototype), _applyDecoratedDescriptor(_class11$2.prototype, "shadowColor", [_dec64], Object.getOwnPropertyDescriptor(_class11$2.prototype, "shadowColor"), _class11$2.prototype), _applyDecoratedDescriptor(_class11$2.prototype, "planeDirection", [_dec65, _dec66], Object.getOwnPropertyDescriptor(_class11$2.prototype, "planeDirection"), _class11$2.prototype), _applyDecoratedDescriptor(_class11$2.prototype, "planeHeight", [editable, _dec67, _dec68, _dec69], Object.getOwnPropertyDescriptor(_class11$2.prototype, "planeHeight"), _class11$2.prototype), _applyDecoratedDescriptor(_class11$2.prototype, "maxReceived", [_dec70, _dec71, _dec72], Object.getOwnPropertyDescriptor(_class11$2.prototype, "maxReceived"), _class11$2.prototype), _applyDecoratedDescriptor(_class11$2.prototype, "shadowMapSize", [_dec73, _dec74, _dec75], Object.getOwnPropertyDescriptor(_class11$2.prototype, "shadowMapSize"), _class11$2.prototype), _descriptor24$2 = _applyDecoratedDescriptor(_class11$2.prototype, "_enabled", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor25$2 = _applyDecoratedDescriptor(_class11$2.prototype, "_type", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ShadowType.Planar;
        }
      }), _descriptor26$2 = _applyDecoratedDescriptor(_class11$2.prototype, "_normal", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(0, 1, 0);
        }
      }), _descriptor27$1 = _applyDecoratedDescriptor(_class11$2.prototype, "_distance", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor28$1 = _applyDecoratedDescriptor(_class11$2.prototype, "_shadowColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(0, 0, 0, 76);
        }
      }), _descriptor29$1 = _applyDecoratedDescriptor(_class11$2.prototype, "_maxReceived", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 4;
        }
      }), _descriptor30$1 = _applyDecoratedDescriptor(_class11$2.prototype, "_size", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(512, 512);
        }
      })), _class11$2)) || _class10$2));
      legacyCC.ShadowsInfo = ShadowsInfo;
      var DEFAULT_WORLD_MIN_POS = exports('DEFAULT_WORLD_MIN_POS', new Vec3(-1024.0, -1024.0, -1024.0));
      var DEFAULT_WORLD_MAX_POS = exports('DEFAULT_WORLD_MAX_POS', new Vec3(1024.0, 1024.0, 1024.0));
      var DEFAULT_OCTREE_DEPTH = exports('DEFAULT_OCTREE_DEPTH', 8);
      var OctreeInfo = exports('OctreeInfo', (_dec76 = ccclass('cc.OctreeInfo'), _dec77 = tooltip(), _dec78 = tooltip(), _dec79 = displayName(), _dec80 = tooltip(), _dec81 = displayName(), _dec82 = range(), _dec83 = type(CCInteger), _dec84 = tooltip(), _dec76(_class13$2 = (_class14$2 = (_temp5$2 = function () {
        function OctreeInfo() {
          _initializerDefineProperty(this, "_enabled", _descriptor31$1, this);

          _initializerDefineProperty(this, "_minPos", _descriptor32$1, this);

          _initializerDefineProperty(this, "_maxPos", _descriptor33$1, this);

          _initializerDefineProperty(this, "_depth", _descriptor34$1, this);

          this._resource = null;
        }

        var _proto5 = OctreeInfo.prototype;

        _proto5.activate = function activate(resource) {
          this._resource = resource;

          this._resource.initialize(this);
        };

        _createClass(OctreeInfo, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(val) {
            if (this._enabled === val) return;
            this._enabled = val;

            if (this._resource) {
              this._resource.enabled = val;
            }
          }
        }, {
          key: "minPos",
          get: function get() {
            return this._minPos;
          },
          set: function set(val) {
            this._minPos = val;

            if (this._resource) {
              this._resource.minPos = val;
            }
          }
        }, {
          key: "maxPos",
          get: function get() {
            return this._maxPos;
          },
          set: function set(val) {
            this._maxPos = val;

            if (this._resource) {
              this._resource.maxPos = val;
            }
          }
        }, {
          key: "depth",
          get: function get() {
            return this._depth;
          },
          set: function set(val) {
            this._depth = val;

            if (this._resource) {
              this._resource.depth = val;
            }
          }
        }]);

        return OctreeInfo;
      }(), _temp5$2), (_applyDecoratedDescriptor(_class14$2.prototype, "enabled", [editable, _dec77], Object.getOwnPropertyDescriptor(_class14$2.prototype, "enabled"), _class14$2.prototype), _applyDecoratedDescriptor(_class14$2.prototype, "minPos", [editable, _dec78, _dec79], Object.getOwnPropertyDescriptor(_class14$2.prototype, "minPos"), _class14$2.prototype), _applyDecoratedDescriptor(_class14$2.prototype, "maxPos", [editable, _dec80, _dec81], Object.getOwnPropertyDescriptor(_class14$2.prototype, "maxPos"), _class14$2.prototype), _applyDecoratedDescriptor(_class14$2.prototype, "depth", [editable, _dec82, slide, _dec83, _dec84], Object.getOwnPropertyDescriptor(_class14$2.prototype, "depth"), _class14$2.prototype), _descriptor31$1 = _applyDecoratedDescriptor(_class14$2.prototype, "_enabled", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor32$1 = _applyDecoratedDescriptor(_class14$2.prototype, "_minPos", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(DEFAULT_WORLD_MIN_POS);
        }
      }), _descriptor33$1 = _applyDecoratedDescriptor(_class14$2.prototype, "_maxPos", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec3(DEFAULT_WORLD_MAX_POS);
        }
      }), _descriptor34$1 = _applyDecoratedDescriptor(_class14$2.prototype, "_depth", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return DEFAULT_OCTREE_DEPTH;
        }
      })), _class14$2)) || _class13$2));
      var SceneGlobals = exports('SceneGlobals', (_dec85 = ccclass('cc.SceneGlobals'), _dec86 = type(SkyboxInfo), _dec85(_class16$2 = (_class17$2 = (_temp6$2 = function () {
        function SceneGlobals() {
          _initializerDefineProperty(this, "ambient", _descriptor35$1, this);

          _initializerDefineProperty(this, "shadows", _descriptor36, this);

          _initializerDefineProperty(this, "_skybox", _descriptor37, this);

          _initializerDefineProperty(this, "fog", _descriptor38, this);

          _initializerDefineProperty(this, "octree", _descriptor39, this);
        }

        var _proto6 = SceneGlobals.prototype;

        _proto6.activate = function activate() {
          var sceneData = legacyCC.director.root.pipeline.pipelineSceneData;
          this.skybox.activate(sceneData.skybox);
          this.ambient.activate(sceneData.ambient);
          this.shadows.activate(sceneData.shadows);
          this.fog.activate(sceneData.fog);
          this.octree.activate(sceneData.octree);
        };

        _createClass(SceneGlobals, [{
          key: "skybox",
          get: function get() {
            return this._skybox;
          },
          set: function set(value) {
            this._skybox = value;
          }
        }]);

        return SceneGlobals;
      }(), _temp6$2), (_descriptor35$1 = _applyDecoratedDescriptor(_class17$2.prototype, "ambient", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new AmbientInfo();
        }
      }), _descriptor36 = _applyDecoratedDescriptor(_class17$2.prototype, "shadows", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new ShadowsInfo();
        }
      }), _descriptor37 = _applyDecoratedDescriptor(_class17$2.prototype, "_skybox", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new SkyboxInfo();
        }
      }), _descriptor38 = _applyDecoratedDescriptor(_class17$2.prototype, "fog", [editable, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new FogInfo();
        }
      }), _applyDecoratedDescriptor(_class17$2.prototype, "skybox", [editable, _dec86], Object.getOwnPropertyDescriptor(_class17$2.prototype, "skybox"), _class17$2.prototype), _descriptor39 = _applyDecoratedDescriptor(_class17$2.prototype, "octree", [editable, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new OctreeInfo();
        }
      })), _class17$2)) || _class16$2));
      legacyCC.SceneGlobals = SceneGlobals;

      var Event = exports('Event', function () {
        function Event(type, bubbles) {
          this.type = void 0;
          this.bubbles = void 0;
          this.target = null;
          this.currentTarget = null;
          this.eventPhase = 0;
          this.propagationStopped = false;
          this.propagationImmediateStopped = false;
          this.type = type;
          this.bubbles = !!bubbles;
        }

        var _proto = Event.prototype;

        _proto.unuse = function unuse() {
          this.type = Event.NO_TYPE;
          this.target = null;
          this.currentTarget = null;
          this.eventPhase = Event.NONE;
          this.propagationStopped = false;
          this.propagationImmediateStopped = false;
        };

        _proto.reuse = function reuse(type, bubbles) {
          this.type = type;
          this.bubbles = bubbles || false;
        };

        _proto.isStopped = function isStopped() {
          return this.propagationStopped || this.propagationImmediateStopped;
        };

        _proto.getCurrentTarget = function getCurrentTarget() {
          return this.currentTarget;
        };

        _proto.getType = function getType() {
          return this.type;
        };

        return Event;
      }());
      Event.NO_TYPE = 'no_type';
      Event.TOUCH = 'touch';
      Event.MOUSE = 'mouse';
      Event.KEYBOARD = 'keyboard';
      Event.ACCELERATION = 'acceleration';
      Event.NONE = 0;
      Event.CAPTURING_PHASE = 1;
      Event.AT_TARGET = 2;
      Event.BUBBLING_PHASE = 3;
      legacyCC.Event = Event;

      var EventAcceleration = exports('EventAcceleration', function (_Event) {
        _inheritsLoose(EventAcceleration, _Event);

        function EventAcceleration(acc, bubbles) {
          var _this;

          _this = _Event.call(this, SystemEventType.DEVICEMOTION, bubbles) || this;
          _this.acc = void 0;
          _this.acc = acc;
          return _this;
        }

        return EventAcceleration;
      }(Event));
      Event.EventAcceleration = EventAcceleration;

      var EventKeyboard = exports('EventKeyboard', function (_Event) {
        _inheritsLoose(EventKeyboard, _Event);

        function EventKeyboard(keyCode, eventType, bubbles) {
          var _this;

          if (typeof eventType === 'boolean') {
            var _isPressed = eventType;
            eventType = _isPressed ? SystemEventType.KEY_DOWN : SystemEventType.KEY_UP;
          }

          _this = _Event.call(this, eventType, bubbles) || this;
          _this.keyCode = void 0;
          _this.rawEvent = void 0;
          _this._isPressed = void 0;
          _this._isPressed = eventType !== SystemEventType.KEY_UP;

          if (typeof keyCode === 'number') {
            _this.keyCode = keyCode;
          } else {
            _this.keyCode = keyCode.keyCode;
            _this.rawEvent = keyCode;
          }

          return _this;
        }

        _createClass(EventKeyboard, [{
          key: "isPressed",
          get: function get() {
            return this._isPressed;
          }
        }]);

        return EventKeyboard;
      }(Event));
      Event.EventKeyboard = EventKeyboard;

      var EventMouse = exports('EventMouse', function (_Event) {
        _inheritsLoose(EventMouse, _Event);

        function EventMouse(eventType, bubbles, prevLoc) {
          var _this;

          _this = _Event.call(this, eventType, bubbles) || this;
          _this.movementX = 0;
          _this.movementY = 0;
          _this.preventSwallow = false;
          _this._eventType = void 0;
          _this._button = EventMouse.BUTTON_MISSING;
          _this._x = 0;
          _this._y = 0;
          _this._prevX = 0;
          _this._prevY = 0;
          _this._scrollX = 0;
          _this._scrollY = 0;
          _this._eventType = eventType;

          if (prevLoc) {
            _this._prevX = prevLoc.x;
            _this._prevY = prevLoc.y;
          }

          return _this;
        }

        var _proto = EventMouse.prototype;

        _proto.setScrollData = function setScrollData(scrollX, scrollY) {
          this._scrollX = scrollX;
          this._scrollY = scrollY;
        };

        _proto.getScrollX = function getScrollX() {
          return this._scrollX;
        };

        _proto.getScrollY = function getScrollY() {
          return this._scrollY;
        };

        _proto.setLocation = function setLocation(x, y) {
          this._x = x;
          this._y = y;
        };

        _proto.getLocation = function getLocation(out) {
          if (!out) {
            out = new Vec2();
          }

          Vec2.set(out, this._x, this._y);
          return out;
        };

        _proto.getLocationInView = function getLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }

          Vec2.set(out, this._x, legacyCC.view._designResolutionSize.height - this._y);
          return out;
        };

        _proto.getUILocation = function getUILocation(out) {
          if (!out) {
            out = new Vec2();
          }

          Vec2.set(out, this._x, this._y);

          legacyCC.view._convertToUISpace(out);

          return out;
        };

        _proto.getPreviousLocation = function getPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }

          Vec2.set(out, this._prevX, this._prevY);
          return out;
        };

        _proto.getUIPreviousLocation = function getUIPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }

          Vec2.set(out, this._prevX, this._prevY);

          legacyCC.view._convertToUISpace(out);

          return out;
        };

        _proto.getDelta = function getDelta(out) {
          if (!out) {
            out = new Vec2();
          }

          Vec2.set(out, this._x - this._prevX, this._y - this._prevY);
          return out;
        };

        _proto.getDeltaX = function getDeltaX() {
          return this._x - this._prevX;
        };

        _proto.getDeltaY = function getDeltaY() {
          return this._y - this._prevY;
        };

        _proto.getUIDelta = function getUIDelta(out) {
          if (!out) {
            out = new Vec2();
          }

          Vec2.set(out, (this._x - this._prevX) / legacyCC.view.getScaleX(), (this._y - this._prevY) / legacyCC.view.getScaleY());
          return out;
        };

        _proto.getUIDeltaX = function getUIDeltaX() {
          return (this._x - this._prevX) / legacyCC.view.getScaleX();
        };

        _proto.getUIDeltaY = function getUIDeltaY() {
          return (this._y - this._prevY) / legacyCC.view.getScaleY();
        };

        _proto.setButton = function setButton(button) {
          this._button = button;
        };

        _proto.getButton = function getButton() {
          return this._button;
        };

        _proto.getLocationX = function getLocationX() {
          return this._x;
        };

        _proto.getLocationY = function getLocationY() {
          return this._y;
        };

        _proto.getUILocationX = function getUILocationX() {
          var viewport = legacyCC.view.getViewportRect();
          return (this._x - viewport.x) / legacyCC.view.getScaleX();
        };

        _proto.getUILocationY = function getUILocationY() {
          var viewport = legacyCC.view.getViewportRect();
          return (this._y - viewport.y) / legacyCC.view.getScaleY();
        };

        _createClass(EventMouse, [{
          key: "eventType",
          get: function get() {
            return this._eventType;
          }
        }]);

        return EventMouse;
      }(Event));
      EventMouse.BUTTON_MISSING = -1;
      EventMouse.BUTTON_LEFT = 0;
      EventMouse.BUTTON_RIGHT = 2;
      EventMouse.BUTTON_MIDDLE = 1;
      EventMouse.BUTTON_4 = 3;
      EventMouse.BUTTON_5 = 4;
      EventMouse.BUTTON_6 = 5;
      EventMouse.BUTTON_7 = 6;
      EventMouse.BUTTON_8 = 7;
      Event.EventMouse = EventMouse;

      var _vec2 = new Vec2();

      var EventTouch = exports('EventTouch', function (_Event) {
        _inheritsLoose(EventTouch, _Event);

        function EventTouch(changedTouches, bubbles, eventType, touches) {
          var _this;

          if (touches === void 0) {
            touches = [];
          }

          _this = _Event.call(this, eventType, bubbles) || this;
          _this.touch = null;
          _this.simulate = false;
          _this.preventSwallow = false;
          _this._eventCode = void 0;
          _this._touches = void 0;
          _this._allTouches = void 0;
          _this._eventCode = eventType;
          _this._touches = changedTouches || [];
          _this._allTouches = touches;
          return _this;
        }

        var _proto = EventTouch.prototype;

        _proto.getEventCode = function getEventCode() {
          return this._eventCode;
        };

        _proto.getTouches = function getTouches() {
          return this._touches;
        };

        _proto.getAllTouches = function getAllTouches() {
          return this._allTouches;
        };

        _proto.setLocation = function setLocation(x, y) {
          if (this.touch) {
            this.touch.setTouchInfo(this.touch.getID(), x, y);
          }
        };

        _proto.getLocation = function getLocation(out) {
          return this.touch ? this.touch.getLocation(out) : new Vec2();
        };

        _proto.getUILocation = function getUILocation(out) {
          return this.touch ? this.touch.getUILocation(out) : new Vec2();
        };

        _proto.getLocationInView = function getLocationInView(out) {
          return this.touch ? this.touch.getLocationInView(out) : new Vec2();
        };

        _proto.getPreviousLocation = function getPreviousLocation(out) {
          return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
        };

        _proto.getStartLocation = function getStartLocation(out) {
          return this.touch ? this.touch.getStartLocation(out) : new Vec2();
        };

        _proto.getUIStartLocation = function getUIStartLocation(out) {
          return this.touch ? this.touch.getUIStartLocation(out) : new Vec2();
        };

        _proto.getID = function getID() {
          return this.touch ? this.touch.getID() : null;
        };

        _proto.getDelta = function getDelta(out) {
          return this.touch ? this.touch.getDelta(out) : new Vec2();
        };

        _proto.getUIDelta = function getUIDelta(out) {
          return this.touch ? this.touch.getUIDelta(out) : new Vec2();
        };

        _proto.getDeltaX = function getDeltaX() {
          return this.touch ? this.touch.getDelta(_vec2).x : 0;
        };

        _proto.getDeltaY = function getDeltaY() {
          return this.touch ? this.touch.getDelta(_vec2).y : 0;
        };

        _proto.getLocationX = function getLocationX() {
          return this.touch ? this.touch.getLocationX() : 0;
        };

        _proto.getLocationY = function getLocationY() {
          return this.touch ? this.touch.getLocationY() : 0;
        };

        return EventTouch;
      }(Event));
      EventTouch.MAX_TOUCHES = 5;
      Event.EventTouch = EventTouch;

      var Acceleration = exports('Acceleration', function Acceleration(x, y, z, timestamp) {
        if (x === void 0) {
          x = 0;
        }

        if (y === void 0) {
          y = 0;
        }

        if (z === void 0) {
          z = 0;
        }

        if (timestamp === void 0) {
          timestamp = 0;
        }

        this.x = void 0;
        this.y = void 0;
        this.z = void 0;
        this.timestamp = void 0;
        this.x = x;
        this.y = y;
        this.z = z;
        this.timestamp = timestamp;
      });

      var KeyCode;

      (function (KeyCode) {
        KeyCode[KeyCode["NONE"] = 0] = "NONE";
        KeyCode[KeyCode["MOBILE_BACK"] = 6] = "MOBILE_BACK";
        KeyCode[KeyCode["BACKSPACE"] = 8] = "BACKSPACE";
        KeyCode[KeyCode["TAB"] = 9] = "TAB";
        KeyCode[KeyCode["ENTER"] = 13] = "ENTER";
        KeyCode[KeyCode["SHIFT_LEFT"] = 16] = "SHIFT_LEFT";
        KeyCode[KeyCode["CTRL_LEFT"] = 17] = "CTRL_LEFT";
        KeyCode[KeyCode["ALT_LEFT"] = 18] = "ALT_LEFT";
        KeyCode[KeyCode["PAUSE"] = 19] = "PAUSE";
        KeyCode[KeyCode["CAPS_LOCK"] = 20] = "CAPS_LOCK";
        KeyCode[KeyCode["ESCAPE"] = 27] = "ESCAPE";
        KeyCode[KeyCode["SPACE"] = 32] = "SPACE";
        KeyCode[KeyCode["PAGE_UP"] = 33] = "PAGE_UP";
        KeyCode[KeyCode["PAGE_DOWN"] = 34] = "PAGE_DOWN";
        KeyCode[KeyCode["END"] = 35] = "END";
        KeyCode[KeyCode["HOME"] = 36] = "HOME";
        KeyCode[KeyCode["ARROW_LEFT"] = 37] = "ARROW_LEFT";
        KeyCode[KeyCode["ARROW_UP"] = 38] = "ARROW_UP";
        KeyCode[KeyCode["ARROW_RIGHT"] = 39] = "ARROW_RIGHT";
        KeyCode[KeyCode["ARROW_DOWN"] = 40] = "ARROW_DOWN";
        KeyCode[KeyCode["INSERT"] = 45] = "INSERT";
        KeyCode[KeyCode["DELETE"] = 46] = "DELETE";
        KeyCode[KeyCode["DIGIT_0"] = 48] = "DIGIT_0";
        KeyCode[KeyCode["DIGIT_1"] = 49] = "DIGIT_1";
        KeyCode[KeyCode["DIGIT_2"] = 50] = "DIGIT_2";
        KeyCode[KeyCode["DIGIT_3"] = 51] = "DIGIT_3";
        KeyCode[KeyCode["DIGIT_4"] = 52] = "DIGIT_4";
        KeyCode[KeyCode["DIGIT_5"] = 53] = "DIGIT_5";
        KeyCode[KeyCode["DIGIT_6"] = 54] = "DIGIT_6";
        KeyCode[KeyCode["DIGIT_7"] = 55] = "DIGIT_7";
        KeyCode[KeyCode["DIGIT_8"] = 56] = "DIGIT_8";
        KeyCode[KeyCode["DIGIT_9"] = 57] = "DIGIT_9";
        KeyCode[KeyCode["KEY_A"] = 65] = "KEY_A";
        KeyCode[KeyCode["KEY_B"] = 66] = "KEY_B";
        KeyCode[KeyCode["KEY_C"] = 67] = "KEY_C";
        KeyCode[KeyCode["KEY_D"] = 68] = "KEY_D";
        KeyCode[KeyCode["KEY_E"] = 69] = "KEY_E";
        KeyCode[KeyCode["KEY_F"] = 70] = "KEY_F";
        KeyCode[KeyCode["KEY_G"] = 71] = "KEY_G";
        KeyCode[KeyCode["KEY_H"] = 72] = "KEY_H";
        KeyCode[KeyCode["KEY_I"] = 73] = "KEY_I";
        KeyCode[KeyCode["KEY_J"] = 74] = "KEY_J";
        KeyCode[KeyCode["KEY_K"] = 75] = "KEY_K";
        KeyCode[KeyCode["KEY_L"] = 76] = "KEY_L";
        KeyCode[KeyCode["KEY_M"] = 77] = "KEY_M";
        KeyCode[KeyCode["KEY_N"] = 78] = "KEY_N";
        KeyCode[KeyCode["KEY_O"] = 79] = "KEY_O";
        KeyCode[KeyCode["KEY_P"] = 80] = "KEY_P";
        KeyCode[KeyCode["KEY_Q"] = 81] = "KEY_Q";
        KeyCode[KeyCode["KEY_R"] = 82] = "KEY_R";
        KeyCode[KeyCode["KEY_S"] = 83] = "KEY_S";
        KeyCode[KeyCode["KEY_T"] = 84] = "KEY_T";
        KeyCode[KeyCode["KEY_U"] = 85] = "KEY_U";
        KeyCode[KeyCode["KEY_V"] = 86] = "KEY_V";
        KeyCode[KeyCode["KEY_W"] = 87] = "KEY_W";
        KeyCode[KeyCode["KEY_X"] = 88] = "KEY_X";
        KeyCode[KeyCode["KEY_Y"] = 89] = "KEY_Y";
        KeyCode[KeyCode["KEY_Z"] = 90] = "KEY_Z";
        KeyCode[KeyCode["NUM_0"] = 96] = "NUM_0";
        KeyCode[KeyCode["NUM_1"] = 97] = "NUM_1";
        KeyCode[KeyCode["NUM_2"] = 98] = "NUM_2";
        KeyCode[KeyCode["NUM_3"] = 99] = "NUM_3";
        KeyCode[KeyCode["NUM_4"] = 100] = "NUM_4";
        KeyCode[KeyCode["NUM_5"] = 101] = "NUM_5";
        KeyCode[KeyCode["NUM_6"] = 102] = "NUM_6";
        KeyCode[KeyCode["NUM_7"] = 103] = "NUM_7";
        KeyCode[KeyCode["NUM_8"] = 104] = "NUM_8";
        KeyCode[KeyCode["NUM_9"] = 105] = "NUM_9";
        KeyCode[KeyCode["NUM_MULTIPLY"] = 106] = "NUM_MULTIPLY";
        KeyCode[KeyCode["NUM_PLUS"] = 107] = "NUM_PLUS";
        KeyCode[KeyCode["NUM_SUBTRACT"] = 109] = "NUM_SUBTRACT";
        KeyCode[KeyCode["NUM_DECIMAL"] = 110] = "NUM_DECIMAL";
        KeyCode[KeyCode["NUM_DIVIDE"] = 111] = "NUM_DIVIDE";
        KeyCode[KeyCode["F1"] = 112] = "F1";
        KeyCode[KeyCode["F2"] = 113] = "F2";
        KeyCode[KeyCode["F3"] = 114] = "F3";
        KeyCode[KeyCode["F4"] = 115] = "F4";
        KeyCode[KeyCode["F5"] = 116] = "F5";
        KeyCode[KeyCode["F6"] = 117] = "F6";
        KeyCode[KeyCode["F7"] = 118] = "F7";
        KeyCode[KeyCode["F8"] = 119] = "F8";
        KeyCode[KeyCode["F9"] = 120] = "F9";
        KeyCode[KeyCode["F10"] = 121] = "F10";
        KeyCode[KeyCode["F11"] = 122] = "F11";
        KeyCode[KeyCode["F12"] = 123] = "F12";
        KeyCode[KeyCode["NUM_LOCK"] = 144] = "NUM_LOCK";
        KeyCode[KeyCode["SCROLL_LOCK"] = 145] = "SCROLL_LOCK";
        KeyCode[KeyCode["SEMICOLON"] = 186] = "SEMICOLON";
        KeyCode[KeyCode["EQUAL"] = 187] = "EQUAL";
        KeyCode[KeyCode["COMMA"] = 188] = "COMMA";
        KeyCode[KeyCode["DASH"] = 189] = "DASH";
        KeyCode[KeyCode["PERIOD"] = 190] = "PERIOD";
        KeyCode[KeyCode["SLASH"] = 191] = "SLASH";
        KeyCode[KeyCode["BACK_QUOTE"] = 192] = "BACK_QUOTE";
        KeyCode[KeyCode["BRACKET_LEFT"] = 219] = "BRACKET_LEFT";
        KeyCode[KeyCode["BACKSLASH"] = 220] = "BACKSLASH";
        KeyCode[KeyCode["BRACKET_RIGHT"] = 221] = "BRACKET_RIGHT";
        KeyCode[KeyCode["QUOTE"] = 222] = "QUOTE";
        KeyCode[KeyCode["SHIFT_RIGHT"] = 2000] = "SHIFT_RIGHT";
        KeyCode[KeyCode["CTRL_RIGHT"] = 2001] = "CTRL_RIGHT";
        KeyCode[KeyCode["ALT_RIGHT"] = 2002] = "ALT_RIGHT";
        KeyCode[KeyCode["NUM_ENTER"] = 2003] = "NUM_ENTER";
      })(KeyCode || (KeyCode = exports('KeyCode', {})));

      var _vec2$1 = new Vec2();

      var Touch = exports('Touch', function () {
        function Touch(x, y, id) {
          if (id === void 0) {
            id = 0;
          }

          this._point = new Vec2();
          this._prevPoint = new Vec2();
          this._lastModified = 0;
          this._id = 0;
          this._startPoint = new Vec2();
          this._startPointCaptured = false;
          this.setTouchInfo(id, x, y);
        }

        var _proto = Touch.prototype;

        _proto.getLocation = function getLocation(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._point.x, this._point.y);
          return out;
        };

        _proto.getLocationX = function getLocationX() {
          return this._point.x;
        };

        _proto.getLocationY = function getLocationY() {
          return this._point.y;
        };

        _proto.getUILocation = function getUILocation(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._point.x, this._point.y);

          legacyCC.view._convertToUISpace(out);

          return out;
        };

        _proto.getUILocationX = function getUILocationX() {
          var viewport = legacyCC.view.getViewportRect();
          return (this._point.x - viewport.x) / legacyCC.view.getScaleX();
        };

        _proto.getUILocationY = function getUILocationY() {
          var viewport = legacyCC.view.getViewportRect();
          return (this._point.y - viewport.y) / legacyCC.view.getScaleY();
        };

        _proto.getPreviousLocation = function getPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._prevPoint.x, this._prevPoint.y);
          return out;
        };

        _proto.getUIPreviousLocation = function getUIPreviousLocation(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._prevPoint.x, this._prevPoint.y);

          legacyCC.view._convertToUISpace(out);

          return out;
        };

        _proto.getStartLocation = function getStartLocation(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._startPoint.x, this._startPoint.y);
          return out;
        };

        _proto.getUIStartLocation = function getUIStartLocation(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._startPoint.x, this._startPoint.y);

          legacyCC.view._convertToUISpace(out);

          return out;
        };

        _proto.getDelta = function getDelta(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._point);
          out.subtract(this._prevPoint);
          return out;
        };

        _proto.getUIDelta = function getUIDelta(out) {
          if (!out) {
            out = new Vec2();
          }

          _vec2$1.set(this._point);

          _vec2$1.subtract(this._prevPoint);

          out.set(legacyCC.view.getScaleX(), legacyCC.view.getScaleY());
          Vec2.divide(out, _vec2$1, out);
          return out;
        };

        _proto.getLocationInView = function getLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._point.x, legacyCC.view._designResolutionSize.height - this._point.y);
          return out;
        };

        _proto.getPreviousLocationInView = function getPreviousLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._prevPoint.x, legacyCC.view._designResolutionSize.height - this._prevPoint.y);
          return out;
        };

        _proto.getStartLocationInView = function getStartLocationInView(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._startPoint.x, legacyCC.view._designResolutionSize.height - this._startPoint.y);
          return out;
        };

        _proto.getID = function getID() {
          return this._id;
        };

        _proto.setTouchInfo = function setTouchInfo(id, x, y) {
          if (id === void 0) {
            id = 0;
          }

          this._prevPoint = this._point;
          this._point = new Vec2(x || 0, y || 0);
          this._id = id;

          if (!this._startPointCaptured) {
            this._startPoint = new Vec2(this._point);
            this._startPointCaptured = true;
          }
        };

        _proto.setPoint = function setPoint(x, y) {
          if (typeof x === 'object') {
            this._point.x = x.x;
            this._point.y = x.y;
          } else {
            this._point.x = x || 0;
            this._point.y = y || 0;
          }

          this._lastModified = legacyCC.game.frameStartTime;
        };

        _proto.setPrevPoint = function setPrevPoint(x, y) {
          if (typeof x === 'object') {
            this._prevPoint = new Vec2(x.x, x.y);
          } else {
            this._prevPoint = new Vec2(x || 0, y || 0);
          }

          this._lastModified = legacyCC.game.frameStartTime;
        };

        _createClass(Touch, [{
          key: "lastModified",
          get: function get() {
            return this._lastModified;
          }
        }]);

        return Touch;
      }());
      legacyCC.Touch = Touch;

      var AccelerometerInputSource = function () {
        function AccelerometerInputSource() {
          this._intervalInMileSeconds = 200;
          this._accelTimer = 0;
          this._eventTarget = new EventTarget();
          this._deviceEventName = void 0;
          this._globalEventClass = void 0;
          this._didAccelerateFunc = void 0;
          this._globalEventClass = window.DeviceMotionEvent || window.DeviceOrientationEvent;

          if (systemInfo.browserType === BrowserType.MOBILE_QQ) {
            this._globalEventClass = window.DeviceOrientationEvent;
          }

          this._deviceEventName = this._globalEventClass === window.DeviceMotionEvent ? 'devicemotion' : 'deviceorientation';
          this._didAccelerateFunc = this._didAccelerate.bind(this);
        }

        var _proto = AccelerometerInputSource.prototype;

        _proto._registerEvent = function _registerEvent() {
          this._accelTimer = performance.now();
          window.addEventListener(this._deviceEventName, this._didAccelerateFunc, false);
        };

        _proto._unregisterEvent = function _unregisterEvent() {
          this._accelTimer = 0;
          window.removeEventListener(this._deviceEventName, this._didAccelerateFunc, false);
        };

        _proto._didAccelerate = function _didAccelerate(event) {
          var now = performance.now();

          if (now - this._accelTimer < this._intervalInMileSeconds) {
            return;
          }

          this._accelTimer = now;
          var x = 0;
          var y = 0;
          var z = 0;

          if (this._globalEventClass === window.DeviceMotionEvent) {
            var deviceMotionEvent = event;
            var _eventAcceleration = deviceMotionEvent.accelerationIncludingGravity;
            x = ((_eventAcceleration === null || _eventAcceleration === void 0 ? void 0 : _eventAcceleration.x) || 0) * 0.1;
            y = ((_eventAcceleration === null || _eventAcceleration === void 0 ? void 0 : _eventAcceleration.y) || 0) * 0.1;
            z = ((_eventAcceleration === null || _eventAcceleration === void 0 ? void 0 : _eventAcceleration.z) || 0) * 0.1;
          } else {
            var deviceOrientationEvent = event;
            x = (deviceOrientationEvent.gamma || 0) / 90 * 0.981;
            y = -((deviceOrientationEvent.beta || 0) / 90) * 0.981;
            z = (deviceOrientationEvent.alpha || 0) / 90 * 0.981;
          }

          if (screenAdapter.isFrameRotated) {
            var tmp = x;
            x = -y;
            y = tmp;
          }
          var LANDSCAPE_LEFT = -90;
          var PORTRAIT_UPSIDE_DOWN = 180;
          var LANDSCAPE_RIGHT = 90;
          var tmpX = x;

          if (window.orientation === LANDSCAPE_RIGHT) {
            x = -y;
            y = tmpX;
          } else if (window.orientation === LANDSCAPE_LEFT) {
            x = y;
            y = -tmpX;
          } else if (window.orientation === PORTRAIT_UPSIDE_DOWN) {
            x = -x;
            y = -y;
          }

          if (systemInfo.os === OS.ANDROID && systemInfo.browserType !== BrowserType.MOBILE_QQ) {
            x = -x;
            y = -y;
          }

          var timestamp = performance.now();
          var acceleration = new Acceleration(x, y, z, timestamp);
          var eventAcceleration = new EventAcceleration(acceleration);

          this._eventTarget.emit(InputEventType.DEVICEMOTION, eventAcceleration);
        };

        _proto.start = function start() {
          var _this = this;

          if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission().then(function (response) {
              if (response === 'granted') {
                _this._registerEvent();
              }
            })["catch"](function (e) {});
          } else {
            this._registerEvent();
          }
        };

        _proto.stop = function stop() {
          this._unregisterEvent();
        };

        _proto.setInterval = function setInterval(intervalInMileSeconds) {
          this._intervalInMileSeconds = intervalInMileSeconds;
        };

        _proto.on = function on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        };

        return AccelerometerInputSource;
      }();

      var code2KeyCode = {
        Backspace: KeyCode.BACKSPACE,
        Tab: KeyCode.TAB,
        Enter: KeyCode.ENTER,
        ShiftLeft: KeyCode.SHIFT_LEFT,
        ControlLeft: KeyCode.CTRL_LEFT,
        AltLeft: KeyCode.ALT_LEFT,
        ShiftRight: KeyCode.SHIFT_RIGHT,
        ControlRight: KeyCode.CTRL_RIGHT,
        AltRight: KeyCode.ALT_RIGHT,
        Pause: KeyCode.PAUSE,
        CapsLock: KeyCode.CAPS_LOCK,
        Escape: KeyCode.ESCAPE,
        Space: KeyCode.SPACE,
        PageUp: KeyCode.PAGE_UP,
        PageDown: KeyCode.PAGE_DOWN,
        End: KeyCode.END,
        Home: KeyCode.HOME,
        ArrowLeft: KeyCode.ARROW_LEFT,
        ArrowUp: KeyCode.ARROW_UP,
        ArrowRight: KeyCode.ARROW_RIGHT,
        ArrowDown: KeyCode.ARROW_DOWN,
        Insert: KeyCode.INSERT,
        Delete: KeyCode.DELETE,
        Digit0: KeyCode.DIGIT_0,
        Digit1: KeyCode.DIGIT_1,
        Digit2: KeyCode.DIGIT_2,
        Digit3: KeyCode.DIGIT_3,
        Digit4: KeyCode.DIGIT_4,
        Digit5: KeyCode.DIGIT_5,
        Digit6: KeyCode.DIGIT_6,
        Digit7: KeyCode.DIGIT_7,
        Digit8: KeyCode.DIGIT_8,
        Digit9: KeyCode.DIGIT_9,
        KeyA: KeyCode.KEY_A,
        KeyB: KeyCode.KEY_B,
        KeyC: KeyCode.KEY_C,
        KeyD: KeyCode.KEY_D,
        KeyE: KeyCode.KEY_E,
        KeyF: KeyCode.KEY_F,
        KeyG: KeyCode.KEY_G,
        KeyH: KeyCode.KEY_H,
        KeyI: KeyCode.KEY_I,
        KeyJ: KeyCode.KEY_J,
        KeyK: KeyCode.KEY_K,
        KeyL: KeyCode.KEY_L,
        KeyM: KeyCode.KEY_M,
        KeyN: KeyCode.KEY_N,
        KeyO: KeyCode.KEY_O,
        KeyP: KeyCode.KEY_P,
        KeyQ: KeyCode.KEY_Q,
        KeyR: KeyCode.KEY_R,
        KeyS: KeyCode.KEY_S,
        KeyT: KeyCode.KEY_T,
        KeyU: KeyCode.KEY_U,
        KeyV: KeyCode.KEY_V,
        KeyW: KeyCode.KEY_W,
        KeyX: KeyCode.KEY_X,
        KeyY: KeyCode.KEY_Y,
        KeyZ: KeyCode.KEY_Z,
        Numpad0: KeyCode.NUM_0,
        Numpad1: KeyCode.NUM_1,
        Numpad2: KeyCode.NUM_2,
        Numpad3: KeyCode.NUM_3,
        Numpad4: KeyCode.NUM_4,
        Numpad5: KeyCode.NUM_5,
        Numpad6: KeyCode.NUM_6,
        Numpad7: KeyCode.NUM_7,
        Numpad8: KeyCode.NUM_8,
        Numpad9: KeyCode.NUM_9,
        NumpadMultiply: KeyCode.NUM_MULTIPLY,
        NumpadAdd: KeyCode.NUM_PLUS,
        NumpadSubtract: KeyCode.NUM_SUBTRACT,
        NumpadDecimal: KeyCode.NUM_DECIMAL,
        NumpadDivide: KeyCode.NUM_DIVIDE,
        NumpadEnter: KeyCode.NUM_ENTER,
        F1: KeyCode.F1,
        F2: KeyCode.F2,
        F3: KeyCode.F3,
        F4: KeyCode.F4,
        F5: KeyCode.F5,
        F6: KeyCode.F6,
        F7: KeyCode.F7,
        F8: KeyCode.F8,
        F9: KeyCode.F9,
        F10: KeyCode.F10,
        F11: KeyCode.F11,
        F12: KeyCode.F12,
        NumLock: KeyCode.NUM_LOCK,
        ScrollLock: KeyCode.SCROLL_LOCK,
        Semicolon: KeyCode.SEMICOLON,
        Equal: KeyCode.EQUAL,
        Comma: KeyCode.COMMA,
        Minus: KeyCode.DASH,
        Period: KeyCode.PERIOD,
        Slash: KeyCode.SLASH,
        Backquote: KeyCode.BACK_QUOTE,
        BracketLeft: KeyCode.BRACKET_LEFT,
        Backslash: KeyCode.BACKSLASH,
        BracketRight: KeyCode.BRACKET_RIGHT,
        Quote: KeyCode.QUOTE
      };

      function getKeyCode(code) {
        return code2KeyCode[code] || KeyCode.NONE;
      }

      var KeyboardInputSource = function () {
        function KeyboardInputSource() {
          this._eventTarget = new EventTarget();

          this._registerEvent();
        }

        var _proto = KeyboardInputSource.prototype;

        _proto._registerEvent = function _registerEvent() {
          var _this = this;

          var canvas = document.getElementById('GameCanvas');
          canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('keydown', function (event) {
            event.stopPropagation();
            event.preventDefault();

            if (!event.repeat) {
              var keyDownInputEvent = _this._getInputEvent(event, InputEventType.KEY_DOWN);

              _this._eventTarget.emit(InputEventType.KEY_DOWN, keyDownInputEvent);
            } else {
              var keyPressingInputEvent = _this._getInputEvent(event, InputEventType.KEY_PRESSING);

              _this._eventTarget.emit(InputEventType.KEY_PRESSING, keyPressingInputEvent);
            }
          });
          canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('keyup', function (event) {
            var inputEvent = _this._getInputEvent(event, InputEventType.KEY_UP);

            event.stopPropagation();
            event.preventDefault();

            _this._eventTarget.emit(InputEventType.KEY_UP, inputEvent);
          });
        };

        _proto._getInputEvent = function _getInputEvent(event, eventType) {
          var keyCode = getKeyCode(event.code);
          var eventKeyboard = new EventKeyboard(keyCode, eventType);
          return eventKeyboard;
        };

        _proto.on = function on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        };

        return KeyboardInputSource;
      }();

      var MouseInputSource = function () {
        function MouseInputSource() {
          this._canvas = void 0;
          this._eventTarget = new EventTarget();
          this._pointLocked = false;
          this._isPressed = false;
          this._preMousePos = new Vec2();

          if (systemInfo.hasFeature(Feature$1.EVENT_MOUSE)) {
            this._canvas = document.getElementById('GameCanvas');

            if (!this._canvas && !TEST) {
              console.warn('failed to access canvas');
            }

            this._registerEvent();
          }
        }

        var _proto = MouseInputSource.prototype;

        _proto._getCanvasRect = function _getCanvasRect() {
          var canvas = this._canvas;
          var box = canvas === null || canvas === void 0 ? void 0 : canvas.getBoundingClientRect();

          if (box) {
            return new Rect(box.x, box.y, box.width, box.height);
          }

          return new Rect(0, 0, 0, 0);
        };

        _proto._getLocation = function _getLocation(mouseEvent) {
          var canvasRect = this._getCanvasRect();

          var dpr = screenAdapter.devicePixelRatio;
          var x = this._pointLocked ? this._preMousePos.x / dpr + mouseEvent.movementX : mouseEvent.clientX - canvasRect.x;
          var y = this._pointLocked ? this._preMousePos.y / dpr - mouseEvent.movementY : canvasRect.y + canvasRect.height - mouseEvent.clientY;
          x *= dpr;
          y *= dpr;
          return new Vec2(x, y);
        };

        _proto._registerEvent = function _registerEvent() {
          var _this = this,
              _this$_canvas,
              _this$_canvas2,
              _this$_canvas3,
              _this$_canvas4;

          window.addEventListener('mousedown', function () {
            _this._isPressed = true;
          });
          (_this$_canvas = this._canvas) === null || _this$_canvas === void 0 ? void 0 : _this$_canvas.addEventListener('mousedown', this._createCallback(InputEventType.MOUSE_DOWN));
          (_this$_canvas2 = this._canvas) === null || _this$_canvas2 === void 0 ? void 0 : _this$_canvas2.addEventListener('mousemove', this._createCallback(InputEventType.MOUSE_MOVE));

          var handleMouseUp = this._createCallback(InputEventType.MOUSE_UP);

          window.addEventListener('mouseup', handleMouseUp);
          (_this$_canvas3 = this._canvas) === null || _this$_canvas3 === void 0 ? void 0 : _this$_canvas3.addEventListener('mouseup', handleMouseUp);
          (_this$_canvas4 = this._canvas) === null || _this$_canvas4 === void 0 ? void 0 : _this$_canvas4.addEventListener('wheel', this._handleMouseWheel.bind(this));

          this._registerPointerLockEvent();
        };

        _proto._registerPointerLockEvent = function _registerPointerLockEvent() {
          var _this2 = this;

          var lockChangeAlert = function lockChangeAlert() {
            var canvas = _this2._canvas;

            if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
              _this2._pointLocked = true;
            } else {
              _this2._pointLocked = false;
            }
          };

          if ('onpointerlockchange' in document) {
            document.addEventListener('pointerlockchange', lockChangeAlert, false);
          } else if ('onmozpointerlockchange' in document) {
            document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
          }
        };

        _proto._createCallback = function _createCallback(eventType) {
          var _this3 = this;

          return function (mouseEvent) {
            var _this3$_canvas;

            var location = _this3._getLocation(mouseEvent);

            var button = mouseEvent.button;

            switch (eventType) {
              case InputEventType.MOUSE_DOWN:
                (_this3$_canvas = _this3._canvas) === null || _this3$_canvas === void 0 ? void 0 : _this3$_canvas.focus();
                _this3._isPressed = true;
                break;

              case InputEventType.MOUSE_UP:
                _this3._isPressed = false;
                break;

              case InputEventType.MOUSE_MOVE:
                if (!_this3._isPressed) {
                  button = EventMouse.BUTTON_MISSING;
                }

                break;
            }

            var eventMouse = new EventMouse(eventType, false, _this3._preMousePos);
            eventMouse.setLocation(location.x, location.y);
            eventMouse.setButton(button);
            eventMouse.movementX = mouseEvent.movementX;
            eventMouse.movementY = mouseEvent.movementY;

            _this3._preMousePos.set(location.x, location.y);

            mouseEvent.stopPropagation();

            if (mouseEvent.target === _this3._canvas) {
              mouseEvent.preventDefault();
            }

            _this3._eventTarget.emit(eventType, eventMouse);
          };
        };

        _proto._handleMouseWheel = function _handleMouseWheel(mouseEvent) {
          var eventType = InputEventType.MOUSE_WHEEL;

          var location = this._getLocation(mouseEvent);

          var button = mouseEvent.button;
          var eventMouse = new EventMouse(eventType, false, this._preMousePos);
          eventMouse.setLocation(location.x, location.y);
          eventMouse.setButton(button);
          eventMouse.movementX = mouseEvent.movementX;
          eventMouse.movementY = mouseEvent.movementY;
          var wheelSensitivityFactor = 5;
          eventMouse.setScrollData(mouseEvent.deltaX * wheelSensitivityFactor, -mouseEvent.deltaY * wheelSensitivityFactor);

          this._preMousePos.set(location.x, location.y);

          mouseEvent.stopPropagation();

          if (mouseEvent.target === this._canvas) {
            mouseEvent.preventDefault();
          }

          this._eventTarget.emit(eventType, eventMouse);
        };

        _proto.on = function on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        };

        return MouseInputSource;
      }();

      var tempVec2 = new Vec2();

      var TouchManager = function () {
        function TouchManager() {
          this._touchMap = void 0;
          this._maxTouches = 8;
          this._touchMap = new Map();
        }

        var _proto = TouchManager.prototype;

        _proto._cloneTouch = function _cloneTouch(touch) {
          var touchID = touch.getID();
          touch.getStartLocation(tempVec2);
          var clonedTouch = new Touch(tempVec2.x, tempVec2.y, touchID);
          touch.getLocation(tempVec2);
          clonedTouch.setPoint(tempVec2.x, tempVec2.y);
          touch.getPreviousLocation(tempVec2);
          clonedTouch.setPrevPoint(tempVec2);
          return clonedTouch;
        };

        _proto._createTouch = function _createTouch(touchID, x, y) {
          if (this._touchMap.has(touchID)) {
            console.log('Cannot create the same touch object.');
            return undefined;
          }

          var checkResult = this._checkTouchMapSizeMoreThanMax(touchID);

          if (checkResult) {
            console.log('The touches is more than MAX_TOUCHES.');
            return undefined;
          }

          var touch = new Touch(x, y, touchID);

          this._touchMap.set(touchID, touch);

          this._updateTouch(touch, x, y);

          return this._cloneTouch(touch);
        };

        _proto.releaseTouch = function releaseTouch(touchID) {
          if (!this._touchMap.has(touchID)) {
            return;
          }

          this._touchMap["delete"](touchID);
        };

        _proto.getTouch = function getTouch(touchID, x, y) {
          var touch = this._touchMap.get(touchID);

          if (!touch) {
            touch = this._createTouch(touchID, x, y);
          } else {
            this._updateTouch(touch, x, y);
          }

          return touch ? this._cloneTouch(touch) : undefined;
        };

        _proto.getAllTouches = function getAllTouches() {
          var _this = this;

          var touches = [];

          this._touchMap.forEach(function (touch) {
            if (touch) {
              var clonedTouch = _this._cloneTouch(touch);

              touches.push(clonedTouch);
            }
          });

          return touches;
        };

        _proto._updateTouch = function _updateTouch(touch, x, y) {
          touch.getLocation(tempVec2);
          touch.setPrevPoint(tempVec2);
          touch.setPoint(x, y);
        };

        _proto._checkTouchMapSizeMoreThanMax = function _checkTouchMapSizeMoreThanMax(touchID) {
          var _this2 = this;

          if (this._touchMap.has(touchID)) {
            return false;
          }

          var maxSize = macro.ENABLE_MULTI_TOUCH ? this._maxTouches : 1;

          if (this._touchMap.size < maxSize) {
            return false;
          }

          var now = performance.now();

          this._touchMap.forEach(function (touch) {
            if (now - touch.lastModified > macro.TOUCH_TIMEOUT) {
              console.log("The touches is more than MAX_TOUCHES, release touch id " + touch.getID() + ".");

              _this2.releaseTouch(touch.getID());
            }
          });

          return maxSize >= this._touchMap.size;
        };

        return TouchManager;
      }();

      var touchManager = new TouchManager();

      var TouchInputSource = function () {
        function TouchInputSource() {
          this._canvas = void 0;
          this._eventTarget = new EventTarget();

          if (systemInfo.hasFeature(Feature$1.INPUT_TOUCH)) {
            this._canvas = document.getElementById('GameCanvas');

            if (!this._canvas && !TEST) {
              console.warn('failed to access canvas');
            }

            this._registerEvent();
          }
        }

        var _proto = TouchInputSource.prototype;

        _proto._registerEvent = function _registerEvent() {
          var _this$_canvas, _this$_canvas2, _this$_canvas3, _this$_canvas4;

          (_this$_canvas = this._canvas) === null || _this$_canvas === void 0 ? void 0 : _this$_canvas.addEventListener('touchstart', this._createCallback(InputEventType.TOUCH_START));
          (_this$_canvas2 = this._canvas) === null || _this$_canvas2 === void 0 ? void 0 : _this$_canvas2.addEventListener('touchmove', this._createCallback(InputEventType.TOUCH_MOVE));
          (_this$_canvas3 = this._canvas) === null || _this$_canvas3 === void 0 ? void 0 : _this$_canvas3.addEventListener('touchend', this._createCallback(InputEventType.TOUCH_END));
          (_this$_canvas4 = this._canvas) === null || _this$_canvas4 === void 0 ? void 0 : _this$_canvas4.addEventListener('touchcancel', this._createCallback(InputEventType.TOUCH_CANCEL));
        };

        _proto._createCallback = function _createCallback(eventType) {
          var _this = this;

          return function (event) {
            var canvasRect = _this._getCanvasRect();

            var handleTouches = [];
            var length = event.changedTouches.length;

            for (var i = 0; i < length; ++i) {
              var changedTouch = event.changedTouches[i];
              var touchID = changedTouch.identifier;

              if (touchID === null) {
                continue;
              }

              var location = _this._getLocation(changedTouch, canvasRect);

              var touch = touchManager.getTouch(touchID, location.x, location.y);

              if (!touch) {
                continue;
              }

              if (eventType === InputEventType.TOUCH_END || eventType === InputEventType.TOUCH_CANCEL) {
                touchManager.releaseTouch(touchID);
              }

              handleTouches.push(touch);
            }

            event.stopPropagation();

            if (event.target === _this._canvas) {
              event.preventDefault();
            }

            if (eventType === InputEventType.TOUCH_START) {
              var _this$_canvas5;

              (_this$_canvas5 = _this._canvas) === null || _this$_canvas5 === void 0 ? void 0 : _this$_canvas5.focus();
            }

            if (handleTouches.length > 0) {
              var eventTouch = new EventTouch(handleTouches, false, eventType, macro.ENABLE_MULTI_TOUCH ? touchManager.getAllTouches() : handleTouches);

              _this._eventTarget.emit(eventType, eventTouch);
            }
          };
        };

        _proto._getCanvasRect = function _getCanvasRect() {
          var canvas = this._canvas;
          var box = canvas === null || canvas === void 0 ? void 0 : canvas.getBoundingClientRect();

          if (box) {
            return new Rect(box.x, box.y, box.width, box.height);
          }

          return new Rect(0, 0, 0, 0);
        };

        _proto._getLocation = function _getLocation(touch, canvasRect) {
          var x = touch.clientX - canvasRect.x;
          var y = canvasRect.y + canvasRect.height - touch.clientY;

          if (screenAdapter.isFrameRotated) {
            var tmp = x;
            x = canvasRect.height - y;
            y = tmp;
          }

          var dpr = screenAdapter.devicePixelRatio;
          x *= dpr;
          y *= dpr;
          return new Vec2(x, y);
        };

        _proto.on = function on(eventType, callback, target) {
          this._eventTarget.on(eventType, callback, target);
        };

        return TouchInputSource;
      }();

      var _pointerEventTypeMap;
      var EventDispatcherPriority;

      (function (EventDispatcherPriority) {
        EventDispatcherPriority[EventDispatcherPriority["GLOBAL"] = 0] = "GLOBAL";
        EventDispatcherPriority[EventDispatcherPriority["UI"] = 1] = "UI";
      })(EventDispatcherPriority || (EventDispatcherPriority = {}));

      var InputEventDispatcher = function () {
        function InputEventDispatcher(inputEventTarget) {
          this.priority = EventDispatcherPriority.GLOBAL;
          this._inputEventTarget = void 0;
          this._inputEventTarget = inputEventTarget;
        }

        var _proto = InputEventDispatcher.prototype;

        _proto.dispatchEvent = function dispatchEvent(event) {
          this._inputEventTarget.emit(event.type, event);

          return true;
        };

        return InputEventDispatcher;
      }();

      var pointerEventTypeMap = (_pointerEventTypeMap = {}, _pointerEventTypeMap[InputEventType.MOUSE_DOWN] = InputEventType.TOUCH_START, _pointerEventTypeMap[InputEventType.MOUSE_MOVE] = InputEventType.TOUCH_MOVE, _pointerEventTypeMap[InputEventType.MOUSE_UP] = InputEventType.TOUCH_END, _pointerEventTypeMap);
      var Input = exports('Input', function () {
        function Input() {
          this._dispatchImmediately = !NATIVE;
          this._eventTarget = new EventTarget();
          this._touchInput = new TouchInputSource();
          this._mouseInput = new MouseInputSource();
          this._keyboardInput = new KeyboardInputSource();
          this._accelerometerInput = new AccelerometerInputSource();
          this._eventTouchList = [];
          this._eventMouseList = [];
          this._eventKeyboardList = [];
          this._eventAccelerationList = [];
          this._needSimulateTouchMoveEvent = false;
          this._inputEventDispatcher = void 0;
          this._eventDispatcherList = [];

          this._registerEvent();

          this._inputEventDispatcher = new InputEventDispatcher(this._eventTarget);

          this._registerEventDispatcher(this._inputEventDispatcher);
        }

        var _proto2 = Input.prototype;

        _proto2.on = function on(eventType, callback, target) {

          this._eventTarget.on(eventType, callback, target);

          return callback;
        };

        _proto2.once = function once(eventType, callback, target) {

          this._eventTarget.once(eventType, callback, target);

          return callback;
        };

        _proto2.off = function off(eventType, callback, target) {

          this._eventTarget.off(eventType, callback, target);
        };

        _proto2.setAccelerometerEnabled = function setAccelerometerEnabled(isEnable) {

          if (isEnable) {
            this._accelerometerInput.start();
          } else {
            this._accelerometerInput.stop();
          }
        };

        _proto2.setAccelerometerInterval = function setAccelerometerInterval(intervalInMileSeconds) {

          this._accelerometerInput.setInterval(intervalInMileSeconds);
        };

        _proto2._simulateEventTouch = function _simulateEventTouch(eventMouse) {
          var eventType = pointerEventTypeMap[eventMouse.type];
          var touchID = 0;
          var touch = touchManager.getTouch(touchID, eventMouse.getLocationX(), eventMouse.getLocationY());

          if (!touch) {
            return;
          }

          var changedTouches = [touch];
          var eventTouch = new EventTouch(changedTouches, false, eventType, changedTouches);

          if (eventType === InputEventType.TOUCH_END) {
            touchManager.releaseTouch(touchID);
          }

          this._dispatchOrPushEventTouch(eventTouch, this._eventTouchList);
        };

        _proto2._registerEventDispatcher = function _registerEventDispatcher(eventDispatcher) {
          this._eventDispatcherList.push(eventDispatcher);

          this._eventDispatcherList.sort(function (a, b) {
            return b.priority - a.priority;
          });
        };

        _proto2._emitEvent = function _emitEvent(event) {
          var length = this._eventDispatcherList.length;

          for (var i = 0; i < length; ++i) {
            var dispatcher = this._eventDispatcherList[i];

            if (!dispatcher.dispatchEvent(event)) {
              break;
            }
          }
        };

        _proto2._registerEvent = function _registerEvent() {
          var _this = this;

          if (sys.hasFeature(sys.Feature.INPUT_TOUCH)) {
            var eventTouchList = this._eventTouchList;

            this._touchInput.on(InputEventType.TOUCH_START, function (event) {
              _this._dispatchOrPushEventTouch(event, eventTouchList);
            });

            this._touchInput.on(InputEventType.TOUCH_MOVE, function (event) {
              _this._dispatchOrPushEventTouch(event, eventTouchList);
            });

            this._touchInput.on(InputEventType.TOUCH_END, function (event) {
              _this._dispatchOrPushEventTouch(event, eventTouchList);
            });

            this._touchInput.on(InputEventType.TOUCH_CANCEL, function (event) {
              _this._dispatchOrPushEventTouch(event, eventTouchList);
            });
          }

          if (sys.hasFeature(sys.Feature.EVENT_MOUSE)) {
            var eventMouseList = this._eventMouseList;

            this._mouseInput.on(InputEventType.MOUSE_DOWN, function (event) {
              _this._needSimulateTouchMoveEvent = true;

              _this._simulateEventTouch(event);

              _this._dispatchOrPushEvent(event, eventMouseList);
            });

            this._mouseInput.on(InputEventType.MOUSE_MOVE, function (event) {
              if (_this._needSimulateTouchMoveEvent) {
                _this._simulateEventTouch(event);
              }

              _this._dispatchOrPushEvent(event, eventMouseList);
            });

            this._mouseInput.on(InputEventType.MOUSE_UP, function (event) {
              _this._needSimulateTouchMoveEvent = false;

              _this._simulateEventTouch(event);

              _this._dispatchOrPushEvent(event, eventMouseList);
            });

            this._mouseInput.on(InputEventType.MOUSE_WHEEL, function (event) {
              _this._dispatchOrPushEvent(event, eventMouseList);
            });
          }

          if (sys.hasFeature(sys.Feature.EVENT_KEYBOARD)) {
            var eventKeyboardList = this._eventKeyboardList;

            this._keyboardInput.on(InputEventType.KEY_DOWN, function (event) {
              _this._dispatchOrPushEvent(event, eventKeyboardList);
            });

            this._keyboardInput.on(InputEventType.KEY_PRESSING, function (event) {
              _this._dispatchOrPushEvent(event, eventKeyboardList);
            });

            this._keyboardInput.on(InputEventType.KEY_UP, function (event) {
              _this._dispatchOrPushEvent(event, eventKeyboardList);
            });
          }

          if (sys.hasFeature(sys.Feature.EVENT_ACCELEROMETER)) {
            var eventAccelerationList = this._eventAccelerationList;

            this._accelerometerInput.on(InputEventType.DEVICEMOTION, function (event) {
              _this._dispatchOrPushEvent(event, eventAccelerationList);
            });
          }
        };

        _proto2._clearEvents = function _clearEvents() {
          this._eventMouseList.length = 0;
          this._eventTouchList.length = 0;
          this._eventKeyboardList.length = 0;
          this._eventAccelerationList.length = 0;
        };

        _proto2._dispatchOrPushEvent = function _dispatchOrPushEvent(event, eventList) {
          if (this._dispatchImmediately) {
            this._emitEvent(event);
          } else {
            eventList.push(event);
          }
        };

        _proto2._dispatchOrPushEventTouch = function _dispatchOrPushEventTouch(eventTouch, touchEventList) {
          if (this._dispatchImmediately) {
            var touches = eventTouch.getTouches();
            var touchesLength = touches.length;

            for (var i = 0; i < touchesLength; ++i) {
              eventTouch.touch = touches[i];
              eventTouch.propagationStopped = eventTouch.propagationImmediateStopped = false;

              this._emitEvent(eventTouch);
            }
          } else {
            touchEventList.push(eventTouch);
          }
        };

        _proto2._frameDispatchEvents = function _frameDispatchEvents() {
          var eventMouseList = this._eventMouseList;

          for (var i = 0, length = eventMouseList.length; i < length; ++i) {
            var eventMouse = eventMouseList[i];

            this._emitEvent(eventMouse);
          }

          var eventTouchList = this._eventTouchList;

          for (var _i = 0, _length = eventTouchList.length; _i < _length; ++_i) {
            var eventTouch = eventTouchList[_i];
            var touches = eventTouch.getTouches();
            var touchesLength = touches.length;

            for (var j = 0; j < touchesLength; ++j) {
              eventTouch.touch = touches[j];
              eventTouch.propagationStopped = eventTouch.propagationImmediateStopped = false;

              this._emitEvent(eventTouch);
            }
          }

          var eventKeyboardList = this._eventKeyboardList;

          for (var _i2 = 0, _length2 = eventKeyboardList.length; _i2 < _length2; ++_i2) {
            var eventKeyboard = eventKeyboardList[_i2];

            this._emitEvent(eventKeyboard);
          }

          var eventAccelerationList = this._eventAccelerationList;

          for (var _i3 = 0, _length3 = eventAccelerationList.length; _i3 < _length3; ++_i3) {
            var eventAcceleration = eventAccelerationList[_i3];

            this._emitEvent(eventAcceleration);
          }

          this._clearEvents();
        };

        return Input;
      }());
      Input.EventType = InputEventType;
      var input = exports('input', new Input());

      var SystemEvent = exports('SystemEvent', function (_EventTarget) {
        _inheritsLoose(SystemEvent, _EventTarget);

        function SystemEvent() {
          var _this;

          _this = _EventTarget.call(this) || this;
          input.on(InputEventType.MOUSE_DOWN, function (e) {
            _this.emit(SystemEventType.MOUSE_DOWN, e);
          });
          input.on(InputEventType.MOUSE_MOVE, function (e) {
            _this.emit(SystemEventType.MOUSE_MOVE, e);
          });
          input.on(InputEventType.MOUSE_UP, function (e) {
            _this.emit(SystemEventType.MOUSE_UP, e);
          });
          input.on(InputEventType.MOUSE_WHEEL, function (e) {
            _this.emit(SystemEventType.MOUSE_WHEEL, e);
          });
          input.on(InputEventType.TOUCH_START, function (e) {
            _this.emit(SystemEventType.TOUCH_START, e.touch, e);
          });
          input.on(InputEventType.TOUCH_MOVE, function (e) {
            _this.emit(SystemEventType.TOUCH_MOVE, e.touch, e);
          });
          input.on(InputEventType.TOUCH_END, function (e) {
            _this.emit(SystemEventType.TOUCH_END, e.touch, e);
          });
          input.on(InputEventType.TOUCH_CANCEL, function (e) {
            _this.emit(SystemEventType.TOUCH_CANCEL, e.touch, e);
          });
          input.on(InputEventType.KEY_DOWN, function (e) {
            _this.emit(SystemEventType.KEY_DOWN, e);
          });
          input.on(InputEventType.KEY_PRESSING, function (e) {
            _this.emit(SystemEventType.KEY_DOWN, e);
          });
          input.on(InputEventType.KEY_UP, function (e) {
            _this.emit(SystemEventType.KEY_UP, e);
          });
          input.on(InputEventType.DEVICEMOTION, function (e) {
            _this.emit(SystemEventType.DEVICEMOTION, e);
          });
          return _this;
        }

        var _proto = SystemEvent.prototype;

        _proto.setAccelerometerEnabled = function setAccelerometerEnabled(isEnabled) {
          input.setAccelerometerEnabled(isEnabled);
        };

        _proto.setAccelerometerInterval = function setAccelerometerInterval(interval) {
          input.setAccelerometerInterval(interval);
        };

        _proto.on = function on(type, callback, target, once) {
          _EventTarget.prototype.on.call(this, type, callback, target, once);

          return callback;
        };

        _proto.off = function off(type, callback, target) {
          _EventTarget.prototype.off.call(this, type, callback, target);
        };

        return SystemEvent;
      }(EventTarget));
      SystemEvent.EventType = SystemEventType;
      legacyCC.SystemEvent = SystemEvent;
      var systemEvent = exports('systemEvent', new SystemEvent());
      legacyCC.systemEvent = systemEvent;

      replaceProperty(SystemEventType, 'Node.EventType', [{
        name: 'POSITION_PART',
        newName: 'TRANSFORM_CHANGED'
      }, {
        name: 'ROTATION_PART',
        newName: 'TRANSFORM_CHANGED'
      }, {
        name: 'SCALE_PART',
        newName: 'TRANSFORM_CHANGED'
      }]);
      replaceProperty(Event, 'Event', [{
        name: 'ACCELERATION',
        newName: 'DEVICEMOTION',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      markAsWarning(Event, 'Event', [{
        name: 'TOUCH',
        suggest: 'please use SystemEvent.EventType.TOUCH_START, SystemEvent.EventType.TOUCH_MOVE, SystemEvent.EventType.TOUCH_END and SystemEvent.EventType.TOUCH_CANCEL instead'
      }, {
        name: 'MOUSE',
        suggest: 'please use SystemEvent.EventType.MOUSE_DOWN, SystemEvent.EventType.MOUSE_MOVE, SystemEvent.EventType.MOUSE_UP, SystemEvent.EventType.MOUSE_WHEEL, Node.EventType.MOUSE_ENTER and Node.EventType.MOUSE_LEAVE instead'
      }, {
        name: 'KEYBOARD',
        suggest: 'please use SystemEvent.EventType.KEY_DOWN and SystemEvent.EventType.KEY_UP instead'
      }]);
      replaceProperty(EventMouse, 'EventMouse', ['DOWN', 'UP', 'MOVE'].map(function (item) {
        return {
          name: item,
          newName: "MOUSE_" + item,
          target: SystemEvent.EventType,
          targetName: 'SystemEvent.EventType'
        };
      }));
      replaceProperty(EventMouse, 'EventMouse', [{
        name: 'SCROLL',
        newName: 'MOUSE_WHEEL',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      markAsWarning(EventMouse.prototype, 'EventMouse.prototype', [{
        name: 'eventType',
        suggest: 'please use EventMouse.prototype.type instead'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'BEGAN',
        newName: 'TOUCH_START',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'MOVED',
        newName: 'TOUCH_MOVE',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'ENDED',
        newName: 'TOUCH_END',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      replaceProperty(EventTouch, 'EventTouch', [{
        name: 'CANCELLED',
        newName: 'TOUCH_CANCEL',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      markAsWarning(EventTouch.prototype, 'EventTouch.prototype', [{
        name: 'getEventCode',
        suggest: 'please use EventTouch.prototype.type instead'
      }]);
      replaceProperty(EventTouch.prototype, 'EventTouch.prototype', [{
        name: 'getUILocationInView',
        newName: 'getLocationInView',
        target: EventTouch,
        targetName: 'EventTouch'
      }]);
      markAsWarning(macro.KEY, 'macro.KEY', ['back', 'menu', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '*', '+', '-', '/', ';', '=', ',', '.', '[', ']', 'dpadLeft', 'dpadRight', 'dpadUp', 'dpadDown', 'dpadCenter'].map(function (item) {
        return {
          name: item
        };
      }));
      markAsWarning(macro.KEY, 'macro.KEY', [{
        name: 'shift',
        suggest: 'please use KeyCode.SHIFT_LEFT instead'
      }]);
      markAsWarning(macro.KEY, 'macro.KEY', [{
        name: 'ctrl',
        suggest: 'please use KeyCode.CTRL_LEFT instead'
      }]);
      markAsWarning(macro.KEY, 'macro.KEY', [{
        name: 'alt',
        suggest: 'please use KeyCode.ALT_LEFT instead'
      }]);
      markAsWarning(macro, 'macro', [{
        name: 'KEY',
        suggest: 'please use KeyCode instead'
      }]);

      var _dec$u, _class$u;
      replaceProperty(BaseNode.prototype, 'BaseNode', [{
        name: 'childrenCount',
        newName: 'children.length',
        customGetter: function customGetter() {
          return this.children.length;
        }
      }]);
      replaceProperty(Node$1.prototype, 'Node', [{
        name: 'width',
        targetName: 'node.getComponent(UITransform)',
        customGetter: function customGetter() {
          return this._uiProps.uiTransformComp.width;
        },
        customSetter: function customSetter(value) {
          this._uiProps.uiTransformComp.width = value;
        }
      }, {
        name: 'height',
        targetName: 'node.getComponent(UITransform)',
        customGetter: function customGetter() {
          return this._uiProps.uiTransformComp.height;
        },
        customSetter: function customSetter(value) {
          this._uiProps.uiTransformComp.height = value;
        }
      }, {
        name: 'anchorX',
        targetName: 'node.getComponent(UITransform)',
        customGetter: function customGetter() {
          return this._uiProps.uiTransformComp.anchorX;
        },
        customSetter: function customSetter(value) {
          this._uiProps.uiTransformComp.anchorX = value;
        }
      }, {
        name: 'anchorY',
        targetName: 'node.getComponent(UITransform)',
        customGetter: function customGetter() {
          return this._uiProps.uiTransformComp.anchorY;
        },
        customSetter: function customSetter(value) {
          this._uiProps.uiTransformComp.anchorY = value;
        }
      }, {
        name: 'getAnchorPoint',
        targetName: 'node.getComponent(UITransform)',
        customFunction: function customFunction(out) {
          if (!out) {
            out = new Vec2();
          }

          out.set(this._uiProps.uiTransformComp.anchorPoint);
          return out;
        }
      }, {
        name: 'setAnchorPoint',
        targetName: 'node.getComponent(UITransform)',
        customFunction: function customFunction(point, y) {
          this._uiProps.uiTransformComp.setAnchorPoint(point, y);
        }
      }, {
        name: 'getContentSize',
        targetName: 'node.getComponent(UITransform)',
        customFunction: function customFunction(out) {
          if (!out) {
            out = new Size();
          }

          out.set(this._uiProps.uiTransformComp.contentSize);
          return out;
        }
      }, {
        name: 'setContentSize',
        targetName: 'node.getComponent(UITransform)',
        customFunction: function customFunction(size, height) {
          if (typeof size === 'number') {
            this._uiProps.uiTransformComp.setContentSize(size, height);
          } else {
            this._uiProps.uiTransformComp.setContentSize(size);
          }
        }
      }]);
      removeProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
        name: 'aspect'
      }, {
        name: 'selfShadow'
      }, {
        name: 'linear'
      }, {
        name: 'packing'
      }, {
        name: 'autoAdapt'
      }, {
        name: 'fixedArea'
      }, {
        name: 'pcf'
      }, {
        name: 'bias'
      }, {
        name: 'normalBias'
      }, {
        name: 'near'
      }, {
        name: 'far'
      }, {
        name: 'shadowDistance'
      }, {
        name: 'invisibleOcclusionRange'
      }, {
        name: 'orthoSize'
      }, {
        name: 'saturation'
      }]);
      replaceProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
        name: 'distance',
        newName: 'planeHeight'
      }, {
        name: 'normal',
        newName: 'planeDirection'
      }]);
      removeProperty(Node$1.prototype, 'Node.prototype', [{
        name: 'addLayer'
      }, {
        name: 'removeLayer'
      }]);
      replaceProperty(NodeUIProperties.prototype, 'NodeUIProperties', [{
        name: 'opacityDirty',
        newName: 'colorDirty'
      }]);
      removeProperty(Layers, 'Layers', [{
        name: 'All'
      }, {
        name: 'RaycastMask'
      }, {
        name: 'check'
      }]);
      replaceProperty(Layers, 'Layers', [{
        name: 'Default',
        newName: 'DEFAULT',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'Always',
        newName: 'ALWAYS',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'IgnoreRaycast',
        newName: 'IGNORE_RAYCAST',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'Gizmos',
        newName: 'GIZMOS',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'Editor',
        newName: 'EDITOR',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'UI',
        newName: 'UI_3D',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'UI2D',
        newName: 'UI_2D',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'SceneGizmo',
        newName: 'SCENE_GIZMO',
        target: Layers.Enum,
        targetName: 'Layers.Enum'
      }, {
        name: 'makeInclusiveMask',
        newName: 'makeMaskInclude',
        target: Layers,
        targetName: 'Layers'
      }, {
        name: 'makeExclusiveMask',
        newName: 'makeMaskExclude',
        target: Layers,
        targetName: 'Layers'
      }]);
      removeProperty(Layers.Enum, 'Layers.Enum', [{
        name: 'ALWAYS'
      }]);
      removeProperty(Layers.BitMask, 'Layers.BitMask', [{
        name: 'ALWAYS'
      }]);
      var HideInHierarchy$1 = CCObject.Flags.HideInHierarchy;
      var DontSave$1 = CCObject.Flags.DontSave;
      var PrivateNode = exports('PrivateNode', (_dec$u = ccclass('cc.PrivateNode'), _dec$u(_class$u = function (_Node) {
        _inheritsLoose(PrivateNode, _Node);

        function PrivateNode(name) {
          var _this;

          _this = _Node.call(this, name) || this;
          warnID(12003, _this.name);
          _this.hideFlags |= DontSave$1 | HideInHierarchy$1;
          return _this;
        }

        return PrivateNode;
      }(Node$1)) || _class$u));

      replaceProperty(SystemEventType, 'SystemEventType', ['MOUSE_ENTER', 'MOUSE_LEAVE', 'TRANSFORM_CHANGED', 'SCENE_CHANGED_FOR_PERSISTS', 'SIZE_CHANGED', 'ANCHOR_CHANGED', 'COLOR_CHANGED', 'CHILD_ADDED', 'CHILD_REMOVED', 'PARENT_CHANGED', 'NODE_DESTROYED', 'LAYER_CHANGED', 'SIBLING_ORDER_CHANGED'].map(function (name) {
        return {
          name: name,
          target: Node$1.EventType,
          targetName: 'Node.EventType'
        };
      }));
      replaceProperty(Node$1.EventType, 'Node.EventType', [{
        name: 'DEVICEMOTION',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }, {
        name: 'KEY_DOWN',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }, {
        name: 'KEY_UP',
        target: SystemEvent.EventType,
        targetName: 'SystemEvent.EventType'
      }]);
      legacyCC.PrivateNode = PrivateNode;

      var _dec$v, _class$v, _class2$r, _descriptor$l, _descriptor2$g, _temp$s;
      var Scene = exports('Scene', (_dec$v = ccclass('cc.Scene'), _dec$v(_class$v = (_class2$r = (_temp$s = function (_BaseNode) {
        _inheritsLoose(Scene, _BaseNode);

        var _proto = Scene.prototype;

        _proto._updateScene = function _updateScene() {
          this._scene = this;
        };

        _proto._init = function _init() {
        };

        function Scene(name) {
          var _this;

          _this = _BaseNode.call(this, name) || this;

          _initializerDefineProperty(_this, "autoReleaseAssets", _descriptor$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_globals", _descriptor2$g, _assertThisInitialized(_this));

          _this.dependAssets = null;
          _this._renderScene = null;
          _this._inited = void 0;
          _this._prefabSyncedInLiveReload = false;
          _this._pos = Vec3.ZERO;
          _this._rot = Quat.IDENTITY;
          _this._scale = Vec3.ONE;
          _this._mat = Mat4.IDENTITY;
          _this._dirtyFlags = 0;
          _this._lpos = Vec3.ZERO;
          _this._lrot = Quat.IDENTITY;
          _this._lscale = Vec3.ONE;
          _this._activeInHierarchy = false;

          if (legacyCC.director && legacyCC.director.root) {
            _this._renderScene = legacyCC.director.root.createScene({});
          }

          _this._inited = legacyCC.game ? !legacyCC.game._isCloning : true;

          _this._init();

          return _this;
        }

        _proto.destroy = function destroy() {
          var success = CCObject.prototype.destroy.call(this);

          if (success) {
            var children = this._children;

            for (var i = 0; i < children.length; ++i) {
              children[i].active = false;
            }
          }

          if (this._renderScene) legacyCC.director.root.destroyScene(this._renderScene);
          this._active = false;
          this._activeInHierarchy = false;
          return success;
        };

        _proto.addComponent = function addComponent() {
          throw new Error(getError(3822));
        };

        _proto._onHierarchyChanged = function _onHierarchyChanged() {};

        _proto._onBatchCreated = function _onBatchCreated(dontSyncChildPrefab) {
          _BaseNode.prototype._onBatchCreated.call(this, dontSyncChildPrefab);

          var len = this._children.length;

          for (var i = 0; i < len; ++i) {
            this.children[i]._siblingIndex = i;

            this._children[i]._onBatchCreated(dontSyncChildPrefab);
          }
        };

        _proto.getPosition = function getPosition(out) {
          return Vec3.copy(out || new Vec3(), Vec3.ZERO);
        };

        _proto.getRotation = function getRotation(out) {
          return Quat.copy(out || new Quat(), Quat.IDENTITY);
        };

        _proto.getScale = function getScale(out) {
          return Vec3.copy(out || new Vec3(), Vec3.ONE);
        };

        _proto.getWorldPosition = function getWorldPosition(out) {
          return Vec3.copy(out || new Vec3(), Vec3.ZERO);
        };

        _proto.getWorldRotation = function getWorldRotation(out) {
          return Quat.copy(out || new Quat(), Quat.IDENTITY);
        };

        _proto.getWorldScale = function getWorldScale(out) {
          return Vec3.copy(out || new Vec3(), Vec3.ONE);
        };

        _proto.getWorldMatrix = function getWorldMatrix(out) {
          return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
        };

        _proto.getWorldRS = function getWorldRS(out) {
          return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
        };

        _proto.getWorldRT = function getWorldRT(out) {
          return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
        };

        _proto.updateWorldTransform = function updateWorldTransform() {};

        _proto._instantiate = function _instantiate() {};

        _proto._load = function _load() {
          if (!this._inited) {

            expandNestedPrefabInstanceNode(this);
            applyTargetOverrides(this);

            this._onBatchCreated(EDITOR );

            this._inited = true;
          }

          this.walk(BaseNode._setScene);
        };

        _proto._activate = function _activate(active) {
          active = active !== false;

          legacyCC.director._nodeActivator.activateNode(this, active);

          {
            this._globals.activate();

            if (this._renderScene) {
              this._renderScene.activate();
            }
          }
        };

        _createClass(Scene, [{
          key: "renderScene",
          get: function get() {
            return this._renderScene;
          }
        }, {
          key: "globals",
          get: function get() {
            return this._globals;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "position",
          get: function get() {
            return Vec3.ZERO;
          }
        }, {
          key: "worldPosition",
          get: function get() {
            return Vec3.ZERO;
          }
        }, {
          key: "rotation",
          get: function get() {
            return Quat.IDENTITY;
          }
        }, {
          key: "worldRotation",
          get: function get() {
            return Quat.IDENTITY;
          }
        }, {
          key: "scale",
          get: function get() {
            return Vec3.ONE;
          }
        }, {
          key: "worldScale",
          get: function get() {
            return Vec3.ONE;
          }
        }, {
          key: "eulerAngles",
          get: function get() {
            return Vec3.ZERO;
          }
        }, {
          key: "worldMatrix",
          get: function get() {
            return Mat4.IDENTITY;
          }
        }]);

        return Scene;
      }(BaseNode), _temp$s), (_applyDecoratedDescriptor(_class2$r.prototype, "globals", [editable], Object.getOwnPropertyDescriptor(_class2$r.prototype, "globals"), _class2$r.prototype), _descriptor$l = _applyDecoratedDescriptor(_class2$r.prototype, "autoReleaseAssets", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor2$g = _applyDecoratedDescriptor(_class2$r.prototype, "_globals", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new SceneGlobals();
        }
      })), _class2$r)) || _class$v));
      legacyCC.Scene = Scene;

      function find(path, referenceNode) {
        if (!referenceNode) {
          var scene = legacyCC.director.getScene();

          if (!scene) {

            return null;
          }

          referenceNode = scene;
        }

        return referenceNode.getChildByPath(path);
      }
      legacyCC.find = find;

      var fastRemoveAt$2 = array.fastRemoveAt;
      var IsStartCalled$1 = CCObject.Flags.IsStartCalled;
      var IsOnEnableCalled$1 = CCObject.Flags.IsOnEnableCalled;
      var IsEditorOnEnableCalled$1 = CCObject.Flags.IsEditorOnEnableCalled;

      function sortedIndex(array, comp) {
        var order = comp.constructor._executionOrder;
        var id = comp._id;
        var l = 0;

        for (var h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
          var test = array[m];
          var testOrder = test.constructor._executionOrder;

          if (testOrder > order) {
            h = m - 1;
          } else if (testOrder < order) {
            l = m + 1;
          } else {
            var testId = test._id;

            if (testId > id) {
              h = m - 1;
            } else if (testId < id) {
              l = m + 1;
            } else {
              return m;
            }
          }
        }

        return ~l;
      }

      function stableRemoveInactive(iterator, flagToClear) {
        var array = iterator.array;
        var next = iterator.i + 1;

        while (next < array.length) {
          var comp = array[next];

          if (comp.node._activeInHierarchy) {
            ++next;
          } else {
            iterator.removeAt(next);

            if (flagToClear) {
              comp._objFlags &= ~flagToClear;
            }
          }
        }
      }

      var LifeCycleInvoker = function LifeCycleInvoker(invokeFunc) {
        this._zero = void 0;
        this._neg = void 0;
        this._pos = void 0;
        this._invoke = void 0;
        var Iterator = MutableForwardIterator;
        this._zero = new Iterator([]);
        this._neg = new Iterator([]);
        this._pos = new Iterator([]);

        this._invoke = invokeFunc;
      };
      LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;

      function compareOrder(a, b) {
        return a.constructor._executionOrder - b.constructor._executionOrder;
      }

      var OneOffInvoker = function (_LifeCycleInvoker) {
        _inheritsLoose(OneOffInvoker, _LifeCycleInvoker);

        function OneOffInvoker() {
          return _LifeCycleInvoker.apply(this, arguments) || this;
        }

        var _proto = OneOffInvoker.prototype;

        _proto.add = function add(comp) {
          var order = comp.constructor._executionOrder;
          (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
        };

        _proto.remove = function remove(comp) {
          var order = comp.constructor._executionOrder;
          (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
        };

        _proto.cancelInactive = function cancelInactive(flagToClear) {
          stableRemoveInactive(this._zero, flagToClear);
          stableRemoveInactive(this._neg, flagToClear);
          stableRemoveInactive(this._pos, flagToClear);
        };

        _proto.invoke = function invoke() {
          var compsNeg = this._neg;

          if (compsNeg.array.length > 0) {
            compsNeg.array.sort(compareOrder);

            this._invoke(compsNeg);

            compsNeg.array.length = 0;
          }

          this._invoke(this._zero);

          this._zero.array.length = 0;
          var compsPos = this._pos;

          if (compsPos.array.length > 0) {
            compsPos.array.sort(compareOrder);

            this._invoke(compsPos);

            compsPos.array.length = 0;
          }
        };

        return OneOffInvoker;
      }(LifeCycleInvoker);

      var ReusableInvoker = function (_LifeCycleInvoker2) {
        _inheritsLoose(ReusableInvoker, _LifeCycleInvoker2);

        function ReusableInvoker() {
          return _LifeCycleInvoker2.apply(this, arguments) || this;
        }

        var _proto2 = ReusableInvoker.prototype;

        _proto2.add = function add(comp) {
          var order = comp.constructor._executionOrder;

          if (order === 0) {
            this._zero.array.push(comp);
          } else {
            var _array = order < 0 ? this._neg.array : this._pos.array;

            var i = sortedIndex(_array, comp);

            if (i < 0) {
              _array.splice(~i, 0, comp);
            }
          }
        };

        _proto2.remove = function remove(comp) {
          var order = comp.constructor._executionOrder;

          if (order === 0) {
            this._zero.fastRemove(comp);
          } else {
            var iterator = order < 0 ? this._neg : this._pos;
            var i = sortedIndex(iterator.array, comp);

            if (i >= 0) {
              iterator.removeAt(i);
            }
          }
        };

        _proto2.invoke = function invoke(dt) {
          if (this._neg.array.length > 0) {
            this._invoke(this._neg, dt);
          }

          this._invoke(this._zero, dt);

          if (this._pos.array.length > 0) {
            this._invoke(this._pos, dt);
          }
        };

        return ReusableInvoker;
      }(LifeCycleInvoker);

      function createInvokeImplJit(code, useDt, ensureFlag) {
        var body = "" + ('var a=it.array;' + 'for(it.i=0;it.i<a.length;++it.i){' + 'var c=a[it.i];') + code + "}";
        var fastPath = useDt ? Function('it', 'dt', body) : Function('it', body);
        var singleInvoke = Function('c', 'dt', code);
        return createInvokeImpl(singleInvoke, fastPath, ensureFlag);
      }
      function createInvokeImpl(singleInvoke, fastPath, ensureFlag) {
        return function (iterator, dt) {
          try {
            fastPath(iterator, dt);
          } catch (e) {
            legacyCC._throw(e);

            var _array2 = iterator.array;

            if (ensureFlag) {
              _array2[iterator.i]._objFlags |= ensureFlag;
            }

            ++iterator.i;

            for (; iterator.i < _array2.length; ++iterator.i) {
              try {
                singleInvoke(_array2[iterator.i], dt);
              } catch (e) {
                legacyCC._throw(e);

                if (ensureFlag) {
                  _array2[iterator.i]._objFlags |= ensureFlag;
                }
              }
            }
          }
        };
      }
      var invokeStart =  createInvokeImplJit("c.start();c._objFlags|=" + IsStartCalled$1, false, IsStartCalled$1) ;
      var invokeUpdate =  createInvokeImplJit('c.update(dt)', true) ;
      var invokeLateUpdate =  createInvokeImplJit('c.lateUpdate(dt)', true) ;
      var invokeOnEnable =  function (iterator) {
        var compScheduler = legacyCC.director._compScheduler;
        var array = iterator.array;

        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var comp = array[iterator.i];

          if (comp._enabled) {
            comp.onEnable();
            var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

            if (!deactivatedDuringOnEnable) {
              compScheduler._onEnabled(comp);
            }
          }
        }
      };
      var ComponentScheduler = function () {
        function ComponentScheduler() {
          this._deferredComps = [];
          this.unscheduleAll();
        }

        var _proto3 = ComponentScheduler.prototype;

        _proto3.unscheduleAll = function unscheduleAll() {
          this.startInvoker = new OneOffInvoker(invokeStart);
          this.updateInvoker = new ReusableInvoker(invokeUpdate);
          this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate);
          this._updating = false;
        };

        _proto3._onEnabled = function _onEnabled(comp) {
          legacyCC.director.getScheduler().resumeTarget(comp);
          comp._objFlags |= IsOnEnableCalled$1;

          if (this._updating) {
            this._deferredComps.push(comp);
          } else {
            this._scheduleImmediate(comp);
          }
        };

        _proto3._onDisabled = function _onDisabled(comp) {
          legacyCC.director.getScheduler().pauseTarget(comp);
          comp._objFlags &= ~IsOnEnableCalled$1;

          var index = this._deferredComps.indexOf(comp);

          if (index >= 0) {
            fastRemoveAt$2(this._deferredComps, index);
            return;
          }

          if (comp.start && !(comp._objFlags & IsStartCalled$1)) {
            this.startInvoker.remove(comp);
          }

          if (comp.update) {
            this.updateInvoker.remove(comp);
          }

          if (comp.lateUpdate) {
            this.lateUpdateInvoker.remove(comp);
          }
        };

        _proto3.enableComp = function enableComp(comp, invoker) {
          if (!(comp._objFlags & IsOnEnableCalled$1)) {
            if (comp.onEnable) {
              if (invoker) {
                invoker.add(comp);
                return;
              } else {
                comp.onEnable();
                var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

                if (deactivatedDuringOnEnable) {
                  return;
                }
              }
            }

            this._onEnabled(comp);
          }
        };

        _proto3.disableComp = function disableComp(comp) {
          if (comp._objFlags & IsOnEnableCalled$1) {
            if (comp.onDisable) {
              comp.onDisable();
            }

            this._onDisabled(comp);
          }
        };

        _proto3.startPhase = function startPhase() {
          this._updating = true;
          this.startInvoker.invoke();

          this._startForNewComps();
        };

        _proto3.updatePhase = function updatePhase(dt) {
          this.updateInvoker.invoke(dt);
        };

        _proto3.lateUpdatePhase = function lateUpdatePhase(dt) {
          this.lateUpdateInvoker.invoke(dt);
          this._updating = false;

          this._startForNewComps();
        };

        _proto3._startForNewComps = function _startForNewComps() {
          if (this._deferredComps.length > 0) {
            this._deferredSchedule();

            this.startInvoker.invoke();
          }
        };

        _proto3._scheduleImmediate = function _scheduleImmediate(comp) {
          if (typeof comp.start === 'function' && !(comp._objFlags & IsStartCalled$1)) {
            this.startInvoker.add(comp);
          }

          if (typeof comp.update === 'function') {
            this.updateInvoker.add(comp);
          }

          if (typeof comp.lateUpdate === 'function') {
            this.lateUpdateInvoker.add(comp);
          }
        };

        _proto3._deferredSchedule = function _deferredSchedule() {
          var comps = this._deferredComps;

          for (var i = 0, len = comps.length; i < len; i++) {
            this._scheduleImmediate(comps[i]);
          }

          comps.length = 0;
        };

        return ComponentScheduler;
      }();

      var MAX_POOL_SIZE = 4;
      var IsPreloadStarted$1 = CCObject.Flags.IsPreloadStarted;
      var IsOnLoadStarted$1 = CCObject.Flags.IsOnLoadStarted;
      var IsOnLoadCalled$2 = CCObject.Flags.IsOnLoadCalled;
      var Deactivating$2 = CCObject.Flags.Deactivating;

      var UnsortedInvoker = function (_LifeCycleInvoker) {
        _inheritsLoose(UnsortedInvoker, _LifeCycleInvoker);

        function UnsortedInvoker() {
          return _LifeCycleInvoker.apply(this, arguments) || this;
        }

        var _proto = UnsortedInvoker.prototype;

        _proto.add = function add(comp) {
          this._zero.array.push(comp);
        };

        _proto.remove = function remove(comp) {
          this._zero.fastRemove(comp);
        };

        _proto.cancelInactive = function cancelInactive(flagToClear) {
          LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
        };

        _proto.invoke = function invoke() {
          this._invoke(this._zero);

          this._zero.array.length = 0;
        };

        return UnsortedInvoker;
      }(LifeCycleInvoker);

      var invokePreload =  createInvokeImplJit('c.__preload();') ;
      var invokeOnLoad =  createInvokeImplJit("c.onLoad();c._objFlags|=" + IsOnLoadCalled$2, false, IsOnLoadCalled$2) ;
      var activateTasksPool = new Pool(MAX_POOL_SIZE);

      activateTasksPool.get = function getActivateTask() {
        var task = this._get() || {
          preload: new UnsortedInvoker(invokePreload),
          onLoad: new OneOffInvoker(invokeOnLoad),
          onEnable: new OneOffInvoker(invokeOnEnable)
        };
        task.preload._zero.i = -1;
        var invoker = task.onLoad;
        invoker._zero.i = -1;
        invoker._neg.i = -1;
        invoker._pos.i = -1;
        invoker = task.onEnable;
        invoker._zero.i = -1;
        invoker._neg.i = -1;
        invoker._pos.i = -1;
        return task;
      };

      function _componentCorrupted(node, comp, index) {
        errorID(3817, node.name, index);
        console.log('Corrupted component value:', comp);

        if (comp) {
          node._removeComponent(comp);
        } else {
          array.removeAt(node._components, index);
        }
      }

      var NodeActivator = exports('NodeActivator', function () {
        function NodeActivator() {
          this.resetComp = void 0;
          this.reset();
        }

        var _proto2 = NodeActivator.prototype;

        _proto2.reset = function reset() {
          this._activatingStack = [];
        };

        _proto2.activateNode = function activateNode(node, active) {
          if (active) {
            var task = activateTasksPool.get();

            this._activatingStack.push(task);

            this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);

            task.preload.invoke();
            task.onLoad.invoke();
            task.onEnable.invoke();

            this._activatingStack.pop();

            activateTasksPool.put(task);
          } else {
            this._deactivateNodeRecursively(node);

            var stack = this._activatingStack;

            for (var _iterator = _createForOfIteratorHelperLoose(stack), _step; !(_step = _iterator()).done;) {
              var lastTask = _step.value;
              lastTask.preload.cancelInactive(IsPreloadStarted$1);
              lastTask.onLoad.cancelInactive(IsOnLoadStarted$1);
              lastTask.onEnable.cancelInactive();
            }
          }

          node.emit(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, node);
        };

        _proto2.activateComp = function activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
          if (!isValid(comp, true)) {
            return;
          }

          if (!(comp._objFlags & IsPreloadStarted$1)) {
            comp._objFlags |= IsPreloadStarted$1;

            if (comp.__preload) {
              if (preloadInvoker) {
                preloadInvoker.add(comp);
              } else {
                comp.__preload();
              }
            }
          }

          if (!(comp._objFlags & IsOnLoadStarted$1)) {
            comp._objFlags |= IsOnLoadStarted$1;

            if (comp.onLoad) {
              if (onLoadInvoker) {
                onLoadInvoker.add(comp);
              } else {
                comp.onLoad();
                comp._objFlags |= IsOnLoadCalled$2;
              }
            } else {
              comp._objFlags |= IsOnLoadCalled$2;
            }
          }

          if (comp._enabled) {
            {
              assertIsTrue(comp.node, getError(3823, comp.uuid, comp.name));
            }

            var deactivatedOnLoading = !comp.node._activeInHierarchy;

            if (deactivatedOnLoading) {
              return;
            }

            legacyCC.director._compScheduler.enableComp(comp, onEnableInvoker);
          }
        };

        _proto2.destroyComp = function destroyComp(comp) {
          legacyCC.director._compScheduler.disableComp(comp);

          if (comp.onDestroy && comp._objFlags & IsOnLoadCalled$2) {
            comp.onDestroy();
          }
        };

        _proto2._activateNodeRecursively = function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
          if (node._objFlags & Deactivating$2) {
            errorID(3816, node.name);
            return;
          }

          node._activeInHierarchy = true;
          var originCount = node._components.length;

          for (var i = 0; i < originCount; ++i) {
            var component = node._components[i];

            if (component instanceof legacyCC.Component) {
              this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker);
            } else {
              _componentCorrupted(node, component, i);

              --i;
              --originCount;
            }
          }

          for (var _i = 0, len = node._children.length; _i < len; ++_i) {
            var child = node._children[_i];

            if (child._active) {
              this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
            }
          }

          node._onPostActivated(true);
        };

        _proto2._deactivateNodeRecursively = function _deactivateNodeRecursively(node) {

          node._objFlags |= Deactivating$2;
          node._activeInHierarchy = false;
          var originCount = node._components.length;

          for (var c = 0; c < originCount; ++c) {
            var component = node._components[c];

            if (component._enabled) {
              legacyCC.director._compScheduler.disableComp(component);

              if (node._activeInHierarchy) {
                node._objFlags &= ~Deactivating$2;
                return;
              }
            }
          }

          for (var i = 0, len = node._children.length; i < len; ++i) {
            var child = node._children[i];

            if (child._activeInHierarchy) {
              this._deactivateNodeRecursively(child);

              if (node._activeInHierarchy) {
                node._objFlags &= ~Deactivating$2;
                return;
              }
            }
          }

          node._onPostActivated(false);

          node._objFlags &= ~Deactivating$2;
        };

        return NodeActivator;
      }());

      var _dec$w, _class$w, _class2$s, _descriptor$m, _temp$t;
      var SceneAsset = exports('SceneAsset', (_dec$w = ccclass('cc.SceneAsset'), _dec$w(_class$w = (_class2$s = (_temp$t = function (_Asset) {
        _inheritsLoose(SceneAsset, _Asset);

        function SceneAsset() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "scene", _descriptor$m, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = SceneAsset.prototype;

        _proto.initDefault = function initDefault(uuid) {
          _Asset.prototype.initDefault.call(this, uuid);

          this.scene = new Scene('New Scene');
        };

        _proto.validate = function validate() {
          return !!this.scene;
        };

        return SceneAsset;
      }(Asset), _temp$t), (_descriptor$m = _applyDecoratedDescriptor(_class2$s.prototype, "scene", [editable, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$s)) || _class$w));
      legacyCC.SceneAsset = SceneAsset;

      var _dec$x, _class$x, _class2$t, _descriptor$n, _temp$u;
      var TextAsset = exports('TextAsset', (_dec$x = ccclass('cc.TextAsset'), _dec$x(_class$x = (_class2$t = (_temp$u = function (_Asset) {
        _inheritsLoose(TextAsset, _Asset);

        function TextAsset() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "text", _descriptor$n, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = TextAsset.prototype;

        _proto.toString = function toString() {
          return this.text;
        };

        return TextAsset;
      }(Asset), _temp$u), (_descriptor$n = _applyDecoratedDescriptor(_class2$t.prototype, "text", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      })), _class2$t)) || _class$x));
      legacyCC.TextAsset = TextAsset;

      var _dec$y, _class$y, _class2$u, _descriptor$o, _temp$v;
      var JsonAsset = exports('JsonAsset', (_dec$y = ccclass('cc.JsonAsset'), _dec$y(_class$y = (_class2$u = (_temp$v = function (_Asset) {
        _inheritsLoose(JsonAsset, _Asset);

        function JsonAsset() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "json", _descriptor$o, _assertThisInitialized(_this));

          return _this;
        }

        return JsonAsset;
      }(Asset), _temp$v), (_descriptor$o = _applyDecoratedDescriptor(_class2$u.prototype, "json", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$u)) || _class$y));
      legacyCC.JsonAsset = JsonAsset;

      var GEOMETRY_RENDERER_TECHNIQUE_COUNT = 6;
      var PipelineSceneData = function () {
        var _proto = PipelineSceneData.prototype;

        _proto._init = function _init() {
        };

        function PipelineSceneData() {
          this.fog = new Fog();
          this.ambient = new Ambient();
          this.skybox = new Skybox();
          this.shadows = new Shadows();
          this.octree = new Octree();
          this.validPunctualLights = [];
          this.renderObjects = [];
          this.castShadowObjects = [];
          this.dirShadowObjects = [];
          this.shadowFrameBufferMap = new Map();
          this._geometryRendererMaterials = [];
          this._geometryRendererPasses = [];
          this._geometryRendererShaders = [];
          this._occlusionQueryVertexBuffer = null;
          this._occlusionQueryIndicesBuffer = null;
          this._occlusionQueryInputAssembler = null;
          this._occlusionQueryMaterial = null;
          this._occlusionQueryShader = null;
          this._isHDR = true;
          this._shadingScale = 1.0;

          this._init();

          this.shadingScale = 1.0;
        }

        _proto.activate = function activate(device, pipeline) {
          this._device = device;
          this._pipeline = pipeline;
          this.initGeometryRendererMaterials();
          this.initOcclusionQuery();
          return true;
        };

        _proto.initGeometryRendererMaterials = function initGeometryRendererMaterials() {
          var offset = 0;

          for (var tech = 0; tech < GEOMETRY_RENDERER_TECHNIQUE_COUNT; tech++) {
            this._geometryRendererMaterials[tech] = new Material();
            this._geometryRendererMaterials[tech]._uuid = "geometry-renderer-material-" + tech;

            this._geometryRendererMaterials[tech].initialize({
              effectName: 'geometry-renderer',
              technique: tech
            });

            for (var pass = 0; pass < this._geometryRendererMaterials[tech].passes.length; ++pass) {
              this._geometryRendererPasses[offset] = this._geometryRendererMaterials[tech].passes[pass];
              this._geometryRendererShaders[offset] = this._geometryRendererMaterials[tech].passes[pass].getShaderVariant();
              offset++;
            }
          }
        };

        _proto.initOcclusionQuery = function initOcclusionQuery() {
          if (!this._occlusionQueryInputAssembler) {
            this._occlusionQueryInputAssembler = this._createOcclusionQueryIA();
          }

          if (!this._occlusionQueryMaterial) {
            var mat = new Material();
            mat._uuid = 'default-occlusion-query-material';
            mat.initialize({
              effectName: 'occlusion-query'
            });
            this._occlusionQueryMaterial = mat;
            this._occlusionQueryShader = mat.passes[0].getShaderVariant();
          }
        };

        _proto.getOcclusionQueryPass = function getOcclusionQueryPass() {
          return this._occlusionQueryMaterial.passes[0];
        };

        _proto.onGlobalPipelineStateChanged = function onGlobalPipelineStateChanged() {};

        _proto.destroy = function destroy() {
          var _this$_occlusionQuery, _this$_occlusionQuery2, _this$_occlusionQuery3;

          this.ambient.destroy();
          this.skybox.destroy();
          this.fog.destroy();
          this.shadows.destroy();
          this.octree.destroy();
          this.validPunctualLights.length = 0;
          (_this$_occlusionQuery = this._occlusionQueryInputAssembler) === null || _this$_occlusionQuery === void 0 ? void 0 : _this$_occlusionQuery.destroy();
          this._occlusionQueryInputAssembler = null;
          (_this$_occlusionQuery2 = this._occlusionQueryVertexBuffer) === null || _this$_occlusionQuery2 === void 0 ? void 0 : _this$_occlusionQuery2.destroy();
          this._occlusionQueryVertexBuffer = null;
          (_this$_occlusionQuery3 = this._occlusionQueryIndicesBuffer) === null || _this$_occlusionQuery3 === void 0 ? void 0 : _this$_occlusionQuery3.destroy();
          this._occlusionQueryIndicesBuffer = null;
        };

        _proto._createOcclusionQueryIA = function _createOcclusionQueryIA() {
          var device = this._device;
          var vertices = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1]);
          var vbStride = Float32Array.BYTES_PER_ELEMENT * 3;
          var vbSize = vbStride * 8;
          this._occlusionQueryVertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbSize, vbStride));

          this._occlusionQueryVertexBuffer.update(vertices);

          var indices = new Uint16Array([0, 2, 1, 1, 2, 3, 4, 5, 6, 5, 7, 6, 1, 3, 7, 1, 7, 5, 0, 4, 6, 0, 6, 2, 0, 1, 5, 0, 5, 4, 2, 6, 7, 2, 7, 3]);
          var ibStride = Uint16Array.BYTES_PER_ELEMENT;
          var ibSize = ibStride * 36;
          this._occlusionQueryIndicesBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibSize, ibStride));

          this._occlusionQueryIndicesBuffer.update(indices);

          var attributes = [new Attribute('a_position', Format.RGB32F)];
          var info = new InputAssemblerInfo(attributes, [this._occlusionQueryVertexBuffer], this._occlusionQueryIndicesBuffer);
          var inputAssembler = device.createInputAssembler(info);
          return inputAssembler;
        };

        _createClass(PipelineSceneData, [{
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "isHDR",
          get: function get() {
            return this._isHDR;
          },
          set: function set(val) {
            this._isHDR = val;
          }
        }, {
          key: "shadingScale",
          get: function get() {
            return this._shadingScale;
          },
          set: function set(val) {
            if (this._shadingScale !== val) {
              this._shadingScale = val;

              this._pipeline.emit(PipelineEventType.ATTACHMENT_SCALE_CAHNGED, val);
            }
          }
        }, {
          key: "geometryRendererPasses",
          get: function get() {
            return this._geometryRendererPasses;
          }
        }, {
          key: "geometryRendererShaders",
          get: function get() {
            return this._geometryRendererShaders;
          }
        }]);

        return PipelineSceneData;
      }();

      var _dec$z, _dec2$f, _dec3$a, _class$z, _class2$v, _descriptor$p, _temp$w;
      var PIPELINE_TYPE = 0;
      var ForwardPipeline = exports('ForwardPipeline', (_dec$z = ccclass('ForwardPipeline'), _dec2$f = type([RenderTextureConfig]), _dec3$a = displayOrder(), _dec$z(_class$z = (_class2$v = (_temp$w = function (_RenderPipeline) {
        _inheritsLoose(ForwardPipeline, _RenderPipeline);

        function ForwardPipeline() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _RenderPipeline.call.apply(_RenderPipeline, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "renderTextures", _descriptor$p, _assertThisInitialized(_this));

          _this._postRenderPass = null;
          return _this;
        }

        var _proto = ForwardPipeline.prototype;

        _proto.initialize = function initialize(info) {
          _RenderPipeline.prototype.initialize.call(this, info);

          if (this._flows.length === 0) {
            var shadowFlow = new ShadowFlow();
            shadowFlow.initialize(ShadowFlow.initInfo);

            this._flows.push(shadowFlow);

            var forwardFlow = new ForwardFlow();
            forwardFlow.initialize(ForwardFlow.initInfo);

            this._flows.push(forwardFlow);
          }

          return true;
        };

        _proto.activate = function activate(swapchain) {

          this._macros = {
            CC_PIPELINE_TYPE: PIPELINE_TYPE
          };
          this._pipelineSceneData = new PipelineSceneData();

          if (!_RenderPipeline.prototype.activate.call(this, swapchain)) {
            return false;
          }

          if (!this._activeRenderer(swapchain)) {
            errorID(2402);
            return false;
          }

          return true;
        };

        _proto._ensureEnoughSize = function _ensureEnoughSize(cameras) {
          var newWidth = this._width;
          var newHeight = this._height;

          for (var i = 0; i < cameras.length; ++i) {
            var window = cameras[i].window;
            newWidth = Math.max(window.width, newWidth);
            newHeight = Math.max(window.height, newHeight);
          }

          if (newWidth !== this._width || newHeight !== this._height) {
            this._width = newWidth;
            this._height = newHeight;
          }
        };

        _proto.destroy = function destroy() {
          this._destroyUBOs();

          this._destroyQuadInputAssembler();

          var rpIter = this._renderPasses.values();

          var rpRes = rpIter.next();

          while (!rpRes.done) {
            rpRes.value.destroy();
            rpRes = rpIter.next();
          }

          this._commandBuffers.length = 0;
          return _RenderPipeline.prototype.destroy.call(this);
        };

        _proto._activeRenderer = function _activeRenderer(swapchain) {
          var device = this.device;

          this._commandBuffers.push(device.commandBuffer);

          var shadowMapSampler = this.globalDSManager.pointSampler;

          this._descriptorSet.bindSampler(UNIFORM_SHADOWMAP_BINDING, shadowMapSampler);

          this._descriptorSet.bindTexture(UNIFORM_SHADOWMAP_BINDING, builtinResMgr.get('default-texture').getGFXTexture());

          this._descriptorSet.bindSampler(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, shadowMapSampler);

          this._descriptorSet.bindTexture(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, builtinResMgr.get('default-texture').getGFXTexture());

          this._descriptorSet.update();

          return true;
        };

        _proto._destroyUBOs = function _destroyUBOs() {
          if (this._descriptorSet) {
            this._descriptorSet.getBuffer(UBOGlobal.BINDING).destroy();

            this._descriptorSet.getBuffer(UBOShadow.BINDING).destroy();

            this._descriptorSet.getBuffer(UBOCamera.BINDING).destroy();

            this._descriptorSet.getTexture(UNIFORM_SHADOWMAP_BINDING).destroy();

            this._descriptorSet.getTexture(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING).destroy();
          }
        };

        _createClass(ForwardPipeline, [{
          key: "postRenderPass",
          get: function get() {
            return this._postRenderPass;
          }
        }]);

        return ForwardPipeline;
      }(RenderPipeline), _temp$w), (_descriptor$p = _applyDecoratedDescriptor(_class2$v.prototype, "renderTextures", [_dec2$f, serializable, _dec3$a], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$v)) || _class$z));

      var _dec$A, _dec2$g, _dec3$b, _class$A, _class2$w, _descriptor$q, _class3$b, _temp$x;
      var colors$2 = [new Color$1(0, 0, 0, 0), new Color$1(0, 0, 0, 0), new Color$1(0, 0, 0, 0)];
      var GbufferStage = exports('GbufferStage', (_dec$A = ccclass('GbufferStage'), _dec2$g = type([RenderQueueDesc]), _dec3$b = displayOrder(), _dec$A(_class$A = (_class2$w = (_temp$x = _class3$b = function (_RenderStage) {
        _inheritsLoose(GbufferStage, _RenderStage);

        function GbufferStage() {
          var _this;

          _this = _RenderStage.call(this) || this;

          _initializerDefineProperty(_this, "renderQueues", _descriptor$q, _assertThisInitialized(_this));

          _this._renderQueues = [];
          _this._renderArea = new Rect$1();
          _this._batchedQueue = void 0;
          _this._instancedQueue = void 0;
          _this._phaseID = getPhaseID('default');
          _this._batchedQueue = new RenderBatchedQueue();
          _this._instancedQueue = new RenderInstancedQueue();
          return _this;
        }

        var _proto = GbufferStage.prototype;

        _proto.initialize = function initialize(info) {
          _RenderStage.prototype.initialize.call(this, info);

          if (info.renderQueues) {
            this.renderQueues = info.renderQueues;
          }

          return true;
        };

        _proto.activate = function activate(pipeline, flow) {
          _RenderStage.prototype.activate.call(this, pipeline, flow);

          for (var i = 0; i < this.renderQueues.length; i++) {
            this._renderQueues[i] = convertRenderQueue(this.renderQueues[i]);
          }
        };

        _proto.destroy = function destroy() {};

        _proto.render = function render(camera) {
          this._instancedQueue.clear();

          this._batchedQueue.clear();

          var pipeline = this._pipeline;
          var device = pipeline.device;

          this._renderQueues.forEach(renderQueueClearFunc);

          pipeline.generateRenderArea(camera, this._renderArea);
          pipeline.updateQuadVertexData(this._renderArea, camera.window);
          var renderObjects = pipeline.pipelineSceneData.renderObjects;
          var m = 0;
          var p = 0;
          var k = 0;

          for (var i = 0; i < renderObjects.length; ++i) {
            var ro = renderObjects[i];
            var subModels = ro.model.subModels;

            for (m = 0; m < subModels.length; ++m) {
              var subModel = subModels[m];
              var passes = subModel.passes;

              for (p = 0; p < passes.length; ++p) {
                var pass = passes[p];
                if (pass.phase !== this._phaseID) continue;
                var batchingScheme = pass.batchingScheme;

                if (batchingScheme === BatchingSchemes.INSTANCING) {
                  var instancedBuffer = pass.getInstancedBuffer();
                  instancedBuffer.merge(subModel, ro.model.instancedAttributes, p);

                  this._instancedQueue.queue.add(instancedBuffer);
                } else if (batchingScheme === BatchingSchemes.VB_MERGING) {
                  var batchedBuffer = pass.getBatchedBuffer();
                  batchedBuffer.merge(subModel, p, ro.model);

                  this._batchedQueue.queue.add(batchedBuffer);
                } else {
                  for (k = 0; k < this._renderQueues.length; k++) {
                    this._renderQueues[k].insertRenderPass(ro, m, p);
                  }
                }
              }
            }
          }

          this._renderQueues.forEach(renderQueueSortFunc);

          var cmdBuff = pipeline.commandBuffers[0];

          this._instancedQueue.uploadBuffers(cmdBuff);

          this._batchedQueue.uploadBuffers(cmdBuff);

          if (camera.clearFlag & ClearFlagBit.COLOR) {
            if (pipeline.pipelineSceneData.isHDR) {
              SRGBToLinear(colors$2[0], camera.clearColor);
            } else {
              colors$2[0].x = camera.clearColor.x;
              colors$2[0].y = camera.clearColor.y;
              colors$2[0].z = camera.clearColor.z;
            }
          }

          colors$2[0].w = camera.clearColor.w;
          var deferredData = pipeline.getPipelineRenderData();
          var framebuffer = deferredData.gbufferFrameBuffer;
          var renderPass = framebuffer.renderPass;
          cmdBuff.beginRenderPass(renderPass, framebuffer, this._renderArea, colors$2, camera.clearDepth, camera.clearStencil);
          cmdBuff.setScissor(pipeline.generateScissor(camera));
          cmdBuff.setViewport(pipeline.generateViewport(camera));
          cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);

          for (var _i = 0; _i < this.renderQueues.length; _i++) {
            this._renderQueues[_i].recordCommandBuffer(device, renderPass, cmdBuff);
          }

          this._instancedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          this._batchedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

          cmdBuff.endRenderPass();
        };

        return GbufferStage;
      }(RenderStage), _class3$b.initInfo = {
        name: 'GbufferStage',
        priority: DeferredStagePriority.GBUFFER,
        tag: 0,
        renderQueues: [{
          isTransparent: false,
          sortMode: RenderQueueSortMode.FRONT_TO_BACK,
          stages: ['default']
        }, {
          isTransparent: true,
          sortMode: RenderQueueSortMode.BACK_TO_FRONT,
          stages: ['default']
        }]
      }, _temp$x), (_descriptor$q = _applyDecoratedDescriptor(_class2$w.prototype, "renderQueues", [_dec2$g, serializable, _dec3$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$w)) || _class$A));

      var _dec$B, _dec2$h, _dec3$c, _dec4$7, _dec5$4, _class$B, _class2$x, _descriptor$r, _descriptor2$h, _class3$c, _temp$y;
      var colors$3 = [new Color$1(0, 0, 0, 1)];
      var LightingStage = exports('LightingStage', (_dec$B = ccclass('LightingStage'), _dec2$h = type(Material), _dec3$c = displayOrder(), _dec4$7 = type([RenderQueueDesc]), _dec5$4 = displayOrder(), _dec$B(_class$B = (_class2$x = (_temp$y = _class3$c = function (_RenderStage) {
        _inheritsLoose(LightingStage, _RenderStage);

        function LightingStage() {
          var _this;

          _this = _RenderStage.call(this) || this;
          _this._deferredLitsBufs = null;
          _this._maxDeferredLights = UBODeferredLight.LIGHTS_PER_PASS;
          _this._lightMeterScale = 10000.0;
          _this._descriptorSet = null;
          _this._renderArea = new Rect$1();
          _this._uiPhase = void 0;

          _initializerDefineProperty(_this, "_deferredMaterial", _descriptor$r, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "renderQueues", _descriptor2$h, _assertThisInitialized(_this));

          _this._phaseID = getPhaseID('default');
          _this._renderQueues = [];
          _this._uiPhase = new UIPhase();
          return _this;
        }

        var _proto = LightingStage.prototype;

        _proto.initialize = function initialize(info) {
          _RenderStage.prototype.initialize.call(this, info);

          return true;
        };

        _proto.gatherLights = function gatherLights(camera) {
          var pipeline = this._pipeline;
          var cmdBuff = pipeline.commandBuffers[0];
          var sphereLights = camera.scene.sphereLights;
          var spotLights = camera.scene.spotLights;

          var _sphere = Sphere.create(0, 0, 0, 1);

          var _vec4Array = new Float32Array(4);

          var exposure = camera.exposure;
          var idx = 0;
          var elementLen = Vec4.length;
          var fieldLen = elementLen * this._maxDeferredLights;

          for (var i = 0; i < sphereLights.length && idx < this._maxDeferredLights; i++, ++idx) {
            var light = sphereLights[i];
            Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);

            if (intersect.sphereFrustum(_sphere, camera.frustum)) {
              Vec3.toArray(_vec4Array, light.position);
              _vec4Array[3] = 0;

              this._lightBufferData.set(_vec4Array, idx * elementLen);

              Vec3.toArray(_vec4Array, light.color);

              if (light.useColorTemperature) {
                var tempRGB = light.colorTemperatureRGB;
                _vec4Array[0] *= tempRGB.x;
                _vec4Array[1] *= tempRGB.y;
                _vec4Array[2] *= tempRGB.z;
              }

              if (pipeline.pipelineSceneData.isHDR) {
                _vec4Array[3] = light.luminance * exposure * this._lightMeterScale;
              } else {
                _vec4Array[3] = light.luminance;
              }

              this._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 1);

              _vec4Array[0] = light.size;
              _vec4Array[1] = light.range;
              _vec4Array[2] = 0.0;

              this._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 2);
            }
          }

          for (var _i = 0; _i < spotLights.length && idx < this._maxDeferredLights; _i++, ++idx) {
            var _light = spotLights[_i];
            Sphere.set(_sphere, _light.position.x, _light.position.y, _light.position.z, _light.range);

            if (intersect.sphereFrustum(_sphere, camera.frustum)) {
              Vec3.toArray(_vec4Array, _light.position);
              _vec4Array[3] = 1;

              this._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 0);

              Vec3.toArray(_vec4Array, _light.color);

              if (_light.useColorTemperature) {
                var _tempRGB = _light.colorTemperatureRGB;
                _vec4Array[0] *= _tempRGB.x;
                _vec4Array[1] *= _tempRGB.y;
                _vec4Array[2] *= _tempRGB.z;
              }

              if (pipeline.pipelineSceneData.isHDR) {
                _vec4Array[3] = _light.luminance * exposure * this._lightMeterScale;
              } else {
                _vec4Array[3] = _light.luminance;
              }

              this._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 1);

              _vec4Array[0] = _light.size;
              _vec4Array[1] = _light.range;
              _vec4Array[2] = _light.spotAngle;

              this._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 2);

              Vec3.toArray(_vec4Array, _light.direction);

              this._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 3);
            }
          }

          var offset = fieldLen * 3 + 3;

          this._lightBufferData.set([idx], offset);

          cmdBuff.updateBuffer(this._deferredLitsBufs, this._lightBufferData);
        };

        _proto._createStageDescriptor = function _createStageDescriptor(pass) {
          var device = this._pipeline.device;
          var totalSize = Float32Array.BYTES_PER_ELEMENT * 4 * 4 * this._maxDeferredLights;
          totalSize = Math.ceil(totalSize / device.capabilities.uboOffsetAlignment) * device.capabilities.uboOffsetAlignment;
          this._deferredLitsBufs = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, totalSize, device.capabilities.uboOffsetAlignment));
          var deferredLitsBufView = device.createBuffer(new BufferViewInfo(this._deferredLitsBufs, 0, totalSize));
          this._lightBufferData = new Float32Array(totalSize / Float32Array.BYTES_PER_ELEMENT);
          this._descriptorSet = device.createDescriptorSet(new DescriptorSetInfo(pass.localSetLayout));

          this._descriptorSet.bindBuffer(UBOForwardLight.BINDING, deferredLitsBufView);

          var _localUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));

          this._descriptorSet.bindBuffer(UBOLocal.BINDING, _localUBO);
        };

        _proto.activate = function activate(pipeline, flow) {
          _RenderStage.prototype.activate.call(this, pipeline, flow);

          this._uiPhase.activate(pipeline);

          for (var i = 0; i < this.renderQueues.length; i++) {
            this._renderQueues[i] = convertRenderQueue(this.renderQueues[i]);
          }

          this._planarQueue = new PlanarShadowQueue(this._pipeline);

          if (this._deferredMaterial) {
            pipeline.pipelineSceneData.deferredLightingMaterial = this._deferredMaterial;
          }
        };

        _proto.destroy = function destroy() {
          var _this$_deferredLitsBu;

          (_this$_deferredLitsBu = this._deferredLitsBufs) === null || _this$_deferredLitsBu === void 0 ? void 0 : _this$_deferredLitsBu.destroy();
          this._deferredLitsBufs = null;
          this._descriptorSet = null;
        };

        _proto.render = function render(camera) {
          var pipeline = this._pipeline;
          var device = pipeline.device;
          var cmdBuff = pipeline.commandBuffers[0];
          var sceneData = pipeline.pipelineSceneData;
          var renderObjects = sceneData.renderObjects;

          this._planarQueue.gatherShadowPasses(camera, cmdBuff);

          pipeline.generateRenderArea(camera, this._renderArea);
          var deferredData = pipeline.getPipelineRenderData();
          var lightingMat = sceneData.deferredLightingMaterial;
          var pass = lightingMat.passes[0];
          var shader = pass.getShaderVariant();

          for (var i = 0; i < 3; ++i) {
            pass.descriptorSet.bindTexture(i, deferredData.gbufferRenderTargets[i]);
            pass.descriptorSet.bindSampler(i, deferredData.sampler);
          }

          pass.descriptorSet.bindTexture(3, deferredData.outputDepth);
          pass.descriptorSet.bindSampler(3, deferredData.sampler);
          pass.descriptorSet.update();

          if (!this._descriptorSet) {
            this._createStageDescriptor(pass);
          }

          this.gatherLights(camera);

          if (camera.clearFlag & ClearFlagBit.COLOR) {
            colors$3[0].x = camera.clearColor.x;
            colors$3[0].y = camera.clearColor.y;
            colors$3[0].z = camera.clearColor.z;
          }

          colors$3[0].w = 0;
          var framebuffer = deferredData.outputFrameBuffer;
          var renderPass = framebuffer.renderPass;
          pipeline.pipelineUBO.updateShadowUBO(camera);
          cmdBuff.beginRenderPass(renderPass, framebuffer, this._renderArea, colors$3, camera.clearDepth, camera.clearStencil);
          cmdBuff.setScissor(pipeline.generateScissor(camera));
          cmdBuff.setViewport(pipeline.generateViewport(camera));
          cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);
          var inputAssembler = pipeline.quadIAOffscreen;
          var pso = null;

          if (pass != null && shader != null && inputAssembler != null) {
            pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, renderPass, inputAssembler);
          }

          if (pso != null) {
            this._descriptorSet.update();

            cmdBuff.bindPipelineState(pso);
            cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
            cmdBuff.bindDescriptorSet(SetIndex.LOCAL, this._descriptorSet);
            cmdBuff.bindInputAssembler(inputAssembler);
            cmdBuff.draw(inputAssembler);
          }

          this._renderQueues.forEach(renderQueueClearFunc);

          var m = 0;
          var p = 0;
          var k = 0;

          for (var _i2 = 0; _i2 < renderObjects.length; ++_i2) {
            var ro = renderObjects[_i2];
            var subModels = ro.model.subModels;

            for (m = 0; m < subModels.length; ++m) {
              var subModel = subModels[m];
              var passes = subModel.passes;

              for (p = 0; p < passes.length; ++p) {
                var _pass = passes[p];
                if (_pass.phase !== this._phaseID) continue;

                for (k = 0; k < this._renderQueues.length; k++) {
                  this._renderQueues[k].insertRenderPass(ro, m, p);
                }
              }
            }
          }

          if (renderObjects.length > 0) {
            this._renderQueues.forEach(renderQueueSortFunc);

            for (var _i3 = 0; _i3 < this._renderQueues.length; _i3++) {
              this._renderQueues[_i3].recordCommandBuffer(device, renderPass, cmdBuff);
            }

            this._planarQueue.recordCommandBuffer(device, renderPass, cmdBuff);
          }

          this._pipeline.geometryRenderer.render(renderPass, cmdBuff);

          this._uiPhase.render(camera, renderPass);

          cmdBuff.endRenderPass();
        };

        return LightingStage;
      }(RenderStage), _class3$c.initInfo = {
        name: 'LightingStage',
        priority: DeferredStagePriority.LIGHTING,
        tag: 0
      }, _temp$y), (_descriptor$r = _applyDecoratedDescriptor(_class2$x.prototype, "_deferredMaterial", [_dec2$h, serializable, _dec3$c], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$h = _applyDecoratedDescriptor(_class2$x.prototype, "renderQueues", [_dec4$7, serializable, _dec5$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$x)) || _class$B));

      var _dec$C, _dec2$i, _dec3$d, _dec4$8, _dec5$5, _class$C, _class2$y, _descriptor$s, _descriptor2$i, _class3$d, _temp$z;
      var colors$4 = [new Color$1(0, 0, 0, 1)];
      var PostProcessStage = exports('PostProcessStage', (_dec$C = ccclass('PostProcessStage'), _dec2$i = type(Material), _dec3$d = displayOrder(), _dec4$8 = type([RenderQueueDesc]), _dec5$5 = displayOrder(), _dec$C(_class$C = (_class2$y = (_temp$z = _class3$d = function (_RenderStage) {
        _inheritsLoose(PostProcessStage, _RenderStage);

        function PostProcessStage() {
          var _this;

          _this = _RenderStage.call(this) || this;

          _initializerDefineProperty(_this, "_postProcessMaterial", _descriptor$s, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "renderQueues", _descriptor2$i, _assertThisInitialized(_this));

          _this._renderArea = new Rect$1();
          _this._stageDesc = void 0;
          _this._localUBO = void 0;
          _this._uiPhase = new UIPhase();
          return _this;
        }

        var _proto = PostProcessStage.prototype;

        _proto.initialize = function initialize(info) {
          _RenderStage.prototype.initialize.call(this, info);

          return true;
        };

        _proto.activate = function activate(pipeline, flow) {
          _RenderStage.prototype.activate.call(this, pipeline, flow);

          if (this._postProcessMaterial) {
            pipeline.pipelineSceneData.postprocessMaterial = this._postProcessMaterial;
          }

          this._uiPhase.activate(pipeline);
        };

        _proto.destroy = function destroy() {};

        _proto.render = function render(camera) {
          var pipeline = this._pipeline;
          var device = pipeline.device;
          var sceneData = pipeline.pipelineSceneData;
          var cmdBuff = pipeline.commandBuffers[0];
          pipeline.pipelineUBO.updateCameraUBO(camera);
          var vp = camera.viewport;
          this._renderArea.x = vp.x * camera.window.width;
          this._renderArea.y = vp.y * camera.window.height;
          this._renderArea.width = vp.width * camera.window.width;
          this._renderArea.height = vp.height * camera.window.height;
          var renderData = pipeline.getPipelineRenderData();
          var framebuffer = camera.window.framebuffer;
          var renderPass = pipeline.getRenderPass(camera.clearFlag, framebuffer);

          if (camera.clearFlag & ClearFlagBit.COLOR) {
            colors$4[0].x = camera.clearColor.x;
            colors$4[0].y = camera.clearColor.y;
            colors$4[0].z = camera.clearColor.z;
          }

          colors$4[0].w = camera.clearColor.w;
          cmdBuff.beginRenderPass(renderPass, framebuffer, this._renderArea, colors$4, camera.clearDepth, camera.clearStencil);
          cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);
          var builtinPostProcess = sceneData.postprocessMaterial;
          var pass = builtinPostProcess.passes[0];
          var shader = pass.getShaderVariant();

          if (pipeline.bloomEnabled) {
            pass.descriptorSet.bindTexture(0, renderData.bloom.combineTex);
          } else {
            pass.descriptorSet.bindTexture(0, renderData.outputRenderTargets[0]);
          }

          pass.descriptorSet.bindSampler(0, renderData.sampler);
          pass.descriptorSet.update();
          var inputAssembler = camera.window.swapchain ? pipeline.quadIAOnscreen : pipeline.quadIAOffscreen;
          var pso = null;

          if (pass != null && shader != null && inputAssembler != null) {
            pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, renderPass, inputAssembler);
          }

          var renderObjects = pipeline.pipelineSceneData.renderObjects;

          if (pso != null && renderObjects.length > 0) {
            if (!this._stageDesc) {
              this._stageDesc = device.createDescriptorSet(new DescriptorSetInfo(pass.localSetLayout));
              this._localUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));

              this._stageDesc.bindBuffer(UBOLocal.BINDING, this._localUBO);
            }

            this._stageDesc.update();

            cmdBuff.bindPipelineState(pso);
            cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
            cmdBuff.bindDescriptorSet(SetIndex.LOCAL, this._stageDesc);
            cmdBuff.bindInputAssembler(inputAssembler);
            cmdBuff.draw(inputAssembler);
          }

          this._uiPhase.render(camera, renderPass);

          renderProfiler(device, renderPass, cmdBuff, pipeline.profiler, camera);
          cmdBuff.endRenderPass();
        };

        return PostProcessStage;
      }(RenderStage), _class3$d.initInfo = {
        name: 'PostProcessStage',
        priority: CommonStagePriority.POST_PROCESS,
        tag: 0
      }, _temp$z), (_descriptor$s = _applyDecoratedDescriptor(_class2$y.prototype, "_postProcessMaterial", [_dec2$i, serializable, _dec3$d], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$i = _applyDecoratedDescriptor(_class2$y.prototype, "renderQueues", [_dec4$8, serializable, _dec5$5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$y)) || _class$C));

      var AntiAliasing;

      (function (AntiAliasing) {
        AntiAliasing[AntiAliasing["NONE"] = 0] = "NONE";
        AntiAliasing[AntiAliasing["FXAA"] = 1] = "FXAA";
      })(AntiAliasing || (AntiAliasing = {}));

      var BLOOM_PREFILTERPASS_INDEX = 0;
      var BLOOM_DOWNSAMPLEPASS_INDEX = 1;
      var BLOOM_UPSAMPLEPASS_INDEX = BLOOM_DOWNSAMPLEPASS_INDEX + MAX_BLOOM_FILTER_PASS_NUM;
      var BLOOM_COMBINEPASS_INDEX = BLOOM_UPSAMPLEPASS_INDEX + MAX_BLOOM_FILTER_PASS_NUM;
      var DeferredPipelineSceneData = function (_PipelineSceneData) {
        _inheritsLoose(DeferredPipelineSceneData, _PipelineSceneData);

        function DeferredPipelineSceneData() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _PipelineSceneData.call.apply(_PipelineSceneData, [this].concat(args)) || this;
          _this._antiAliasing = AntiAliasing.NONE;
          return _this;
        }

        var _proto = DeferredPipelineSceneData.prototype;

        _proto.onGlobalPipelineStateChanged = function onGlobalPipelineStateChanged() {
          this.updatePipelinePassInfo();
        };

        _proto.updateBloomPass = function updateBloomPass() {
          if (!this._bloomMaterial) return;
          var prefilterPass = this._bloomMaterial.passes[BLOOM_PREFILTERPASS_INDEX];
          prefilterPass.beginChangeStatesSilently();
          prefilterPass.tryCompile();
          prefilterPass.endChangeStatesSilently();
          var downsamplePasses = [];
          var upsamplePasses = [];

          for (var i = 0; i < MAX_BLOOM_FILTER_PASS_NUM; ++i) {
            var downsamplePass = this._bloomMaterial.passes[BLOOM_DOWNSAMPLEPASS_INDEX + i];
            downsamplePass.beginChangeStatesSilently();
            downsamplePass.tryCompile();
            downsamplePass.endChangeStatesSilently();
            var upsamplePass = this._bloomMaterial.passes[BLOOM_UPSAMPLEPASS_INDEX + i];
            upsamplePass.beginChangeStatesSilently();
            upsamplePass.tryCompile();
            upsamplePass.endChangeStatesSilently();
            downsamplePasses.push(downsamplePass["native"]);
            upsamplePasses.push(upsamplePass["native"]);
          }

          var combinePass = this._bloomMaterial.passes[BLOOM_COMBINEPASS_INDEX];
          combinePass.beginChangeStatesSilently();
          combinePass.tryCompile();
          combinePass.endChangeStatesSilently();
        };

        _proto.updatePostProcessPass = function updatePostProcessPass() {
          if (!this.postprocessMaterial) return;
          var passPost = this.postprocessMaterial.passes[0];
          passPost.beginChangeStatesSilently();
          passPost.tryCompile();
          passPost.endChangeStatesSilently();
        };

        _proto.initPipelinePassInfo = function initPipelinePassInfo() {
          var deferredMat = new Material();
          deferredMat._uuid = 'builtin-deferred-material';
          deferredMat.initialize({
            effectName: 'deferred-lighting'
          });

          for (var i = 0; i < deferredMat.passes.length; ++i) {
            deferredMat.passes[i].tryCompile();
          }

          this._deferredLightingMaterial = deferredMat;
          var bloomMat = new Material();
          bloomMat._uuid = 'builtin-bloom-material';
          bloomMat.initialize({
            effectName: 'bloom'
          });

          for (var _i = 0; _i < bloomMat.passes.length; ++_i) {
            bloomMat.passes[_i].tryCompile();
          }

          this._bloomMaterial = bloomMat;
          var postMat = new Material();
          postMat._uuid = 'builtin-post-process-material';

          if (macro.ENABLE_ANTIALIAS_FXAA) {
            this._antiAliasing = AntiAliasing.FXAA;
          }

          postMat.initialize({
            effectName: 'post-process',
            defines: {
              ANTIALIAS_TYPE: this._antiAliasing
            }
          });

          for (var _i2 = 0; _i2 < postMat.passes.length; ++_i2) {
            postMat.passes[_i2].tryCompile();
          }

          this._postprocessMaterial = postMat;
          this.updatePipelinePassInfo();
        };

        _proto.updatePipelinePassInfo = function updatePipelinePassInfo() {
          this.updateBloomPass();
          this.updatePostProcessPass();
          this.updateDeferredPassInfo();
        };

        _proto.activate = function activate(device, pipeline) {
          _PipelineSceneData.prototype.activate.call(this, device, pipeline);

          this.initPipelinePassInfo();
          return true;
        };

        _proto.updateDeferredPassInfo = function updateDeferredPassInfo() {
          this.updateDeferredLightPass();
        };

        _proto.updateDeferredLightPass = function updateDeferredLightPass() {
          if (!this._deferredLightingMaterial) return;

          if (this.shadows.enabled) {
            this._pipeline.macros.CC_RECEIVE_SHADOW = 1;
          }

          var passLit = this._deferredLightingMaterial.passes[0];
          passLit.beginChangeStatesSilently();
          passLit.tryCompile();
          passLit.endChangeStatesSilently();
        };

        _createClass(DeferredPipelineSceneData, [{
          key: "antiAliasing",
          get: function get() {
            return this._antiAliasing;
          },
          set: function set(value) {
            this._antiAliasing = value;

            if (this._postprocessMaterial) {
              var defines = this._postprocessMaterial.passes[0].defines;
              Object.assign(defines, {
                ANTIALIAS_TYPE: value
              });
              var renderMat = new Material();
              renderMat.initialize({
                effectAsset: this._postprocessMaterial.effectAsset,
                defines: defines
              });

              for (var i = 0; i < renderMat.passes.length; ++i) {
                renderMat.passes[i].tryCompile();
              }

              this._postprocessMaterial = renderMat;
            }
          }
        }, {
          key: "bloomMaterial",
          get: function get() {
            return this._bloomMaterial;
          },
          set: function set(mat) {
            if (this._bloomMaterial === mat || !mat) return;
            this._bloomMaterial = mat;
            this.updatePipelinePassInfo();
          }
        }, {
          key: "postprocessMaterial",
          get: function get() {
            return this._postprocessMaterial;
          },
          set: function set(mat) {
            if (this._postprocessMaterial === mat || !mat) return;
            this._postprocessMaterial = mat;
            this.updatePipelinePassInfo();
          }
        }, {
          key: "deferredLightingMaterial",
          get: function get() {
            return this._deferredLightingMaterial;
          },
          set: function set(mat) {
            if (this._deferredLightingMaterial === mat || !mat) return;
            this._deferredLightingMaterial = mat;
            this.updatePipelinePassInfo();
          }
        }]);

        return DeferredPipelineSceneData;
      }(PipelineSceneData);

      var _dec$D, _dec2$j, _dec3$e, _class$D, _class2$z, _descriptor$t, _class3$e, _temp$A;
      var colors$5 = [new Color$1(0, 0, 0, 1)];

      var UBOBloom = function UBOBloom() {};

      UBOBloom.TEXTURE_SIZE_OFFSET = 0;
      UBOBloom.COUNT = UBOBloom.TEXTURE_SIZE_OFFSET + 4;
      UBOBloom.SIZE = UBOBloom.COUNT * 4;
      var BloomStage = exports('BloomStage', (_dec$D = ccclass('BloomStage'), _dec2$j = type(Material), _dec3$e = displayOrder(), _dec$D(_class$D = (_class2$z = (_temp$A = _class3$e = function (_RenderStage) {
        _inheritsLoose(BloomStage, _RenderStage);

        function BloomStage() {
          var _this;

          _this = _RenderStage.call(this) || this;
          _this.threshold = 1.0;
          _this.intensity = 0.8;
          _this.iterations = 2;

          _initializerDefineProperty(_this, "_bloomMaterial", _descriptor$t, _assertThisInitialized(_this));

          _this._renderArea = new Rect$1();
          _this._bloomUBO = [];
          return _this;
        }

        var _proto = BloomStage.prototype;

        _proto.initialize = function initialize(info) {
          _RenderStage.prototype.initialize.call(this, info);

          return true;
        };

        _proto.activate = function activate(pipeline, flow) {
          _RenderStage.prototype.activate.call(this, pipeline, flow);

          if (this._bloomMaterial) {
            pipeline.pipelineSceneData.bloomMaterial = this._bloomMaterial;
          }
        };

        _proto.destroy = function destroy() {};

        _proto.render = function render(camera) {
          var _camera$window;

          var pipeline = this._pipeline;
          pipeline.generateBloomRenderData();

          if (!((_camera$window = camera.window) === null || _camera$window === void 0 ? void 0 : _camera$window.swapchain) && !pipeline.macros.CC_PIPELINE_TYPE) {
            return;
          }

          if (!pipeline.bloomEnabled || pipeline.pipelineSceneData.renderObjects.length === 0) return;

          if (this._bloomUBO.length === 0) {
            var passNumber = MAX_BLOOM_FILTER_PASS_NUM * 2 + 2;

            for (var i = 0; i < passNumber; ++i) {
              this._bloomUBO[i] = pipeline.device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOBloom.SIZE, UBOBloom.SIZE));
            }
          }

          if (camera.clearFlag & ClearFlagBit.COLOR) {
            colors$5[0].x = camera.clearColor.x;
            colors$5[0].y = camera.clearColor.y;
            colors$5[0].z = camera.clearColor.z;
          }

          colors$5[0].w = camera.clearColor.w;

          this._prefilterPass(camera, pipeline);

          this._downsamplePass(camera, pipeline);

          this._upsamplePass(camera, pipeline);

          this._combinePass(camera, pipeline);
        };

        _proto._prefilterPass = function _prefilterPass(camera, pipeline) {
          pipeline.generateRenderArea(camera, this._renderArea);
          this._renderArea.width >>= 1;
          this._renderArea.height >>= 1;
          var cmdBuff = pipeline.commandBuffers[0];
          var sceneData = pipeline.pipelineSceneData;
          var builtinBloomProcess = sceneData.bloomMaterial;
          var pass = builtinBloomProcess.passes[BLOOM_PREFILTERPASS_INDEX];
          var renderData = pipeline.getPipelineRenderData();
          var bloomData = renderData.bloom;
          var textureSize = new Float32Array(UBOBloom.COUNT);
          textureSize[UBOBloom.TEXTURE_SIZE_OFFSET + 2] = this.threshold;
          cmdBuff.updateBuffer(this._bloomUBO[0], textureSize);
          cmdBuff.beginRenderPass(bloomData.renderPass, bloomData.prefilterFramebuffer, this._renderArea, colors$5, 0, 0);
          cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);
          pass.descriptorSet.bindBuffer(0, this._bloomUBO[0]);
          pass.descriptorSet.bindTexture(1, renderData.outputRenderTargets[0]);
          pass.descriptorSet.bindSampler(1, bloomData.sampler);
          pass.descriptorSet.update();
          cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
          var inputAssembler = camera.window.swapchain ? pipeline.quadIAOffscreen : pipeline.quadIAOnscreen;
          var pso = null;
          var shader = pass.getShaderVariant();

          if (pass != null && shader != null && inputAssembler != null) {
            pso = PipelineStateManager.getOrCreatePipelineState(pipeline.device, pass, shader, bloomData.renderPass, inputAssembler);
          }

          if (pso != null) {
            cmdBuff.bindPipelineState(pso);
            cmdBuff.bindInputAssembler(inputAssembler);
            cmdBuff.draw(inputAssembler);
          }

          cmdBuff.endRenderPass();
        };

        _proto._downsamplePass = function _downsamplePass(camera, pipeline) {
          pipeline.generateRenderArea(camera, this._renderArea);
          this._renderArea.width >>= 1;
          this._renderArea.height >>= 1;
          var cmdBuff = pipeline.commandBuffers[0];
          var sceneData = pipeline.pipelineSceneData;
          var builtinBloomProcess = sceneData.bloomMaterial;
          var bloomData = pipeline.getPipelineRenderData().bloom;
          var textureSize = new Float32Array(UBOBloom.COUNT);

          for (var i = 0; i < this.iterations; ++i) {
            textureSize[UBOBloom.TEXTURE_SIZE_OFFSET + 0] = this._renderArea.width;
            textureSize[UBOBloom.TEXTURE_SIZE_OFFSET + 1] = this._renderArea.height;
            cmdBuff.updateBuffer(this._bloomUBO[i + 1], textureSize);
            this._renderArea.width >>= 1;
            this._renderArea.height >>= 1;
            cmdBuff.beginRenderPass(bloomData.renderPass, bloomData.downsampleFramebuffers[i], this._renderArea, colors$5, 0, 0);
            var pass = builtinBloomProcess.passes[BLOOM_DOWNSAMPLEPASS_INDEX + i];
            var shader = pass.getShaderVariant();
            pass.descriptorSet.bindBuffer(0, this._bloomUBO[i + 1]);

            if (i === 0) {
              pass.descriptorSet.bindTexture(1, bloomData.prefiterTex);
            } else {
              pass.descriptorSet.bindTexture(1, bloomData.downsampleTexs[i - 1]);
            }

            pass.descriptorSet.bindSampler(1, bloomData.sampler);
            pass.descriptorSet.update();
            cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
            var inputAssembler = camera.window.swapchain ? pipeline.quadIAOffscreen : pipeline.quadIAOnscreen;
            var pso = null;

            if (pass != null && shader != null && inputAssembler != null) {
              pso = PipelineStateManager.getOrCreatePipelineState(pipeline.device, pass, shader, bloomData.renderPass, inputAssembler);
            }

            if (pso != null) {
              cmdBuff.bindPipelineState(pso);
              cmdBuff.bindInputAssembler(inputAssembler);
              cmdBuff.draw(inputAssembler);
            }

            cmdBuff.endRenderPass();
          }
        };

        _proto._upsamplePass = function _upsamplePass(camera, pipeline) {
          var bloomData = pipeline.getPipelineRenderData().bloom;
          pipeline.generateRenderArea(camera, this._renderArea);
          this._renderArea.width >>= this.iterations + 1;
          this._renderArea.height >>= this.iterations + 1;
          var cmdBuff = pipeline.commandBuffers[0];
          var sceneData = pipeline.pipelineSceneData;
          var builtinBloomProcess = sceneData.bloomMaterial;
          var textureSize = new Float32Array(UBOBloom.COUNT);

          for (var i = 0; i < this.iterations; ++i) {
            var index = i + MAX_BLOOM_FILTER_PASS_NUM + 1;
            textureSize[UBOBloom.TEXTURE_SIZE_OFFSET + 0] = this._renderArea.width;
            textureSize[UBOBloom.TEXTURE_SIZE_OFFSET + 1] = this._renderArea.height;
            cmdBuff.updateBuffer(this._bloomUBO[index], textureSize);
            this._renderArea.width <<= 1;
            this._renderArea.height <<= 1;
            cmdBuff.beginRenderPass(bloomData.renderPass, bloomData.upsampleFramebuffers[this.iterations - 1 - i], this._renderArea, colors$5, 0, 0);
            var pass = builtinBloomProcess.passes[BLOOM_UPSAMPLEPASS_INDEX + i];
            var shader = pass.getShaderVariant();
            pass.descriptorSet.bindBuffer(0, this._bloomUBO[index]);

            if (i === 0) {
              pass.descriptorSet.bindTexture(1, bloomData.downsampleTexs[this.iterations - 1]);
            } else {
              pass.descriptorSet.bindTexture(1, bloomData.upsampleTexs[this.iterations - i]);
            }

            pass.descriptorSet.bindSampler(1, bloomData.sampler);
            pass.descriptorSet.update();
            cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
            var inputAssembler = camera.window.swapchain ? pipeline.quadIAOffscreen : pipeline.quadIAOnscreen;
            var pso = null;

            if (pass != null && shader != null && inputAssembler != null) {
              pso = PipelineStateManager.getOrCreatePipelineState(pipeline.device, pass, shader, bloomData.renderPass, inputAssembler);
            }

            if (pso != null) {
              cmdBuff.bindPipelineState(pso);
              cmdBuff.bindInputAssembler(inputAssembler);
              cmdBuff.draw(inputAssembler);
            }

            cmdBuff.endRenderPass();
          }
        };

        _proto._combinePass = function _combinePass(camera, pipeline) {
          pipeline.generateRenderArea(camera, this._renderArea);
          var cmdBuff = pipeline.commandBuffers[0];
          var sceneData = pipeline.pipelineSceneData;
          var builtinBloomProcess = sceneData.bloomMaterial;
          var deferredData = pipeline.getPipelineRenderData();
          var bloomData = deferredData.bloom;
          var uboIndex = MAX_BLOOM_FILTER_PASS_NUM * 2 + 1;
          var textureSize = new Float32Array(UBOBloom.COUNT);
          textureSize[UBOBloom.TEXTURE_SIZE_OFFSET + 3] = this.intensity;
          cmdBuff.updateBuffer(this._bloomUBO[uboIndex], textureSize);
          cmdBuff.beginRenderPass(bloomData.renderPass, bloomData.combineFramebuffer, this._renderArea, colors$5, 0, 0);
          cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);
          var pass = builtinBloomProcess.passes[BLOOM_COMBINEPASS_INDEX];
          pass.descriptorSet.bindBuffer(0, this._bloomUBO[uboIndex]);
          pass.descriptorSet.bindTexture(1, deferredData.outputRenderTargets[0]);
          pass.descriptorSet.bindTexture(2, bloomData.upsampleTexs[0]);
          pass.descriptorSet.bindSampler(1, bloomData.sampler);
          pass.descriptorSet.bindSampler(2, bloomData.sampler);
          pass.descriptorSet.update();
          cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
          var inputAssembler = camera.window.swapchain ? pipeline.quadIAOffscreen : pipeline.quadIAOnscreen;
          var pso = null;
          var shader = pass.getShaderVariant();

          if (pass != null && shader != null && inputAssembler != null) {
            pso = PipelineStateManager.getOrCreatePipelineState(pipeline.device, pass, shader, bloomData.renderPass, inputAssembler);
          }

          if (pso != null) {
            cmdBuff.bindPipelineState(pso);
            cmdBuff.bindInputAssembler(inputAssembler);
            cmdBuff.draw(inputAssembler);
          }

          cmdBuff.endRenderPass();
        };

        return BloomStage;
      }(RenderStage), _class3$e.initInfo = {
        name: 'BloomStage',
        priority: CommonStagePriority.BLOOM,
        tag: 0
      }, _temp$A), (_descriptor$t = _applyDecoratedDescriptor(_class2$z.prototype, "_bloomMaterial", [_dec2$j, serializable, _dec3$e], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$z)) || _class$D));

      var _dec$E, _class$E, _class2$A, _temp$B;
      var MainFlow = exports('MainFlow', (_dec$E = ccclass('MainFlow'), _dec$E(_class$E = (_temp$B = _class2$A = function (_RenderFlow) {
        _inheritsLoose(MainFlow, _RenderFlow);

        function MainFlow() {
          return _RenderFlow.apply(this, arguments) || this;
        }

        var _proto = MainFlow.prototype;

        _proto.initialize = function initialize(info) {
          _RenderFlow.prototype.initialize.call(this, info);

          if (this._stages.length === 0) {
            var gbufferStage = new GbufferStage();
            gbufferStage.initialize(GbufferStage.initInfo);

            this._stages.push(gbufferStage);

            var lightingStage = new LightingStage();
            lightingStage.initialize(LightingStage.initInfo);

            this._stages.push(lightingStage);

            var bloomStage = new BloomStage();
            bloomStage.initialize(BloomStage.initInfo);

            this._stages.push(bloomStage);

            var postProcessStage = new PostProcessStage();
            postProcessStage.initialize(PostProcessStage.initInfo);

            this._stages.push(postProcessStage);
          }

          return true;
        };

        _proto.activate = function activate(pipeline) {
          _RenderFlow.prototype.activate.call(this, pipeline);
        };

        _proto.render = function render(camera) {
          _RenderFlow.prototype.render.call(this, camera);
        };

        _proto.destroy = function destroy() {
          _RenderFlow.prototype.destroy.call(this);
        };

        return MainFlow;
      }(RenderFlow), _class2$A.initInfo = {
        name: PIPELINE_FLOW_MAIN,
        priority: DeferredFlowPriority.MAIN,
        stages: []
      }, _temp$B)) || _class$E));

      var _dec$F, _dec2$k, _dec3$f, _class$F, _class2$B, _descriptor$u, _temp$C;
      var PIPELINE_TYPE$1 = 1;
      var DeferredRenderData = function (_PipelineRenderData) {
        _inheritsLoose(DeferredRenderData, _PipelineRenderData);

        function DeferredRenderData() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _PipelineRenderData.call.apply(_PipelineRenderData, [this].concat(args)) || this;
          _this.gbufferFrameBuffer = null;
          _this.gbufferRenderTargets = [];
          return _this;
        }

        return DeferredRenderData;
      }(PipelineRenderData);
      var DeferredPipeline = exports('DeferredPipeline', (_dec$F = ccclass('DeferredPipeline'), _dec2$k = type([RenderTextureConfig]), _dec3$f = displayOrder(), _dec$F(_class$F = (_class2$B = (_temp$C = function (_RenderPipeline) {
        _inheritsLoose(DeferredPipeline, _RenderPipeline);

        function DeferredPipeline() {
          var _this2;

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          _this2 = _RenderPipeline.call.apply(_RenderPipeline, [this].concat(args)) || this;
          _this2._gbufferRenderPass = null;
          _this2._lightingRenderPass = null;

          _initializerDefineProperty(_this2, "renderTextures", _descriptor$u, _assertThisInitialized(_this2));

          return _this2;
        }

        var _proto = DeferredPipeline.prototype;

        _proto.initialize = function initialize(info) {
          _RenderPipeline.prototype.initialize.call(this, info);

          if (this._flows.length === 0) {
            var shadowFlow = new ShadowFlow();
            shadowFlow.initialize(ShadowFlow.initInfo);

            this._flows.push(shadowFlow);

            var mainFlow = new MainFlow();
            mainFlow.initialize(MainFlow.initInfo);

            this._flows.push(mainFlow);
          }

          return true;
        };

        _proto.activate = function activate(swapchain) {

          this._macros = {
            CC_PIPELINE_TYPE: PIPELINE_TYPE$1
          };
          this._pipelineSceneData = new DeferredPipelineSceneData();

          if (!_RenderPipeline.prototype.activate.call(this, swapchain)) {
            return false;
          }

          if (!this._activeRenderer(swapchain)) {
            errorID(2402);
            return false;
          }

          return true;
        };

        _proto.destroy = function destroy() {
          this._destroyUBOs();

          this._destroyQuadInputAssembler();

          this._destroyDeferredData();

          var rpIter = this._renderPasses.values();

          var rpRes = rpIter.next();

          while (!rpRes.done) {
            rpRes.value.destroy();
            rpRes = rpIter.next();
          }

          this._commandBuffers.length = 0;
          return _RenderPipeline.prototype.destroy.call(this);
        };

        _proto.getPipelineRenderData = function getPipelineRenderData() {
          if (!this._pipelineRenderData) {
            this._generateDeferredRenderData();
          }

          return this._pipelineRenderData;
        };

        _proto._activeRenderer = function _activeRenderer(swapchain) {
          var device = this.device;

          this._commandBuffers.push(device.commandBuffer);

          var sampler = this.globalDSManager.pointSampler;

          this._descriptorSet.bindSampler(UNIFORM_SHADOWMAP_BINDING, sampler);

          this._descriptorSet.bindTexture(UNIFORM_SHADOWMAP_BINDING, builtinResMgr.get('default-texture').getGFXTexture());

          this._descriptorSet.bindSampler(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, sampler);

          this._descriptorSet.bindTexture(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, builtinResMgr.get('default-texture').getGFXTexture());

          this._descriptorSet.update();

          var inputAssemblerDataOffscreen = new PipelineInputAssemblerData();
          inputAssemblerDataOffscreen = this._createQuadInputAssembler();

          if (!inputAssemblerDataOffscreen.quadIB || !inputAssemblerDataOffscreen.quadVB || !inputAssemblerDataOffscreen.quadIA) {
            return false;
          }

          this._quadIB = inputAssemblerDataOffscreen.quadIB;
          this._quadVBOffscreen = inputAssemblerDataOffscreen.quadVB;
          this._quadIAOffscreen = inputAssemblerDataOffscreen.quadIA;

          var inputAssemblerDataOnscreen = this._createQuadInputAssembler();

          if (!inputAssemblerDataOnscreen.quadIB || !inputAssemblerDataOnscreen.quadVB || !inputAssemblerDataOnscreen.quadIA) {
            return false;
          }

          this._quadVBOnscreen = inputAssemblerDataOnscreen.quadVB;
          this._quadIAOnscreen = inputAssemblerDataOnscreen.quadIA;

          if (!this._gbufferRenderPass) {
            var colorAttachment0 = new ColorAttachment();
            colorAttachment0.format = Format.RGBA16F;
            colorAttachment0.loadOp = LoadOp.CLEAR;
            colorAttachment0.storeOp = StoreOp.STORE;
            var colorAttachment1 = new ColorAttachment();
            colorAttachment1.format = Format.RGBA16F;
            colorAttachment1.loadOp = LoadOp.CLEAR;
            colorAttachment1.storeOp = StoreOp.STORE;
            var colorAttachment2 = new ColorAttachment();
            colorAttachment2.format = Format.RGBA16F;
            colorAttachment2.loadOp = LoadOp.CLEAR;
            colorAttachment2.storeOp = StoreOp.STORE;
            var depthStencilAttachment = new DepthStencilAttachment();
            depthStencilAttachment.format = Format.DEPTH_STENCIL;
            depthStencilAttachment.depthLoadOp = LoadOp.CLEAR;
            depthStencilAttachment.depthStoreOp = StoreOp.STORE;
            depthStencilAttachment.stencilLoadOp = LoadOp.CLEAR;
            depthStencilAttachment.stencilStoreOp = StoreOp.STORE;
            var renderPassInfo = new RenderPassInfo([colorAttachment0, colorAttachment1, colorAttachment2], depthStencilAttachment);
            this._gbufferRenderPass = device.createRenderPass(renderPassInfo);
          }

          if (!this._lightingRenderPass) {
            var colorAttachment = new ColorAttachment();
            colorAttachment.format = Format.RGBA8;
            colorAttachment.loadOp = LoadOp.CLEAR;
            colorAttachment.storeOp = StoreOp.STORE;
            colorAttachment.barrier = device.getGeneralBarrier(new GeneralBarrierInfo(AccessFlagBit.NONE, AccessFlagBit.COLOR_ATTACHMENT_WRITE));

            var _depthStencilAttachment = new DepthStencilAttachment();

            _depthStencilAttachment.format = Format.DEPTH_STENCIL;
            _depthStencilAttachment.depthLoadOp = LoadOp.LOAD;
            _depthStencilAttachment.depthStoreOp = StoreOp.DISCARD;
            _depthStencilAttachment.stencilLoadOp = LoadOp.LOAD;
            _depthStencilAttachment.stencilStoreOp = StoreOp.DISCARD;
            colorAttachment.barrier = device.getGeneralBarrier(new GeneralBarrierInfo(AccessFlagBit.DEPTH_STENCIL_ATTACHMENT_WRITE, AccessFlagBit.DEPTH_STENCIL_ATTACHMENT_WRITE));

            var _renderPassInfo = new RenderPassInfo([colorAttachment], _depthStencilAttachment);

            this._lightingRenderPass = device.createRenderPass(_renderPassInfo);
          }

          this._width = swapchain.width;
          this._height = swapchain.height;

          this._generateDeferredRenderData();

          return true;
        };

        _proto._destroyUBOs = function _destroyUBOs() {
          if (this._descriptorSet) {
            this._descriptorSet.getBuffer(UBOGlobal.BINDING).destroy();

            this._descriptorSet.getBuffer(UBOShadow.BINDING).destroy();

            this._descriptorSet.getBuffer(UBOCamera.BINDING).destroy();

            this._descriptorSet.getTexture(UNIFORM_SHADOWMAP_BINDING).destroy();

            this._descriptorSet.getTexture(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING).destroy();
          }
        };

        _proto._destroyDeferredData = function _destroyDeferredData() {
          var deferredData = this._pipelineRenderData;

          if (deferredData) {
            if (deferredData.gbufferFrameBuffer) deferredData.gbufferFrameBuffer.destroy();
            if (deferredData.outputFrameBuffer) deferredData.outputFrameBuffer.destroy();
            if (deferredData.outputDepth) deferredData.outputDepth.destroy();

            for (var i = 0; i < deferredData.gbufferRenderTargets.length; i++) {
              deferredData.gbufferRenderTargets[i].destroy();
            }

            deferredData.gbufferRenderTargets.length = 0;

            for (var _i = 0; _i < deferredData.outputRenderTargets.length; _i++) {
              deferredData.outputRenderTargets[_i].destroy();
            }

            deferredData.outputRenderTargets.length = 0;

            this._destroyBloomData();
          }

          this._pipelineRenderData = null;
        };

        _proto._ensureEnoughSize = function _ensureEnoughSize(cameras) {
          var newWidth = this._width;
          var newHeight = this._height;

          for (var i = 0; i < cameras.length; ++i) {
            var window = cameras[i].window;
            newWidth = Math.max(window.width, newWidth);
            newHeight = Math.max(window.height, newHeight);
          }

          if (newWidth !== this._width || newHeight !== this._height) {
            this._width = newWidth;
            this._height = newHeight;

            this._destroyDeferredData();

            this._generateDeferredRenderData();
          }
        };

        _proto._generateDeferredRenderData = function _generateDeferredRenderData() {
          var _this3 = this;

          var device = this.device;
          var data = this._pipelineRenderData = new DeferredRenderData();
          var sceneData = this.pipelineSceneData;

          for (var i = 0; i < 3; ++i) {
            data.gbufferRenderTargets.push(device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA16F, this._width * sceneData.shadingScale, this._height * sceneData.shadingScale)));
          }

          data.outputDepth = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.DEPTH_STENCIL_ATTACHMENT | TextureUsageBit.SAMPLED, Format.DEPTH_STENCIL, this._width * sceneData.shadingScale, this._height * sceneData.shadingScale));
          data.gbufferFrameBuffer = device.createFramebuffer(new FramebufferInfo(this._gbufferRenderPass, data.gbufferRenderTargets, data.outputDepth));
          data.outputRenderTargets.push(device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA16F, this._width * sceneData.shadingScale, this._height * sceneData.shadingScale)));
          data.outputFrameBuffer = device.createFramebuffer(new FramebufferInfo(this._lightingRenderPass, data.outputRenderTargets, null));
          data.sampler = this.globalDSManager.pointSampler;
          this.on(PipelineEventType.ATTACHMENT_SCALE_CAHNGED, function (val) {
            data.sampler = val < 1 ? _this3.globalDSManager.pointSampler : _this3.globalDSManager.linearSampler;

            _this3.applyFramebufferRatio(data.gbufferFrameBuffer);

            _this3.applyFramebufferRatio(data.outputFrameBuffer);
          });
        };

        return DeferredPipeline;
      }(RenderPipeline), _temp$C), (_descriptor$u = _applyDecoratedDescriptor(_class2$B.prototype, "renderTextures", [_dec2$k, serializable, _dec3$f], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$B)) || _class$F));

      function createDefaultPipeline() {
        var rppl = new ForwardPipeline();
        rppl.initialize({
          flows: []
        });
        return rppl;
      }

      var v2_0 = new Vec2();
      var SplashScreen = function () {
        var _proto = SplashScreen.prototype;

        _proto.pauseRendering = function pauseRendering() {
          this.isPause = true;
        };

        _proto.resumeRendering = function resumeRendering() {
          this.isPause = false;
        };

        _proto.main = function main(root) {
          if (root == null) {
            error('RENDER ROOT IS NULL.');
            return;
          }

          if (window._CCSettings && window._CCSettings.splashScreen) {
            var setting = this.settings = window._CCSettings.splashScreen;
            setting.totalTime = this.settings.totalTime != null ? this.settings.totalTime : 3000;
            setting.base64src = this.settings.base64src || '';
            setting.effect = this.settings.effect || 'FADE-INOUT';
            setting.clearColor = this.settings.clearColor || new Color$1(0.88, 0.88, 0.88, 1);
            setting.displayRatio = this.settings.displayRatio != null ? this.settings.displayRatio : 0.4;
            setting.displayWatermark = this.settings.displayWatermark != null ? this.settings.displayWatermark : true;
          } else {
            this.settings = {
              totalTime: 3000,
              base64src: '',
              effect: 'FADE-INOUT',
              clearColor: new Color$1(0.88, 0.88, 0.88, 1),
              displayRatio: 0.4,
              displayWatermark: true
            };
          }

          if (this.settings.base64src === '' || this.settings.totalTime <= 0) {
            if (this.callBack) {
              this.callBack();
            }

            this.callBack = null;
            this.settings = null;
            this._directCall = true;
          } else {
            legacyCC.view.resizeWithBrowserSize(true);
            var designRes = window._CCSettings.designResolution;

            if (designRes) {
              legacyCC.view.setDesignResolutionSize(designRes.width, designRes.height, designRes.policy);
            } else {
              legacyCC.view.setDesignResolutionSize(960, 640, 4);
            }

            this.device = root.device;
            this.swapchain = root.mainWindow.swapchain;
            this.framebuffer = root.mainWindow.framebuffer;
            legacyCC.game.once(legacyCC.Game.EVENT_GAME_INITED, function () {
              legacyCC.director._lateUpdate = performance.now();
            }, legacyCC.director);
            this.callBack = null;
            this.cancelAnimate = false;
            this.startTime = -1;
            this.preInit();
            this.logoImage = new Image();
            this.logoImage.onload = this.init.bind(this);
            this.logoImage.src = this.settings.base64src;
          }
        };

        _proto.setOnFinish = function setOnFinish(cb) {
          if (this._directCall) {
            if (cb) {
              SplashScreen._ins = undefined;
              cb();
              return;
            }
          }

          this.callBack = cb;
        };

        _proto._tryToStart = function _tryToStart() {
          if (this._splashFinish && this._loadFinish) {
            if (this.callBack) {
              this.callBack();
              this.hide();
              legacyCC.game.resume();
            }
          }
        };

        _proto.preInit = function preInit() {
          var clearColor = this.settings.clearColor;
          this.clearColors = [new Color$1(clearColor.x, clearColor.y, clearColor.z, clearColor.w)];
          var device = this.device,
              swapchain = this.swapchain;
          this.renderArea = new Rect$1(0, 0, swapchain.width, swapchain.height);
          this.cmdBuff = device.commandBuffer;
          var verts = new Float32Array([0.5, 0.5, 1, 0, -0.5, 0.5, 0, 0, 0.5, -0.5, 1, 1, -0.5, -0.5, 0, 1]);
          var vbStride = Float32Array.BYTES_PER_ELEMENT * 4;
          var vbSize = vbStride * 4;
          this.vertexBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbSize, vbStride));
          this.vertexBuffers.update(verts);
          var indices = new Uint16Array([0, 1, 2, 1, 3, 2]);
          var ibStride = Uint16Array.BYTES_PER_ELEMENT;
          var ibSize = ibStride * 6;
          this.indicesBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibSize, ibStride));
          this.indicesBuffers.update(indices);
          var attributes = [new Attribute('a_position', Format.RG32F), new Attribute('a_texCoord', Format.RG32F)];
          var IAInfo = new InputAssemblerInfo(attributes, [this.vertexBuffers], this.indicesBuffers);
          this.quadAssmebler = device.createInputAssembler(IAInfo);
          this.projection = new Mat4();
          Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
        };

        _proto.init = function init() {
          var _this = this;

          this.initLogo();
          if (this.settings.displayWatermark) this.initWarterMark();

          var animate = function animate(time) {
            if (_this.cancelAnimate) return;
            var settings = _this.settings;
            var device = _this.device,
                swapchain = _this.swapchain;
            Mat4.ortho(_this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
            var dw = swapchain.width;
            var dh = swapchain.height;
            var refW = dw < dh ? dw : dh;
            if (_this.startTime < 0) _this.startTime = time;
            var elapsedTime = time - _this.startTime;
            var percent = clamp01(elapsedTime / settings.totalTime);
            var u_p = cubicOut(percent);
            if (settings.effect === 'NONE') u_p = 1.0;
            var logoTW = _this.logoTexture.width;
            var logoTH = _this.logoTexture.height;
            var logoW = refW * settings.displayRatio;
            var scaleX = logoW * logoTW / logoTH;
            var scaleY = logoW;

            if (swapchain.surfaceTransform === SurfaceTransform.ROTATE_90 || swapchain.surfaceTransform === SurfaceTransform.ROTATE_270) {
              scaleX = logoW * dw / dh;
              scaleY = logoW * logoTH / logoTW * dh / dw;
            }

            _this.logoMat.setProperty('resolution', v2_0.set(dw, dh), 0);

            _this.logoMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);

            _this.logoMat.setProperty('translate', v2_0.set(dw * 0.5, dh * 0.5), 0);

            _this.logoMat.setProperty('percent', u_p);

            _this.logoMat.setProperty('u_projection', _this.projection);

            _this.logoMat.passes[0].update();

            if (settings.displayWatermark && _this.watermarkMat) {
              var wartermarkW = refW * 0.5;
              var wartermarkTW = _this.watermarkTexture.width;
              var wartermarkTH = _this.watermarkTexture.height;
              var _scaleX = wartermarkW;

              var _scaleY = wartermarkW * wartermarkTH / wartermarkTW;

              if (swapchain.surfaceTransform === SurfaceTransform.ROTATE_90 || swapchain.surfaceTransform === SurfaceTransform.ROTATE_270) {
                _scaleX = wartermarkW * 0.5;
                _scaleY = wartermarkW * dw / dh * 0.5;
              }

              _this.watermarkMat.setProperty('resolution', v2_0.set(dw, dh), 0);

              _this.watermarkMat.setProperty('scale', v2_0.set(_scaleX, _scaleY), 0);

              _this.watermarkMat.setProperty('translate', v2_0.set(dw * 0.5, dh * 0.1), 0);

              _this.watermarkMat.setProperty('percent', u_p);

              _this.watermarkMat.setProperty('u_projection', _this.projection);

              _this.watermarkMat.passes[0].update();
            }

            if (!_this.isPause) {
              _this.frame();

              if (elapsedTime > settings.totalTime) _this.splashFinish = true;
            }

            requestAnimationFrame(animate);
          };

          legacyCC.game.pause();
          this.handle = requestAnimationFrame(animate);
        };

        _proto.hide = function hide() {
          cancelAnimationFrame(this.handle);
          this.cancelAnimate = true;
          setTimeout(this.destroy.bind(this));
        };

        _proto.initLogo = function initLogo() {
          var device = this.device;
          this.logoMat = new Material();
          this.logoMat.initialize({
            effectName: 'splash-screen'
          });
          var samplerInfo = new SamplerInfo();
          samplerInfo.addressU = Address.CLAMP;
          samplerInfo.addressV = Address.CLAMP;
          samplerInfo.addressW = Address.CLAMP;
          this.sampler = device.getSampler(samplerInfo);
          this.logoTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, this.logoImage.width, this.logoImage.height));
          var pass = this.logoMat.passes[0];
          var binding = pass.getBinding('mainTexture');
          pass.bindTexture(binding, this.logoTexture);
          this.shader = pass.getShaderVariant();
          var descriptorSet = pass.descriptorSet;
          descriptorSet.bindSampler(binding, this.sampler);
          descriptorSet.update();
          var region = new BufferTextureCopy();
          region.texExtent.width = this.logoImage.width;
          region.texExtent.height = this.logoImage.height;
          region.texExtent.depth = 1;
          device.copyTexImagesToTexture([this.logoImage], this.logoTexture, [region]);
        };

        _proto.initWarterMark = function initWarterMark() {
          var wartemarkImg = document.createElement('canvas');
          wartemarkImg.width = 330;
          wartemarkImg.height = 30;
          wartemarkImg.style.width = "" + wartemarkImg.width;
          wartemarkImg.style.height = "" + wartemarkImg.height;
          var ctx = wartemarkImg.getContext('2d');
          ctx.font = 18 + "px Arial";
          ctx.textBaseline = 'top';
          ctx.textAlign = 'left';
          ctx.fillStyle = '`#424242`';
          var text = 'Powered by Cocos Creator';
          var textMetrics = ctx.measureText(text);
          ctx.fillText(text, (330 - textMetrics.width) / 2, 6);
          var region = new BufferTextureCopy();
          region.texExtent.width = wartemarkImg.width;
          region.texExtent.height = wartemarkImg.height;
          region.texExtent.depth = 1;
          this.watermarkTexture = this.device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, wartemarkImg.width, wartemarkImg.height));
          this.device.copyTexImagesToTexture([wartemarkImg], this.watermarkTexture, [region]);
          this.watermarkMat = new Material();
          this.watermarkMat.initialize({
            effectName: 'splash-screen'
          });
          var pass = this.watermarkMat.passes[0];
          var binding = pass.getBinding('mainTexture');
          pass.bindTexture(binding, this.watermarkTexture);
          pass.descriptorSet.update();
        };

        _proto.frame = function frame() {
          var device = this.device,
              swapchain = this.swapchain;
          device.acquire([swapchain]);
          var cmdBuff = this.cmdBuff;
          var framebuffer = this.framebuffer;
          var renderArea = this.renderArea;
          renderArea.width = swapchain.width;
          renderArea.height = swapchain.height;
          cmdBuff.begin();
          cmdBuff.beginRenderPass(framebuffer.renderPass, framebuffer, renderArea, this.clearColors, 1.0, 0);
          var logoPass = this.logoMat.passes[0];
          var logoPso = PipelineStateManager.getOrCreatePipelineState(device, logoPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
          cmdBuff.bindPipelineState(logoPso);
          cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, logoPass.descriptorSet);
          cmdBuff.bindInputAssembler(this.quadAssmebler);
          cmdBuff.draw(this.quadAssmebler);

          if (this.settings.displayWatermark && this.watermarkMat) {
            var wartermarkPass = this.watermarkMat.passes[0];
            var watermarkPso = PipelineStateManager.getOrCreatePipelineState(device, wartermarkPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
            cmdBuff.bindPipelineState(watermarkPso);
            cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, wartermarkPass.descriptorSet);
            cmdBuff.bindInputAssembler(this.quadAssmebler);
            cmdBuff.draw(this.quadAssmebler);
          }

          cmdBuff.endRenderPass();
          cmdBuff.end();
          device.flushCommands([cmdBuff]);
          device.queue.submit([cmdBuff]);
          device.present();
        };

        _proto.destroy = function destroy() {
          this.callBack = null;
          this.device = null;
          this.swapchain = null;
          this.clearColors = null;
          if (this.logoImage.destroy) this.logoImage.destroy();
          this.logoImage = null;
          this.framebuffer = null;
          this.renderArea = null;
          this.cmdBuff = null;
          this.shader = null;
          this.logoMat.destroy();
          this.logoMat = null;
          this.logoTexture.destroy();
          this.logoTexture = null;
          this.quadAssmebler.destroy();
          this.quadAssmebler = null;
          this.vertexBuffers.destroy();
          this.vertexBuffers = null;
          this.indicesBuffers.destroy();
          this.indicesBuffers = null;
          this.sampler = null;

          if (this.watermarkTexture) {
            this.watermarkMat.destroy();
            this.watermarkMat = null;
            this.watermarkTexture.destroy();
            this.watermarkTexture = null;
          }

          this.settings = null;
          SplashScreen._ins = undefined;
        };

        function SplashScreen() {
          this.handle = 0;
          this.callBack = null;
          this.cancelAnimate = false;
          this.startTime = -1;
          this.isPause = false;
          this._splashFinish = false;
          this._loadFinish = false;
          this._directCall = false;
        }

        _createClass(SplashScreen, [{
          key: "splashFinish",
          set: function set(v) {
            this._splashFinish = v;

            this._tryToStart();
          }
        }, {
          key: "loadFinish",
          set: function set(v) {
            this._loadFinish = v;

            this._tryToStart();
          }
        }], [{
          key: "instance",
          get: function get() {
            if (!SplashScreen._ins) {
              SplashScreen._ins = new SplashScreen();
            }

            return SplashScreen._ins;
          }
        }]);

        return SplashScreen;
      }();
      SplashScreen._ins = void 0;
      legacyCC.internal.SplashScreen = SplashScreen;

      var System = exports('System', function () {
        function System() {
          this._id = '';
          this._priority = 0;
          this._executeInEditMode = false;
        }

        System.sortByPriority = function sortByPriority(a, b) {
          if (a._priority < b._priority) {
            return 1;
          } else if (a._priority > b.priority) {
            return -1;
          } else {
            return 0;
          }
        };

        var _proto = System.prototype;

        _proto.init = function init() {};

        _proto.update = function update(dt) {};

        _proto.postUpdate = function postUpdate(dt) {};

        _createClass(System, [{
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(value) {
            this._priority = value;
          }
        }, {
          key: "id",
          get: function get() {
            return this._id;
          },
          set: function set(id) {
            this._id = id;
          }
        }]);

        return System;
      }());

      System.Priority = Enum({
        LOW: 0,
        MEDIUM: 100,
        HIGH: 200,
        SCHEDULER: 1 << 31 >>> 0
      });

      var MAX_POOL_SIZE$1 = 20;
      var idGenerator$3 = new IDGenerator('Scheduler');

      var ListEntry = function ListEntry(target, priority, paused, markedForDeletion) {
        this.target = void 0;
        this.priority = void 0;
        this.paused = void 0;
        this.markedForDeletion = void 0;
        this.target = target;
        this.priority = priority;
        this.paused = paused;
        this.markedForDeletion = markedForDeletion;
      };

      ListEntry.get = function (target, priority, paused, markedForDeletion) {
        var result = ListEntry._listEntries.pop();

        if (result) {
          result.target = target;
          result.priority = priority;
          result.paused = paused;
          result.markedForDeletion = markedForDeletion;
        } else {
          result = new ListEntry(target, priority, paused, markedForDeletion);
        }

        return result;
      };

      ListEntry.put = function (entry) {
        if (ListEntry._listEntries.length < MAX_POOL_SIZE$1) {
          entry.target = null;

          ListEntry._listEntries.push(entry);
        }
      };

      ListEntry._listEntries = [];

      var HashUpdateEntry = function HashUpdateEntry(list, entry, target, callback) {
        this.list = void 0;
        this.entry = void 0;
        this.target = void 0;
        this.callback = void 0;
        this.list = list;
        this.entry = entry;
        this.target = target;
        this.callback = callback;
      };

      HashUpdateEntry.get = function (list, entry, target, callback) {
        var result = HashUpdateEntry._hashUpdateEntries.pop();

        if (result) {
          result.list = list;
          result.entry = entry;
          result.target = target;
          result.callback = callback;
        } else {
          result = new HashUpdateEntry(list, entry, target, callback);
        }

        return result;
      };

      HashUpdateEntry.put = function (entry) {
        if (HashUpdateEntry._hashUpdateEntries.length < MAX_POOL_SIZE$1) {
          entry.list = entry.entry = entry.target = entry.callback = null;

          HashUpdateEntry._hashUpdateEntries.push(entry);
        }
      };

      HashUpdateEntry._hashUpdateEntries = [];

      var HashTimerEntry = function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
        this.timers = void 0;
        this.target = void 0;
        this.timerIndex = void 0;
        this.currentTimer = void 0;
        this.currentTimerSalvaged = void 0;
        this.paused = void 0;
        this.timers = timers;
        this.target = target;
        this.timerIndex = timerIndex;
        this.currentTimer = currentTimer;
        this.currentTimerSalvaged = currentTimerSalvaged;
        this.paused = paused;
      };

      HashTimerEntry.get = function (timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
        var result = HashTimerEntry._hashTimerEntries.pop();

        if (result) {
          result.timers = timers;
          result.target = target;
          result.timerIndex = timerIndex;
          result.currentTimer = currentTimer;
          result.currentTimerSalvaged = currentTimerSalvaged;
          result.paused = paused;
        } else {
          result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
        }

        return result;
      };

      HashTimerEntry.put = function (entry) {
        if (HashTimerEntry._hashTimerEntries.length < MAX_POOL_SIZE$1) {
          entry.timers = entry.target = entry.currentTimer = null;

          HashTimerEntry._hashTimerEntries.push(entry);
        }
      };

      HashTimerEntry._hashTimerEntries = [];

      var CallbackTimer = function () {
        function CallbackTimer() {
          this._lock = void 0;
          this._scheduler = void 0;
          this._elapsed = void 0;
          this._runForever = void 0;
          this._useDelay = void 0;
          this._timesExecuted = void 0;
          this._repeat = void 0;
          this._delay = void 0;
          this._interval = void 0;
          this._target = void 0;
          this._callback = void 0;
          this._lock = false;
          this._scheduler = null;
          this._elapsed = -1;
          this._runForever = false;
          this._useDelay = false;
          this._timesExecuted = 0;
          this._repeat = 0;
          this._delay = 0;
          this._interval = 0;
          this._target = null;
          this._callback = null;
        }

        var _proto = CallbackTimer.prototype;

        _proto.initWithCallback = function initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
          this._lock = false;
          this._scheduler = scheduler;
          this._target = target;
          this._callback = callback;
          this._elapsed = -1;
          this._interval = seconds;
          this._delay = delay;
          this._useDelay = this._delay > 0;
          this._repeat = repeat;
          this._runForever = this._repeat === legacyCC.macro.REPEAT_FOREVER;
          return true;
        };

        _proto.getInterval = function getInterval() {
          return this._interval;
        };

        _proto.setInterval = function setInterval(interval) {
          this._interval = interval;
        };

        _proto.update = function update(dt) {
          if (this._elapsed === -1) {
            this._elapsed = 0;
            this._timesExecuted = 0;
          } else {
            this._elapsed += dt;

            if (this._runForever && !this._useDelay) {
              if (this._elapsed >= this._interval) {
                this.trigger();
                this._elapsed = 0;
              }
            } else {
              if (this._useDelay) {
                if (this._elapsed >= this._delay) {
                  this.trigger();
                  this._elapsed -= this._delay;
                  this._timesExecuted += 1;
                  this._useDelay = false;
                }
              } else if (this._elapsed >= this._interval) {
                this.trigger();
                this._elapsed = 0;
                this._timesExecuted += 1;
              }

              if (this._callback && !this._runForever && this._timesExecuted > this._repeat) {
                this.cancel();
              }
            }
          }
        };

        _proto.getCallback = function getCallback() {
          return this._callback;
        };

        _proto.trigger = function trigger() {
          if (this._target && this._callback) {
            this._lock = true;

            this._callback.call(this._target, this._elapsed);

            this._lock = false;
          }
        };

        _proto.cancel = function cancel() {
          this._scheduler.unschedule(this._callback, this._target);
        };

        return CallbackTimer;
      }();

      CallbackTimer._timers = [];

      CallbackTimer.get = function () {
        return CallbackTimer._timers.pop() || new CallbackTimer();
      };

      CallbackTimer.put = function (timer) {
        if (CallbackTimer._timers.length < MAX_POOL_SIZE$1 && !timer._lock) {
          timer._scheduler = timer._target = timer._callback = null;

          CallbackTimer._timers.push(timer);
        }
      };

      var Scheduler = exports('Scheduler', function (_System) {
        _inheritsLoose(Scheduler, _System);

        Scheduler.enableForTarget = function enableForTarget(target) {
          var found = false;

          if (target.uuid) {
            found = true;
          } else if (target.id) {
            found = true;
          }

          if (!found) {
            if (target.__instanceId) {
              warnID(1513);
            } else {
              target.id = idGenerator$3.getNewId();
            }
          }
        };

        function Scheduler() {
          var _this;

          _this = _System.call(this) || this;
          _this._timeScale = void 0;
          _this._updatesNegList = void 0;
          _this._updates0List = void 0;
          _this._updatesPosList = void 0;
          _this._hashForUpdates = void 0;
          _this._hashForTimers = void 0;
          _this._currentTarget = void 0;
          _this._currentTargetSalvaged = void 0;
          _this._updateHashLocked = void 0;
          _this._arrayForTimers = void 0;
          _this._timeScale = 1.0;
          _this._updatesNegList = [];
          _this._updates0List = [];
          _this._updatesPosList = [];
          _this._hashForUpdates = createMap(true);
          _this._hashForTimers = createMap(true);
          _this._currentTarget = null;
          _this._currentTargetSalvaged = false;
          _this._updateHashLocked = false;
          _this._arrayForTimers = [];
          return _this;
        }

        var _proto2 = Scheduler.prototype;

        _proto2.setTimeScale = function setTimeScale(timeScale) {
          this._timeScale = timeScale;
        };

        _proto2.getTimeScale = function getTimeScale() {
          return this._timeScale;
        };

        _proto2.update = function update(dt) {
          this._updateHashLocked = true;

          if (this._timeScale !== 1) {
            dt *= this._timeScale;
          }

          var i;
          var list;
          var len;
          var entry;

          for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
            entry = list[i];

            if (!entry.paused && !entry.markedForDeletion) {
              entry.target.update(dt);
            }
          }

          for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
            entry = list[i];

            if (!entry.paused && !entry.markedForDeletion) {
              entry.target.update(dt);
            }
          }

          for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
            entry = list[i];

            if (!entry.paused && !entry.markedForDeletion) {
              entry.target.update(dt);
            }
          }

          var elt;
          var arr = this._arrayForTimers;

          for (i = 0; i < arr.length; i++) {
            elt = arr[i];
            this._currentTarget = elt;
            this._currentTargetSalvaged = false;

            if (!elt.paused) {
              for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
                elt.currentTimer = elt.timers[elt.timerIndex];
                elt.currentTimerSalvaged = false;
                elt.currentTimer.update(dt);
                elt.currentTimer = null;
              }
            }

            if (this._currentTargetSalvaged && this._currentTarget.timers.length === 0) {
              this._removeHashElement(this._currentTarget);

              --i;
            }
          }

          for (i = 0, list = this._updatesNegList; i < list.length;) {
            entry = list[i];

            if (entry.markedForDeletion) {
              this._removeUpdateFromHash(entry);
            } else {
              i++;
            }
          }

          for (i = 0, list = this._updates0List; i < list.length;) {
            entry = list[i];

            if (entry.markedForDeletion) {
              this._removeUpdateFromHash(entry);
            } else {
              i++;
            }
          }

          for (i = 0, list = this._updatesPosList; i < list.length;) {
            entry = list[i];

            if (entry.markedForDeletion) {
              this._removeUpdateFromHash(entry);
            } else {
              i++;
            }
          }

          this._updateHashLocked = false;
          this._currentTarget = null;
        };

        _proto2.schedule = function schedule(callback, target, interval, repeat, delay, paused) {
          if (typeof callback !== 'function') {
            var tmp = callback;
            callback = target;
            target = tmp;
          }

          if (arguments.length === 3 || arguments.length === 4 || arguments.length === 5) {
            paused = !!repeat;
            repeat = legacyCC.macro.REPEAT_FOREVER;
            delay = 0;
          }

          assertID(target, 1502);
          var targetId = target.uuid || target.id;

          if (!targetId) {
            errorID(1510);
            return;
          }

          var element = this._hashForTimers[targetId];

          if (!element) {
            element = HashTimerEntry.get(null, target, 0, null, null, paused);

            this._arrayForTimers.push(element);

            this._hashForTimers[targetId] = element;
          } else if (element.paused !== paused) {
            warnID(1511);
          }

          var timer;
          var i;

          if (element.timers == null) {
            element.timers = [];
          } else {
            for (i = 0; i < element.timers.length; ++i) {
              timer = element.timers[i];

              if (timer && callback === timer._callback) {
                logID(1507, timer.getInterval(), interval);
                timer._interval = interval;
                return;
              }
            }
          }

          timer = CallbackTimer.get();
          timer.initWithCallback(this, callback, target, interval, repeat, delay);
          element.timers.push(timer);

          if (this._currentTarget === element && this._currentTargetSalvaged) {
            this._currentTargetSalvaged = false;
          }
        };

        _proto2.scheduleUpdate = function scheduleUpdate(target, priority, paused) {
          var targetId = target.uuid || target.id;

          if (!targetId) {
            errorID(1510);
            return;
          }

          var hashElement = this._hashForUpdates[targetId];

          if (hashElement && hashElement.entry) {
            if (hashElement.entry.priority !== priority) {
              if (this._updateHashLocked) {
                logID(1506);
                hashElement.entry.markedForDeletion = false;
                hashElement.entry.paused = paused;
                return;
              } else {
                this.unscheduleUpdate(target);
              }
            } else {
              hashElement.entry.markedForDeletion = false;
              hashElement.entry.paused = paused;
              return;
            }
          }

          var listElement = ListEntry.get(target, priority, paused, false);
          var ppList;

          if (priority === 0) {
            ppList = this._updates0List;

            this._appendIn(ppList, listElement);
          } else {
            ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;

            this._priorityIn(ppList, listElement, priority);
          }

          this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
        };

        _proto2.unschedule = function unschedule(callback, target) {
          if (!target || !callback) {
            return;
          }

          var targetId = target.uuid || target.id;

          if (!targetId) {
            errorID(1510);
            return;
          }

          var element = this._hashForTimers[targetId];

          if (element) {
            var timers = element.timers;

            for (var i = 0, li = timers.length; i < li; i++) {
              var timer = timers[i];

              if (callback === timer._callback) {
                if (timer === element.currentTimer && !element.currentTimerSalvaged) {
                  element.currentTimerSalvaged = true;
                }

                timers.splice(i, 1);
                CallbackTimer.put(timer);

                if (element.timerIndex >= i) {
                  element.timerIndex--;
                }

                if (timers.length === 0) {
                  if (this._currentTarget === element) {
                    this._currentTargetSalvaged = true;
                  } else {
                    this._removeHashElement(element);
                  }
                }

                return;
              }
            }
          }
        };

        _proto2.unscheduleUpdate = function unscheduleUpdate(target) {
          if (!target) {
            return;
          }

          var targetId = target.uuid || target.id;

          if (!targetId) {
            errorID(1510);
            return;
          }

          var element = this._hashForUpdates[targetId];

          if (element) {
            if (this._updateHashLocked) {
              element.entry.markedForDeletion = true;
            } else {
              this._removeUpdateFromHash(element.entry);
            }
          }
        };

        _proto2.unscheduleAllForTarget = function unscheduleAllForTarget(target) {
          if (!target) {
            return;
          }

          var targetId = target.uuid || target.id;

          if (!targetId) {
            errorID(1510);
            return;
          }

          var element = this._hashForTimers[targetId];

          if (element) {
            var timers = element.timers;

            if (timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged) {
              element.currentTimerSalvaged = true;
            }

            for (var i = 0, l = timers.length; i < l; i++) {
              CallbackTimer.put(timers[i]);
            }

            timers.length = 0;

            if (this._currentTarget === element) {
              this._currentTargetSalvaged = true;
            } else {
              this._removeHashElement(element);
            }
          }

          this.unscheduleUpdate(target);
        };

        _proto2.unscheduleAll = function unscheduleAll() {
          this.unscheduleAllWithMinPriority(System.Priority.SCHEDULER);
        };

        _proto2.unscheduleAllWithMinPriority = function unscheduleAllWithMinPriority(minPriority) {
          var i;
          var element;
          var arr = this._arrayForTimers;

          for (i = arr.length - 1; i >= 0; i--) {
            element = arr[i];
            this.unscheduleAllForTarget(element.target);
          }

          var entry;
          var temp_length = 0;

          if (minPriority < 0) {
            for (i = 0; i < this._updatesNegList.length;) {
              temp_length = this._updatesNegList.length;
              entry = this._updatesNegList[i];

              if (entry && entry.priority >= minPriority) {
                this.unscheduleUpdate(entry.target);
              }

              if (temp_length === this._updatesNegList.length) {
                i++;
              }
            }
          }

          if (minPriority <= 0) {
            for (i = 0; i < this._updates0List.length;) {
              temp_length = this._updates0List.length;
              entry = this._updates0List[i];

              if (entry) {
                this.unscheduleUpdate(entry.target);
              }

              if (temp_length === this._updates0List.length) {
                i++;
              }
            }
          }

          for (i = 0; i < this._updatesPosList.length;) {
            temp_length = this._updatesPosList.length;
            entry = this._updatesPosList[i];

            if (entry && entry.priority >= minPriority) {
              this.unscheduleUpdate(entry.target);
            }

            if (temp_length === this._updatesPosList.length) {
              i++;
            }
          }
        };

        _proto2.isScheduled = function isScheduled(callback, target) {
          assertID(callback, 1508);
          assertID(target, 1509);
          var targetId = target.uuid || target.id;

          if (!targetId) {
            errorID(1510);
            return false;
          }

          var element = this._hashForTimers[targetId];

          if (!element) {
            return false;
          }

          if (element.timers == null) {
            return false;
          } else {
            var timers = element.timers;

            for (var i = 0; i < timers.length; ++i) {
              var timer = timers[i];

              if (callback === timer._callback) {
                return true;
              }
            }

            return false;
          }
        };

        _proto2.pauseAllTargets = function pauseAllTargets() {
          return this.pauseAllTargetsWithMinPriority(System.Priority.SCHEDULER);
        };

        _proto2.pauseAllTargetsWithMinPriority = function pauseAllTargetsWithMinPriority(minPriority) {
          var idsWithSelectors = [];
          var element;
          var locArrayForTimers = this._arrayForTimers;
          var i;
          var li;

          for (i = 0, li = locArrayForTimers.length; i < li; i++) {
            element = locArrayForTimers[i];

            if (element) {
              element.paused = true;
              idsWithSelectors.push(element.target);
            }
          }

          var entry;

          if (minPriority < 0) {
            for (i = 0; i < this._updatesNegList.length; i++) {
              entry = this._updatesNegList[i];

              if (entry) {
                if (entry.priority >= minPriority) {
                  entry.paused = true;
                  idsWithSelectors.push(entry.target);
                }
              }
            }
          }

          if (minPriority <= 0) {
            for (i = 0; i < this._updates0List.length; i++) {
              entry = this._updates0List[i];

              if (entry) {
                entry.paused = true;
                idsWithSelectors.push(entry.target);
              }
            }
          }

          for (i = 0; i < this._updatesPosList.length; i++) {
            entry = this._updatesPosList[i];

            if (entry) {
              if (entry.priority >= minPriority) {
                entry.paused = true;
                idsWithSelectors.push(entry.target);
              }
            }
          }

          return idsWithSelectors;
        };

        _proto2.resumeTargets = function resumeTargets(targetsToResume) {
          if (!targetsToResume) {
            return;
          }

          for (var i = 0; i < targetsToResume.length; i++) {
            this.resumeTarget(targetsToResume[i]);
          }
        };

        _proto2.pauseTarget = function pauseTarget(target) {
          assertID(target, 1503);
          var targetId = target.uuid || target.id;

          if (!targetId) {
            errorID(1510);
            return;
          }

          var element = this._hashForTimers[targetId];

          if (element) {
            element.paused = true;
          }

          var elementUpdate = this._hashForUpdates[targetId];

          if (elementUpdate) {
            elementUpdate.entry.paused = true;
          }
        };

        _proto2.resumeTarget = function resumeTarget(target) {
          assertID(target, 1504);
          var targetId = target.uuid || target.id;

          if (!targetId) {
            errorID(1510);
            return;
          }

          var element = this._hashForTimers[targetId];

          if (element) {
            element.paused = false;
          }

          var elementUpdate = this._hashForUpdates[targetId];

          if (elementUpdate) {
            elementUpdate.entry.paused = false;
          }
        };

        _proto2.isTargetPaused = function isTargetPaused(target) {
          assertID(target, 1505);
          var targetId = target.uuid || target.id;

          if (!targetId) {
            errorID(1510);
            return false;
          }

          var element = this._hashForTimers[targetId];

          if (element) {
            return element.paused;
          }

          var elementUpdate = this._hashForUpdates[targetId];

          if (elementUpdate) {
            return elementUpdate.entry.paused;
          }

          return false;
        };

        _proto2._removeHashElement = function _removeHashElement(element) {
          var targetId = element.target.uuid || element.target.id;
          delete this._hashForTimers[targetId];
          var arr = this._arrayForTimers;

          for (var i = 0, l = arr.length; i < l; i++) {
            if (arr[i] === element) {
              arr.splice(i, 1);
              break;
            }
          }

          HashTimerEntry.put(element);
        };

        _proto2._removeUpdateFromHash = function _removeUpdateFromHash(entry) {
          var targetId = entry.target.uuid || entry.target.id;
          var element = this._hashForUpdates[targetId];

          if (element) {
            var list = element.list;
            var listEntry = element.entry;

            for (var i = 0, l = list.length; i < l; i++) {
              if (list[i] === listEntry) {
                list.splice(i, 1);
                break;
              }
            }

            delete this._hashForUpdates[targetId];
            ListEntry.put(listEntry);
            HashUpdateEntry.put(element);
          }
        };

        _proto2._priorityIn = function _priorityIn(ppList, listElement, priority) {
          for (var i = 0; i < ppList.length; i++) {
            if (priority < ppList[i].priority) {
              ppList.splice(i, 0, listElement);
              return;
            }
          }

          ppList.push(listElement);
        };

        _proto2._appendIn = function _appendIn(ppList, listElement) {
          ppList.push(listElement);
        };

        return Scheduler;
      }(System));
      Scheduler.ID = 'scheduler';
      legacyCC.Scheduler = Scheduler;

      var _orientationMap;
      var orientationMap$1 = (_orientationMap = {}, _orientationMap[Orientation.PORTRAIT] = SurfaceTransform.IDENTITY, _orientationMap[Orientation.LANDSCAPE_RIGHT] = SurfaceTransform.ROTATE_90, _orientationMap[Orientation.PORTRAIT_UPSIDE_DOWN] = SurfaceTransform.ROTATE_180, _orientationMap[Orientation.LANDSCAPE_LEFT] = SurfaceTransform.ROTATE_270, _orientationMap);
      var RenderWindow = function () {
        RenderWindow.registerCreateFunc = function registerCreateFunc(root) {
          root._createWindowFun = function (_root) {
            return new RenderWindow(_root);
          };
        };

        function RenderWindow(root) {
          this._title = '';
          this._width = 1;
          this._height = 1;
          this._swapchain = null;
          this._renderPass = null;
          this._colorTextures = [];
          this._depthStencilTexture = null;
          this._cameras = [];
          this._hasOnScreenAttachments = false;
          this._hasOffScreenAttachments = false;
          this._framebuffer = null;
        }

        var _proto = RenderWindow.prototype;

        _proto.initialize = function initialize(device, info) {
          this._init();

          if (info.title !== undefined) {
            this._title = info.title;
          }

          if (info.swapchain !== undefined) {
            this._swapchain = info.swapchain;
          }

          this._width = info.width;
          this._height = info.height;
          this._renderPass = device.createRenderPass(info.renderPassInfo);

          if (info.swapchain) {
            this._setSwapchain(info.swapchain);

            this._colorTextures.push(info.swapchain.colorTexture);

            this._depthStencilTexture = info.swapchain.depthStencilTexture;
          } else {
            for (var i = 0; i < info.renderPassInfo.colorAttachments.length; i++) {
              this._colorTextures.push(device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_SRC, info.renderPassInfo.colorAttachments[i].format, this._width, this._height)));
            }

            if (info.renderPassInfo.depthStencilAttachment.format !== Format.UNKNOWN) {
              this._depthStencilTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.DEPTH_STENCIL_ATTACHMENT | TextureUsageBit.SAMPLED, info.renderPassInfo.depthStencilAttachment.format, this._width, this._height));
            }
          }

          this._setFrameBuffer(device.createFramebuffer(new FramebufferInfo(this._renderPass, this._colorTextures, this._depthStencilTexture)));

          return true;
        };

        _proto.destroy = function destroy() {
          this.clearCameras();

          if (this._framebuffer) {
            this._framebuffer.destroy();

            this._framebuffer = null;
          }

          if (this._depthStencilTexture) {
            this._depthStencilTexture.destroy();

            this._depthStencilTexture = null;
          }

          for (var i = 0; i < this._colorTextures.length; i++) {
            var colorTexture = this._colorTextures[i];

            if (colorTexture) {
              colorTexture.destroy();
            }
          }

          this._colorTextures.length = 0;

          this._destroy();
        };

        _proto.resize = function resize(width, height) {
          if (this._swapchain) {
            this._swapchain.resize(width, height, orientationMap$1[screenAdapter.orientation]);

            this._width = this._swapchain.width;
            this._height = this._swapchain.height;
          } else {
            for (var i = 0; i < this._colorTextures.length; i++) {
              this._colorTextures[i].resize(width, height);
            }

            if (this._depthStencilTexture) {
              this._depthStencilTexture.resize(width, height);
            }

            this._width = width;
            this._height = height;
          }

          if (this.framebuffer) {
            this.framebuffer.destroy();
            this.framebuffer.initialize(new FramebufferInfo(this._renderPass, this._colorTextures, this._depthStencilTexture));
          }

          for (var _iterator = _createForOfIteratorHelperLoose(this._cameras), _step; !(_step = _iterator()).done;) {
            var camera = _step.value;
            camera.resize(width, height);
          }
        };

        _proto.extractRenderCameras = function extractRenderCameras(cameras) {
          for (var j = 0; j < this._cameras.length; j++) {
            var camera = this._cameras[j];

            if (camera.enabled) {
              camera.update();
              cameras.push(camera);
            }
          }
        };

        _proto.attachCamera = function attachCamera(camera) {
          for (var i = 0; i < this._cameras.length; i++) {
            if (this._cameras[i] === camera) {
              return;
            }
          }

          this._cameras.push(camera);

          this.sortCameras();
        };

        _proto.detachCamera = function detachCamera(camera) {
          for (var i = 0; i < this._cameras.length; ++i) {
            if (this._cameras[i] === camera) {
              this._cameras.splice(i, 1);

              return;
            }
          }
        };

        _proto.clearCameras = function clearCameras() {
          this._cameras.length = 0;
        };

        _proto.sortCameras = function sortCameras() {
          this._cameras.sort(function (a, b) {
            return a.priority - b.priority;
          });
        };

        _proto._init = function _init() {
        };

        _proto._destroy = function _destroy() {
        };

        _proto._setSwapchain = function _setSwapchain(val) {
          this._swapchain = val;
        };

        _proto._setFrameBuffer = function _setFrameBuffer(val) {
          this._framebuffer = val;
        };

        _createClass(RenderWindow, [{
          key: "width",
          get: function get() {
            return this._width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          }
        }, {
          key: "swapchain",
          get: function get() {
            return this._swapchain;
          }
        }, {
          key: "framebuffer",
          get: function get() {
            return this._framebuffer;
          }
        }, {
          key: "cameras",
          get: function get() {
            return this._cameras;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]);

        return RenderWindow;
      }();

      var Root = exports('Root', function () {
        function Root(device) {
          var _this = this;

          this._createSceneFun = null;
          this._createWindowFun = null;
          this._device = void 0;
          this._windows = [];
          this._mainWindow = null;
          this._curWindow = null;
          this._tempWindow = null;
          this._pipeline = null;
          this._batcher = null;
          this._dataPoolMgr = void 0;
          this._scenes = [];
          this._modelPools = new Map();
          this._cameraPool = null;
          this._lightPools = new Map();
          this._fpsTime = 0;
          this._frameCount = 0;
          this._fps = 0;
          this._fixedFPS = 0;
          this._useDeferredPipeline = false;
          this._fixedFPSFrameTime = 0;
          this._cumulativeTime = 0;
          this._frameTime = 0;
          this._device = device;
          this._dataPoolMgr = legacyCC.internal.DataPoolManager && new legacyCC.internal.DataPoolManager(device);
          RenderScene.registerCreateFunc(this);
          RenderWindow.registerCreateFunc(this);
          this._cameraPool = new Pool$1(function () {
            return new Camera(_this._device);
          }, 4, function (cam) {
            return cam.destroy();
          });
        }

        var _proto = Root.prototype;

        _proto.initialize = function initialize(info) {
          this._init();

          var swapchain = legacyCC.game._swapchain;
          var colorAttachment = new ColorAttachment();
          colorAttachment.format = swapchain.colorTexture.format;
          var depthStencilAttachment = new DepthStencilAttachment();
          depthStencilAttachment.format = swapchain.depthStencilTexture.format;
          depthStencilAttachment.depthStoreOp = StoreOp.DISCARD;
          depthStencilAttachment.stencilStoreOp = StoreOp.DISCARD;
          var renderPassInfo = new RenderPassInfo([colorAttachment], depthStencilAttachment);
          this._mainWindow = this.createWindow({
            title: 'rootMainWindow',
            width: swapchain.width,
            height: swapchain.height,
            renderPassInfo: renderPassInfo,
            swapchain: swapchain
          });
          this._curWindow = this._mainWindow;
          return Promise.resolve(builtinResMgr.initBuiltinRes(this._device));
        };

        _proto.destroy = function destroy() {
          this.destroyScenes();

          if (this._pipeline) {
            this._pipeline.destroy();

            this._pipeline = null;
          }

          if (this._batcher) {
            this._batcher.destroy();

            this._batcher = null;
          }

          this._curWindow = null;
          this._mainWindow = null;
          this.dataPoolManager.clear();

          this._destroy();
        };

        _proto.resize = function resize(width, height) {
          for (var _iterator = _createForOfIteratorHelperLoose(this._windows), _step; !(_step = _iterator()).done;) {
            var window = _step.value;

            if (window.swapchain) {
              window.resize(width, height);
            }
          }
        };

        _proto.setRenderPipeline = function setRenderPipeline(rppl) {
          if (rppl instanceof DeferredPipeline) {
            this._useDeferredPipeline = true;
          }

          var isCreateDefaultPipeline = false;

          if (!rppl) {
            rppl = createDefaultPipeline();
            isCreateDefaultPipeline = true;
          }

          this._pipeline = rppl;

          if (!this._useDeferredPipeline || !this.device.hasFeature(Feature.COMPUTE_SHADER)) {
            this._pipeline.clusterEnabled = false;
          }

          this._pipeline.bloomEnabled = false;

          if (!this._pipeline.activate(this._mainWindow.swapchain)) {
            if (isCreateDefaultPipeline) {
              this._pipeline.destroy();
            }

            this._pipeline = null;
            return false;
          }

          var scene = legacyCC.director.getScene();

          if (scene) {
            scene.globals.activate();
          }

          this.onGlobalPipelineStateChanged();

          if (!this._batcher && legacyCC.internal.Batcher2D) {
            this._batcher = new legacyCC.internal.Batcher2D(this);

            if (!this._batcher.initialize()) {
              this.destroy();
              return false;
            }
          }

          return true;
        };

        _proto.onGlobalPipelineStateChanged = function onGlobalPipelineStateChanged() {
          for (var i = 0; i < this._scenes.length; i++) {
            this._scenes[i].onGlobalPipelineStateChanged();
          }

          this._pipeline.pipelineSceneData.onGlobalPipelineStateChanged();
        };

        _proto.activeWindow = function activeWindow(window) {
          this._curWindow = window;
        };

        _proto.resetCumulativeTime = function resetCumulativeTime() {
          this._setCumulativeTime(0);
        };

        _proto.frameMove = function frameMove(deltaTime) {
          this._setFrameTime(deltaTime);

          ++this._frameCount;

          this._setCumulativeTime(deltaTime);

          this._fpsTime += deltaTime;

          if (this._fpsTime > 1.0) {
            this._fps = this._frameCount;
            this._frameCount = 0;
            this._fpsTime = 0.0;
          }

          for (var i = 0; i < this._scenes.length; ++i) {
            this._scenes[i].removeBatches();
          }

          var windows = this._windows;
          var cameraList = [];

          for (var _i = 0; _i < windows.length; _i++) {
            var window = windows[_i];
            window.extractRenderCameras(cameraList);
          }

          if (this._pipeline && cameraList.length > 0) {
            this._device.acquire([legacyCC.game._swapchain]);

            var scenes = this._scenes;
            var stamp = legacyCC.director.getTotalFrames();

            if (this._batcher) {
              this._batcher.update();

              this._batcher.uploadBuffers();
            }

            for (var _i2 = 0; _i2 < scenes.length; _i2++) {
              scenes[_i2].update(stamp);
            }

            legacyCC.director.emit(legacyCC.Director.EVENT_BEFORE_COMMIT);
            cameraList.sort(function (a, b) {
              return a.priority - b.priority;
            });

            this._pipeline.render(cameraList);

            this._device.present();
          }

          if (this._batcher) this._batcher.reset();
        };

        _proto.createWindow = function createWindow(info) {
          var window = this._createWindowFun(this);

          window.initialize(this.device, info);

          this._windows.push(window);

          return window;
        };

        _proto.destroyWindow = function destroyWindow(window) {
          for (var i = 0; i < this._windows.length; ++i) {
            if (this._windows[i] === window) {
              window.destroy();

              this._windows.splice(i, 1);

              return;
            }
          }
        };

        _proto.destroyWindows = function destroyWindows() {
          for (var _iterator2 = _createForOfIteratorHelperLoose(this._windows), _step2; !(_step2 = _iterator2()).done;) {
            var window = _step2.value;
            window.destroy();
          }

          this._windows.length = 0;
        };

        _proto.createScene = function createScene(info) {
          var scene = this._createSceneFun(this);

          scene.initialize(info);

          this._scenes.push(scene);

          return scene;
        };

        _proto.destroyScene = function destroyScene(scene) {
          for (var i = 0; i < this._scenes.length; ++i) {
            if (this._scenes[i] === scene) {
              scene.destroy();

              this._scenes.splice(i, 1);

              return;
            }
          }
        };

        _proto.destroyScenes = function destroyScenes() {
          for (var _iterator3 = _createForOfIteratorHelperLoose(this._scenes), _step3; !(_step3 = _iterator3()).done;) {
            var scene = _step3.value;
            scene.destroy();
          }

          this._scenes.length = 0;
        };

        _proto.createModel = function createModel(ModelCtor) {
          var p = this._modelPools.get(ModelCtor);

          if (!p) {
            this._modelPools.set(ModelCtor, new Pool$1(function () {
              return new ModelCtor();
            }, 10, function (obj) {
              return obj.destroy();
            }));

            p = this._modelPools.get(ModelCtor);
          }

          var model = p.alloc();
          model.initialize();
          return model;
        };

        _proto.destroyModel = function destroyModel(m) {
          var p = this._modelPools.get(m.constructor);

          if (p) {
            p.free(m);

            if (m.scene) {
              m.scene.removeModel(m);
            }
          } else {
            warnID(1300, m.constructor.name);
          }

          m.destroy();
        };

        _proto.createCamera = function createCamera() {
          return this._cameraPool.alloc();
        };

        _proto.createLight = function createLight(LightCtor) {
          var l = this._lightPools.get(LightCtor);

          if (!l) {
            this._lightPools.set(LightCtor, new Pool$1(function () {
              return new LightCtor();
            }, 4, function (obj) {
              return obj.destroy();
            }));

            l = this._lightPools.get(LightCtor);
          }

          var light = l.alloc();
          light.initialize();
          return light;
        };

        _proto.destroyLight = function destroyLight(l) {
          var p = this._lightPools.get(l.constructor);

          if (p) {
            p.free(l);

            if (l.scene) {
              switch (l.type) {
                case LightType.SPHERE:
                  l.scene.removeSphereLight(l);
                  break;

                case LightType.SPOT:
                  l.scene.removeSpotLight(l);
                  break;
              }
            }
          }

          l.destroy();
        };

        _proto._init = function _init() {
        };

        _proto._destroy = function _destroy() {
        };

        _proto._setCumulativeTime = function _setCumulativeTime(deltaTime) {
          this._cumulativeTime += deltaTime;
        };

        _proto._setFrameTime = function _setFrameTime(deltaTime) {
          this._frameTime = deltaTime;
        };

        _createClass(Root, [{
          key: "device",
          get: function get() {
            return this._device;
          }
        }, {
          key: "mainWindow",
          get: function get() {
            return this._mainWindow;
          }
        }, {
          key: "curWindow",
          get: function get() {
            return this._curWindow;
          },
          set: function set(window) {
            this._curWindow = window;
          }
        }, {
          key: "tempWindow",
          get: function get() {
            return this._tempWindow;
          },
          set: function set(window) {
            this._tempWindow = window;
          }
        }, {
          key: "windows",
          get: function get() {
            return this._windows;
          }
        }, {
          key: "pipeline",
          get: function get() {
            return this._pipeline;
          }
        }, {
          key: "batcher2D",
          get: function get() {
            return this._batcher;
          }
        }, {
          key: "scenes",
          get: function get() {
            return this._scenes;
          }
        }, {
          key: "cumulativeTime",
          get: function get() {
            return this._cumulativeTime;
          }
        }, {
          key: "frameTime",
          get: function get() {
            return this._frameTime;
          }
        }, {
          key: "frameCount",
          get: function get() {
            return this._frameCount;
          }
        }, {
          key: "fps",
          get: function get() {
            return this._fps;
          }
        }, {
          key: "fixedFPS",
          get: function get() {
            return this._fixedFPS;
          },
          set: function set(fps) {
            if (fps > 0) {
              this._fixedFPS = fps;
              this._fixedFPSFrameTime = 1000.0 / fps;
            } else {
              this._fixedFPSFrameTime = 0;
            }
          }
        }, {
          key: "dataPoolManager",
          get: function get() {
            return this._dataPoolMgr;
          }
        }, {
          key: "useDeferredPipeline",
          get: function get() {
            return this._useDeferredPipeline;
          }
        }]);

        return Root;
      }());
      legacyCC.Root = Root;

      var Game = exports('Game', function (_EventTarget) {
        _inheritsLoose(Game, _EventTarget);

        function Game() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _EventTarget.call.apply(_EventTarget, [this].concat(args)) || this;
          _this.frame = null;
          _this.container = null;
          _this.canvas = null;
          _this.renderType = -1;
          _this.eventTargetOn = _EventTarget.prototype.on;
          _this.eventTargetOnce = _EventTarget.prototype.once;
          _this.config = {};
          _this.onStart = null;
          _this.frameTime = 1000 / 60;
          _this.collisionMatrix = [];
          _this.groupList = [];
          _this._persistRootNodes = {};
          _this._gfxDevice = null;
          _this._swapchain = null;
          _this._configLoaded = false;
          _this._isCloning = false;
          _this._inited = false;
          _this._engineInited = false;
          _this._rendererInitialized = false;
          _this._paused = true;
          _this._frameRate = 60;
          _this._intervalId = 0;
          _this._initTime = 0;
          _this._startTime = 0;
          _this._deltaTime = 0.0;
          _this._onEngineInitedCallback = [];
          return _this;
        }

        var _proto = Game.prototype;

        _proto.setFrameRate = function setFrameRate(frameRate) {
          this.frameRate = frameRate;
        };

        _proto.getFrameRate = function getFrameRate() {
          return this.frameRate;
        };

        _proto.step = function step() {
          legacyCC.director.tick(this.frameTime / 1000);
        };

        _proto.pause = function pause() {
          if (this._paused) {
            return;
          }

          this._paused = true;

          if (this._intervalId) {
            window.cAF(this._intervalId);
            this._intervalId = 0;
          }
        };

        _proto.resume = function resume() {
          if (!this._paused) {
            return;
          }

          input._clearEvents();

          if (this._intervalId) {
            window.cAF(this._intervalId);
            this._intervalId = 0;
          }

          this._paused = false;

          this._updateCallback();

          this._intervalId = window.rAF(this._frameCB);
        };

        _proto.isPaused = function isPaused() {
          return this._paused;
        };

        _proto.restart = function restart() {
          var _this2 = this;

          var endFramePromise = new Promise(function (resolve) {
            return legacyCC.director.once(legacyCC.Director.EVENT_END_FRAME, function () {
              return resolve();
            });
          });
          return endFramePromise.then(function () {
            for (var id in _this2._persistRootNodes) {
              _this2.removePersistRootNode(_this2._persistRootNodes[id]);
            }

            legacyCC.director.getScene().destroy();

            legacyCC.Object._deferredDestroy();

            legacyCC.director.reset();
            legacyCC.profiler.reset();

            _this2.pause();

            return _this2._setRenderPipelineNShowSplash().then(function () {
              _this2.resume();

              _this2._safeEmit(Game.EVENT_RESTART);
            });
          });
        };

        _proto.end = function end() {
          systemInfo.close();
        };

        _proto.on = function on(type, callback, target, once) {
          if (this._engineInited && type === Game.EVENT_ENGINE_INITED || this._inited && type === Game.EVENT_GAME_INITED || this._rendererInitialized && type === Game.EVENT_RENDERER_INITED) {
            callback.call(target);
          }

          return this.eventTargetOn(type, callback, target, once);
        };

        _proto.once = function once(type, callback, target) {
          if (this._engineInited && type === Game.EVENT_ENGINE_INITED) {
            return callback.call(target);
          }

          return this.eventTargetOnce(type, callback, target);
        };

        _proto.init = function init(config) {
          var _this3 = this;

          this._initConfig(config);

          {
            screen._init({
              configOrientation: config.orientation || 'auto',
              exactFitScreen: config.exactFitScreen
            });
          }

          if (this.config.assetOptions) {
            legacyCC.assetManager.init(this.config.assetOptions);
          }

          if (this.config.layers) {
            var userLayers = this.config.layers;

            for (var i = 0; i < userLayers.length; i++) {
              var layer = userLayers[i];
              var bitNum = log2(layer.value);
              Layers.addLayer(layer.name, bitNum);
            }
          }

          return this._initEngine().then(function () {
            {
              _this3._initEvents();
            }

            if (legacyCC.director.root && legacyCC.director.root.dataPoolManager) {
              legacyCC.director.root.dataPoolManager.jointTexturePool.registerCustomTextureLayouts(config.customJointTextureLayouts);
            }

            return _this3._engineInited;
          });
        };

        _proto.run = function run(configOrCallback, onStart) {
          var _this4 = this;

          var initPromise;

          if (typeof configOrCallback !== 'function' && configOrCallback) {
            initPromise = this.init(configOrCallback);
            this.onStart = onStart !== null && onStart !== void 0 ? onStart : null;
          } else {
            this.onStart = configOrCallback !== null && configOrCallback !== void 0 ? configOrCallback : null;
          }

          garbageCollectionManager.init();
          return Promise.resolve(initPromise).then(function () {
            return _this4._setRenderPipelineNShowSplash();
          }).then(function () {
          });
        };

        _proto.addPersistRootNode = function addPersistRootNode(node) {
          if (!legacyCC.Node.isNode(node) || !node.uuid) {
            warnID(3800);
            return;
          }

          var id = node.uuid;

          if (!this._persistRootNodes[id]) {
            var scene = legacyCC.director._scene;

            if (legacyCC.isValid(scene)) {
              if (!node.parent) {
                node.parent = scene;
              } else if (!(node.parent instanceof legacyCC.Scene)) {
                warnID(3801);
                return;
              } else if (node.parent !== scene) {
                warnID(3802);
                return;
              } else {
                node._originalSceneId = scene.uuid;
              }
            }

            this._persistRootNodes[id] = node;
            node._persistNode = true;

            legacyCC.assetManager._releaseManager._addPersistNodeRef(node);
          }
        };

        _proto.removePersistRootNode = function removePersistRootNode(node) {
          var id = node.uuid || '';

          if (node === this._persistRootNodes[id]) {
            delete this._persistRootNodes[id];
            node._persistNode = false;
            node._originalSceneId = '';

            legacyCC.assetManager._releaseManager._removePersistNodeRef(node);
          }
        };

        _proto.isPersistRootNode = function isPersistRootNode(node) {
          return !!node._persistNode;
        };

        _proto.onEngineInitedAsync = function onEngineInitedAsync(func) {
          this._onEngineInitedCallback.push(func);
        };

        _proto._initEngine = function _initEngine() {
          var _this5 = this;

          this._initDevice();

          var director = legacyCC.director;
          return Promise.resolve(director._init()).then(function () {
            legacyCC.view.init();
            log("Cocos Creator v" + engineVersion);

            _this5.emit(Game.EVENT_ENGINE_INITED);

            _this5._engineInited = true;

            if (legacyCC.internal.dynamicAtlasManager) {
              legacyCC.internal.dynamicAtlasManager.enabled = !macro.CLEANUP_IMAGE_CACHE;
            }
          }).then(function () {
            var initCallbackPromises = _this5._onEngineInitedCallback.map(function (func) {
              return func();
            }).filter(Boolean);

            _this5._onEngineInitedCallback.length = 0;
            return Promise.all(initCallbackPromises);
          });
        };

        _proto._setAnimFrame = function _setAnimFrame() {
          var frameRate = this._frameRate;

          {
            var rAF = window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;

            if (frameRate !== 60 && frameRate !== 30) {
              window.rAF = this._stTime.bind(this);
              window.cAF = this._ctTime;
            } else {
              window.rAF = rAF || this._stTime.bind(this);
              window.cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.ocancelAnimationFrame || this._ctTime;

              this._updateCallback();
            }
          }
        };

        _proto._stTime = function _stTime(callback) {
          var currTime = performance.now();
          var elapseTime = Math.max(0, currTime - this._startTime);
          var timeToCall = Math.max(0, this.frameTime - elapseTime);
          var id = window.setTimeout(callback, timeToCall);
          return id;
        };

        _proto._ctTime = function _ctTime(id) {
          window.clearTimeout(id);
        };

        _proto._calculateDT = function _calculateDT(now) {
          if (!now) now = performance.now();
          this._deltaTime = now > this._startTime ? (now - this._startTime) / 1000 : 0;

          if (this._deltaTime > Game.DEBUG_DT_THRESHOLD) {
            this._deltaTime = this.frameTime / 1000;
          }

          this._startTime = now;
          return this._deltaTime;
        };

        _proto._updateCallback = function _updateCallback() {
          var _this6 = this;

          var director = legacyCC.director;
          var callback;

          if ( this._frameRate === 30) {
            var skip = true;

            callback = function callback(time) {
              _this6._intervalId = window.rAF(_this6._frameCB);
              skip = !skip;

              if (skip) {
                return;
              }

              director.tick(_this6._calculateDT(time));
            };
          } else {
            callback = function callback(time) {
              director.tick(_this6._calculateDT(time));
              _this6._intervalId = window.rAF(_this6._frameCB);
            };
          }

          this._frameCB = callback;
        };

        _proto._runMainLoop = function _runMainLoop() {
          if (!this._inited || EDITOR ) {
            return;
          }

          var config = this.config;
          var director = legacyCC.director;
          setDisplayStats(!!config.showFPS);
          director.startAnimation();
          this.resume();
        };

        _proto._initConfig = function _initConfig(config) {
          if (typeof config.debugMode !== 'number') {
            config.debugMode = DebugMode.NONE;
          }

          config.exposeClassName = !!config.exposeClassName;

          if (typeof config.frameRate !== 'number') {
            config.frameRate = 60;
          }

          var renderMode = config.renderMode;

          if (typeof renderMode !== 'number' || renderMode > 3 || renderMode < 0) {
            config.renderMode = 0;
          }

          config.showFPS = !!config.showFPS;

          _resetDebugSetting(config.debugMode);

          this.config = config;
          this._configLoaded = true;
          this.frameRate = config.frameRate;
        };

        _proto._determineRenderType = function _determineRenderType() {
          var config = this.config;
          var userRenderMode = parseInt(config.renderMode, 10);
          this.renderType = Game.RENDER_TYPE_CANVAS;
          var supportRender = false;

          if (userRenderMode === 1) {
            this.renderType = Game.RENDER_TYPE_CANVAS;
            supportRender = true;
          } else if (userRenderMode === 0 || userRenderMode === 2) {
            this.renderType = Game.RENDER_TYPE_WEBGL;
            supportRender = true;
          } else if (userRenderMode === 3) {
            this.renderType = Game.RENDER_TYPE_HEADLESS;
            supportRender = true;
          }

          if (!supportRender) {
            throw new Error(getError(3820, userRenderMode));
          }
        };

        _proto._initDevice = function _initDevice() {
          if (this._rendererInitialized) {
            return;
          }

          var adapter = this.config.adapter;

          if (adapter) {
            this.canvas = adapter.canvas;
            this.frame = adapter.frame;
            this.container = adapter.container;
          }

          this._determineRenderType();

          if (this.renderType === Game.RENDER_TYPE_WEBGL) {
            var deviceInfo = new DeviceInfo(bindingMappingInfo);

            {
              var useWebGL2 = !!window.WebGL2RenderingContext;
              var userAgent = window.navigator.userAgent.toLowerCase();

              if (userAgent.indexOf('safari') !== -1 && userAgent.indexOf('chrome') === -1 || sys.browserType === BrowserType.UC) {
                  useWebGL2 = false;
                }

              var deviceCtors = [];

              if (useWebGL2 && legacyCC.WebGL2Device) {
                deviceCtors.push(legacyCC.WebGL2Device);
              }

              if (legacyCC.WebGLDevice) {
                deviceCtors.push(legacyCC.WebGLDevice);
              }

              if (legacyCC.EmptyDevice) {
                deviceCtors.push(legacyCC.EmptyDevice);
              }

              Device.canvas = this.canvas;

              for (var i = 0; i < deviceCtors.length; i++) {
                this._gfxDevice = new deviceCtors[i]();

                if (this._gfxDevice.initialize(deviceInfo)) {
                  break;
                }
              }
            }
          } else if (this.renderType === Game.RENDER_TYPE_HEADLESS && legacyCC.EmptyDevice) {
            this._gfxDevice = new legacyCC.EmptyDevice();

            this._gfxDevice.initialize(new DeviceInfo(bindingMappingInfo));
          }

          if (!this._gfxDevice) {
            error('can not support canvas rendering in 3D');
            this.renderType = Game.RENDER_TYPE_CANVAS;
            return;
          }

          var swapchainInfo = new SwapchainInfo(this.canvas);
          var windowSize = screen.windowSize;
          swapchainInfo.width = windowSize.width;
          swapchainInfo.height = windowSize.height;
          this._swapchain = this._gfxDevice.createSwapchain(swapchainInfo);

          this.canvas.oncontextmenu = function () {
            return false;
          };
        };

        _proto._initEvents = function _initEvents() {
          systemInfo.on('show', this._onShow, this);
          systemInfo.on('hide', this._onHide, this);
        };

        _proto._onHide = function _onHide() {
          this.emit(Game.EVENT_HIDE);
          this.pause();
        };

        _proto._onShow = function _onShow() {
          this.emit(Game.EVENT_SHOW);
          this.resume();
        };

        _proto._setRenderPipelineNShowSplash = function _setRenderPipelineNShowSplash() {
          var _this7 = this;

          return Promise.resolve(this._setupRenderPipeline()).then(function () {
            return Promise.resolve(_this7._showSplashScreen()).then(function () {
              _this7._inited = true;
              _this7._initTime = performance.now();

              _this7._runMainLoop();

              _this7._safeEmit(Game.EVENT_GAME_INITED);

              if (_this7.onStart) {
                _this7.onStart();
              }
            });
          });
        };

        _proto._setupRenderPipeline = function _setupRenderPipeline() {
          var _this8 = this;

          var renderPipeline = this.config.renderPipeline;

          if (!renderPipeline) {
            return this._setRenderPipeline();
          }

          return new Promise(function (resolve, reject) {
            legacyCC.assetManager.loadAny(renderPipeline, function (err, asset) {
              return err || !(asset instanceof RenderPipeline) ? reject(err) : resolve(asset);
            });
          }).then(function (asset) {
            _this8._setRenderPipeline(asset);
          })["catch"](function (reason) {
            warn(reason);
            warn("Failed load render pipeline: " + renderPipeline + ", engine failed to initialize, will fallback to default pipeline");

            _this8._setRenderPipeline();
          });
        };

        _proto._showSplashScreen = function _showSplashScreen() {
          if ( legacyCC.internal.SplashScreen) {
            var splashScreen = legacyCC.internal.SplashScreen.instance;
            splashScreen.main(legacyCC.director.root);
            return new Promise(function (resolve) {
              splashScreen.setOnFinish(function () {
                return resolve();
              });
              splashScreen.loadFinish = true;
            });
          }

          return null;
        };

        _proto._setRenderPipeline = function _setRenderPipeline(rppl) {
          if (!legacyCC.director.root.setRenderPipeline(rppl)) {
            this._setRenderPipeline();
          }

          this._rendererInitialized = true;

          this._safeEmit(Game.EVENT_RENDERER_INITED);
        };

        _proto._safeEmit = function _safeEmit(event) {
          {
            this.emit(event);
          }
        };

        _createClass(Game, [{
          key: "inited",
          get: function get() {
            return this._inited;
          }
        }, {
          key: "frameRate",
          get: function get() {
            return this._frameRate;
          },
          set: function set(frameRate) {
            if (typeof frameRate !== 'number') {
              frameRate = parseInt(frameRate, 10);

              if (Number.isNaN(frameRate)) {
                frameRate = 60;
              }
            }

            this._frameRate = frameRate;
            this.frameTime = 1000 / frameRate;

            this._setAnimFrame();
          }
        }, {
          key: "deltaTime",
          get: function get() {
            return this._deltaTime;
          }
        }, {
          key: "totalTime",
          get: function get() {
            return performance.now() - this._initTime;
          }
        }, {
          key: "frameStartTime",
          get: function get() {
            return this._startTime;
          }
        }]);

        return Game;
      }(EventTarget));
      Game.EVENT_HIDE = 'game_on_hide';
      Game.EVENT_SHOW = 'game_on_show';
      Game.EVENT_LOW_MEMORY = 'game_on_low_memory';
      Game.EVENT_GAME_INITED = 'game_inited';
      Game.EVENT_ENGINE_INITED = 'engine_inited';
      Game.EVENT_RENDERER_INITED = 'renderer_inited';
      Game.EVENT_RESTART = 'game_on_restart';
      Game.RENDER_TYPE_CANVAS = 0;
      Game.RENDER_TYPE_WEBGL = 1;
      Game.RENDER_TYPE_OPENGL = 2;
      Game.RENDER_TYPE_HEADLESS = 3;
      Game.DEBUG_DT_THRESHOLD = 1;
      legacyCC.Game = Game;
      var game = exports('game', legacyCC.game = new Game());

      var Director = exports('Director', function (_EventTarget) {
        _inheritsLoose(Director, _EventTarget);

        function Director() {
          var _this;

          _this = _EventTarget.call(this) || this;
          _this._compScheduler = void 0;
          _this._nodeActivator = void 0;
          _this._invalid = void 0;
          _this._paused = void 0;
          _this._root = void 0;
          _this._loadingScene = void 0;
          _this._scene = void 0;
          _this._totalFrames = void 0;
          _this._scheduler = void 0;
          _this._systems = void 0;
          _this._invalid = false;
          _this._paused = false;
          _this._root = null;
          _this._loadingScene = '';
          _this._scene = null;
          _this._totalFrames = 0;
          _this._scheduler = new Scheduler();
          _this._compScheduler = new ComponentScheduler();
          _this._nodeActivator = new NodeActivator();
          _this._systems = [];
          game.once(Game.EVENT_RENDERER_INITED, _this._initOnRendererInitialized, _assertThisInitialized(_this));
          return _this;
        }

        var _proto = Director.prototype;

        _proto.calculateDeltaTime = function calculateDeltaTime(now) {};

        _proto.end = function end() {
          var _this2 = this;

          this.once(Director.EVENT_END_FRAME, function () {
            _this2.purgeDirector();
          });
        };

        _proto.pause = function pause() {
          if (this._paused) {
            return;
          }

          this._paused = true;
        };

        _proto.purgeDirector = function purgeDirector() {
          this._scheduler.unscheduleAll();

          this._compScheduler.unscheduleAll();

          this._nodeActivator.reset();

          {
            if (legacyCC.isValid(this._scene)) {
              this._scene.destroy();
            }

            this._scene = null;
          }

          this.stopAnimation();
          legacyCC.assetManager.releaseAll();
        };

        _proto.reset = function reset() {
          this.purgeDirector();
          this.emit(Director.EVENT_RESET);
          this.startAnimation();
        };

        _proto.runSceneImmediate = function runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
          if (scene instanceof SceneAsset) scene = scene.scene;
          assertID(scene instanceof Scene, 1216);

          {
            console.time('InitScene');
          }

          scene._load();

          {
            console.timeEnd('InitScene');
          }

          {
            console.time('AttachPersist');
          }

          var persistNodeList = Object.keys(game._persistRootNodes).map(function (x) {
            return game._persistRootNodes[x];
          });

          for (var i = 0; i < persistNodeList.length; i++) {
            var node = persistNodeList[i];
            node.emit(legacyCC.Node.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
            var existNode = scene.uuid === node._originalSceneId && scene.getChildByUuid(node.uuid);

            if (existNode) {
              var index = existNode.getSiblingIndex();

              existNode._destroyImmediate();

              scene.insertChild(node, index);
            } else {
              node.parent = scene;
            }
          }

          {
            console.timeEnd('AttachPersist');
          }

          var oldScene = this._scene;

          {
            console.time('Destroy');
          }

          if (legacyCC.isValid(oldScene)) {
            oldScene.destroy();
          }

          {
            {
              console.time('AutoRelease');
            }

            legacyCC.assetManager._releaseManager._autoRelease(oldScene, scene, game._persistRootNodes);

            {
              console.timeEnd('AutoRelease');
            }
          }

          this._scene = null;

          CCObject._deferredDestroy();

          {
            console.timeEnd('Destroy');
          }

          if (onBeforeLoadScene) {
            onBeforeLoadScene();
          }

          this.emit(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
          this._scene = scene;

          {
            console.time('Activate');
          }

          scene._activate();

          {
            console.timeEnd('Activate');
          }

          if (this._root) {
            this._root.resetCumulativeTime();
          }

          this.startAnimation();

          if (onLaunched) {
            onLaunched(null, scene);
          }

          this.emit(legacyCC.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
        };

        _proto.runScene = function runScene(scene, onBeforeLoadScene, onLaunched) {
          var _this3 = this;

          if (scene instanceof SceneAsset) scene = scene.scene;
          assertID(scene, 1205);
          assertID(scene instanceof Scene, 1216);

          scene._load();

          this.once(legacyCC.Director.EVENT_END_FRAME, function () {
            _this3.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
          });
        };

        _proto.loadScene = function loadScene(sceneName, onLaunched, onUnloaded) {
          var _this4 = this;

          if (this._loadingScene) {
            warnID(1208, sceneName, this._loadingScene);
            return false;
          }

          var bundle = legacyCC.assetManager.bundles.find(function (bundle) {
            return !!bundle.getSceneInfo(sceneName);
          });

          if (bundle) {
            this.emit(legacyCC.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
            this._loadingScene = sceneName;
            console.time("LoadScene " + sceneName);
            bundle.loadScene(sceneName, function (err, scene) {
              console.timeEnd("LoadScene " + sceneName);
              _this4._loadingScene = '';

              if (err) {
                error(err);

                if (onLaunched) {
                  onLaunched(err);
                }
              } else {
                _this4.runSceneImmediate(scene, onUnloaded, onLaunched);
              }
            });
            return true;
          } else {
            errorID(1209, sceneName);
            return false;
          }
        };

        _proto.preloadScene = function preloadScene(sceneName, onProgress, onLoaded) {
          var bundle = legacyCC.assetManager.bundles.find(function (bundle) {
            return !!bundle.getSceneInfo(sceneName);
          });

          if (bundle) {
            bundle.preloadScene(sceneName, null, onProgress, onLoaded);
          } else {
            var err = "Can not preload the scene \"" + sceneName + "\" because it is not in the build settings.";

            if (onLoaded) {
              onLoaded(new Error(err));
            }

            error("preloadScene: " + err);
          }
        };

        _proto.resume = function resume() {
          if (!this._paused) {
            return;
          }

          this._paused = false;
        };

        _proto.getScene = function getScene() {
          return this._scene;
        };

        _proto.getDeltaTime = function getDeltaTime() {
          return game.deltaTime;
        };

        _proto.getTotalTime = function getTotalTime() {
          return game.totalTime;
        };

        _proto.getCurrentTime = function getCurrentTime() {
          return game.frameStartTime;
        };

        _proto.getTotalFrames = function getTotalFrames() {
          return this._totalFrames;
        };

        _proto.isPaused = function isPaused() {
          return this._paused;
        };

        _proto.getScheduler = function getScheduler() {
          return this._scheduler;
        };

        _proto.setScheduler = function setScheduler(scheduler) {
          if (this._scheduler !== scheduler) {
            this.unregisterSystem(this._scheduler);
            this._scheduler = scheduler;
            this.registerSystem(Scheduler.ID, scheduler, 200);
          }
        };

        _proto.registerSystem = function registerSystem(name, sys, priority) {
          sys.id = name;
          sys.priority = priority;
          sys.init();

          this._systems.push(sys);

          this._systems.sort(System.sortByPriority);
        };

        _proto.unregisterSystem = function unregisterSystem(sys) {
          array.fastRemove(this._systems, sys);

          this._systems.sort(System.sortByPriority);
        };

        _proto.getSystem = function getSystem(name) {
          return this._systems.find(function (sys) {
            return sys.id === name;
          });
        };

        _proto.getAnimationManager = function getAnimationManager() {
          return this.getSystem(legacyCC.AnimationManager.ID);
        };

        _proto.startAnimation = function startAnimation() {
          this._invalid = false;
        };

        _proto.stopAnimation = function stopAnimation() {
          this._invalid = true;
        };

        _proto.mainLoop = function mainLoop(now) {
          var dt;

          {
            dt = game._calculateDT(now);
          }

          this.tick(dt);
        };

        _proto.tick = function tick(dt) {
          if (!this._invalid) {
            this.emit(Director.EVENT_BEGIN_FRAME);

            {
              input._frameDispatchEvents();
            }

            if (!this._paused) {
              this.emit(Director.EVENT_BEFORE_UPDATE);

              this._compScheduler.startPhase();

              this._compScheduler.updatePhase(dt);

              for (var i = 0; i < this._systems.length; ++i) {
                this._systems[i].update(dt);
              }

              this._compScheduler.lateUpdatePhase(dt);

              this.emit(Director.EVENT_AFTER_UPDATE);

              CCObject._deferredDestroy();

              for (var _i = 0; _i < this._systems.length; ++_i) {
                this._systems[_i].postUpdate(dt);
              }
            }

            this.emit(Director.EVENT_BEFORE_DRAW);

            this._root.frameMove(dt);

            this.emit(Director.EVENT_AFTER_DRAW);
            Node$1.resetHasChangedFlags();
            Node$1.clearNodeArray();
            containerManager.update(dt);
            this.emit(Director.EVENT_END_FRAME);
            this._totalFrames++;
          }
        };

        _proto._initOnRendererInitialized = function _initOnRendererInitialized() {
          this._totalFrames = 0;
          this._paused = false;
          this.registerSystem(Scheduler.ID, this._scheduler, 200);
          this.emit(Director.EVENT_INIT);
        };

        _proto._init = function _init() {
          this._root = new Root(game._gfxDevice);
          var rootInfo = {};
          return this._root.initialize(rootInfo)["catch"](function (error) {
            errorID(1217);
            return Promise.reject(error);
          });
        };

        _createClass(Director, [{
          key: "root",
          get: function get() {
            return this._root;
          }
        }]);

        return Director;
      }(EventTarget));
      Director.EVENT_INIT = 'director_init';
      Director.EVENT_RESET = 'director_reset';
      Director.EVENT_BEFORE_SCENE_LOADING = 'director_before_scene_loading';
      Director.EVENT_BEFORE_SCENE_LAUNCH = 'director_before_scene_launch';
      Director.EVENT_AFTER_SCENE_LAUNCH = 'director_after_scene_launch';
      Director.EVENT_BEFORE_UPDATE = 'director_before_update';
      Director.EVENT_AFTER_UPDATE = 'director_after_update';
      Director.EVENT_BEFORE_DRAW = 'director_before_draw';
      Director.EVENT_AFTER_DRAW = 'director_after_draw';
      Director.EVENT_BEFORE_COMMIT = 'director_before_commit';
      Director.EVENT_BEFORE_PHYSICS = 'director_before_physics';
      Director.EVENT_AFTER_PHYSICS = 'director_after_physics';
      Director.EVENT_BEGIN_FRAME = 'director_begin_frame';
      Director.EVENT_END_FRAME = 'director_end_frame';
      Director.instance = void 0;
      legacyCC.Director = Director;
      var director = exports('director', Director.instance = legacyCC.director = new Director());

      var vmath = {};
      replaceProperty(vmath, 'vmath', [{
        name: 'vec2',
        newName: 'Vec2',
        target: math,
        targetName: 'math'
      }, {
        name: 'vec3',
        newName: 'Vec3',
        target: math,
        targetName: 'math'
      }, {
        name: 'vec4',
        newName: 'Vec4',
        target: math,
        targetName: 'math'
      }, {
        name: 'quat',
        newName: 'Quat',
        target: math,
        targetName: 'math'
      }, {
        name: 'mat3',
        newName: 'Mat3',
        target: math,
        targetName: 'math'
      }, {
        name: 'mat4',
        newName: 'Mat4',
        target: math,
        targetName: 'math'
      }, {
        name: 'color4',
        newName: 'Color',
        target: math,
        targetName: 'math'
      }, {
        name: 'rect',
        newName: 'Rect',
        target: math,
        targetName: 'math'
      }, {
        name: 'approx',
        newName: 'approx',
        target: math,
        targetName: 'math'
      }, {
        name: 'EPSILON',
        newName: 'EPSILON',
        target: math,
        targetName: 'math'
      }, {
        name: 'equals',
        newName: 'equals',
        target: math,
        targetName: 'math'
      }, {
        name: 'clamp',
        newName: 'clamp',
        target: math,
        targetName: 'math'
      }, {
        name: 'clamp01',
        newName: 'clamp01',
        target: math,
        targetName: 'math'
      }, {
        name: 'lerp',
        newName: 'lerp',
        target: math,
        targetName: 'math'
      }, {
        name: 'toRadian',
        newName: 'toRadian',
        target: math,
        targetName: 'math'
      }, {
        name: 'toDegree',
        newName: 'toDegree',
        target: math,
        targetName: 'math'
      }, {
        name: 'random',
        newName: 'random',
        target: math,
        targetName: 'math'
      }, {
        name: 'randomRange',
        newName: 'randomRange',
        target: math,
        targetName: 'math'
      }, {
        name: 'randomRangeInt',
        newName: 'randomRangeInt',
        target: math,
        targetName: 'math'
      }, {
        name: 'pseudoRandom',
        newName: 'pseudoRandom',
        target: math,
        targetName: 'math'
      }, {
        name: 'pseudoRandomRangeInt',
        newName: 'pseudoRandomRangeInt',
        target: math,
        targetName: 'math'
      }, {
        name: 'nextPow2',
        newName: 'nextPow2',
        target: math,
        targetName: 'math'
      }, {
        name: 'repeat',
        newName: 'repeat',
        target: math,
        targetName: 'math'
      }, {
        name: 'pingPong',
        newName: 'pingPong',
        target: math,
        targetName: 'math'
      }, {
        name: 'inverseLerp',
        newName: 'inverseLerp',
        target: math,
        targetName: 'math'
      }]);
      legacyCC.vmath = vmath;
      replaceProperty(Scheduler.prototype, 'Scheduler.prototype', [{
        name: 'enableForTarget',
        newName: 'enableForTarget',
        target: Scheduler,
        targetName: 'Scheduler'
      }]);
      replaceProperty(Scheduler, 'Scheduler', [{
        name: 'PRIORITY_SYSTEM',
        newName: 'System.Priority.SCHEDULER',
        customGetter: function customGetter() {
          return System.Priority.SCHEDULER;
        }
      }]);
      removeProperty(Scheduler, 'Scheduler', [{
        name: 'PRIORITY_NON_SYSTEM',
        suggest: 'Use enum` System.Priority` instead'
      }]);
      replaceProperty(SubModel.prototype, 'SubModel.prototype', [{
        name: 'subMeshData',
        newName: 'subMesh'
      }]);
      removeProperty(SubModel.prototype, 'SubModel.prototype', [{
        name: 'getSubModel',
        suggest: 'Use `subModels[i]` instead'
      }, {
        name: 'subModelNum',
        suggest: 'Use `subModels.length` instead'
      }]);
      replaceProperty(Root.prototype, 'Root.prototype', [{
        name: 'ui',
        newName: 'batcher2D'
      }]);
      markAsWarning(game, 'game', [{
        name: 'collisionMatrix'
      }, {
        name: 'groupList'
      }]);
      markAsWarning(Director.prototype, 'director', [{
        name: 'calculateDeltaTime'
      }, {
        name: 'getDeltaTime',
        suggest: 'Use game.deltaTime instead'
      }, {
        name: 'getTotalTime',
        suggest: 'Use game.totalTime instead'
      }, {
        name: 'getCurrentTime',
        suggest: 'Use game.frameStartTime instead'
      }]);
      removeProperty(Director.prototype, 'director', [{
        name: 'setAnimationInterval',
        suggest: 'please use game.frameRate instead'
      }, {
        name: 'getAnimationInterval',
        suggest: 'please use game.frameRate instead'
      }, {
        name: 'getRunningScene',
        suggest: 'please use getScene instead'
      }, {
        name: 'setDepthTest',
        suggest: 'please use camera API instead'
      }, {
        name: 'setClearColor',
        suggest: 'please use camera API instead'
      }, {
        name: 'getWinSize',
        suggest: 'please use view.getVisibleSize instead'
      }, {
        name: 'getWinSizeInPixels'
      }, {
        name: 'purgeCachedData',
        suggest: 'please use assetManager.releaseAll instead'
      }, {
        name: 'convertToGL'
      }, {
        name: 'convertToUI'
      }]);

      var visibleRect = {
        topLeft: legacyCC.v2(0, 0),
        topRight: legacyCC.v2(0, 0),
        top: legacyCC.v2(0, 0),
        bottomLeft: legacyCC.v2(0, 0),
        bottomRight: legacyCC.v2(0, 0),
        bottom: legacyCC.v2(0, 0),
        center: legacyCC.v2(0, 0),
        left: legacyCC.v2(0, 0),
        right: legacyCC.v2(0, 0),
        width: 0,
        height: 0,
        init: function init(visibleRect_) {
          var w = this.width = visibleRect_.width;
          var h = this.height = visibleRect_.height;
          var l = visibleRect_.x;
          var b = visibleRect_.y;
          var t = b + h;
          var r = l + w;
          this.topLeft.x = l;
          this.topLeft.y = t;
          this.topRight.x = r;
          this.topRight.y = t;
          this.top.x = l + w / 2;
          this.top.y = t;
          this.bottomLeft.x = l;
          this.bottomLeft.y = b;
          this.bottomRight.x = r;
          this.bottomRight.y = b;
          this.bottom.x = l + w / 2;
          this.bottom.y = b;
          this.center.x = l + w / 2;
          this.center.y = b + h / 2;
          this.left.x = l;
          this.left.y = b + h / 2;
          this.right.x = r;
          this.right.y = b + h / 2;
        }
      };
      legacyCC.visibleRect = visibleRect;

      var _orientationMap$1;
      var localWinSize = new Size();
      var orientationMap$2 = (_orientationMap$1 = {}, _orientationMap$1[macro.ORIENTATION_AUTO] = Orientation.AUTO, _orientationMap$1[macro.ORIENTATION_LANDSCAPE] = Orientation.LANDSCAPE, _orientationMap$1[macro.ORIENTATION_PORTRAIT] = Orientation.PORTRAIT, _orientationMap$1);
      var View = exports('View', function (_EventTarget) {
        _inheritsLoose(View, _EventTarget);

        function View() {
          var _this;

          _this = _EventTarget.call(this) || this;
          _this._designResolutionSize = void 0;
          _this._scaleX = void 0;
          _this._scaleY = void 0;
          _this._viewportRect = void 0;
          _this._visibleRect = void 0;
          _this._autoFullScreen = void 0;
          _this._retinaEnabled = void 0;
          _this._resizeCallback = void 0;
          _this._resolutionPolicy = void 0;
          _this._rpExactFit = void 0;
          _this._rpShowAll = void 0;
          _this._rpNoBorder = void 0;
          _this._rpFixedHeight = void 0;
          _this._rpFixedWidth = void 0;
          var _strategyer = ContainerStrategy;
          var _strategy = ContentStrategy;
          _this._designResolutionSize = new Size(0, 0);
          _this._scaleX = 1;
          _this._scaleY = 1;
          _this._viewportRect = new Rect(0, 0, 0, 0);
          _this._visibleRect = new Rect(0, 0, 0, 0);
          _this._autoFullScreen = false;
          _this._retinaEnabled = false;
          _this._resizeCallback = null;
          _this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
          _this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL);
          _this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
          _this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
          _this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
          _this._resolutionPolicy = _this._rpShowAll;
          return _this;
        }

        var _proto = View.prototype;

        _proto.init = function init() {
          var windowSize = screen.windowSize;
          var w = windowSize.width;
          var h = windowSize.height;
          this._designResolutionSize.width = w;
          this._designResolutionSize.height = h;
          this._viewportRect.width = w;
          this._viewportRect.height = h;
          this._visibleRect.width = w;
          this._visibleRect.height = h;
          localWinSize.width = this._visibleRect.width;
          localWinSize.height = this._visibleRect.height;

          if (visibleRect) {
            visibleRect.init(this._visibleRect);
          }

          screenAdapter.on('window-resize', this._updateAdaptResult, this);
          screenAdapter.on('orientation-change', this._updateAdaptResult, this);
          screenAdapter.on('fullscreen-change', this._updateAdaptResult, this);
        };

        _proto.resizeWithBrowserSize = function resizeWithBrowserSize(enabled) {
          screenAdapter.handleResizeEvent = enabled;
        };

        _proto.setResizeCallback = function setResizeCallback(callback) {
          if (typeof callback === 'function' || callback == null) {
            this._resizeCallback = callback;
          }
        };

        _proto.setOrientation = function setOrientation(orientation) {
          screenAdapter.orientation = orientationMap$2[orientation];
        };

        _proto.adjustViewportMeta = function adjustViewportMeta(enabled) {};

        _proto.enableRetina = function enableRetina(enabled) {
          this._retinaEnabled = !!enabled;
        };

        _proto.isRetinaEnabled = function isRetinaEnabled() {
          return this._retinaEnabled;
        };

        _proto.enableAutoFullScreen = function enableAutoFullScreen(enabled) {
          if (enabled === this._autoFullScreen) {
            return;
          }

          this._autoFullScreen = enabled;

          if (enabled) {
            screen.requestFullScreen()["catch"](function (e) {});
          }
        };

        _proto.isAutoFullScreenEnabled = function isAutoFullScreenEnabled() {
          return this._autoFullScreen;
        };

        _proto.setCanvasSize = function setCanvasSize(width, height) {
          screenAdapter.resolutionScale = 1;
          var dpr = screenAdapter.devicePixelRatio;
          var windowSize = new Size(width * dpr, height * dpr);
          screen.windowSize = windowSize;
        };

        _proto.getCanvasSize = function getCanvasSize() {
          return screen.windowSize;
        };

        _proto.getFrameSize = function getFrameSize() {
          var dpr = screenAdapter.devicePixelRatio;
          var sizeInCssPixels = screen.windowSize;
          sizeInCssPixels.width /= dpr;
          sizeInCssPixels.height /= dpr;
          return sizeInCssPixels;
        };

        _proto.setFrameSize = function setFrameSize(width, height) {
          var dpr = screenAdapter.devicePixelRatio;
          screen.windowSize = new Size(width * dpr, height * dpr);
        };

        _proto.getVisibleSize = function getVisibleSize() {
          return new Size(this._visibleRect.width, this._visibleRect.height);
        };

        _proto.getVisibleSizeInPixel = function getVisibleSizeInPixel() {
          return new Size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
        };

        _proto.getVisibleOrigin = function getVisibleOrigin() {
          return new Vec2(this._visibleRect.x, this._visibleRect.y);
        };

        _proto.getVisibleOriginInPixel = function getVisibleOriginInPixel() {
          return new Vec2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
        };

        _proto.getResolutionPolicy = function getResolutionPolicy() {
          return this._resolutionPolicy;
        };

        _proto._updateResolutionPolicy = function _updateResolutionPolicy(resolutionPolicy) {
          if (resolutionPolicy instanceof ResolutionPolicy) {
            this._resolutionPolicy = resolutionPolicy;
          } else {
            var _locPolicy = ResolutionPolicy;

            if (resolutionPolicy === _locPolicy.EXACT_FIT) {
              this._resolutionPolicy = this._rpExactFit;
            }

            if (resolutionPolicy === _locPolicy.SHOW_ALL) {
              this._resolutionPolicy = this._rpShowAll;
            }

            if (resolutionPolicy === _locPolicy.NO_BORDER) {
              this._resolutionPolicy = this._rpNoBorder;
            }

            if (resolutionPolicy === _locPolicy.FIXED_HEIGHT) {
              this._resolutionPolicy = this._rpFixedHeight;
            }

            if (resolutionPolicy === _locPolicy.FIXED_WIDTH) {
              this._resolutionPolicy = this._rpFixedWidth;
            }
          }
        };

        _proto.setResolutionPolicy = function setResolutionPolicy(resolutionPolicy) {
          this._updateResolutionPolicy(resolutionPolicy);

          var designedResolution = view.getDesignResolutionSize();
          view.setDesignResolutionSize(designedResolution.width, designedResolution.height, resolutionPolicy);
        };

        _proto.setDesignResolutionSize = function setDesignResolutionSize(width, height, resolutionPolicy) {
          if (!(width > 0 && height > 0)) {
            errorID(2200);
            return;
          }

          this._updateResolutionPolicy(resolutionPolicy);

          var policy = this._resolutionPolicy;

          if (policy) {
            policy.preApply(this);
          }

          this._designResolutionSize.width = width;
          this._designResolutionSize.height = height;
          var result = policy.apply(this, this._designResolutionSize);

          if (result.scale && result.scale.length === 2) {
            this._scaleX = result.scale[0];
            this._scaleY = result.scale[1];
          }

          if (result.viewport) {
            var vp = this._viewportRect;
            var vb = this._visibleRect;
            var rv = result.viewport;
            vp.x = rv.x;
            vp.y = rv.y;
            vp.width = rv.width;
            vp.height = rv.height;
            vb.x = 0;
            vb.y = 0;
            vb.width = rv.width / this._scaleX;
            vb.height = rv.height / this._scaleY;
          }

          policy.postApply(this);
          localWinSize.width = this._visibleRect.width;
          localWinSize.height = this._visibleRect.height;

          if (visibleRect) {
            visibleRect.init(this._visibleRect);
          }

          this.emit('design-resolution-changed');
        };

        _proto.getDesignResolutionSize = function getDesignResolutionSize() {
          return new Size(this._designResolutionSize.width, this._designResolutionSize.height);
        };

        _proto.setRealPixelResolution = function setRealPixelResolution(width, height, resolutionPolicy) {
          {
            document.documentElement.style.width = width + "px";
            document.body.style.width = width + "px";
            document.body.style.left = '0px';
            document.body.style.top = '0px';
          }

          this.setDesignResolutionSize(width, height, resolutionPolicy);
        };

        _proto.getViewportRect = function getViewportRect() {
          return this._viewportRect;
        };

        _proto.getScaleX = function getScaleX() {
          return this._scaleX;
        };

        _proto.getScaleY = function getScaleY() {
          return this._scaleY;
        };

        _proto.getDevicePixelRatio = function getDevicePixelRatio() {
          return screenAdapter.devicePixelRatio;
        };

        _proto.convertToLocationInView = function convertToLocationInView(tx, ty, relatedPos, out) {
          if (out === void 0) {
            out = new Vec2();
          }

          var x = screenAdapter.devicePixelRatio * (tx - relatedPos.left);
          var y = screenAdapter.devicePixelRatio * (relatedPos.top + relatedPos.height - ty);

          if (screenAdapter.isFrameRotated) {
            out.x = screen.windowSize.width - y;
            out.y = x;
          } else {
            out.x = x;
            out.y = y;
          }

          return out;
        };

        _proto._convertToUISpace = function _convertToUISpace(point) {
          var viewport = this._viewportRect;
          point.x = (point.x - viewport.x) / this._scaleX;
          point.y = (point.y - viewport.y) / this._scaleY;
        };

        _proto._updateAdaptResult = function _updateAdaptResult() {
          var _this$_resizeCallback;

          legacyCC.director.root.resize(screen.windowSize.width, screen.windowSize.height);
          var width = this._designResolutionSize.width;
          var height = this._designResolutionSize.height;

          if (width > 0) {
            this.setDesignResolutionSize(width, height, this._resolutionPolicy);
          }

          this.emit('canvas-resize');
          (_this$_resizeCallback = this._resizeCallback) === null || _this$_resizeCallback === void 0 ? void 0 : _this$_resizeCallback.call(this);
        };

        return View;
      }(EventTarget));
      View.instance = void 0;

      var ContainerStrategy = function () {
        function ContainerStrategy() {
          this.name = 'ContainerStrategy';
        }

        var _proto2 = ContainerStrategy.prototype;

        _proto2.preApply = function preApply(_view) {};

        _proto2.apply = function apply(_view, designedResolution) {};

        _proto2.postApply = function postApply(_view) {};

        _proto2._setupCanvas = function _setupCanvas() {
          var locCanvas = game.canvas;

          if (locCanvas) {
            var windowSize = screen.windowSize;
            locCanvas.width = windowSize.width;
            locCanvas.height = windowSize.height;
          }
        };

        return ContainerStrategy;
      }();

      ContainerStrategy.EQUAL_TO_FRAME = void 0;
      ContainerStrategy.PROPORTION_TO_FRAME = void 0;

      var ContentStrategy = function () {
        function ContentStrategy() {
          this.name = 'ContentStrategy';
          this._result = void 0;
          this._result = {
            scale: [1, 1],
            viewport: null
          };
        }

        var _proto3 = ContentStrategy.prototype;

        _proto3.preApply = function preApply(_view) {};

        _proto3.apply = function apply(_view, designedResolution) {
          return {
            scale: [1, 1]
          };
        };

        _proto3.postApply = function postApply(_view) {};

        _proto3._buildResult = function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
          if (Math.abs(containerW - contentW) < 2) {
            contentW = containerW;
          }

          if (Math.abs(containerH - contentH) < 2) {
            contentH = containerH;
          }

          var viewport = new Rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
          this._result.scale = [scaleX, scaleY];
          this._result.viewport = viewport;
          return this._result;
        };

        return ContentStrategy;
      }();

      ContentStrategy.EXACT_FIT = void 0;
      ContentStrategy.SHOW_ALL = void 0;
      ContentStrategy.NO_BORDER = void 0;
      ContentStrategy.FIXED_HEIGHT = void 0;
      ContentStrategy.FIXED_WIDTH = void 0;

      (function () {
        var EqualToFrame = function (_ContainerStrategy) {
          _inheritsLoose(EqualToFrame, _ContainerStrategy);

          function EqualToFrame() {
            var _this2;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this2 = _ContainerStrategy.call.apply(_ContainerStrategy, [this].concat(args)) || this;
            _this2.name = 'EqualToFrame';
            return _this2;
          }

          var _proto4 = EqualToFrame.prototype;

          _proto4.apply = function apply(_view, designedResolution) {
            screenAdapter.isProportionalToFrame = false;

            this._setupCanvas();
          };

          return EqualToFrame;
        }(ContainerStrategy);

        var ProportionalToFrame = function (_ContainerStrategy2) {
          _inheritsLoose(ProportionalToFrame, _ContainerStrategy2);

          function ProportionalToFrame() {
            var _this3;

            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            _this3 = _ContainerStrategy2.call.apply(_ContainerStrategy2, [this].concat(args)) || this;
            _this3.name = 'ProportionalToFrame';
            return _this3;
          }

          var _proto5 = ProportionalToFrame.prototype;

          _proto5.apply = function apply(_view, designedResolution) {
            screenAdapter.isProportionalToFrame = true;

            this._setupCanvas();
          };

          return ProportionalToFrame;
        }(ContainerStrategy);

        ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
        ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();

        var ExactFit = function (_ContentStrategy) {
          _inheritsLoose(ExactFit, _ContentStrategy);

          function ExactFit() {
            var _this4;

            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }

            _this4 = _ContentStrategy.call.apply(_ContentStrategy, [this].concat(args)) || this;
            _this4.name = 'ExactFit';
            return _this4;
          }

          var _proto6 = ExactFit.prototype;

          _proto6.apply = function apply(_view, designedResolution) {
            var windowSize = screen.windowSize;
            var containerW = windowSize.width;
            var containerH = windowSize.height;
            var scaleX = containerW / designedResolution.width;
            var scaleY = containerH / designedResolution.height;
            return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
          };

          return ExactFit;
        }(ContentStrategy);

        var ShowAll = function (_ContentStrategy2) {
          _inheritsLoose(ShowAll, _ContentStrategy2);

          function ShowAll() {
            var _this5;

            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }

            _this5 = _ContentStrategy2.call.apply(_ContentStrategy2, [this].concat(args)) || this;
            _this5.name = 'ShowAll';
            return _this5;
          }

          var _proto7 = ShowAll.prototype;

          _proto7.apply = function apply(_view, designedResolution) {
            var windowSize = screen.windowSize;
            var containerW = windowSize.width;
            var containerH = windowSize.height;
            var designW = designedResolution.width;
            var designH = designedResolution.height;
            var scaleX = containerW / designW;
            var scaleY = containerH / designH;
            var scale = 0;
            var contentW;
            var contentH;

            if (scaleX < scaleY) {
              scale = scaleX;
              contentW = containerW;
              contentH = designH * scale;
            } else {
              scale = scaleY;
              contentW = designW * scale;
              contentH = containerH;
            }

            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          };

          return ShowAll;
        }(ContentStrategy);

        var NoBorder = function (_ContentStrategy3) {
          _inheritsLoose(NoBorder, _ContentStrategy3);

          function NoBorder() {
            var _this6;

            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }

            _this6 = _ContentStrategy3.call.apply(_ContentStrategy3, [this].concat(args)) || this;
            _this6.name = 'NoBorder';
            return _this6;
          }

          var _proto8 = NoBorder.prototype;

          _proto8.apply = function apply(_view, designedResolution) {
            var windowSize = screen.windowSize;
            var containerW = windowSize.width;
            var containerH = windowSize.height;
            var designW = designedResolution.width;
            var designH = designedResolution.height;
            var scaleX = containerW / designW;
            var scaleY = containerH / designH;
            var scale;
            var contentW;
            var contentH;

            if (scaleX < scaleY) {
              scale = scaleY;
              contentW = designW * scale;
              contentH = containerH;
            } else {
              scale = scaleX;
              contentW = containerW;
              contentH = designH * scale;
            }

            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          };

          return NoBorder;
        }(ContentStrategy);

        var FixedHeight = function (_ContentStrategy4) {
          _inheritsLoose(FixedHeight, _ContentStrategy4);

          function FixedHeight() {
            var _this7;

            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
              args[_key6] = arguments[_key6];
            }

            _this7 = _ContentStrategy4.call.apply(_ContentStrategy4, [this].concat(args)) || this;
            _this7.name = 'FixedHeight';
            return _this7;
          }

          var _proto9 = FixedHeight.prototype;

          _proto9.apply = function apply(_view, designedResolution) {
            var windowSize = screen.windowSize;
            var containerW = windowSize.width;
            var containerH = windowSize.height;
            var designH = designedResolution.height;
            var scale = containerH / designH;
            var contentW = containerW;
            var contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          };

          return FixedHeight;
        }(ContentStrategy);

        var FixedWidth = function (_ContentStrategy5) {
          _inheritsLoose(FixedWidth, _ContentStrategy5);

          function FixedWidth() {
            var _this8;

            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
              args[_key7] = arguments[_key7];
            }

            _this8 = _ContentStrategy5.call.apply(_ContentStrategy5, [this].concat(args)) || this;
            _this8.name = 'FixedWidth';
            return _this8;
          }

          var _proto10 = FixedWidth.prototype;

          _proto10.apply = function apply(_view, designedResolution) {
            var windowSize = screen.windowSize;
            var containerW = windowSize.width;
            var containerH = windowSize.height;
            var designW = designedResolution.width;
            var scale = containerW / designW;
            var contentW = containerW;
            var contentH = containerH;
            return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
          };

          return FixedWidth;
        }(ContentStrategy);

        ContentStrategy.EXACT_FIT = new ExactFit();
        ContentStrategy.SHOW_ALL = new ShowAll();
        ContentStrategy.NO_BORDER = new NoBorder();
        ContentStrategy.FIXED_HEIGHT = new FixedHeight();
        ContentStrategy.FIXED_WIDTH = new FixedWidth();
      })();

      var ResolutionPolicy = exports('ResolutionPolicy', function () {
        function ResolutionPolicy(containerStg, contentStg) {
          this.name = 'ResolutionPolicy';
          this._containerStrategy = void 0;
          this._contentStrategy = void 0;
          this._containerStrategy = null;
          this._contentStrategy = null;
          this.setContainerStrategy(containerStg);
          this.setContentStrategy(contentStg);
        }

        var _proto11 = ResolutionPolicy.prototype;

        _proto11.preApply = function preApply(_view) {
          this._contentStrategy.preApply(_view);
        };

        _proto11.apply = function apply(_view, designedResolution) {
          this._containerStrategy.apply(_view, designedResolution);

          return this._contentStrategy.apply(_view, designedResolution);
        };

        _proto11.postApply = function postApply(_view) {
          this._contentStrategy.postApply(_view);
        };

        _proto11.setContainerStrategy = function setContainerStrategy(containerStg) {
          if (containerStg instanceof ContainerStrategy) {
            this._containerStrategy = containerStg;
          }
        };

        _proto11.setContentStrategy = function setContentStrategy(contentStg) {
          if (contentStg instanceof ContentStrategy) {
            this._contentStrategy = contentStg;
          }
        };

        _createClass(ResolutionPolicy, [{
          key: "canvasSize",
          get: function get() {
            return screen.windowSize;
          }
        }]);

        return ResolutionPolicy;
      }());
      ResolutionPolicy.EXACT_FIT = 0;
      ResolutionPolicy.NO_BORDER = 1;
      ResolutionPolicy.SHOW_ALL = 2;
      ResolutionPolicy.FIXED_HEIGHT = 3;
      ResolutionPolicy.FIXED_WIDTH = 4;
      ResolutionPolicy.UNKNOWN = 5;
      ResolutionPolicy.ContainerStrategy = ContainerStrategy;
      ResolutionPolicy.ContentStrategy = ContentStrategy;
      legacyCC.ResolutionPolicy = ResolutionPolicy;
      var view = exports('view', View.instance = legacyCC.view = new View());
      legacyCC.winSize = localWinSize;

      removeProperty(View.prototype, 'View.prototype', [{
        name: 'isAntiAliasEnabled',
        suggest: 'The API of Texture2d have been largely modified, no alternative'
      }, {
        name: 'enableAntiAlias',
        suggest: 'The API of Texture2d have been largely modified, no alternative'
      }]);
      markAsWarning(View.prototype, 'View.prototype', [{
        name: 'adjustViewportMeta'
      }, {
        name: 'enableAutoFullScreen',
        suggest: 'use screen.requestFullScreen() instead.'
      }, {
        name: 'isAutoFullScreenEnabled'
      }, {
        name: 'setCanvasSize',
        suggest: 'setting size in CSS pixels is not recommended, please use screen.windowSize instead.'
      }, {
        name: 'getCanvasSize',
        suggest: 'please use screen.windowSize instead.'
      }, {
        name: 'getFrameSize',
        suggest: 'getting size in CSS pixels is not recommended, please use screen.windowSize instead.'
      }, {
        name: 'setFrameSize',
        suggest: 'setting size in CSS pixels is not recommended, please use screen.windowSize instead.'
      }, {
        name: 'getDevicePixelRatio',
        suggest: 'use screen.devicePixelRatio instead.'
      }, {
        name: 'convertToLocationInView'
      }, {
        name: 'enableRetina'
      }, {
        name: 'isRetinaEnabled'
      }]);
      markAsWarning(legacyCC, 'cc', [{
        name: 'winSize',
        suggest: 'please use view.getVisibleSize() instead.'
      }]);
      markAsWarning(sys, 'sys', [{
        name: 'capabilities',
        suggest: 'please use sys.hasFeature() method instead.'
      }]);
      replaceProperty(sys, 'sys', ['UNKNOWN', 'ENGLISH', 'CHINESE', 'FRENCH', 'ITALIAN', 'GERMAN', 'SPANISH', 'DUTCH', 'RUSSIAN', 'KOREAN', 'JAPANESE', 'HUNGARIAN', 'PORTUGUESE', 'ARABIC', 'NORWEGIAN', 'POLISH', 'TURKISH', 'UKRAINIAN', 'ROMANIAN', 'BULGARIAN'].map(function (item) {
        return {
          name: "LANGUAGE_" + item,
          newName: item,
          target: sys.Language,
          targetName: 'sys.Language'
        };
      }));
      replaceProperty(sys, 'sys', ['UNKNOWN', 'IOS', 'ANDROID', 'WINDOWS', 'LINUX', 'OSX'].map(function (item) {
        return {
          name: "OS_" + item,
          newName: item,
          target: sys.OS,
          targetName: 'sys.OS'
        };
      }));
      replaceProperty(sys, 'sys', ['UNKNOWN', 'WECHAT', 'ANDROID', 'IE', 'EDGE', 'QQ', 'MOBILE_QQ', 'UC', 'UCBS', 'BAIDU_APP', 'BAIDU', 'MAXTHON', 'OPERA', 'OUPENG', 'MIUI', 'FIREFOX', 'SAFARI', 'CHROME', 'LIEBAO', 'QZONE', 'SOUGOU', 'HUAWEI'].map(function (item) {
        return {
          name: "BROWSER_TYPE_" + item,
          newName: item,
          target: sys.BrowserType,
          targetName: 'sys.BrowserType'
        };
      }));
      replaceProperty(sys, 'sys', [{
        name: 'BROWSER_TYPE_360',
        newName: 'BROWSER_360',
        target: sys.BrowserType,
        targetName: 'sys.BrowserType'
      }]);
      replaceProperty(sys, 'sys', ['UNKNOWN', 'EDITOR_PAGE', 'EDITOR_CORE', 'MOBILE_BROWSER', 'DESKTOP_BROWSER', 'WIN32', 'MACOS', 'IOS', 'ANDROID', 'OHOS', 'WECHAT_GAME', 'BAIDU_MINI_GAME', 'XIAOMI_QUICK_GAME', 'ALIPAY_MINI_GAME', 'BYTEDANCE_MINI_GAME', 'OPPO_MINI_GAME', 'VIVO_MINI_GAME', 'HUAWEI_QUICK_GAME', 'COCOSPLAY', 'LINKSURE_MINI_GAME', 'QTT_MINI_GAME'].map(function (item) {
        return {
          name: item,
          target: sys.Platform,
          targetName: 'sys.Platform'
        };
      }));
      replaceProperty(sys, 'sys', [{
        name: 'IPHONE',
        newName: 'IOS',
        target: sys.Platform,
        targetName: 'sys.Platform'
      }, {
        name: 'IPAD',
        newName: 'IOS',
        target: sys.Platform,
        targetName: 'sys.Platform'
      }]);
      removeProperty(sys, 'sys', ['LINUX', 'BLACKBERRY', 'NACL', 'EMSCRIPTEN', 'TIZEN', 'WINRT', 'WP8', 'QQ_PLAY', 'FB_PLAYABLE_ADS'].map(function (item) {
        return {
          name: item
        };
      }));
      replaceProperty(sys, 'sys', [{
        name: 'windowPixelResolution',
        target: screen,
        targetName: 'screen',
        newName: 'windowSize'
      }]);
      markAsWarning(screen, 'screen', [{
        name: 'autoFullScreen',
        suggest: 'please use screen.requestFullScreen() instead.'
      }, {
        name: 'disableAutoFullScreen'
      }]);

      var isMatchByWord = function isMatchByWord(path, test) {
        if (path.length > test.length) {
          var nextAscii = path.charCodeAt(test.length);
          return nextAscii === 47;
        }

        return true;
      };

      var processOptions = function processOptions(options) {

        var uuids = options.uuids;
        var paths = options.paths;
        var types = options.types;
        var bundles = options.deps;
        var realEntries = options.paths = Object.create(null);

        if (options.debug === false) {
          for (var i = 0, l = uuids.length; i < l; i++) {
            uuids[i] = decodeUuid(uuids[i]);
          }

          for (var id in paths) {
            var entry = paths[id];
            var type = entry[1];
            entry[1] = types[type];
          }
        } else {
          var out = Object.create(null);

          for (var _i = 0, _l = uuids.length; _i < _l; _i++) {
            var uuid = uuids[_i];
            uuids[_i] = out[uuid] = decodeUuid(uuid);
          }

          uuids = out;
        }

        for (var _id in paths) {
          var _entry = paths[_id];
          realEntries[uuids[_id]] = _entry;
        }

        var scenes = options.scenes;

        for (var name in scenes) {
          var _uuid = scenes[name];
          scenes[name] = uuids[_uuid];
        }

        var packs = options.packs;

        for (var packId in packs) {
          var packedIds = packs[packId];

          for (var j = 0; j < packedIds.length; ++j) {
            packedIds[j] = uuids[packedIds[j]];
          }
        }

        var versions = options.versions;

        if (versions) {
          for (var folder in versions) {
            var entries = versions[folder];

            for (var _i2 = 0; _i2 < entries.length; _i2 += 2) {
              var _uuid2 = entries[_i2];
              entries[_i2] = uuids[_uuid2] || _uuid2;
            }
          }
        }

        var redirect = options.redirect;

        if (redirect) {
          for (var _i3 = 0; _i3 < redirect.length; _i3 += 2) {
            redirect[_i3] = uuids[redirect[_i3]];
            redirect[_i3 + 1] = bundles[redirect[_i3 + 1]];
          }
        }

        var extensionMap = options.extensionMap;

        if (extensionMap) {
          var _loop = function _loop(ext) {
            if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
              return "continue";
            }

            options.extensionMap[ext].forEach(function (uuid, index) {
              options.extensionMap[ext][index] = uuids[uuid] || uuid;
            });
          };

          for (var ext in options.extensionMap) {
            var _ret = _loop(ext);

            if (_ret === "continue") continue;
          }
        }
      };

      var Config = function () {
        function Config() {
          this.name = '';
          this.base = '';
          this.importBase = '';
          this.nativeBase = '';
          this.deps = null;
          this.assetInfos = new Cache();
          this.scenes = new Cache();
          this.paths = new Cache();
        }

        var _proto = Config.prototype;

        _proto.init = function init(options) {
          var _this = this;

          processOptions(options);
          this.importBase = options.importBase || '';
          this.nativeBase = options.nativeBase || '';
          this.base = options.base || '';
          this.name = options.name || '';
          this.deps = options.deps || [];

          this._initUuid(options.uuids);

          this._initPath(options.paths);

          this._initScene(options.scenes);

          this._initPackage(options.packs);

          this._initVersion(options.versions);

          this._initRedirect(options.redirect);

          var _loop2 = function _loop2(ext) {
            if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
              return "continue";
            }

            options.extensionMap[ext].forEach(function (uuid) {
              var assetInfo = _this.assetInfos.get(uuid);

              if (assetInfo) {
                assetInfo.extension = ext;
              }
            });
          };

          for (var ext in options.extensionMap) {
            var _ret2 = _loop2(ext);

            if (_ret2 === "continue") continue;
          }
        };

        _proto.getInfoWithPath = function getInfoWithPath(path, type) {
          if (!path) {
            return null;
          }

          path = normalize(path);
          var items = this.paths.get(path);

          if (items) {
            if (type) {
              for (var i = 0, l = items.length; i < l; i++) {
                var assetInfo = items[i];

                if (js.isChildClassOf(assetInfo.ctor, type)) {
                  return assetInfo;
                }
              }
            } else {
              return items[0];
            }
          }

          return null;
        };

        _proto.getDirWithPath = function getDirWithPath(path, type, out) {
          path = normalize(path);

          if (path[path.length - 1] === '/') {
            path = path.slice(0, -1);
          }

          var infos = out || [];
          this.paths.forEach(function (items, p) {
            if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
              for (var i = 0, l = items.length; i < l; i++) {
                var entry = items[i];

                if (!type || js.isChildClassOf(entry.ctor, type)) {
                  infos.push(entry);
                }
              }
            }
          });
          return infos;
        };

        _proto.getAssetInfo = function getAssetInfo(uuid) {
          return this.assetInfos.get(uuid) || null;
        };

        _proto.getSceneInfo = function getSceneInfo(name) {
          if (!name.endsWith('.scene')) {
            name += '.scene';
          }

          if (name[0] !== '/' && !name.startsWith('db://')) {
            name = "/" + name;
          }

          var info = this.scenes.find(function (val, key) {
            return key.endsWith(name);
          });
          return info;
        };

        _proto.destroy = function destroy() {
          this.paths.destroy();
          this.scenes.destroy();
          this.assetInfos.destroy();
        };

        _proto._initUuid = function _initUuid(uuidList) {
          if (!uuidList) {
            return;
          }

          this.assetInfos.clear();

          for (var i = 0, l = uuidList.length; i < l; i++) {
            var uuid = uuidList[i];
            this.assetInfos.add(uuid, {
              uuid: uuid
            });
          }
        };

        _proto._initPath = function _initPath(pathList) {
          if (!pathList) {
            return;
          }

          var paths = this.paths;
          paths.clear();

          for (var uuid in pathList) {
            var info = pathList[uuid];
            var path = info[0];
            var type = info[1];
            var isSubAsset = info.length === 3;
            var assetInfo = this.assetInfos.get(uuid);
            assetInfo.path = path;
            assetInfo.ctor = js._getClassById(type);

            if (paths.has(path)) {
              if (isSubAsset) {
                paths.get(path).push(assetInfo);
              } else {
                paths.get(path).unshift(assetInfo);
              }
            } else {
              paths.add(path, [assetInfo]);
            }
          }
        };

        _proto._initScene = function _initScene(sceneList) {
          if (!sceneList) {
            return;
          }

          var scenes = this.scenes;
          scenes.clear();
          var assetInfos = this.assetInfos;

          for (var sceneName in sceneList) {
            var uuid = sceneList[sceneName];
            var assetInfo = assetInfos.get(uuid);
            assetInfo.url = sceneName;
            scenes.add(sceneName, assetInfo);
          }
        };

        _proto._initPackage = function _initPackage(packageList) {
          if (!packageList) {
            return;
          }

          var assetInfos = this.assetInfos;

          for (var packUuid in packageList) {
            var uuids = packageList[packUuid];
            var pack = {
              uuid: packUuid,
              packedUuids: uuids,
              ext: '.json'
            };
            assetInfos.add(packUuid, pack);

            for (var i = 0, l = uuids.length; i < l; i++) {
              var uuid = uuids[i];
              var assetInfo = assetInfos.get(uuid);
              var assetPacks = assetInfo.packs;

              if (assetPacks) {
                if (l === 1) {
                  assetPacks.unshift(pack);
                } else {
                  assetPacks.push(pack);
                }
              } else {
                assetInfo.packs = [pack];
              }
            }
          }
        };

        _proto._initVersion = function _initVersion(versions) {
          if (!versions) {
            return;
          }

          var assetInfos = this.assetInfos;
          var entries = versions["import"];

          if (entries) {
            for (var i = 0, l = entries.length; i < l; i += 2) {
              var uuid = entries[i];
              var assetInfo = assetInfos.get(uuid);
              assetInfo.ver = entries[i + 1];
            }
          }

          entries = versions["native"];

          if (entries) {
            for (var _i4 = 0, _l2 = entries.length; _i4 < _l2; _i4 += 2) {
              var _uuid3 = entries[_i4];

              var _assetInfo = assetInfos.get(_uuid3);

              _assetInfo.nativeVer = entries[_i4 + 1];
            }
          }
        };

        _proto._initRedirect = function _initRedirect(redirect) {
          if (!redirect) {
            return;
          }

          var assetInfos = this.assetInfos;

          for (var i = 0, l = redirect.length; i < l; i += 2) {
            var uuid = redirect[i];
            var assetInfo = assetInfos.get(uuid);
            assetInfo.redirect = redirect[i + 1];
          }
        };

        return Config;
      }();

      function visitAsset(asset, deps) {
        if (!asset._uuid) {
          return;
        }

        deps.push(asset._uuid);
      }

      function visitComponent(comp, deps) {
        var props = Object.getOwnPropertyNames(comp);

        for (var i = 0; i < props.length; i++) {
          var propName = props[i];

          if (propName === 'node' || propName === '__eventTargets') {
            continue;
          }

          var value = comp[propName];

          if (typeof value === 'object' && value) {
            if (Array.isArray(value)) {
              for (var j = 0; j < value.length; j++) {
                var val = value[j];

                if (val instanceof Asset) {
                  visitAsset(val, deps);
                }
              }
            } else if (!value.constructor || value.constructor === Object) {
              var keys = Object.getOwnPropertyNames(value);

              for (var _j = 0; _j < keys.length; _j++) {
                var _val = value[keys[_j]];

                if (_val instanceof Asset) {
                  visitAsset(_val, deps);
                }
              }
            } else if (value instanceof Asset) {
              visitAsset(value, deps);
            }
          }
        }
      }

      function visitNode(node, deps) {
        for (var i = 0; i < node._components.length; i++) {
          visitComponent(node._components[i], deps);
        }

        for (var _i = 0; _i < node._children.length; _i++) {
          visitNode(node._children[_i], deps);
        }
      }

      function descendOpRef(asset, refs, exclude, op) {
        exclude.push(asset._uuid);
        var depends = dependUtil.getDeps(asset._uuid);

        for (var i = 0, l = depends.length; i < l; i++) {
          var dependAsset = assets.get(depends[i]);

          if (!dependAsset) {
            continue;
          }

          var uuid = dependAsset._uuid;

          if (!(uuid in refs)) {
            refs[uuid] = dependAsset.refCount + op;
          } else {
            refs[uuid] += op;
          }

          if (exclude.includes(uuid)) {
            continue;
          }

          descendOpRef(dependAsset, refs, exclude, op);
        }
      }

      var _temp$D = [];

      function checkCircularReference(asset) {
        var refs = Object.create(null);
        refs[asset._uuid] = asset.refCount;
        descendOpRef(asset, refs, _temp$D, -1);
        _temp$D.length = 0;

        if (refs[asset._uuid] !== 0) {
          return refs[asset._uuid];
        }

        for (var uuid in refs) {
          if (refs[uuid] !== 0) {
            descendOpRef(assets.get(uuid), refs, _temp$D, 1);
          }
        }

        _temp$D.length = 0;
        return refs[asset._uuid];
      }

      var ReleaseManager = function () {
        function ReleaseManager() {
          this._persistNodeDeps = new Cache();
          this._toDelete = new Cache();
          this._eventListener = false;
        }

        var _proto = ReleaseManager.prototype;

        _proto.init = function init() {
          this._persistNodeDeps.clear();

          this._toDelete.clear();
        };

        _proto._addPersistNodeRef = function _addPersistNodeRef(node) {
          var deps = [];
          visitNode(node, deps);

          for (var i = 0, l = deps.length; i < l; i++) {
            var dependAsset = assets.get(deps[i]);

            if (dependAsset) {
              dependAsset.addRef();
            }
          }

          this._persistNodeDeps.add(node.uuid, deps);
        };

        _proto._removePersistNodeRef = function _removePersistNodeRef(node) {
          if (!this._persistNodeDeps.has(node.uuid)) {
            return;
          }

          var deps = this._persistNodeDeps.get(node.uuid);

          for (var i = 0, l = deps.length; i < l; i++) {
            var dependAsset = assets.get(deps[i]);

            if (dependAsset) {
              dependAsset.decRef();
            }
          }

          this._persistNodeDeps.remove(node.uuid);
        };

        _proto._autoRelease = function _autoRelease(oldScene, newScene, persistNodes) {
          if (oldScene) {
            var childs = dependUtil.getDeps(oldScene.uuid);

            for (var i = 0, l = childs.length; i < l; i++) {
              var asset = assets.get(childs[i]);

              if (asset) {
                asset.decRef( oldScene.autoReleaseAssets);
              }
            }

            var dependencies = dependUtil._depends.get(oldScene.uuid);

            if (dependencies && dependencies.persistDeps) {
              var persistDeps = dependencies.persistDeps;

              for (var _i2 = 0, _l = persistDeps.length; _i2 < _l; _i2++) {
                var _asset = assets.get(persistDeps[_i2]);

                if (_asset) {
                  _asset.decRef( oldScene.autoReleaseAssets);
                }
              }
            }

            if (oldScene.uuid !== newScene.uuid) {
              dependUtil.remove(oldScene.uuid);
            }
          }

          var sceneDeps = dependUtil._depends.get(newScene.uuid);

          if (sceneDeps) {
            sceneDeps.persistDeps = [];
          }

          for (var key in persistNodes) {
            var _ref;

            var node = persistNodes[key];

            var deps = this._persistNodeDeps.get(node.uuid);

            for (var _iterator = _createForOfIteratorHelperLoose(deps), _step; !(_step = _iterator()).done;) {
              var dep = _step.value;
              var dependAsset = assets.get(dep);

              if (dependAsset) {
                dependAsset.addRef();
              }
            }

            if (!sceneDeps) {
              continue;
            }

            (_ref = sceneDeps.persistDeps).push.apply(_ref, deps);
          }
        };

        _proto.tryRelease = function tryRelease(asset, force) {
          if (force === void 0) {
            force = false;
          }

          if (!(asset instanceof Asset)) {
            return;
          }

          if (force) {
            this._free(asset, force);

            return;
          }

          this._toDelete.add(asset._uuid, asset);

          if (!this._eventListener) {
            this._eventListener = true;
            callInNextTick(this._freeAssets.bind(this));
          }
        };

        _proto._freeAssets = function _freeAssets() {
          var _this = this;

          this._eventListener = false;

          this._toDelete.forEach(function (asset) {
            _this._free(asset);
          });

          this._toDelete.clear();
        };

        _proto._free = function _free(asset, force) {
          if (force === void 0) {
            force = false;
          }

          var uuid = asset._uuid;

          this._toDelete.remove(uuid);

          if (!isValid(asset, true)) {
            return;
          }

          if (!force) {
            if (asset.refCount > 0) {
              if (checkCircularReference(asset) > 0) {
                return;
              }
            }
          }

          assets.remove(uuid);
          var depends = dependUtil.getDeps(uuid);

          for (var i = 0, l = depends.length; i < l; i++) {
            var dependAsset = assets.get(depends[i]);

            if (dependAsset) {
              dependAsset.decRef(false);

              {
                this._free(dependAsset, false);
              }
            }
          }

          {
            asset.destroy();
          }

          dependUtil.remove(uuid);
        };

        return ReleaseManager;
      }();

      var releaseManager = new ReleaseManager();

      var defaultProgressCallback = null;
      function setDefaultProgressCallback(onProgress) {
        defaultProgressCallback = onProgress;
      }
      function clear$1(task, clearRef) {
        for (var i = 0, l = task.input.length; i < l; i++) {
          var _item = task.input[i];

          if (clearRef) {
            if (!_item.isNative && _item.content instanceof Asset) {
              _item.content.decRef(false);
            }
          }

          _item.recycle();
        }

        task.input = null;
      }
      function urlAppendTimestamp(url, append) {
        if (append) {
          if (/\?/.test(url)) {
            return url + "&_t=" + Date.now();
          }

          return url + "?_t=" + Date.now();
        }

        return url;
      }
      function retry(process, times, wait, onComplete, index) {
        if (index === void 0) {
          index = 0;
        }

        process(index, function (err, result) {
          index++;

          if (!err || index > times) {
            if (onComplete) {
              onComplete(err, result);
            }
          } else {
            setTimeout(function () {
              retry(process, times, wait, onComplete, index);
            }, wait);
          }
        });
      }
      function getDepends(uuid, data, exclude, depends, config) {
        try {
          var info = dependUtil.parse(uuid, data);

          for (var i = 0, l = info.deps.length; i < l; i++) {
            var dep = info.deps[i];

            if (!(dep in exclude)) {
              exclude[dep] = true;
              depends.push({
                uuid: dep,
                bundle: config && config.name
              });
            }
          }

          if (info.nativeDep) {
            if (config) {
              info.nativeDep.bundle = config.name;
            }

            depends.push(_extends({}, info.nativeDep));
          }
        } catch (e) {
          error(e.message, e.stack);
        }
      }
      function cache(id, asset, cacheAsset) {
        if (!asset) {
          return;
        }

        cacheAsset = cacheAsset !== undefined ? cacheAsset : legacyCC.assetManager.cacheAsset;

        if (!isScene(asset) && cacheAsset && !asset.isDefault) {
          assets.add(id, asset);
        }
      }
      function setProperties(uuid, asset, assetsMap) {
        var missingAsset = false;
        var depends = dependMap.get(asset);

        if (depends) {
          var missingAssetReporter = null;

          for (var i = 0, l = depends.length; i < l; i++) {
            var depend = depends[i];
            var dependAsset = assetsMap[depend.uuid + "@import"];

            if (!dependAsset) {
              {
                error("The asset " + depend.uuid + " is missing!");
              }

              if (depend.type && depend.type !== Asset) {
                var placeHolder = new depend.type();
                placeHolder.initDefault(depend.uuid);
                depend.owner[depend.prop] = placeHolder;
              }

              missingAsset = true;
            } else {
              depend.owner[depend.prop] = dependAsset.addRef();
            }
          }

          if (missingAssetReporter) {
            missingAssetReporter.reportByOwner();
          }

          dependMap["delete"](asset);
        }

        if (nativeDependMap.has(asset)) {
          if (assetsMap[uuid + "@native"]) {
            asset._nativeAsset = assetsMap[uuid + "@native"];
          } else {
            missingAsset = true;
            console.error("the native asset of " + uuid + " is missing!");
          }

          nativeDependMap["delete"](asset);
        }

        return missingAsset;
      }
      function gatherAsset(task) {
        var source = task.source;

        if (!task.options.__outputAsArray__ && source.length === 1) {
          task.output = source[0].content;
        } else {
          var output = task.output = [];

          for (var i = 0, l = source.length; i < l; i++) {
            output.push(source[i].content);
          }
        }
      }
      function forEach(array, process, onComplete) {
        var count = 0;
        var errs = [];
        var length = array.length;

        if (length === 0 && onComplete) {
          onComplete(errs);
        }

        var cb = function cb(err) {
          if (err) {
            errs.push(err);
          }

          count++;

          if (count === length) {
            if (onComplete) {
              onComplete(errs);
            }
          }
        };

        for (var i = 0; i < length; i++) {
          process(array[i], cb);
        }
      }
      function parseParameters(options, onProgress, onComplete) {
        var optionsOut = options;
        var onProgressOut = onProgress;
        var onCompleteOut = onComplete;

        if (onComplete === undefined) {
          var isCallback = typeof options === 'function';

          if (onProgress) {
            onCompleteOut = onProgress;

            if (!isCallback) {
              onProgressOut = null;
            }
          } else if (onProgress === undefined && isCallback) {
            onCompleteOut = options;
            optionsOut = null;
            onProgressOut = null;
          }

          if (onProgress !== undefined && isCallback) {
            onProgressOut = options;
            optionsOut = null;
          }
        }

        return {
          options: optionsOut || Object.create(null),
          onProgress: onProgressOut,
          onComplete: onCompleteOut
        };
      }
      function parseLoadResArgs(type, onProgress, onComplete) {
        var typeOut = type;
        var onProgressOut = onProgress;
        var onCompleteOut = onComplete;

        if (onComplete === undefined) {
          var isValidType = js.isChildClassOf(type, Asset);

          if (onProgress) {
            onCompleteOut = onProgress;

            if (isValidType) {
              onProgressOut = null;
            }
          } else if (onProgress === undefined && !isValidType) {
            onCompleteOut = type;
            onProgressOut = null;
            typeOut = null;
          }

          if (onProgress !== undefined && !isValidType) {
            onProgressOut = type;
            typeOut = null;
          }
        }

        return {
          type: typeOut,
          onProgress: onProgressOut || defaultProgressCallback,
          onComplete: onCompleteOut
        };
      }
      function checkCircleReference(owner, uuid, map, checked) {
        if (checked === void 0) {
          checked = {};
        }

        var item = map[uuid];

        if (!item || checked[uuid]) {
          return false;
        }

        checked[uuid] = true;
        var result = false;
        var deps = dependUtil.getDeps(uuid);

        if (deps) {
          for (var i = 0, l = deps.length; i < l; i++) {
            var dep = deps[i];

            if (dep === owner || checkCircleReference(owner, dep, map, checked)) {
              result = true;
              break;
            }
          }
        }

        return result;
      }
      function asyncify(cb) {
        return function (p1, p2) {
          if (!cb) {
            return;
          }

          var refs = [];

          if (Array.isArray(p2)) {
            p2.forEach(function (x) {
              return x instanceof Asset && refs.push(x.addRef());
            });
          } else if (p2 instanceof Asset) {
            refs.push(p2.addRef());
          }

          callInNextTick(function () {
            refs.forEach(function (x) {
              return x.decRef(false);
            });
            cb(p1, p2);
          });
        };
      }

      var Bundle = function () {
        function Bundle() {
          this._config = new Config();
        }

        var _proto = Bundle.prototype;

        _proto.getInfoWithPath = function getInfoWithPath(path, type) {
          return this._config.getInfoWithPath(path, type);
        };

        _proto.getDirWithPath = function getDirWithPath(path, type, out) {
          return this._config.getDirWithPath(path, type, out);
        };

        _proto.getAssetInfo = function getAssetInfo(uuid) {
          return this._config.getAssetInfo(uuid);
        };

        _proto.getSceneInfo = function getSceneInfo(name) {
          return this._config.getSceneInfo(name);
        };

        _proto.init = function init(options) {
          this._config.init(options);

          bundles.add(options.name, this);
        };

        _proto.load = function load(paths, type, onProgress, onComplete) {
          var _parseLoadResArgs = parseLoadResArgs(type, onProgress, onComplete),
              _type = _parseLoadResArgs.type,
              onProg = _parseLoadResArgs.onProgress,
              onComp = _parseLoadResArgs.onComplete;

          var options = {
            __requestType__: RequestType.PATH,
            type: _type,
            bundle: this.name,
            __outputAsArray__: Array.isArray(paths)
          };
          legacyCC.assetManager.loadAny(paths, options, onProg, onComp);
        };

        _proto.preload = function preload(paths, type, onProgress, onComplete) {
          var _parseLoadResArgs2 = parseLoadResArgs(type, onProgress, onComplete),
              _type = _parseLoadResArgs2.type,
              onProg = _parseLoadResArgs2.onProgress,
              onComp = _parseLoadResArgs2.onComplete;

          legacyCC.assetManager.preloadAny(paths, {
            __requestType__: RequestType.PATH,
            type: _type,
            bundle: this.name
          }, onProg, onComp);
        };

        _proto.loadDir = function loadDir(dir, type, onProgress, onComplete) {
          var _parseLoadResArgs3 = parseLoadResArgs(type, onProgress, onComplete),
              _type = _parseLoadResArgs3.type,
              onProg = _parseLoadResArgs3.onProgress,
              onComp = _parseLoadResArgs3.onComplete;

          legacyCC.assetManager.loadAny(dir, {
            __requestType__: RequestType.DIR,
            type: _type,
            bundle: this.name,
            __outputAsArray__: true
          }, onProg, onComp);
        };

        _proto.preloadDir = function preloadDir(dir, type, onProgress, onComplete) {
          var _parseLoadResArgs4 = parseLoadResArgs(type, onProgress, onComplete),
              _type = _parseLoadResArgs4.type,
              onProg = _parseLoadResArgs4.onProgress,
              onComp = _parseLoadResArgs4.onComplete;

          legacyCC.assetManager.preloadAny(dir, {
            __requestType__: RequestType.DIR,
            type: _type,
            bundle: this.name
          }, onProg, onComp);
        };

        _proto.loadScene = function loadScene(sceneName, options, onProgress, onComplete) {
          var _parseParameters = parseParameters(options, onProgress, onComplete),
              opts = _parseParameters.options,
              onProg = _parseParameters.onProgress,
              onComp = _parseParameters.onComplete;

          opts.preset = opts.preset || 'scene';
          opts.bundle = this.name;
          legacyCC.assetManager.loadAny({
            scene: sceneName
          }, opts, onProg, function (err, sceneAsset) {
            if (err) {
              error(err.message, err.stack);
            } else if (sceneAsset instanceof SceneAsset && sceneAsset.scene) {
              var scene = sceneAsset.scene;
              scene._id = sceneAsset._uuid;
              scene.name = sceneAsset.name;
            } else {
              err = new Error("The asset " + sceneAsset._uuid + " is not a scene");
            }

            if (onComp) {
              onComp(err, sceneAsset);
            }
          });
        };

        _proto.preloadScene = function preloadScene(sceneName, options, onProgress, onComplete) {
          var _parseParameters2 = parseParameters(options, onProgress, onComplete),
              opts = _parseParameters2.options,
              onProg = _parseParameters2.onProgress,
              onComp = _parseParameters2.onComplete;

          opts.bundle = this.name;
          legacyCC.assetManager.preloadAny({
            scene: sceneName
          }, opts, onProg, function (err) {
            if (err) {
              errorID(1210, sceneName, err.message);
            }

            if (onComp) {
              onComp(err);
            }
          });
        };

        _proto.get = function get(path, type) {
          var info = this.getInfoWithPath(path, type);

          if (info) {
            return assets.get(info.uuid) || null;
          }

          return null;
        };

        _proto.release = function release(path, type) {
          var asset = this.get(path, type);

          if (asset) {
            releaseManager.tryRelease(asset, true);
          }
        };

        _proto.releaseUnusedAssets = function releaseUnusedAssets() {
          var _this = this;

          assets.forEach(function (asset) {
            var info = _this.getAssetInfo(asset._uuid);

            if (info && !info.redirect) {
              releaseManager.tryRelease(asset);
            }
          });
        };

        _proto.releaseAll = function releaseAll() {
          var _this2 = this;

          assets.forEach(function (asset) {
            var info = _this2.getAssetInfo(asset._uuid);

            if (info && !info.redirect) {
              releaseManager.tryRelease(asset, true);
            }
          });
        };

        _proto._destroy = function _destroy() {
          this._config.destroy();
        };

        _createClass(Bundle, [{
          key: "config",
          get: function get() {
            return this._config;
          }
        }, {
          key: "name",
          get: function get() {
            return this._config.name;
          }
        }, {
          key: "deps",
          get: function get() {
            return this._config.deps;
          }
        }, {
          key: "base",
          get: function get() {
            return this._config.base;
          }
        }]);

        return Bundle;
      }();
      var resources = exports('resources', new Bundle());
      legacyCC.resources = resources;

      function downloadDomImage(url, options, onComplete) {
        var img = new Image();

        if (window.location.protocol !== 'file:') {
          img.crossOrigin = 'anonymous';
        }

        function loadCallback() {
          img.removeEventListener('load', loadCallback);
          img.removeEventListener('error', errorCallback);

          if (onComplete) {
            onComplete(null, img);
          }
        }

        function errorCallback() {
          img.removeEventListener('load', loadCallback);
          img.removeEventListener('error', errorCallback);

          if (onComplete) {
            onComplete(new Error(getError(4930, url)));
          }
        }

        img.addEventListener('load', loadCallback);
        img.addEventListener('error', errorCallback);
        img.src = url;
        return img;
      }

      function downloadFile(url, options, onProgress, onComplete) {
        var xhr = new XMLHttpRequest();
        var errInfo = "download failed: " + url + ", status: ";
        xhr.open('GET', url, true);

        if (options.xhrResponseType !== undefined) {
          xhr.responseType = options.xhrResponseType;
        }

        if (options.xhrWithCredentials !== undefined) {
          xhr.withCredentials = options.xhrWithCredentials;
        }

        if (options.xhrMimeType !== undefined && xhr.overrideMimeType) {
          xhr.overrideMimeType(options.xhrMimeType);
        }

        if (options.xhrTimeout !== undefined) {
          xhr.timeout = options.xhrTimeout;
        }

        if (options.xhrHeader) {
          for (var header in options.xhrHeader) {
            xhr.setRequestHeader(header, options.xhrHeader[header]);
          }
        }

        xhr.onload = function () {
          if (xhr.status === 200 || xhr.status === 0) {
            if (onComplete) {
              onComplete(null, xhr.response);
            }
          } else if (onComplete) {
            onComplete(new Error("" + errInfo + xhr.status + "(no response)"));
          }
        };

        if (onProgress) {
          xhr.onprogress = function (e) {
            if (e.lengthComputable) {
              onProgress(e.loaded, e.total);
            }
          };
        }

        xhr.onerror = function () {
          if (onComplete) {
            onComplete(new Error("" + errInfo + xhr.status + "(error)"));
          }
        };

        xhr.ontimeout = function () {
          if (onComplete) {
            onComplete(new Error("" + errInfo + xhr.status + "(time out)"));
          }
        };

        xhr.onabort = function () {
          if (onComplete) {
            onComplete(new Error("" + errInfo + xhr.status + "(abort)"));
          }
        };

        xhr.send(null);
        return xhr;
      }

      var downloaded = {};
      function downloadScript(url, options, onComplete) {
        if (downloaded[url]) {
          if (onComplete) {
            onComplete(null);
          }

          return null;
        }

        var script = document.createElement('script');

        if (window.location.protocol !== 'file:') {
          script.crossOrigin = 'anonymous';
        }

        script.async = options.scriptAsyncLoading || false;
        script.src = url;

        function loadHandler() {
          script.parentNode.removeChild(script);
          script.removeEventListener('load', loadHandler, false);
          script.removeEventListener('error', errorHandler, false);
          downloaded[url] = true;

          if (onComplete) {
            onComplete(null);
          }
        }

        function errorHandler() {
          script.parentNode.removeChild(script);
          script.removeEventListener('load', loadHandler, false);
          script.removeEventListener('error', errorHandler, false);

          if (onComplete) {
            onComplete(new Error(getError(4928, url)));
          }
        }

        script.addEventListener('load', loadHandler, false);
        script.addEventListener('error', errorHandler, false);
        document.body.appendChild(script);
        return script;
      }

      var REGEX = /^(?:\w+:\/\/|\.+\/).+/;

      var downloadImage = function downloadImage(url, options, onComplete) {
        var func = sys.hasFeature(sys.Feature.IMAGE_BITMAP) && legacyCC.assetManager.allowImageBitmap ? downloadBlob : downloadDomImage;
        func(url, options, onComplete);
      };

      var downloadBlob = function downloadBlob(url, options, onComplete) {
        options.xhrResponseType = 'blob';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };

      var downloadJson = function downloadJson(url, options, onComplete) {
        options.xhrResponseType = 'json';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };

      var downloadArrayBuffer = function downloadArrayBuffer(url, options, onComplete) {
        options.xhrResponseType = 'arraybuffer';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };

      var downloadCCON = function downloadCCON(url, options, onComplete) {
        downloadJson(url, options, function (err, json) {
          if (err) {
            onComplete(err);
            return;
          }

          var cconPreface = parseCCONJson(json);
          var chunkPromises = Promise.all(cconPreface.chunks.map(function (chunk) {
            return new Promise(function (resolve, reject) {
              downloadArrayBuffer("" + mainFileName(url) + chunk, {}, function (errChunk, chunkBuffer) {
                if (err) {
                  reject(err);
                } else {
                  resolve(new Uint8Array(chunkBuffer));
                }
              });
            });
          }));
          chunkPromises.then(function (chunks) {
            var ccon = new CCON(cconPreface.document, chunks);
            onComplete(null, ccon);
          })["catch"](function (err) {
            onComplete(err);
          });
        });
      };

      var downloadCCONB = function downloadCCONB(url, options, onComplete) {
        downloadArrayBuffer(url, options, function (err, arrayBuffer) {
          if (err) {
            onComplete(err);
            return;
          }

          try {
            var ccon = decodeCCONBinary(new Uint8Array(arrayBuffer));
            onComplete(null, ccon);
          } catch (err) {
            onComplete(err);
          }
        });
      };

      var downloadText = function downloadText(url, options, onComplete) {
        options.xhrResponseType = 'text';
        downloadFile(url, options, options.onFileProgress, onComplete);
      };

      var downloadBundle = function downloadBundle(nameOrUrl, options, onComplete) {
        var bundleName = basename(nameOrUrl);
        var url = nameOrUrl;

        if (!REGEX.test(url)) {
          if (downloader.remoteBundles.indexOf(bundleName) !== -1) {
            url = downloader.remoteServerAddress + "remote/" + bundleName;
          } else {
            url = "assets/" + bundleName;
          }
        }

        var version = options.version || downloader.bundleVers[bundleName];
        var count = 0;
        var config = url + "/config." + (version ? version + "." : '') + "json";
        var out = null;
        var error = null;
        downloadJson(config, options, function (err, response) {
          error = err;
          out = response;

          if (out) {
            out.base = url + "/";
          }

          if (++count === 2) {
            onComplete(error, out);
          }
        });
        var jspath = url + "/index." + (version ? version + "." : '') + "js";
        downloadScript(jspath, options, function (err) {
          error = err;

          if (++count === 2) {
            onComplete(err, out);
          }
        });
      };

      var Downloader = function () {
        function Downloader() {
          this.maxConcurrency = 6;
          this.maxRequestsPerFrame = 6;
          this.maxRetryCount =  3 ;
          this.appendTimeStamp = !!EDITOR;
          this.limited = !EDITOR;
          this.retryInterval = 2000;
          this.bundleVers = null;
          this.remoteBundles = [];
          this.downloadDomImage = downloadDomImage;
          this.downloadDomAudio = null;
          this.downloadFile = downloadFile;
          this.downloadScript = downloadScript;
          this._downloaders = {
            '.png': downloadImage,
            '.jpg': downloadImage,
            '.bmp': downloadImage,
            '.jpeg': downloadImage,
            '.gif': downloadImage,
            '.ico': downloadImage,
            '.tiff': downloadImage,
            '.webp': downloadImage,
            '.image': downloadImage,
            '.pvr': downloadArrayBuffer,
            '.pkm': downloadArrayBuffer,
            '.astc': downloadArrayBuffer,
            '.txt': downloadText,
            '.xml': downloadText,
            '.vsh': downloadText,
            '.fsh': downloadText,
            '.atlas': downloadText,
            '.tmx': downloadText,
            '.tsx': downloadText,
            '.json': downloadJson,
            '.ExportJson': downloadJson,
            '.plist': downloadText,
            '.ccon': downloadCCON,
            '.cconb': downloadCCONB,
            '.fnt': downloadText,
            '.binary': downloadArrayBuffer,
            '.bin': downloadArrayBuffer,
            '.dbbin': downloadArrayBuffer,
            '.skel': downloadArrayBuffer,
            '.js': downloadScript,
            bundle: downloadBundle,
            "default": downloadText
          };
          this._downloading = new Cache();
          this._queue = [];
          this._queueDirty = false;
          this._totalNum = 0;
          this._totalNumThisPeriod = 0;
          this._lastDate = -1;
          this._checkNextPeriod = false;
          this._remoteServerAddress = '';
          this._maxInterval = 1 / 30;
        }

        var _proto = Downloader.prototype;

        _proto.init = function init(remoteServerAddress, bundleVers, remoteBundles) {
          if (remoteServerAddress === void 0) {
            remoteServerAddress = '';
          }

          if (bundleVers === void 0) {
            bundleVers = {};
          }

          if (remoteBundles === void 0) {
            remoteBundles = [];
          }

          this._downloading.clear();

          this._queue.length = 0;
          this._remoteServerAddress = remoteServerAddress;
          this.bundleVers = bundleVers;
          this.remoteBundles = remoteBundles;
        };

        _proto.register = function register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._downloaders, type);
          } else {
            this._downloaders[type] = handler;
          }
        };

        _proto.download = function download(id, url, type, options, onComplete) {
          var _this = this;

          var file = files.get(id);

          if (file) {
            onComplete(null, file);
            return;
          }

          var downloadCallbacks = this._downloading.get(id);

          if (downloadCallbacks) {
            downloadCallbacks.push(onComplete);

            var request = this._queue.find(function (x) {
              return x.id === id;
            });

            if (!request) {
              return;
            }

            var priority = options.priority || 0;

            if (request.priority < priority) {
              request.priority = priority;
              this._queueDirty = true;
            }

            return;
          }

          var maxRetryCount = typeof options.maxRetryCount !== 'undefined' ? options.maxRetryCount : this.maxRetryCount;
          var maxConcurrency = typeof options.maxConcurrency !== 'undefined' ? options.maxConcurrency : this.maxConcurrency;
          var maxRequestsPerFrame = typeof options.maxRequestsPerFrame !== 'undefined' ? options.maxRequestsPerFrame : this.maxRequestsPerFrame;
          var handler = this._downloaders[type] || this._downloaders["default"];

          var process = function process(index, callback) {
            if (index === 0) {
              _this._downloading.add(id, [onComplete]);
            }

            if (!_this.limited) {
              handler(urlAppendTimestamp(url, _this.appendTimeStamp), options, callback);
              return;
            }

            _this._updateTime();

            var done = function done(err, data) {
              _this._totalNum--;

              _this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);

              callback(err, data);
            };

            if (_this._totalNum < maxConcurrency && _this._totalNumThisPeriod < maxRequestsPerFrame) {
              handler(urlAppendTimestamp(url, _this.appendTimeStamp), options, done);
              _this._totalNum++;
              _this._totalNumThisPeriod++;
            } else {
              _this._queue.push({
                id: id,
                priority: options.priority || 0,
                url: url,
                options: options,
                done: done,
                handler: handler
              });

              _this._queueDirty = true;

              if (_this._totalNum < maxConcurrency) {
                _this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
              }
            }
          };

          var finale = function finale(err, result) {
            if (!err) {
              files.add(id, result);
            }

            var callbacks = _this._downloading.remove(id);

            for (var i = 0, l = callbacks.length; i < l; i++) {
              callbacks[i](err, result);
            }
          };

          retry(process, maxRetryCount, this.retryInterval, finale);
        };

        _proto.loadSubpackage = function loadSubpackage(name, completeCallback) {
          legacyCC.assetManager.loadBundle(name, null, completeCallback);
        };

        _proto._updateTime = function _updateTime() {
          var now = performance.now();
          var deltaTime = legacyCC.game.deltaTime;
          var interval = deltaTime > this._maxInterval ? this._maxInterval : deltaTime;

          if (now - this._lastDate > interval * 1000) {
            this._totalNumThisPeriod = 0;
            this._lastDate = now;
          }
        };

        _proto._handleQueue = function _handleQueue(maxConcurrency, maxRequestsPerFrame) {
          this._checkNextPeriod = false;

          this._updateTime();

          while (this._queue.length > 0 && this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
            if (this._queueDirty) {
              this._queue.sort(function (a, b) {
                return a.priority - b.priority;
              });

              this._queueDirty = false;
            }

            var request = this._queue.pop();

            if (!request) {
              break;
            }

            this._totalNum++;
            this._totalNumThisPeriod++;
            request.handler(urlAppendTimestamp(request.url, this.appendTimeStamp), request.options, request.done);
          }

          this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
        };

        _proto._handleQueueInNextFrame = function _handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame) {
          if (!this._checkNextPeriod && this._queue.length > 0) {
            callInNextTick(this._handleQueue.bind(this), maxConcurrency, maxRequestsPerFrame);
            this._checkNextPeriod = true;
          }
        };

        _createClass(Downloader, [{
          key: "remoteServerAddress",
          get: function get() {
            return this._remoteServerAddress;
          }
        }]);

        return Downloader;
      }();
      var downloader = new Downloader();

      function createImageAsset(id, data, options, onComplete) {
        var out = null;
        var err = null;

        try {
          out = new ImageAsset();
          out._nativeUrl = id;
          out._nativeAsset = data;
        } catch (e) {
          err = e;
        }

        onComplete(err, out);
      }

      function createJsonAsset(id, data, options, onComplete) {
        var out = new JsonAsset();
        out.json = data;
        onComplete(null, out);
      }

      function createTextAsset(id, data, options, onComplete) {
        var out = new TextAsset();
        out.text = data;
        onComplete(null, out);
      }

      function createBufferAsset(id, data, options, onComplete) {
        var out = new BufferAsset();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }

      function createAsset(id, data, options, onComplete) {
        var out = new Asset();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }

      function createBundle(id, data, options, onComplete) {
        var bundle = bundles.get(data.name);

        if (!bundle) {
          bundle = data.name === BuiltinBundleName.RESOURCES ? resources : new Bundle();
          data.base = data.base || id + "/";
          bundle.init(data);
        }

        module.import("virtual:///prerequisite-imports/" + bundle.name).then(function () {
          onComplete(null, bundle);
        })["catch"](onComplete);
      }

      var Factory = function () {
        function Factory() {
          this._creating = new Cache();
          this._producers = {
            '.png': createImageAsset,
            '.jpg': createImageAsset,
            '.bmp': createImageAsset,
            '.jpeg': createImageAsset,
            '.gif': createImageAsset,
            '.ico': createImageAsset,
            '.tiff': createImageAsset,
            '.webp': createImageAsset,
            '.image': createImageAsset,
            '.pvr': createImageAsset,
            '.pkm': createImageAsset,
            '.txt': createTextAsset,
            '.xml': createTextAsset,
            '.vsh': createTextAsset,
            '.fsh': createTextAsset,
            '.atlas': createTextAsset,
            '.tmx': createTextAsset,
            '.tsx': createTextAsset,
            '.fnt': createTextAsset,
            '.json': createJsonAsset,
            '.ExportJson': createJsonAsset,
            '.binary': createBufferAsset,
            '.bin': createBufferAsset,
            '.dbbin': createBufferAsset,
            '.skel': createBufferAsset,
            bundle: createBundle,
            "default": createAsset
          };
        }

        var _proto = Factory.prototype;

        _proto.register = function register(type, handler) {
          if (typeof type === 'object') {
            js.mixin(this._producers, type);
          } else {
            this._producers[type] = handler;
          }
        };

        _proto.create = function create(id, data, type, options, onComplete) {
          var _this = this;

          var handler = this._producers[type] || this._producers["default"];
          var asset = assets.get(id);

          if (!options.reloadAsset && asset) {
            onComplete(null, asset);
            return;
          }

          var creating = this._creating.get(id);

          if (creating) {
            creating.push(onComplete);
            return;
          }

          this._creating.add(id, [onComplete]);

          handler(id, data, options, function (err, result) {
            if (!err && result instanceof Asset) {
              result._uuid = id;
              cache(id, result, options.cacheAsset);
            }

            var callbacks = _this._creating.remove(id);

            for (var i = 0, l = callbacks.length; i < l; i++) {
              callbacks[i](err, result);
            }
          });
        };

        return Factory;
      }();
      var factory = new Factory();

      var PackManager = function () {
        function PackManager() {
          this._loading = new Cache();
          this._unpackers = {
            '.json': this.unpackJson
          };
        }

        var _proto = PackManager.prototype;

        _proto.unpackJson = function unpackJson(pack, json, options, onComplete) {
          var out = js.createMap(true);
          var err = null;

          if (Array.isArray(json)) {
            json = unpackJSONs(json);

            if (json.length !== pack.length) {
              errorID(4915);
            }

            for (var i = 0; i < pack.length; i++) {
              out[pack[i] + "@import"] = json[i];
            }
          } else {
            var textureType = js._getClassId(Texture2D);

            var imageAssetType = js._getClassId(ImageAsset);

            if (json.type === textureType && json.data) {
              var datas = json.data;

              if (datas.length !== pack.length) {
                errorID(4915);
              }

              for (var _i = 0; _i < pack.length; _i++) {
                out[pack[_i] + "@import"] = packCustomObjData(textureType, {
                  base: datas[_i][0],
                  mipmaps: datas[_i][1]
                });
              }
            } else if (json.type === imageAssetType && json.data) {
              var _datas = json.data;

              if (_datas.length !== pack.length) {
                errorID(4915);
              }

              for (var _i2 = 0; _i2 < pack.length; _i2++) {
                out[pack[_i2] + "@import"] = _datas[_i2];
              }
            } else {
              err = new Error('unmatched type pack!');
              out = null;
            }
          }

          onComplete(err, out);
        };

        _proto.init = function init() {
          this._loading.clear();
        };

        _proto.register = function register(type, handler) {
          if (typeof type === 'object') {
            js.mixin(this._unpackers, type);
          } else {
            this._unpackers[type] = handler;
          }
        };

        _proto.unpack = function unpack(pack, data, type, options, onComplete) {
          if (!data) {
            onComplete(new Error('package data is wrong!'));
            return;
          }

          var unpacker = this._unpackers[type];
          unpacker(pack, data, options, onComplete);
        };

        _proto.load = function load(item, options, onComplete) {
          var _this = this;

          if (item.isNative || !item.info || !item.info.packs) {
            downloader.download(item.id, item.url, item.ext, item.options, onComplete);
            return;
          }

          if (files.has(item.id)) {
            onComplete(null, files.get(item.id));
            return;
          }

          var packs = item.info.packs;
          var pack = packs.find(function (val) {
            return _this._loading.has(val.uuid);
          });

          if (pack) {
            this._loading.get(pack.uuid).push({
              onComplete: onComplete,
              id: item.id
            });

            return;
          }

          pack = packs[0];

          this._loading.add(pack.uuid, [{
            onComplete: onComplete,
            id: item.id
          }]);

          var url = transform(pack.uuid, {
            ext: pack.ext,
            bundle: item.config.name
          });
          downloader.download(pack.uuid, url, pack.ext, item.options, function (err, data) {
            files.remove(pack.uuid);

            if (err) {
              error(err.message, err.stack);
            }

            _this.unpack(pack.packedUuids, data, pack.ext, item.options, function (err2, result) {
              if (!err2) {
                for (var id in result) {
                  files.add(id, result[id]);
                }
              }

              var callbacks = _this._loading.remove(pack.uuid);

              for (var i = 0, l = callbacks.length; i < l; i++) {
                var cb = callbacks[i];

                if (err || err2) {
                  cb.onComplete(err || err2);
                  continue;
                }

                var unpackedData = result[cb.id];

                if (!unpackedData) {
                  cb.onComplete(new Error('can not retrieve data from package'));
                } else {
                  cb.onComplete(null, unpackedData);
                }
              }
            });
          });
        };

        return PackManager;
      }();
      var packManager = new PackManager();

      function fetch(task, done) {
        var firstTask = false;

        if (!task.progress) {
          task.progress = {
            finish: 0,
            total: task.input.length,
            canInvoke: true
          };
          firstTask = true;
        }

        var options = task.options,
            progress = task.progress;
        var depends = [];
        var total = progress.total;
        var exclude = options.__exclude__ = options.__exclude__ || Object.create(null);
        task.output = [];
        forEach(task.input, function (item, cb) {
          if (!item.isNative && assets.has(item.uuid)) {
            var asset = assets.get(item.uuid);
            item.content = asset.addRef();
            task.output.push(item);

            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }

            cb();
            return;
          }

          packManager.load(item, task.options, function (err, data) {
            if (err) {
              if (!task.isFinish) {
                if (!legacyCC.assetManager.force || firstTask) {
                  error(err.message, err.stack);
                  progress.canInvoke = false;
                  done(err);
                } else {
                  task.output.push(item);

                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }
                }
              }
            } else if (!task.isFinish) {
              item.file = data;
              task.output.push(item);

              if (!item.isNative) {
                exclude[item.uuid] = true;
                getDepends(item.uuid, data, exclude, depends, item.config);
                progress.total = total + depends.length;
              }

              if (progress.canInvoke) {
                task.dispatch('progress', ++progress.finish, progress.total, item);
              }
            }

            cb();
          });
        }, function () {
          if (task.isFinish) {
            clear$1(task, true);
            task.dispatch('error');
            return;
          }

          if (depends.length > 0) {
            var subTask = Task.create({
              input: depends,
              progress: progress,
              options: options,
              onProgress: task.onProgress,
              onError: Task.prototype.recycle,
              onComplete: function onComplete(err) {
                if (!err) {
                  var _task$output;

                  (_task$output = task.output).push.apply(_task$output, subTask.output);

                  subTask.recycle();
                }

                if (firstTask) {
                  decreaseRef(task);
                }

                done(err);
              }
            });
            fetchPipeline.async(subTask);
            return;
          }

          if (firstTask) {
            decreaseRef(task);
          }

          done();
        });
      }

      function decreaseRef(task) {
        var output = task.output;

        for (var i = 0, l = output.length; i < l; i++) {
          if (output[i].content) {
            output[i].content.decRef(false);
          }
        }
      }

      var SAXParser = function () {
        function SAXParser() {
          this._parser = null;

          if (window.DOMParser) {
            this._parser = new DOMParser();
          }
        }

        var _proto = SAXParser.prototype;

        _proto.parse = function parse(xmlTxt) {
          return this._parseXML(xmlTxt);
        };

        _proto._parseXML = function _parseXML(textxml) {
          if (this._parser) {
            return this._parser.parseFromString(textxml, 'text/xml');
          }

          throw new Error('Dom parser is not supported in this platform!');
        };

        return SAXParser;
      }();

      var PlistParser = function (_SAXParser) {
        _inheritsLoose(PlistParser, _SAXParser);

        function PlistParser() {
          return _SAXParser.apply(this, arguments) || this;
        }

        var _proto2 = PlistParser.prototype;

        _proto2.parse = function parse(xmlTxt) {
          var xmlDoc = this._parseXML(xmlTxt);

          var plist = xmlDoc.documentElement;

          if (plist.tagName !== 'plist') {
            warnID(5100);
            return {};
          }

          var node = null;

          for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];

            if (node.nodeType === 1) {
              break;
            }
          }

          return this._parseNode(node);
        };

        _proto2._parseNode = function _parseNode(node) {
          var data = null;
          var tagName = node.tagName;

          if (tagName === 'dict') {
            data = this._parseDict(node);
          } else if (tagName === 'array') {
            data = this._parseArray(node);
          } else if (tagName === 'string') {
            if (node.childNodes.length === 1) {
              data = node.firstChild.nodeValue;
            } else {
              data = '';

              for (var i = 0; i < node.childNodes.length; i++) {
                data += node.childNodes[i].nodeValue;
              }
            }
          } else if (tagName === 'false') {
            data = false;
          } else if (tagName === 'true') {
            data = true;
          } else if (tagName === 'real') {
            data = parseFloat(node.firstChild.nodeValue);
          } else if (tagName === 'integer') {
            data = parseInt(node.firstChild.nodeValue, 10);
          }

          return data;
        };

        _proto2._parseArray = function _parseArray(node) {
          var data = [];

          for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];

            if (child.nodeType !== 1) {
              continue;
            }

            data.push(this._parseNode(child));
          }

          return data;
        };

        _proto2._parseDict = function _parseDict(node) {
          var data = {};
          var key = '';

          for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];

            if (child.nodeType !== 1) {
              continue;
            }

            if (child.tagName === 'key') {
              key = child.firstChild.nodeValue;
            } else {
              data[key] = this._parseNode(child);
            }
          }

          return data;
        };

        return PlistParser;
      }(SAXParser);

      var plistParser = new PlistParser();

      var PVR_HEADER_LENGTH = 13;
      var PVR_MAGIC = 0x03525650;
      var PVR_HEADER_MAGIC = 0;
      var PVR_HEADER_HEIGHT = 6;
      var PVR_HEADER_WIDTH = 7;
      var PVR_HEADER_METADATA = 12;
      var ETC_PKM_HEADER_SIZE = 16;
      var ETC_PKM_FORMAT_OFFSET = 6;
      var ETC_PKM_ENCODED_WIDTH_OFFSET = 8;
      var ETC_PKM_ENCODED_HEIGHT_OFFSET = 10;
      var ETC_PKM_WIDTH_OFFSET = 12;
      var ETC_PKM_HEIGHT_OFFSET = 14;
      var ETC1_RGB_NO_MIPMAPS = 0;
      var ETC2_RGB_NO_MIPMAPS = 1;
      var ETC2_RGBA_NO_MIPMAPS = 3;
      var ASTC_MAGIC = 0x5CA1AB13;
      var ASTC_HEADER_LENGTH = 16;
      var ASTC_HEADER_MAGIC = 4;
      var ASTC_HEADER_SIZE_X_BEGIN = 7;
      var ASTC_HEADER_SIZE_Y_BEGIN = 10;
      var ASTC_HEADER_SIZE_Z_BEGIN = 13;

      function getASTCFormat(xdim, ydim) {
        if (xdim === 4) {
          return PixelFormat.RGBA_ASTC_4x4;
        }

        if (xdim === 5) {
          if (ydim === 4) {
            return PixelFormat.RGBA_ASTC_5x4;
          }

          return PixelFormat.RGBA_ASTC_5x5;
        }

        if (xdim === 6) {
          if (ydim === 5) {
            return PixelFormat.RGBA_ASTC_6x5;
          }

          return PixelFormat.RGBA_ASTC_6x6;
        }

        if (xdim === 8) {
          if (ydim === 5) {
            return PixelFormat.RGBA_ASTC_8x5;
          }

          if (ydim === 6) {
            return PixelFormat.RGBA_ASTC_8x6;
          }

          return PixelFormat.RGBA_ASTC_8x8;
        }

        if (xdim === 10) {
          if (ydim === 5) {
            return PixelFormat.RGBA_ASTC_10x5;
          }

          if (ydim === 6) {
            return PixelFormat.RGBA_ASTC_10x6;
          }

          if (ydim === 8) {
            return PixelFormat.RGBA_ASTC_10x8;
          }

          return PixelFormat.RGBA_ASTC_10x10;
        }

        if (ydim === 10) {
          return PixelFormat.RGBA_ASTC_12x10;
        }

        return PixelFormat.RGBA_ASTC_12x12;
      }

      function readBEUint16(header, offset) {
        return header[offset] << 8 | header[offset + 1];
      }

      var Parser$1 = function () {
        function Parser() {
          this._parsing = new Cache();
          this._parsers = {
            '.png': this.parseImage,
            '.jpg': this.parseImage,
            '.bmp': this.parseImage,
            '.jpeg': this.parseImage,
            '.gif': this.parseImage,
            '.ico': this.parseImage,
            '.tiff': this.parseImage,
            '.webp': this.parseImage,
            '.image': this.parseImage,
            '.pvr': this.parsePVRTex,
            '.pkm': this.parsePKMTex,
            '.astc': this.parseASTCTex,
            '.plist': this.parsePlist,
            "import": this.parseImport,
            '.ccon': this.parseImport,
            '.cconb': this.parseImport
          };
        }

        var _proto = Parser.prototype;

        _proto.parseImage = function parseImage(file, options, onComplete) {
          if (file instanceof HTMLImageElement) {
            onComplete(null, file);
            return;
          }

          createImageBitmap(file, {
            premultiplyAlpha: 'none'
          }).then(function (result) {
            onComplete(null, result);
          }, function (err) {
            onComplete(err, null);
          });
        };

        _proto.parsePVRTex = function parsePVRTex(file, options, onComplete) {
          var err = null;
          var out = null;

          try {
            var buffer = file instanceof ArrayBuffer ? file : file.buffer;
            var header = new Int32Array(buffer, 0, PVR_HEADER_LENGTH);

            if (header[PVR_HEADER_MAGIC] === PVR_MAGIC) {
              var width = header[PVR_HEADER_WIDTH];
              var height = header[PVR_HEADER_HEIGHT];
              var dataOffset = header[PVR_HEADER_METADATA] + 52;
              var pvrtcData = new Uint8Array(buffer, dataOffset);
              out = {
                _data: pvrtcData,
                _compressed: true,
                width: width,
                height: height,
                format: 0
              };
            } else if (header[11] === 0x21525650) {
              var headerLength = header[0];
              var _height = header[1];
              var _width = header[2];

              var _pvrtcData = new Uint8Array(buffer, headerLength);

              out = {
                _data: _pvrtcData,
                _compressed: true,
                width: _width,
                height: _height,
                format: 0
              };
            } else {
              throw new Error('Invalid magic number in PVR header');
            }
          } catch (e) {
            err = e;
          }

          onComplete(err, out);
        };

        _proto.parsePKMTex = function parsePKMTex(file, options, onComplete) {
          var err = null;
          var out = null;

          try {
            var buffer = file instanceof ArrayBuffer ? file : file.buffer;
            var header = new Uint8Array(buffer);
            var format = readBEUint16(header, ETC_PKM_FORMAT_OFFSET);

            if (format !== ETC1_RGB_NO_MIPMAPS && format !== ETC2_RGB_NO_MIPMAPS && format !== ETC2_RGBA_NO_MIPMAPS) {
              throw new Error('Invalid magic number in ETC header');
            }

            var width = readBEUint16(header, ETC_PKM_WIDTH_OFFSET);
            var height = readBEUint16(header, ETC_PKM_HEIGHT_OFFSET);
            var encodedWidth = readBEUint16(header, ETC_PKM_ENCODED_WIDTH_OFFSET);
            var encodedHeight = readBEUint16(header, ETC_PKM_ENCODED_HEIGHT_OFFSET);
            var etcData = new Uint8Array(buffer, ETC_PKM_HEADER_SIZE);
            out = {
              _data: etcData,
              _compressed: true,
              width: width,
              height: height,
              format: 0
            };
          } catch (e) {
            err = e;
          }

          onComplete(err, out);
        };

        _proto.parseASTCTex = function parseASTCTex(file, options, onComplete) {
          var err = null;
          var out = null;

          try {
            var buffer = file instanceof ArrayBuffer ? file : file.buffer;
            var header = new Uint8Array(buffer);
            var magicval = header[0] + (header[1] << 8) + (header[2] << 16) + (header[3] << 24);

            if (magicval !== ASTC_MAGIC) {
              throw new Error('Invalid magic number in ASTC header');
            }

            var xdim = header[ASTC_HEADER_MAGIC];
            var ydim = header[ASTC_HEADER_MAGIC + 1];
            var zdim = header[ASTC_HEADER_MAGIC + 2];

            if ((xdim < 3 || xdim > 6 || ydim < 3 || ydim > 6 || zdim < 3 || zdim > 6) && (xdim < 4 || xdim === 7 || xdim === 9 || xdim === 11 || xdim > 12 || ydim < 4 || ydim === 7 || ydim === 9 || ydim === 11 || ydim > 12 || zdim !== 1)) {
              throw new Error('Invalid block number in ASTC header');
            }

            var format = getASTCFormat(xdim, ydim);
            var xsize = header[ASTC_HEADER_SIZE_X_BEGIN] + (header[ASTC_HEADER_SIZE_X_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_X_BEGIN + 2] << 16);
            var ysize = header[ASTC_HEADER_SIZE_Y_BEGIN] + (header[ASTC_HEADER_SIZE_Y_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_Y_BEGIN + 2] << 16);
            var zsize = header[ASTC_HEADER_SIZE_Z_BEGIN] + (header[ASTC_HEADER_SIZE_Z_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_Z_BEGIN + 2] << 16);
            var astcData = new Uint8Array(buffer, ASTC_HEADER_LENGTH);
            out = {
              _data: astcData,
              _compressed: true,
              width: xsize,
              height: ysize,
              format: format
            };
          } catch (e) {
            err = e;
          }

          onComplete(err, out);
        };

        _proto.parsePlist = function parsePlist(file, options, onComplete) {
          var err = null;
          var result = plistParser.parse(file);

          if (!result) {
            err = new Error('parse failed');
          }

          onComplete(err, result);
        };

        _proto.parseImport = function parseImport(file, options, onComplete) {
          if (!file) {
            onComplete(new Error("The json file of asset " + options.__uuid__ + " is empty or missing"));
            return;
          }

          var result = null;
          var err = null;

          try {
            result = deserializeAsset(file, options);
          } catch (e) {
            err = e;
          }

          onComplete(err, result);
        };

        _proto.init = function init() {
          this._parsing.clear();
        };

        _proto.register = function register(type, handler) {
          if (typeof type === 'object') {
            mixin(this._parsers, type);
          } else {
            this._parsers[type] = handler;
          }
        };

        _proto.parse = function parse(id, file, type, options, onComplete) {
          var _this = this;

          var parsedAsset = parsed.get(id);

          if (parsedAsset) {
            onComplete(null, parsedAsset);
            return;
          }

          var parsing = this._parsing.get(id);

          if (parsing) {
            parsing.push(onComplete);
            return;
          }

          var parseHandler = this._parsers[type];

          if (!parseHandler) {
            onComplete(null, file);
            return;
          }

          this._parsing.add(id, [onComplete]);

          parseHandler(file, options, function (err, data) {
            if (err) {
              files.remove(id);
            } else if (!isScene(data)) {
              parsed.add(id, data);
            }

            var callbacks = _this._parsing.remove(id);

            for (var i = 0, l = callbacks.length; i < l; i++) {
              callbacks[i](err, data);
            }
          });
        };

        return Parser;
      }();
      var parser = new Parser$1();

      function load(task, done) {
        var firstTask = false;

        if (!task.progress) {
          task.progress = {
            finish: 0,
            total: task.input.length,
            canInvoke: true
          };
          firstTask = true;
        }

        var options = task.options,
            progress = task.progress;
        options.__exclude__ = options.__exclude__ || Object.create(null);
        task.output = [];
        forEach(task.input, function (item, cb) {
          var subTask = Task.create({
            input: item,
            onProgress: task.onProgress,
            options: options,
            progress: progress,
            onComplete: function onComplete(err, result) {
              if (err && !task.isFinish) {
                if (!legacyCC.assetManager.force || firstTask) {
                  {
                    error(err.message, err.stack);
                  }

                  progress.canInvoke = false;
                  done(err);
                } else if (progress.canInvoke) {
                  task.dispatch('progress', ++progress.finish, progress.total, item);
                }
              }

              task.output.push(result);
              subTask.recycle();
              cb(null);
            }
          });
          loadOneAssetPipeline.async(subTask);
        }, function () {
          options.__exclude__ = null;

          if (task.isFinish) {
            clear$1(task, true);
            task.dispatch('error');
            return;
          }

          gatherAsset(task);
          clear$1(task, true);
          done();
        });
      }
      var loadOneAssetPipeline = new Pipeline('loadOneAsset', [function fetch(task, done) {
        var item = task.output = task.input;
        var options = item.options,
            isNative = item.isNative,
            uuid = item.uuid,
            file = item.file;
        var reloadAsset = options.reloadAsset;

        if (file || !reloadAsset && !isNative && assets.has(uuid)) {
          done();
          return;
        }

        packManager.load(item, task.options, function (err, data) {
          item.file = data;
          done(err);
        });
      }, function parse(task, done) {
        var item = task.output = task.input;
        var progress = task.progress;
        var exclude = task.options.__exclude__;
        var id = item.id,
            file = item.file,
            options = item.options;

        if (item.isNative) {
          parser.parse(id, file, item.ext, options, function (err, asset) {
            if (err) {
              done(err);
              return;
            }

            item.content = asset;

            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }

            files.remove(id);
            parsed.remove(id);
            done();
          });
        } else {
          var uuid = item.uuid;

          if (uuid in exclude) {
            var _exclude$uuid = exclude[uuid],
                finish = _exclude$uuid.finish,
                content = _exclude$uuid.content,
                err = _exclude$uuid.err,
                callbacks = _exclude$uuid.callbacks;

            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }

            if (finish || checkCircleReference(uuid, uuid, exclude)) {
              if (content) {
                content.addRef();
              }

              item.content = content;
              done(err);
            } else {
              callbacks.push({
                done: done,
                item: item
              });
            }
          } else if (!options.reloadAsset && assets.has(uuid)) {
            var asset = assets.get(uuid);
            item.content = asset.addRef();

            if (progress.canInvoke) {
              task.dispatch('progress', ++progress.finish, progress.total, item);
            }

            done();
          } else {
            options.__uuid__ = uuid;
            parser.parse(id, file, 'import', options, function (err, asset) {
              if (err) {
                done(err);
                return;
              }

              loadDepends(task, asset, done);
            });
          }
        }
      }]);

      function loadDepends(task, asset, done) {
        var item = task.input,
            progress = task.progress;
        var _ref = item,
            uuid = _ref.uuid,
            id = _ref.id,
            options = _ref.options,
            config = _ref.config;
        var cacheAsset = options.cacheAsset;
        var depends = [];

        if (asset.addRef) {
          asset.addRef();
        }

        getDepends(uuid, asset, Object.create(null), depends, config);

        if (progress.canInvoke) {
          task.dispatch('progress', ++progress.finish, progress.total += depends.length, item);
        }

        var repeatItem = task.options.__exclude__[uuid] = {
          content: asset,
          finish: false,
          callbacks: [{
            done: done,
            item: item
          }]
        };
        var subTask = Task.create({
          input: depends,
          options: task.options,
          onProgress: task.onProgress,
          onError: Task.prototype.recycle,
          progress: progress,
          onComplete: function onComplete(err) {
            if (asset.decRef) {
              asset.decRef(false);
            }

            repeatItem.finish = true;
            repeatItem.err = err;

            if (!err) {
              var output = Array.isArray(subTask.output) ? subTask.output : [subTask.output];
              var map = Object.create(null);

              for (var _iterator = _createForOfIteratorHelperLoose(output), _step; !(_step = _iterator()).done;) {
                var dependAsset = _step.value;

                if (!dependAsset) {
                  continue;
                }

                map[dependAsset instanceof Asset ? dependAsset._uuid + "@import" : uuid + "@native"] = dependAsset;
              }

              setProperties(uuid, asset, map);

              try {
                if (typeof asset.onLoaded === 'function' && !onLoadedInvokedMap.has(asset) && !nativeDependMap.has(asset)) {
                  asset.onLoaded();
                  onLoadedInvokedMap.add(asset);
                }
              } catch (e) {
                error("The asset " + uuid + " is invalid for some reason, detail message: " + e.message + ", stack: " + e.stack);
              }

              files.remove(id);
              parsed.remove(id);

              cache(uuid, asset, cacheAsset);
              subTask.recycle();
            }

            var callbacks = repeatItem.callbacks;

            for (var i = 0, l = callbacks.length; i < l; i++) {
              var cb = callbacks[i];

              if (asset.addRef) {
                asset.addRef();
              }

              cb.item.content = asset;
              cb.done(err);
            }

            callbacks.length = 0;
          }
        });
        pipeline.async(subTask);
      }

      function preprocess(task, done) {
        var options = task.options;
        var subOptions = Object.create(null);
        var leftOptions = Object.create(null);

        for (var op in options) {
          switch (op) {
            case RequestType.PATH:
            case RequestType.UUID:
            case RequestType.DIR:
            case RequestType.SCENE:
            case RequestType.URL:
              break;

            case '__requestType__':
            case '__isNative__':
            case 'ext':
            case 'type':
            case '__nativeName__':
            case 'audioLoadMode':
            case 'bundle':
              subOptions[op] = options[op];
              break;

            case '__exclude__':
            case '__outputAsArray__':
              leftOptions[op] = options[op];
              break;

            default:
              subOptions[op] = options[op];
              leftOptions[op] = options[op];
              break;
          }
        }

        task.options = leftOptions;
        var subTask = Task.create({
          input: task.input,
          options: subOptions
        });
        var err = null;

        try {
          task.output = task.source = transformPipeline.sync(subTask);
        } catch (e) {
          err = e;

          for (var i = 0, l = subTask.output.length; i < l; i++) {
            subTask.output[i].recycle();
          }
        }

        subTask.recycle();
        done(err);
      }

      var RequestItem = function () {
        function RequestItem() {
          this.uuid = '';
          this.url = '';
          this.ext = '.json';
          this.content = null;
          this.file = null;
          this.info = null;
          this.config = null;
          this.isNative = false;
          this.options = Object.create(null);
          this._id = '';
        }

        RequestItem.create = function create() {
          var out;

          if (RequestItem._deadPool.length !== 0) {
            out = RequestItem._deadPool.pop();
          } else {
            out = new RequestItem();
          }

          return out;
        };

        var _proto = RequestItem.prototype;

        _proto.recycle = function recycle() {
          if (RequestItem._deadPool.length === RequestItem.MAX_DEAD_NUM) {
            return;
          }

          this._id = '';
          this.uuid = '';
          this.url = '';
          this.ext = '.json';
          this.content = null;
          this.file = null;
          this.info = null;
          this.config = null;
          this.isNative = false;
          this.options = Object.create(null);

          RequestItem._deadPool.push(this);
        };

        _createClass(RequestItem, [{
          key: "id",
          get: function get() {
            if (!this._id) {
              this._id = this.uuid + "@" + (this.isNative ? 'native' : 'import');
            }

            return this._id;
          }
        }]);

        return RequestItem;
      }();

      RequestItem.MAX_DEAD_NUM = 500;
      RequestItem._deadPool = [];

      var infos = [];
      function parse(task) {
        var options = task.options;
        var input = Array.isArray(task.input) ? task.input : [task.input];
        task.output = [];

        var _loop = function _loop(i) {
          var _info2;

          var item = input[i];
          var out = RequestItem.create();
          var config = null;
          var info = null;

          if (typeof item === 'string') {
            item = Object.create(null);
            item[options.__requestType__ || RequestType.UUID] = input[i];
          }

          if (typeof item === 'object') {
            addon(item, options);

            if (item.preset) {
              addon(item, presets[item.preset]);
            }

            for (var key in item) {
              switch (key) {
                case RequestType.UUID:
                  {
                    var _ret2 = function () {
                      var _info;

                      var uuid = out.uuid = decodeUuid(item.uuid);

                      if (!item.bundle) {
                        var bundle = bundles.find(function (bundle) {
                          return !!bundle.getAssetInfo(uuid);
                        });
                        item.bundle = bundle && bundle.name;
                      }

                      if (bundles.has(item.bundle)) {
                        config = bundles.get(item.bundle).config;
                        info = config.getAssetInfo(uuid);

                        if (info && info.redirect) {
                          if (!bundles.has(info.redirect)) {
                            throw new Error("Please load bundle " + info.redirect + " first");
                          }

                          config = bundles.get(info.redirect).config;
                          info = config.getAssetInfo(uuid);
                        }

                        out.config = config;
                        out.info = info;
                      }

                      out.ext = item.ext || ((_info = info) === null || _info === void 0 ? void 0 : _info.extension) || '.json';
                      return "break";
                    }();

                    if (_ret2 === "break") break;
                  }

                case '__requestType__':
                case 'ext':
                case 'bundle':
                case 'preset':
                case 'type':
                  break;

                case RequestType.DIR:
                  if (bundles.has(item.bundle)) {
                    bundles.get(item.bundle).config.getDirWithPath(item.dir, item.type, infos);

                    for (var _iterator = _createForOfIteratorHelperLoose(infos), _step; !(_step = _iterator()).done;) {
                      var assetInfo = _step.value;
                      input.push({
                        uuid: assetInfo.uuid,
                        __isNative__: false,
                        ext: assetInfo.extension || '.json',
                        bundle: item.bundle
                      });
                    }

                    infos.length = 0;
                  }

                  out.recycle();
                  out = null;
                  break;

                case RequestType.PATH:
                  if (bundles.has(item.bundle)) {
                    config = bundles.get(item.bundle).config;
                    info = config.getInfoWithPath(item.path, item.type);

                    if (info && info.redirect) {
                      if (!bundles.has(info.redirect)) {
                        throw new Error("you need to load bundle " + info.redirect + " first");
                      }

                      config = bundles.get(info.redirect).config;
                      info = config.getAssetInfo(info.uuid);
                    }

                    if (!info) {
                      out.recycle();
                      throw new Error("Bundle " + item.bundle + " doesn't contain " + item.path);
                    }

                    out.config = config;
                    out.uuid = info.uuid;
                    out.info = info;
                  }

                  out.ext = item.ext || ((_info2 = info) === null || _info2 === void 0 ? void 0 : _info2.extension) || '.json';
                  break;

                case RequestType.SCENE:
                  if (!item.bundle) {
                    var bundle = bundles.find(function (bundle) {
                      return !!bundle.getSceneInfo(item.scene);
                    });
                    item.bundle = bundle && bundle.name;
                  }

                  if (bundles.has(item.bundle)) {
                    config = bundles.get(item.bundle).config;
                    info = config.getSceneInfo(item.scene);

                    if (info && info.redirect) {
                      if (!bundles.has(info.redirect)) {
                        throw new Error("you need to load bundle " + info.redirect + " first");
                      }

                      config = bundles.get(info.redirect).config;
                      info = config.getAssetInfo(info.uuid);
                    }

                    if (!info) {
                      out.recycle();
                      throw new Error("Bundle " + config.name + " doesn't contain scene " + item.scene);
                    }

                    out.config = config;
                    out.uuid = info.uuid;
                    out.info = info;
                  }

                  break;

                case '__isNative__':
                  out.isNative = item.__isNative__;
                  break;

                case RequestType.URL:
                  out.url = item.url;
                  out.uuid = item.uuid || item.url;
                  out.ext = item.ext || extname(item.url);
                  out.isNative = item.__isNative__ !== undefined ? item.__isNative__ : true;
                  break;

                default:
                  out.options[key] = item[key];
              }

              if (!out) {
                break;
              }
            }
          }

          if (!out) {
            return "continue";
          }

          task.output.push(out);

          if (!out.uuid && !out.url) {
            throw new Error("Can not parse this input:" + JSON.stringify(item));
          }
        };

        for (var i = 0; i < input.length; i++) {
          var _ret = _loop(i);

          if (_ret === "continue") continue;
        }

        return null;
      }
      function combine(task) {
        var input = task.output = task.input;

        for (var i = 0; i < input.length; i++) {
          var item = input[i];

          if (item.url) {
            continue;
          }

          var url = '';
          var base = '';
          var config = item.config;

          if (item.isNative) {
            base = config && config.nativeBase ? config.base + config.nativeBase : legacyCC.assetManager.generalNativeBase;
          } else {
            base = config && config.importBase ? config.base + config.importBase : legacyCC.assetManager.generalImportBase;
          }

          var uuid = item.uuid;
          var ver = '';

          if (item.info) {
            if (item.isNative) {
              ver = item.info.nativeVer ? "." + item.info.nativeVer : '';
            } else {
              ver = item.info.ver ? "." + item.info.ver : '';
            }
          }

          if (item.ext === '.ttf') {
            url = base + "/" + uuid.slice(0, 2) + "/" + uuid + ver + "/" + item.options.__nativeName__;
          } else {
            url = base + "/" + uuid.slice(0, 2) + "/" + uuid + ver + item.ext;
          }

          item.url = url;
        }

        return null;
      }

      var AssetManager = exports('AssetManager', function () {
        function AssetManager() {
          this.pipeline = pipeline.append(preprocess).append(load);
          this.fetchPipeline = fetchPipeline.append(preprocess).append(fetch);
          this.transformPipeline = transformPipeline.append(parse).append(combine);
          this.bundles = bundles;
          this.assets = assets;
          this.generalImportBase = '';
          this.generalNativeBase = '';
          this.dependUtil = dependUtil;
          this.force =  PREVIEW;
          this.allowImageBitmap = !sys.isMobile;
          this.utils = helper;
          this.downloader = downloader;
          this.parser = parser;
          this.packManager = packManager;
          this.cacheAsset = true;
          this.cacheManager = null;
          this.presets = presets;
          this.factory = factory;
          this.preprocessPipe = preprocess;
          this.fetchPipe = fetch;
          this.loadPipe = load;
          this.references = references;
          this._releaseManager = releaseManager;
          this._files = files;
          this._parsed = parsed;
          this._parsePipeline =  null ;
        }

        var _proto = AssetManager.prototype;

        _proto.init = function init(options) {
          if (options === void 0) {
            options = {};
          }

          this._files.clear();

          this._parsed.clear();

          this._releaseManager.init();

          this.assets.clear();
          this.bundles.clear();
          this.packManager.init();
          this.downloader.init(options.server, options.bundleVers, options.remoteBundles);
          this.parser.init();
          this.dependUtil.init();
          var importBase = options.importBase || '';

          if (importBase && importBase.endsWith('/')) {
            importBase = importBase.substr(0, importBase.length - 1);
          }

          var nativeBase = options.nativeBase || '';

          if (nativeBase && nativeBase.endsWith('/')) {
            nativeBase = nativeBase.substr(0, nativeBase.length - 1);
          }

          this.generalImportBase = importBase;
          this.generalNativeBase = nativeBase;
        };

        _proto.getBundle = function getBundle(name) {
          return bundles.get(name) || null;
        };

        _proto.removeBundle = function removeBundle(bundle) {
          bundle._destroy();

          bundles.remove(bundle.name);
        };

        _proto.loadAny = function loadAny(requests, options, onProgress, onComplete) {
          var _parseParameters = parseParameters(options, onProgress, onComplete),
              opts = _parseParameters.options,
              onProg = _parseParameters.onProgress,
              onComp = _parseParameters.onComplete;

          opts.preset = opts.preset || 'default';
          requests = Array.isArray(requests) ? requests.slice() : requests;
          var task = Task.create({
            input: requests,
            onProgress: onProg,
            onComplete: asyncify(onComp),
            options: opts
          });
          pipeline.async(task);
        };

        _proto.preloadAny = function preloadAny(requests, options, onProgress, onComplete) {
          var _parseParameters2 = parseParameters(options, onProgress, onComplete),
              opts = _parseParameters2.options,
              onProg = _parseParameters2.onProgress,
              onComp = _parseParameters2.onComplete;

          opts.preset = opts.preset || 'preload';
          requests = Array.isArray(requests) ? requests.slice() : requests;
          var task = Task.create({
            input: requests,
            onProgress: onProg,
            onComplete: asyncify(onComp),
            options: opts
          });
          fetchPipeline.async(task);
        };

        _proto.loadRemote = function loadRemote(url, options, onComplete) {
          var _parseParameters3 = parseParameters(options, undefined, onComplete),
              opts = _parseParameters3.options,
              onComp = _parseParameters3.onComplete;

          if (!opts.reloadAsset && this.assets.has(url)) {
            asyncify(onComp)(null, this.assets.get(url));
            return;
          }

          opts.__isNative__ = true;
          opts.preset = opts.preset || 'remote';
          this.loadAny({
            url: url
          }, opts, null, function (err, data) {
            if (err) {
              error(err.message, err.stack);

              if (onComp) {
                onComp(err, data);
              }
            } else {
              factory.create(url, data, opts.ext || extname(url), opts, function (p1, p2) {
                if (onComp) {
                  onComp(p1, p2);
                }
              });
            }
          });
        };

        _proto.loadBundle = function loadBundle(nameOrUrl, options, onComplete) {
          var _parseParameters4 = parseParameters(options, undefined, onComplete),
              opts = _parseParameters4.options,
              onComp = _parseParameters4.onComplete;

          var bundleName = basename(nameOrUrl);

          if (this.bundles.has(bundleName)) {
            asyncify(onComp)(null, this.getBundle(bundleName));
            return;
          }

          opts.preset = opts.preset || 'bundle';
          opts.ext = 'bundle';
          opts.__isNative__ = true;
          this.loadAny({
            url: nameOrUrl
          }, opts, null, function (err, data) {
            if (err) {
              error(err.message, err.stack);

              if (onComp) {
                onComp(err, data);
              }
            } else {
              factory.create(nameOrUrl, data, 'bundle', opts, function (p1, p2) {
                if (onComp) {
                  onComp(p1, p2);
                }
              });
            }
          });
        };

        _proto.releaseAsset = function releaseAsset(asset) {
          releaseManager.tryRelease(asset, true);
        };

        _proto.releaseUnusedAssets = function releaseUnusedAssets() {
          assets.forEach(function (asset) {
            releaseManager.tryRelease(asset);
          });
        };

        _proto.releaseAll = function releaseAll() {
          assets.forEach(function (asset) {
            releaseManager.tryRelease(asset, true);
          });
        };

        _proto.loadWithJson = function loadWithJson(json, options, onProgress, onComplete) {
          {
            throw new Error('Only valid in Editor');
          }
        };

        _createClass(AssetManager, [{
          key: "main",
          get: function get() {
            return bundles.get(BuiltinBundleName.MAIN) || null;
          }
        }, {
          key: "resources",
          get: function get() {
            return bundles.get(BuiltinBundleName.RESOURCES) || null;
          }
        }]);

        return AssetManager;
      }());
      AssetManager.Pipeline = Pipeline;
      AssetManager.Task = Task;
      AssetManager.Cache = Cache;
      AssetManager.RequestItem = RequestItem;
      AssetManager.Bundle = Bundle;
      AssetManager.BuiltinBundleName = BuiltinBundleName;
      var assetManager = exports('assetManager', legacyCC.assetManager = new AssetManager());
      legacyCC.AssetManager = AssetManager;

      var ImageFmts = ['.png', '.jpg', '.bmp', '.jpeg', '.gif', '.ico', '.tiff', '.webp', '.image', '.pvr', '.pkm', '.astc'];
      var AudioFmts = ['.mp3', '.ogg', '.wav', '.m4a'];

      function GetTrue() {
        return true;
      }

      var md5Pipe = {
        transformURL: function transformURL(url) {
          var uuid = getUuidFromURL(url);

          if (!uuid) {
            return url;
          }

          var bundle = bundles.find(function (b) {
            return !!b.getAssetInfo(uuid);
          });

          if (!bundle) {
            return url;
          }

          var hashValue = '';
          var info = bundle.getAssetInfo(uuid);

          if (url.startsWith(bundle.base + bundle.config.nativeBase)) {
            hashValue = info.nativeVer || '';
          } else {
            hashValue = info.ver || '';
          }

          if (!hashValue || url.indexOf(hashValue) !== -1) {
            return url;
          }

          var hashPatchInFolder = false;

          if (extname(url) === '.ttf') {
            hashPatchInFolder = true;
          }

          if (hashPatchInFolder) {
            var dirname$1 = dirname(url);
            var basename$1 = basename(url);
            url = dirname$1 + "." + hashValue + "/" + basename$1;
          } else {
            url = url.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,})/, function (match, uuid) {
              return match + "." + hashValue;
            });
          }

          return url;
        }
      };
      var CCLoader = exports('CCLoader', function () {
        function CCLoader() {
          this._autoReleaseSetting = Object.create(null);
          this._parseLoadResArgs = parseLoadResArgs;
        }

        var _proto = CCLoader.prototype;

        _proto.load = function load(res, progressCallback, completeCallback) {
          if (completeCallback === undefined) {
            if (progressCallback !== undefined) {
              completeCallback = progressCallback;
              progressCallback = null;
            }
          }

          var requests = Array.isArray(res) ? res : [res];

          for (var i = 0; i < requests.length; i++) {
            var _item = requests[i];

            if (typeof _item === 'string') {
              requests[i] = {
                url: _item,
                __isNative__: true
              };
            } else {
              if (_item.type) {
                _item.ext = "." + _item.type;
                _item.type = undefined;
              }

              if (_item.url) {
                _item.__isNative__ = true;
              }
            }
          }

          var images = [];
          var audios = [];
          assetManager.loadAny(requests, null, function (finish, total, item) {
            if (item.content) {
              if (ImageFmts.includes(item.ext)) {
                images.push(item.content);
              } else if (AudioFmts.includes(item.ext)) {
                audios.push(item.content);
              }
            }

            if (progressCallback) {
              progressCallback(finish, total, item);
            }
          }, function (err, _native) {
            var out = null;

            if (!err) {
              _native = Array.isArray(_native) ? _native : [_native];

              var _loop = function _loop(_i) {
                var item = _native[_i];

                if (!(item instanceof Asset)) {
                  var _asset = item;
                  var _url = requests[_i].url;

                  if (images.includes(_asset)) {
                    factory.create(_url, item, '.png', {}, function (err, image) {
                      _asset = _native[_i] = image;
                    });
                  } else if (audios.includes(_asset)) {
                    factory.create(_url, item, '.mp3', {}, function (err, audio) {
                      _asset = _native[_i] = audio;
                    });
                  }

                  assets.add(_url, _asset);
                }
              };

              for (var _i = 0; _i < _native.length; _i++) {
                _loop(_i);
              }

              if (_native.length > 1) {
                var map = Object.create(null);

                _native.forEach(function (asset) {
                  map[asset._uuid] = asset;
                });

                out = {
                  isCompleted: GetTrue,
                  _map: map
                };
              } else {
                out = _native[0];
              }
            }

            if (completeCallback) {
              completeCallback(err, out);
            }
          });
        };

        _proto.getXMLHttpRequest = function getXMLHttpRequest() {
          return new XMLHttpRequest();
        };

        _proto.getItem = function getItem(id) {
          return assetManager.assets.has(id) ? {
            content: assetManager.assets.get(id)
          } : null;
        };

        _proto.loadRes = function loadRes(url, type, progressCallback, completeCallback) {
          var _this$_parseLoadResAr = this._parseLoadResArgs(type, progressCallback, completeCallback),
              _type = _this$_parseLoadResAr.type,
              onProgress = _this$_parseLoadResAr.onProgress,
              onComplete = _this$_parseLoadResAr.onComplete;

          var extname$1 = extname(url);

          if (extname$1 && !resources.getInfoWithPath(url, _type)) {
            url = url.slice(0, -extname$1.length);
          }

          resources.load(url, _type, onProgress, onComplete);
        };

        _proto.loadResArray = function loadResArray(urls, type, progressCallback, completeCallback) {
          var _this$_parseLoadResAr2 = this._parseLoadResArgs(type, progressCallback, completeCallback),
              _type = _this$_parseLoadResAr2.type,
              onProgress = _this$_parseLoadResAr2.onProgress,
              onComplete = _this$_parseLoadResAr2.onComplete;

          urls.forEach(function (url, i) {
            var extname$1 = extname(url);

            if (extname$1 && !resources.getInfoWithPath(url, _type)) {
              urls[i] = url.slice(0, -extname$1.length);
            }
          });
          resources.load(urls, _type, onProgress, onComplete);
        };

        _proto.loadResDir = function loadResDir(url, type, progressCallback, completeCallback) {
          var _this$_parseLoadResAr3 = this._parseLoadResArgs(type, progressCallback, completeCallback),
              _type = _this$_parseLoadResAr3.type,
              onProgress = _this$_parseLoadResAr3.onProgress,
              onComplete = _this$_parseLoadResAr3.onComplete;

          resources.loadDir(url, _type, onProgress, function (err, out) {
            var urls = [];

            if (!err) {
              var infos = resources.getDirWithPath(url, _type);
              urls = infos.map(function (info) {
                return info.path;
              });
            }

            if (onComplete) {
              onComplete(err, out, urls);
            }
          });
        };

        _proto.getRes = function getRes(url, type) {
          return assets.has(url) ? assets.get(url) : resources.get(url, type);
        };

        _proto.getResCount = function getResCount() {
          return assets.count;
        };

        _proto.getDependsRecursively = function getDependsRecursively(owner) {
          if (!owner) {
            return [];
          }

          var uuid = typeof owner === 'string' ? owner : owner._uuid;
          return dependUtil.getDepsRecursively(uuid).concat([uuid]);
        };

        _proto.addDownloadHandlers = function addDownloadHandlers(extMap) {
          var handler = Object.create(null);

          var _loop2 = function _loop2(_type2) {
            var func = extMap[_type2];

            handler["." + _type2] = function (url, options, onComplete) {
              func({
                url: url
              }, onComplete);
            };
          };

          for (var _type2 in extMap) {
            _loop2(_type2);
          }

          downloader.register(handler);
        };

        _proto.addLoadHandlers = function addLoadHandlers(extMap) {
          var handler = Object.create(null);

          var _loop3 = function _loop3(_type3) {
            var func = extMap[_type3];

            handler["." + _type3] = function (file, options, onComplete) {
              func({
                content: file
              }, onComplete);
            };
          };

          for (var _type3 in extMap) {
            _loop3(_type3);
          }

          parser.register(handler);
        };

        _proto.release = function release(asset) {
          if (Array.isArray(asset)) {
            for (var i = 0; i < asset.length; i++) {
              var key = asset[i];

              if (typeof key === 'string') {
                key = assets.get(key);
              }

              assetManager.releaseAsset(key);
            }
          } else if (asset) {
            if (typeof asset === 'string') {
              asset = assets.get(asset);
            }

            assetManager.releaseAsset(asset);
          }
        };

        _proto.releaseAsset = function releaseAsset(asset) {
          assetManager.releaseAsset(asset);
        };

        _proto.releaseRes = function releaseRes(res, type) {
          resources.release(res, type);
        };

        _proto.releaseAll = function releaseAll() {
          assetManager.releaseAll();
          assets.clear();
        };

        _proto.removeItem = function removeItem(id) {
          return !!assets.remove(id);
        };

        _proto.setAutoRelease = function setAutoRelease(asset, autoRelease) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }

          this._autoReleaseSetting[asset] = !!autoRelease;
        };

        _proto.setAutoReleaseRecursively = function setAutoReleaseRecursively(asset, autoRelease) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }

          autoRelease = !!autoRelease;
          this._autoReleaseSetting[asset] = autoRelease;
          var depends = dependUtil.getDepsRecursively(asset);

          for (var i = 0; i < depends.length; i++) {
            this._autoReleaseSetting[depends[i]] = autoRelease;
          }
        };

        _proto.isAutoRelease = function isAutoRelease(asset) {
          if (typeof asset === 'object') {
            asset = asset._uuid;
          }

          return !!this._autoReleaseSetting[asset];
        };

        _createClass(CCLoader, [{
          key: "onProgress",
          set: function set(val) {
            setDefaultProgressCallback(val);
          }
        }, {
          key: "_cache",
          get: function get() {
            if (assets instanceof Cache) {
              return assets._map;
            } else {
              var map = {};
              assets.forEach(function (val, key) {
                map[key] = val;
              });
              return map;
            }
          }
        }, {
          key: "md5Pipe",
          get: function get() {
            return md5Pipe;
          }
        }, {
          key: "downloader",
          get: function get() {
            return downloader;
          }
        }, {
          key: "loader",
          get: function get() {
            return assetManager.parser;
          }
        }]);

        return CCLoader;
      }());
      var loader = exports('loader', new CCLoader());
      var AssetLibrary = exports('AssetLibrary', {
        init: function init(options) {
          options.importBase = options.libraryPath;
          options.nativeBase =  options.rawAssetsBase ;
          assetManager.init(options);

          if (options.rawAssets) {
            resources.init({
              base: '',
              deps: [],
              scenes: {},
              redirect: [],
              debug: true,
              packs: {},
              types: [],
              versions: {
                "import": [],
                "native": []
              },
              name: BuiltinBundleName.RESOURCES,
              importBase: options.importBase,
              nativeBase: options.nativeBase,
              paths: options.rawAssets.assets,
              uuids: Object.keys(options.rawAssets.assets),
              extensionMap: {}
            });
          }
        },
        loadAsset: function loadAsset(uuid, callback, options) {
          assetManager.loadAny(uuid, callback);
        }
      });
      var url = exports('url', {});
      replaceProperty(url, 'url', [{
        name: 'normalize',
        target: assetManager.utils,
        targetName: 'assetManager.utils',
        newName: 'normalize'
      }, {
        name: 'raw',
        targetName: 'Asset.prototype',
        newName: 'nativeUrl',
        customFunction: function customFunction(url) {
          if (url.startsWith('resources/')) {
            return transform({
              path: changeExtname(url.substr(10)),
              bundle: BuiltinBundleName.RESOURCES,
              __isNative__: true,
              ext: extname(url)
            });
          }

          return '';
        }
      }]);
      removeProperty(AssetLibrary, 'AssetLibrary', [{
        name: 'getLibUrlNoExt',
        suggest: 'AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use assetManager.utils.getUrlWithUuid instead'
      }, {
        name: 'queryAssetInfo',
        suggest: 'AssetLibrary.queryAssetInfo was removed'
      }]);
      removeProperty(loader, 'loader', [{
        name: 'releaseResDir',
        suggest: 'loader.releaseResDir was removed, please use assetManager.releaseAsset instead'
      }, {
        name: 'flowInDeps',
        suggest: 'loader.flowInDeps was removed'
      }, {
        name: 'assetLoader',
        suggest: 'loader.assetLoader was removed, assetLoader and md5Pipe were merged into assetManager.transformPipeline'
      }]);
      replaceProperty(legacyCC, 'cc', [{
        name: 'loader',
        newName: 'assetManager',
        logTimes: 1,
        customGetter: function customGetter() {
          return loader;
        }
      }, {
        name: 'AssetLibrary',
        newName: 'assetManager',
        logTimes: 1,
        customGetter: function customGetter() {
          return AssetLibrary;
        }
      }, {
        name: 'Pipeline',
        target: AssetManager,
        targetName: 'AssetManager',
        newName: 'Pipeline',
        logTimes: 1
      }, {
        name: 'url',
        targetName: 'assetManager',
        newName: 'utils',
        logTimes: 1,
        customGetter: function customGetter() {
          return url;
        }
      }]);
      removeProperty(legacyCC, 'cc', [{
        name: 'LoadingItems',
        suggest: getError(1400, 'LoadingItems', 'AssetManager.Task')
      }]);
      replaceProperty(macro, 'macro', [{
        name: 'DOWNLOAD_MAX_CONCURRENT',
        target: downloader,
        targetName: 'assetManager.downloader',
        newName: 'maxConcurrency'
      }]);
      replaceProperty(director, 'director', [{
        name: '_getSceneUuid',
        targetName: 'assetManager.main',
        newName: 'getSceneInfo',
        customFunction: function customFunction(sceneName) {
          if (assetManager.main) {
            var _assetManager$main$ge;

            return (_assetManager$main$ge = assetManager.main.getSceneInfo(sceneName)) === null || _assetManager$main$ge === void 0 ? void 0 : _assetManager$main$ge.uuid;
          }

          return '';
        }
      }]);
      replaceProperty(game, 'game', [{
        name: '_sceneInfos',
        targetName: 'assetManager.main',
        newName: 'getSceneInfo',
        customGetter: function customGetter() {
          var scenes = [];

          if (assetManager.main) {
            assetManager.main.config.scenes.forEach(function (val) {
              scenes.push(val);
            });
          }

          return scenes;
        }
      }]);
      var _autoRelease = releaseManager._autoRelease;

      releaseManager._autoRelease = function (oldScene, newScene, persistNodes) {
        _autoRelease.call(releaseManager, oldScene, newScene, persistNodes);

        var releaseSettings = loader._autoReleaseSetting;
        var keys = Object.keys(releaseSettings);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (releaseSettings[key] === true) {
            var _asset2 = assets.get(key);

            if (_asset2) {
              releaseManager.tryRelease(_asset2);
            }
          }
        }
      };

      var _dec$G, _dec2$l, _dec3$g, _dec4$9, _dec5$6, _dec6$4, _class$G, _class2$C, _descriptor$v, _descriptor2$j, _descriptor3$e, _descriptor4$b, _descriptor5$8, _temp$E;
      var EventHandler = exports('EventHandler', (_dec$G = ccclass('cc.ClickEvent'), _dec2$l = type(legacyCC.Node), _dec3$g = tooltip(), _dec4$9 = tooltip(), _dec5$6 = tooltip(), _dec6$4 = tooltip(), _dec$G(_class$G = (_class2$C = (_temp$E = function () {
        function EventHandler() {
          _initializerDefineProperty(this, "target", _descriptor$v, this);

          _initializerDefineProperty(this, "component", _descriptor2$j, this);

          _initializerDefineProperty(this, "_componentId", _descriptor3$e, this);

          _initializerDefineProperty(this, "handler", _descriptor4$b, this);

          _initializerDefineProperty(this, "customEventData", _descriptor5$8, this);
        }

        EventHandler.emitEvents = function emitEvents(events) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          for (var i = 0, l = events.length; i < l; i++) {
            var event = events[i];

            if (!(event instanceof EventHandler)) {
              continue;
            }

            event.emit(args);
          }
        };

        var _proto = EventHandler.prototype;

        _proto.emit = function emit(params) {
          var target = this.target;

          if (!legacyCC.isValid(target)) {
            return;
          }

          this._genCompIdIfNeeded();

          var compType = legacyCC.js._getClassById(this._componentId);

          var comp = target.getComponent(compType);

          if (!legacyCC.isValid(comp)) {
            return;
          }

          var handler = comp[this.handler];

          if (typeof handler !== 'function') {
            return;
          }

          if (this.customEventData != null && this.customEventData !== '') {
            params = params.slice();
            params.push(this.customEventData);
          }

          handler.apply(comp, params);
        };

        _proto._compName2Id = function _compName2Id(compName) {
          var comp = legacyCC.js.getClassByName(compName);
          return legacyCC.js._getClassId(comp);
        };

        _proto._compId2Name = function _compId2Name(compId) {
          var comp = legacyCC.js._getClassById(compId);

          return legacyCC.js.getClassName(comp);
        };

        _proto._genCompIdIfNeeded = function _genCompIdIfNeeded() {
          if (!this._componentId) {
            this._componentName = this.component;
            this.component = '';
          }
        };

        _createClass(EventHandler, [{
          key: "_componentName",
          get: function get() {
            this._genCompIdIfNeeded();

            return this._compId2Name(this._componentId);
          },
          set: function set(value) {
            this._componentId = this._compName2Id(value);
          }
        }]);

        return EventHandler;
      }(), _temp$E), (_descriptor$v = _applyDecoratedDescriptor(_class2$C.prototype, "target", [serializable, _dec2$l, serializable, _dec3$g], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$j = _applyDecoratedDescriptor(_class2$C.prototype, "component", [serializable, editable, _dec4$9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor3$e = _applyDecoratedDescriptor(_class2$C.prototype, "_componentId", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor4$b = _applyDecoratedDescriptor(_class2$C.prototype, "handler", [serializable, editable, _dec5$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$C.prototype, "customEventData", [serializable, editable, _dec6$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      })), _class2$C)) || _class$G));
      legacyCC.Component.EventHandler = EventHandler;

      var _dec$H, _dec2$m, _dec3$h, _dec4$a, _dec5$7, _dec6$5, _dec7$3, _dec8$3, _dec9$3, _dec10$3, _dec11$3, _dec12$3, _dec13$3, _dec14$3, _dec15$3, _dec16$3, _dec17$3, _dec18$3, _dec19$3, _dec20$3, _dec21$3, _dec22$3, _dec23$3, _dec24$3, _dec25$3, _dec26$2, _dec27$2, _dec28$2, _dec29$2, _dec30$2, _dec31$2, _dec32$1, _dec33$1, _dec34$1, _dec35$1, _dec36$1, _dec37$1, _dec38$1, _dec39$1, _dec40$1, _dec41$1, _dec42$1, _dec43$1, _dec44$1, _dec45$1, _dec46$1, _dec47$1, _dec48$1, _class$H, _class2$D, _descriptor$w, _descriptor2$k, _descriptor3$f, _descriptor4$c, _descriptor5$9, _descriptor6$4, _descriptor7$4, _descriptor8$4, _descriptor9$3, _descriptor10$3, _descriptor11$3, _descriptor12$3, _descriptor13$3, _descriptor14$3, _descriptor15$3, _descriptor16$3, _descriptor17$3, _descriptor18$3, _class3$f, _temp$F;

      var _temp_vec3_1 = new Vec3();

      var ProjectionType = Enum(CameraProjection);
      var FOVAxis = Enum(CameraFOVAxis);
      var Aperture = Enum(CameraAperture);
      var Shutter = Enum(CameraShutter);
      var ISO = Enum(CameraISO);
      var ClearFlag = Enum({
        SKYBOX: SKYBOX_FLAG | ClearFlagBit.DEPTH_STENCIL,
        SOLID_COLOR: ClearFlagBit.ALL,
        DEPTH_ONLY: ClearFlagBit.DEPTH_STENCIL,
        DONT_CLEAR: ClearFlagBit.NONE
      });
      var Camera$1 = function (v) { return exports({ Camera: v, CameraComponent: v }), v; }((_dec$H = ccclass('cc.Camera'), _dec2$m = help(), _dec3$h = menu(), _dec4$a = displayOrder(), _dec5$7 = tooltip(), _dec6$5 = type(Layers.BitMask), _dec7$3 = displayOrder(), _dec8$3 = tooltip(), _dec9$3 = type(ClearFlag), _dec10$3 = displayOrder(), _dec11$3 = tooltip(), _dec12$3 = displayOrder(), _dec13$3 = tooltip(), _dec14$3 = displayOrder(), _dec15$3 = tooltip(), _dec16$3 = displayOrder(), _dec17$3 = tooltip(), _dec18$3 = type(ProjectionType), _dec19$3 = displayOrder(), _dec20$3 = tooltip(), _dec21$3 = type(FOVAxis), _dec22$3 = displayOrder(), _dec23$3 = visible(), _dec24$3 = tooltip(), _dec25$3 = displayOrder(), _dec26$2 = visible(), _dec27$2 = tooltip(), _dec28$2 = displayOrder(), _dec29$2 = visible(), _dec30$2 = tooltip(), _dec31$2 = displayOrder(), _dec32$1 = tooltip(), _dec33$1 = displayOrder(), _dec34$1 = tooltip(), _dec35$1 = type(Aperture), _dec36$1 = displayOrder(), _dec37$1 = tooltip(), _dec38$1 = type(Shutter), _dec39$1 = displayOrder(), _dec40$1 = tooltip(), _dec41$1 = type(ISO), _dec42$1 = displayOrder(), _dec43$1 = tooltip(), _dec44$1 = displayOrder(), _dec45$1 = tooltip(), _dec46$1 = type(RenderTexture), _dec47$1 = displayOrder(), _dec48$1 = tooltip(), _dec$H(_class$H = _dec2$m(_class$H = _dec3$h(_class$H = executeInEditMode(_class$H = (_class2$D = (_temp$F = _class3$f = function (_Component) {
        _inheritsLoose(Camera, _Component);

        function Camera() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_projection", _descriptor$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_priority", _descriptor2$k, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fov", _descriptor3$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fovAxis", _descriptor4$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_orthoHeight", _descriptor5$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_near", _descriptor6$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_far", _descriptor7$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_color", _descriptor8$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_depth", _descriptor9$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_stencil", _descriptor10$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_clearFlags", _descriptor11$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_rect", _descriptor12$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_aperture", _descriptor13$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_shutter", _descriptor14$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_iso", _descriptor15$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_screenScale", _descriptor16$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_visibility", _descriptor17$3, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_targetTexture", _descriptor18$3, _assertThisInitialized(_this));

          _this._camera = null;
          _this._inEditorMode = false;
          _this._flows = undefined;
          return _this;
        }

        var _proto = Camera.prototype;

        _proto.onLoad = function onLoad() {
          this._createCamera();
        };

        _proto.onEnable = function onEnable() {
          this.node.hasChangedFlags |= TransformBit.POSITION;

          if (this._camera) {
            this._attachToScene();
          }
        };

        _proto.onDisable = function onDisable() {
          if (this._camera) {
            this._detachFromScene();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this._camera) {
            this._camera.destroy();

            this._camera = null;
          }

          if (this._targetTexture) {
            this._targetTexture.off('resize');
          }
        };

        _proto.screenPointToRay = function screenPointToRay(x, y, out) {
          if (!out) {
            out = Ray.create();
          }

          if (this._camera) {
            this._camera.screenPointToRay(out, x, y);
          }

          return out;
        };

        _proto.worldToScreen = function worldToScreen(worldPos, out) {
          if (!out) {
            out = new Vec3();
          }

          if (this._camera) {
            this._camera.worldToScreen(out, worldPos);
          }

          return out;
        };

        _proto.screenToWorld = function screenToWorld(screenPos, out) {
          if (!out) {
            out = this.node.getWorldPosition();
          }

          if (this._camera) {
            this._camera.screenToWorld(out, screenPos);
          }

          return out;
        };

        _proto.convertToUINode = function convertToUINode(wpos, uiNode, out) {
          if (!out) {
            out = new Vec3();
          }

          if (!this._camera) {
            return out;
          }

          this.worldToScreen(wpos, _temp_vec3_1);
          var cmp = uiNode.getComponent('cc.UITransform');
          var designSize = view.getVisibleSize();
          var xoffset = _temp_vec3_1.x - this._camera.width * 0.5;
          var yoffset = _temp_vec3_1.y - this._camera.height * 0.5;
          _temp_vec3_1.x = xoffset / legacyCC.view.getScaleX() + designSize.width * 0.5;
          _temp_vec3_1.y = yoffset / legacyCC.view.getScaleY() + designSize.height * 0.5;

          if (cmp) {
            cmp.convertToNodeSpaceAR(_temp_vec3_1, out);
          }

          return out;
        };

        _proto._createCamera = function _createCamera() {
          if (!this._camera) {
            this._camera = legacyCC.director.root.createCamera();

            this._camera.initialize({
              name: this.node.name,
              node: this.node,
              projection: this._projection,
              window: this._inEditorMode ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow,
              priority: this._priority
            });

            this._camera.setViewportInOrientedSpace(this._rect);

            this._camera.fovAxis = this._fovAxis;
            this._camera.fov = toRadian(this._fov);
            this._camera.orthoHeight = this._orthoHeight;
            this._camera.nearClip = this._near;
            this._camera.farClip = this._far;
            this._camera.clearColor = this._color;
            this._camera.clearDepth = this._depth;
            this._camera.clearStencil = this._stencil;
            this._camera.clearFlag = this._clearFlags;
            this._camera.visibility = this._visibility;
            this._camera.aperture = this._aperture;
            this._camera.shutter = this._shutter;
            this._camera.iso = this._iso;
          }

          this._updateTargetTexture();
        };

        _proto._attachToScene = function _attachToScene() {
          if (!this.node.scene || !this._camera) {
            return;
          }

          if (this._camera && this._camera.scene) {
            this._camera.scene.removeCamera(this._camera);
          }

          var rs = this._getRenderScene();

          rs.addCamera(this._camera);
        };

        _proto._detachFromScene = function _detachFromScene() {
          if (this._camera && this._camera.scene) {
            this._camera.scene.removeCamera(this._camera);
          }
        };

        _proto._checkTargetTextureEvent = function _checkTargetTextureEvent(old) {
          var _this2 = this;

          if (old) {
            old.off('resize');
          }

          if (this._targetTexture) {
            this._targetTexture.on('resize', function (window) {
              if (_this2._camera) {
                _this2._camera.setFixedSize(window.width, window.height);
              }
            }, this);
          }
        };

        _proto._updateTargetTexture = function _updateTargetTexture() {
          if (!this._camera) {
            return;
          }

          if (this._targetTexture) {
            var window = this._targetTexture.window;

            this._camera.changeTargetWindow(window);

            this._camera.setFixedSize(window.width, window.height);
          }
        };

        _createClass(Camera, [{
          key: "camera",
          get: function get() {
            return this._camera;
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(val) {
            this._priority = val;

            if (this._camera) {
              this._camera.priority = val;
            }
          }
        }, {
          key: "visibility",
          get: function get() {
            return this._visibility;
          },
          set: function set(val) {
            this._visibility = val;

            if (this._camera) {
              this._camera.visibility = val;
            }
          }
        }, {
          key: "clearFlags",
          get: function get() {
            return this._clearFlags;
          },
          set: function set(val) {
            this._clearFlags = val;

            if (this._camera) {
              this._camera.clearFlag = val;
            }
          }
        }, {
          key: "clearColor",
          get: function get() {
            return this._color;
          },
          set: function set(val) {
            this._color.set(val);

            if (this._camera) {
              this._camera.clearColor = this._color;
            }
          }
        }, {
          key: "clearDepth",
          get: function get() {
            return this._depth;
          },
          set: function set(val) {
            this._depth = val;

            if (this._camera) {
              this._camera.clearDepth = val;
            }
          }
        }, {
          key: "clearStencil",
          get: function get() {
            return this._stencil;
          },
          set: function set(val) {
            this._stencil = val;

            if (this._camera) {
              this._camera.clearStencil = val;
            }
          }
        }, {
          key: "projection",
          get: function get() {
            return this._projection;
          },
          set: function set(val) {
            this._projection = val;

            if (this._camera) {
              this._camera.projectionType = val;
            }
          }
        }, {
          key: "fovAxis",
          get: function get() {
            return this._fovAxis;
          },
          set: function set(val) {
            if (val === this._fovAxis) {
              return;
            }

            this._fovAxis = val;

            if (this._camera) {
              this._camera.fovAxis = val;

              if (val === CameraFOVAxis.VERTICAL) {
                this.fov = this._fov * this._camera.aspect;
              } else {
                this.fov = this._fov / this._camera.aspect;
              }
            }
          }
        }, {
          key: "fov",
          get: function get() {
            return this._fov;
          },
          set: function set(val) {
            this._fov = val;

            if (this._camera) {
              this._camera.fov = toRadian(val);
            }
          }
        }, {
          key: "orthoHeight",
          get: function get() {
            return this._orthoHeight;
          },
          set: function set(val) {
            this._orthoHeight = val;

            if (this._camera) {
              this._camera.orthoHeight = val;
            }
          }
        }, {
          key: "near",
          get: function get() {
            return this._near;
          },
          set: function set(val) {
            this._near = val;

            if (this._camera) {
              this._camera.nearClip = val;
            }
          }
        }, {
          key: "far",
          get: function get() {
            return this._far;
          },
          set: function set(val) {
            this._far = val;

            if (this._camera) {
              this._camera.farClip = val;
            }
          }
        }, {
          key: "aperture",
          get: function get() {
            return this._aperture;
          },
          set: function set(val) {
            this._aperture = val;

            if (this._camera) {
              this._camera.aperture = val;
            }
          }
        }, {
          key: "shutter",
          get: function get() {
            return this._shutter;
          },
          set: function set(val) {
            this._shutter = val;

            if (this._camera) {
              this._camera.shutter = val;
            }
          }
        }, {
          key: "iso",
          get: function get() {
            return this._iso;
          },
          set: function set(val) {
            this._iso = val;

            if (this._camera) {
              this._camera.iso = val;
            }
          }
        }, {
          key: "rect",
          get: function get() {
            return this._rect;
          },
          set: function set(val) {
            this._rect = val;

            if (this._camera) {
              this._camera.setViewportInOrientedSpace(val);
            }
          }
        }, {
          key: "targetTexture",
          get: function get() {
            return this._targetTexture;
          },
          set: function set(value) {
            if (this._targetTexture === value) {
              return;
            }

            var old = this._targetTexture;
            this._targetTexture = value;

            this._checkTargetTextureEvent(old);

            this._updateTargetTexture();

            if (!value && this._camera) {
              this._camera.changeTargetWindow( null);

              this._camera.isWindowSize = true;
            }

            this.node.emit(Camera.TARGET_TEXTURE_CHANGE, this);
          }
        }, {
          key: "screenScale",
          get: function get() {
            return this._screenScale;
          },
          set: function set(val) {
            this._screenScale = val;

            if (this._camera) {
              this._camera.screenScale = val;
            }
          }
        }, {
          key: "inEditorMode",
          get: function get() {
            return this._inEditorMode;
          },
          set: function set(value) {
            this._inEditorMode = value;

            if (this._camera) {
              this._camera.changeTargetWindow(value ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow);
            }
          }
        }]);

        return Camera;
      }(Component), _class3$f.ProjectionType = ProjectionType, _class3$f.FOVAxis = FOVAxis, _class3$f.ClearFlag = ClearFlag, _class3$f.Aperture = Aperture, _class3$f.Shutter = Shutter, _class3$f.ISO = ISO, _class3$f.TARGET_TEXTURE_CHANGE = 'tex-change', _temp$F), (_descriptor$w = _applyDecoratedDescriptor(_class2$D.prototype, "_projection", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ProjectionType.PERSPECTIVE;
        }
      }), _descriptor2$k = _applyDecoratedDescriptor(_class2$D.prototype, "_priority", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor3$f = _applyDecoratedDescriptor(_class2$D.prototype, "_fov", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 45;
        }
      }), _descriptor4$c = _applyDecoratedDescriptor(_class2$D.prototype, "_fovAxis", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return FOVAxis.VERTICAL;
        }
      }), _descriptor5$9 = _applyDecoratedDescriptor(_class2$D.prototype, "_orthoHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      }), _descriptor6$4 = _applyDecoratedDescriptor(_class2$D.prototype, "_near", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor7$4 = _applyDecoratedDescriptor(_class2$D.prototype, "_far", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1000;
        }
      }), _descriptor8$4 = _applyDecoratedDescriptor(_class2$D.prototype, "_color", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color('#333333');
        }
      }), _descriptor9$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_depth", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor10$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_stencil", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor11$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_clearFlags", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ClearFlag.SOLID_COLOR;
        }
      }), _descriptor12$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_rect", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Rect(0, 0, 1, 1);
        }
      }), _descriptor13$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_aperture", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Aperture.F16_0;
        }
      }), _descriptor14$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_shutter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Shutter.D125;
        }
      }), _descriptor15$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_iso", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ISO.ISO100;
        }
      }), _descriptor16$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_screenScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor17$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_visibility", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return CAMERA_DEFAULT_MASK;
        }
      }), _descriptor18$3 = _applyDecoratedDescriptor(_class2$D.prototype, "_targetTexture", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$D.prototype, "priority", [_dec4$a, _dec5$7], Object.getOwnPropertyDescriptor(_class2$D.prototype, "priority"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "visibility", [_dec6$5, _dec7$3, _dec8$3], Object.getOwnPropertyDescriptor(_class2$D.prototype, "visibility"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "clearFlags", [_dec9$3, _dec10$3, _dec11$3], Object.getOwnPropertyDescriptor(_class2$D.prototype, "clearFlags"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "clearColor", [_dec12$3, _dec13$3], Object.getOwnPropertyDescriptor(_class2$D.prototype, "clearColor"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "clearDepth", [_dec14$3, _dec15$3], Object.getOwnPropertyDescriptor(_class2$D.prototype, "clearDepth"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "clearStencil", [_dec16$3, _dec17$3], Object.getOwnPropertyDescriptor(_class2$D.prototype, "clearStencil"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "projection", [_dec18$3, _dec19$3, _dec20$3], Object.getOwnPropertyDescriptor(_class2$D.prototype, "projection"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "fovAxis", [_dec21$3, _dec22$3, _dec23$3, _dec24$3], Object.getOwnPropertyDescriptor(_class2$D.prototype, "fovAxis"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "fov", [_dec25$3, _dec26$2, _dec27$2], Object.getOwnPropertyDescriptor(_class2$D.prototype, "fov"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "orthoHeight", [_dec28$2, _dec29$2, _dec30$2], Object.getOwnPropertyDescriptor(_class2$D.prototype, "orthoHeight"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "near", [_dec31$2, _dec32$1], Object.getOwnPropertyDescriptor(_class2$D.prototype, "near"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "far", [_dec33$1, _dec34$1], Object.getOwnPropertyDescriptor(_class2$D.prototype, "far"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "aperture", [_dec35$1, _dec36$1, _dec37$1], Object.getOwnPropertyDescriptor(_class2$D.prototype, "aperture"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "shutter", [_dec38$1, _dec39$1, _dec40$1], Object.getOwnPropertyDescriptor(_class2$D.prototype, "shutter"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "iso", [_dec41$1, _dec42$1, _dec43$1], Object.getOwnPropertyDescriptor(_class2$D.prototype, "iso"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "rect", [_dec44$1, _dec45$1], Object.getOwnPropertyDescriptor(_class2$D.prototype, "rect"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "targetTexture", [_dec46$1, _dec47$1, _dec48$1], Object.getOwnPropertyDescriptor(_class2$D.prototype, "targetTexture"), _class2$D.prototype)), _class2$D)) || _class$H) || _class$H) || _class$H) || _class$H));
      legacyCC.Camera = Camera$1;

      var _dec$I, _dec2$n, _dec3$i, _dec4$b, _dec5$8, _class$I, _class2$E, _descriptor$x, _descriptor2$l, _temp$G;
      var _matInsInfo = {
        parent: null,
        owner: null,
        subModelIdx: 0
      };
      var RenderableComponent = exports('RenderableComponent', (_dec$I = ccclass('cc.RenderableComponent'), _dec2$n = type(Material), _dec3$i = displayOrder(), _dec4$b = displayName(), _dec5$8 = type([Material]), _dec$I(_class$I = (_class2$E = (_temp$G = function (_Component) {
        _inheritsLoose(RenderableComponent, _Component);

        function RenderableComponent() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_visFlags", _descriptor$x, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_materials", _descriptor2$l, _assertThisInitialized(_this));

          _this._materialInstances = [];
          _this._models = [];
          return _this;
        }

        var _proto = RenderableComponent.prototype;

        _proto.getMaterial = function getMaterial(idx) {
          if (idx < 0 || idx >= this._materials.length) {
            return null;
          }

          return this._materials[idx];
        };

        _proto.setMaterial = function setMaterial(material, index) {
          if (material && material instanceof MaterialInstance) {
            console.error('Can\'t set a material instance to a sharedMaterial slot');
          }

          this._materials[index] = material;
          var inst = this._materialInstances[index];

          if (inst) {
            inst.destroy();
            this._materialInstances[index] = null;
          }

          this._onMaterialModified(index, this._materials[index]);
        };

        _proto.getMaterialInstance = function getMaterialInstance(idx) {
          var mat = this._materials[idx];

          if (!mat) {
            return null;
          }

          if (!this._materialInstances[idx]) {
            _matInsInfo.parent = this._materials[idx];
            _matInsInfo.owner = this;
            _matInsInfo.subModelIdx = idx;
            var instantiated = new MaterialInstance(_matInsInfo);
            _matInsInfo.parent = null;
            _matInsInfo.owner = null;
            _matInsInfo.subModelIdx = 0;
            this.setMaterialInstance(instantiated, idx);
          }

          return this._materialInstances[idx];
        };

        _proto.setMaterialInstance = function setMaterialInstance(matInst, index) {
          if (typeof matInst === 'number') {
            warnID(12007);
            var temp = matInst;
            matInst = index;
            index = temp;
          }

          var curInst = this._materialInstances[index];

          if (matInst && matInst.parent) {
            if (matInst !== curInst) {
              this._materialInstances[index] = matInst;

              this._onMaterialModified(index, matInst);
            }

            return;
          }

          if (matInst !== this._materials[index] || curInst) {
            this.setMaterial(matInst, index);
          }
        };

        _proto.getRenderMaterial = function getRenderMaterial(index) {
          return this._materialInstances[index] || this._materials[index];
        };

        _proto._collectModels = function _collectModels() {
          return this._models;
        };

        _proto._attachToScene = function _attachToScene() {};

        _proto._detachFromScene = function _detachFromScene() {};

        _proto._onMaterialModified = function _onMaterialModified(index, material) {};

        _proto._onRebuildPSO = function _onRebuildPSO(index, material) {};

        _proto._clearMaterials = function _clearMaterials() {};

        _proto._onVisibilityChange = function _onVisibilityChange(val) {};

        _createClass(RenderableComponent, [{
          key: "visibility",
          get: function get() {
            return this._visFlags;
          },
          set: function set(val) {
            this._visFlags = val;

            this._onVisibilityChange(val);
          }
        }, {
          key: "sharedMaterial",
          get: function get() {
            return this.getMaterial(0);
          }
        }, {
          key: "sharedMaterials",
          get: function get() {
            return  this._materials;
          },
          set: function set(val) {
            for (var i = 0; i < val.length; i++) {
              if (val[i] !== this._materials[i]) {
                this.setMaterial(val[i], i);
              }
            }

            if (val.length < this._materials.length) {
              for (var _i = val.length; _i < this._materials.length; _i++) {
                this.setMaterial(null, _i);
              }

              this._materials.splice(val.length);
            }
          }
        }, {
          key: "material",
          get: function get() {
            return this.getMaterialInstance(0);
          },
          set: function set(val) {
            if (this._materials.length === 1 && !this._materialInstances[0] && this._materials[0] === val) {
              return;
            }

            this.setMaterialInstance(val, 0);
          }
        }, {
          key: "materials",
          get: function get() {
            for (var i = 0; i < this._materials.length; i++) {
              this._materialInstances[i] = this.getMaterialInstance(i);
            }

            return this._materialInstances;
          },
          set: function set(val) {
            var newLength = val.length;
            var oldLength = this._materials.length;

            for (var i = newLength; i < oldLength; i++) {
              this.setMaterialInstance(null, i);
            }

            this._materials.length = newLength;
            this._materialInstances.length = newLength;

            for (var _i2 = 0; _i2 < newLength; _i2++) {
              if (this._materialInstances[_i2] != val[_i2]) {
                this.setMaterialInstance(val[_i2], _i2);
              }
            }
          }
        }]);

        return RenderableComponent;
      }(Component), _temp$G), (_applyDecoratedDescriptor(_class2$E.prototype, "sharedMaterials", [_dec2$n, _dec3$i, _dec4$b], Object.getOwnPropertyDescriptor(_class2$E.prototype, "sharedMaterials"), _class2$E.prototype), _descriptor$x = _applyDecoratedDescriptor(_class2$E.prototype, "_visFlags", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Layers.Enum.NONE;
        }
      }), _descriptor2$l = _applyDecoratedDescriptor(_class2$E.prototype, "_materials", [_dec5$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$E)) || _class$I));
      legacyCC.RenderableComponent = RenderableComponent;

      replaceProperty(Camera$1, 'Camera', [{
        name: 'CameraClearFlag',
        newName: 'ClearFlag'
      }]);
      replaceProperty(Camera$1.prototype, 'Camera.prototype', [{
        name: 'color',
        newName: 'clearColor'
      }, {
        name: 'depth',
        newName: 'clearDepth'
      }, {
        name: 'stencil',
        newName: 'clearStencil'
      }]);
      legacyCC.CameraComponent = Camera$1;
      js.setClassAlias(Camera$1, 'cc.CameraComponent');

      legacyCC.math = math;
      legacyCC.geometry = geometry;

      var AudioEvent;

      (function (AudioEvent) {
        AudioEvent["PLAYED"] = "play";
        AudioEvent["PAUSED"] = "pause";
        AudioEvent["STOPPED"] = "stop";
        AudioEvent["SEEKED"] = "seeked";
        AudioEvent["ENDED"] = "ended";
        AudioEvent["INTERRUPTION_BEGIN"] = "interruptionBegin";
        AudioEvent["INTERRUPTION_END"] = "interruptionEnd";
        AudioEvent["USER_GESTURE"] = "on_gesture";
      })(AudioEvent || (AudioEvent = {}));

      var AudioType;

      (function (AudioType) {
        AudioType[AudioType["DOM_AUDIO"] = 0] = "DOM_AUDIO";
        AudioType[AudioType["WEB_AUDIO"] = 1] = "WEB_AUDIO";
        AudioType[AudioType["MINIGAME_AUDIO"] = 2] = "MINIGAME_AUDIO";
        AudioType[AudioType["NATIVE_AUDIO"] = 3] = "NATIVE_AUDIO";
        AudioType[AudioType["UNKNOWN_AUDIO"] = 4] = "UNKNOWN_AUDIO";
      })(AudioType || (AudioType = {}));

      var AudioState;

      (function (AudioState) {
        AudioState[AudioState["INIT"] = 0] = "INIT";
        AudioState[AudioState["PLAYING"] = 1] = "PLAYING";
        AudioState[AudioState["PAUSED"] = 2] = "PAUSED";
        AudioState[AudioState["STOPPED"] = 3] = "STOPPED";
        AudioState[AudioState["INTERRUPTED"] = 4] = "INTERRUPTED";
      })(AudioState || (AudioState = {}));

      var operationId = 0;

      function _tryCallingRecursively(target, opInfo) {
        var _opInfo$func;

        if (opInfo.invoking) {
          return;
        }

        opInfo.invoking = true;

        (_opInfo$func = opInfo.func).call.apply(_opInfo$func, [target].concat(opInfo.args)).then(function () {
          opInfo.invoking = false;

          target._operationQueue.shift();

          target._eventTarget.emit(opInfo.id.toString());

          var nextOpInfo = target._operationQueue[0];
          nextOpInfo && _tryCallingRecursively(target, nextOpInfo);
        })["catch"](function (e) {});
      }

      function enqueueOperation(target, propertyKey, descriptor) {
        var originalOperation = descriptor.value;

        descriptor.value = function () {
          var _this = this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return new Promise(function (resolve) {
            var id = operationId++;
            var instance = _this;

            instance._operationQueue.push({
              id: id,
              func: originalOperation,
              args: args,
              invoking: false
            });

            instance._eventTarget.once(id.toString(), resolve);

            var opInfo = instance._operationQueue[0];

            _tryCallingRecursively(instance, opInfo);
          });
        };
      }

      var _class$J, _temp$H;

      function ensurePlaying(domAudio) {
        return new Promise(function (resolve) {
          var promise = domAudio.play();

          if (promise === undefined) {
            return resolve();
          }

          promise.then(resolve)["catch"](function () {
            var onGesture = function onGesture() {
              domAudio.play()["catch"](function (e) {});
              resolve();
            };

            var canvas = document.getElementById('GameCanvas');
            canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('touchend', onGesture, {
              once: true
            });
            canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('mousedown', onGesture, {
              once: true
            });
          });
          return null;
        });
      }

      var OneShotAudioDOM = function () {
        function OneShotAudioDOM(nativeAudio, volume) {
          this._domAudio = void 0;
          this._onPlayCb = void 0;
          this._onEndCb = void 0;
          this._domAudio = nativeAudio;
          nativeAudio.volume = volume;
        }

        var _proto = OneShotAudioDOM.prototype;

        _proto.play = function play() {
          var _this = this;

          ensurePlaying(this._domAudio).then(function () {
            var _this$onPlay;

            (_this$onPlay = _this.onPlay) === null || _this$onPlay === void 0 ? void 0 : _this$onPlay.call(_this);
          })["catch"](function (e) {});
        };

        _proto.stop = function stop() {
          this._domAudio.pause();
        };

        _createClass(OneShotAudioDOM, [{
          key: "onPlay",
          get: function get() {
            return this._onPlayCb;
          },
          set: function set(cb) {
            this._onPlayCb = cb;
          }
        }, {
          key: "onEnd",
          get: function get() {
            return this._onEndCb;
          },
          set: function set(cb) {
            if (this._onEndCb) {
              this._domAudio.removeEventListener('ended', this._onEndCb);
            }

            this._onEndCb = cb;

            if (cb) {
              this._domAudio.addEventListener('ended', cb);
            }
          }
        }]);

        return OneShotAudioDOM;
      }();
      var AudioPlayerDOM = (_class$J = (_temp$H = function () {
        function AudioPlayerDOM(nativeAudio) {
          var _this2 = this;

          this._domAudio = void 0;
          this._state = AudioState.INIT;
          this._onEnded = void 0;
          this._eventTarget = new EventTarget();
          this._operationQueue = [];
          this._domAudio = nativeAudio;
          systemInfo.on('hide', this._onHide, this);
          systemInfo.on('show', this._onShow, this);

          this._onEnded = function () {
            _this2.seek(0)["catch"](function (e) {});

            _this2._state = AudioState.INIT;

            _this2._eventTarget.emit(AudioEvent.ENDED);
          };

          this._domAudio.addEventListener('ended', this._onEnded);
        }

        var _proto2 = AudioPlayerDOM.prototype;

        _proto2.destroy = function destroy() {
          systemInfo.off('hide', this._onHide, this);
          systemInfo.off('show', this._onShow, this);

          this._domAudio.removeEventListener('ended', this._onEnded);

          this._domAudio = null;
        };

        AudioPlayerDOM.load = function load(url) {
          return new Promise(function (resolve) {
            AudioPlayerDOM.loadNative(url).then(function (domAudio) {
              resolve(new AudioPlayerDOM(domAudio));
            })["catch"](function (e) {});
          });
        };

        AudioPlayerDOM.loadNative = function loadNative(url) {
          return new Promise(function (resolve, reject) {
            var domAudio = document.createElement('audio');
            var loadedEvent = 'canplaythrough';

            if (systemInfo.os === OS.IOS) {
              loadedEvent = 'loadedmetadata';
            } else if (systemInfo.browserType === BrowserType.FIREFOX) {
              loadedEvent = 'canplay';
            }

            var timer = setTimeout(function () {
              if (domAudio.readyState === 0) {
                failure();
              } else {
                success();
              }
            }, 8000);

            var clearEvent = function clearEvent() {
              clearTimeout(timer);
              domAudio.removeEventListener(loadedEvent, success, false);
              domAudio.removeEventListener('error', failure, false);
            };

            var success = function success() {
              clearEvent();
              resolve(domAudio);
            };

            var failure = function failure() {
              clearEvent();
              var message = "load audio failure - " + url;
              reject(message);
            };

            domAudio.addEventListener(loadedEvent, success, false);
            domAudio.addEventListener('error', failure, false);
            domAudio.src = url;
          });
        };

        AudioPlayerDOM.loadOneShotAudio = function loadOneShotAudio(url, volume) {
          return new Promise(function (resolve, reject) {
            AudioPlayerDOM.loadNative(url).then(function (domAudio) {
              var oneShotAudio = new OneShotAudioDOM(domAudio, volume);
              resolve(oneShotAudio);
            })["catch"](reject);
          });
        };

        _proto2._onHide = function _onHide() {
          var _this3 = this;

          if (this._state === AudioState.PLAYING) {
            this.pause().then(function () {
              _this3._state = AudioState.INTERRUPTED;

              _this3._eventTarget.emit(AudioEvent.INTERRUPTION_BEGIN);
            })["catch"](function (e) {});
          }
        };

        _proto2._onShow = function _onShow() {
          var _this4 = this;

          if (this._state === AudioState.INTERRUPTED) {
            this.play().then(function () {
              _this4._eventTarget.emit(AudioEvent.INTERRUPTION_END);
            })["catch"](function (e) {});
          }
        };

        _proto2.seek = function seek(time) {
          time = clamp(time, 0, this.duration);
          this._domAudio.currentTime = time;
          return Promise.resolve();
        };

        _proto2.play = function play() {
          var _this5 = this;

          return new Promise(function (resolve) {
            ensurePlaying(_this5._domAudio).then(function () {
              _this5._state = AudioState.PLAYING;
              resolve();
            })["catch"](function (e) {});
          });
        };

        _proto2.pause = function pause() {
          this._domAudio.pause();

          this._state = AudioState.PAUSED;
          return Promise.resolve();
        };

        _proto2.stop = function stop() {
          var _this6 = this;

          return new Promise(function (resolve) {
            _this6._domAudio.pause();

            _this6._domAudio.currentTime = 0;
            _this6._state = AudioState.STOPPED;
            resolve();
          });
        };

        _proto2.onInterruptionBegin = function onInterruptionBegin(cb) {
          this._eventTarget.on(AudioEvent.INTERRUPTION_BEGIN, cb);
        };

        _proto2.offInterruptionBegin = function offInterruptionBegin(cb) {
          this._eventTarget.off(AudioEvent.INTERRUPTION_BEGIN, cb);
        };

        _proto2.onInterruptionEnd = function onInterruptionEnd(cb) {
          this._eventTarget.on(AudioEvent.INTERRUPTION_END, cb);
        };

        _proto2.offInterruptionEnd = function offInterruptionEnd(cb) {
          this._eventTarget.off(AudioEvent.INTERRUPTION_END, cb);
        };

        _proto2.onEnded = function onEnded(cb) {
          this._eventTarget.on(AudioEvent.ENDED, cb);
        };

        _proto2.offEnded = function offEnded(cb) {
          this._eventTarget.off(AudioEvent.ENDED, cb);
        };

        _createClass(AudioPlayerDOM, [{
          key: "src",
          get: function get() {
            return this._domAudio ? this._domAudio.src : '';
          }
        }, {
          key: "type",
          get: function get() {
            return AudioType.DOM_AUDIO;
          }
        }, {
          key: "state",
          get: function get() {
            return this._state;
          }
        }, {
          key: "loop",
          get: function get() {
            return this._domAudio.loop;
          },
          set: function set(val) {
            this._domAudio.loop = val;
          }
        }, {
          key: "volume",
          get: function get() {
            return this._domAudio.volume;
          },
          set: function set(val) {
            val = clamp01(val);
            this._domAudio.volume = val;
          }
        }, {
          key: "duration",
          get: function get() {
            return this._domAudio.duration;
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._domAudio.currentTime;
          }
        }]);

        return AudioPlayerDOM;
      }(), _temp$H), (_applyDecoratedDescriptor(_class$J.prototype, "seek", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$J.prototype, "seek"), _class$J.prototype), _applyDecoratedDescriptor(_class$J.prototype, "play", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$J.prototype, "play"), _class$J.prototype), _applyDecoratedDescriptor(_class$J.prototype, "pause", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$J.prototype, "pause"), _class$J.prototype), _applyDecoratedDescriptor(_class$J.prototype, "stop", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$J.prototype, "stop"), _class$J.prototype)), _class$J);

      var AudioTimer = function () {
        function AudioTimer(nativeAudio) {
          this._nativeAudio = void 0;
          this._startTime = 0;
          this._startOffset = 0;
          this._isPaused = true;
          this._nativeAudio = nativeAudio;
        }

        var _proto = AudioTimer.prototype;

        _proto.destroy = function destroy() {
          this._nativeAudio = undefined;
        };

        _proto._now = function _now() {
          return performance.now() / 1000;
        };

        _proto._calculateCurrentTime = function _calculateCurrentTime() {
          var timePassed = this._now() - this._startTime;

          var currentTime = this._startOffset + timePassed;

          if (currentTime >= this.duration) {
            this._startTime = this._now();
            this._startOffset = 0;
          }

          return currentTime % this.duration;
        };

        _proto.start = function start() {
          this._isPaused = false;
          this._startTime = this._now();
        };

        _proto.pause = function pause() {
          if (this._isPaused) {
            return;
          }

          this._isPaused = true;
          this._startOffset = this._calculateCurrentTime();
        };

        _proto.stop = function stop() {
          this._isPaused = true;
          this._startOffset = 0;
        };

        _proto.seek = function seek(time) {
          this._startTime = this._now();
          this._startOffset = clamp(time, 0, this.duration);
        };

        _createClass(AudioTimer, [{
          key: "duration",
          get: function get() {
            return this._nativeAudio.duration;
          }
        }, {
          key: "currentTime",
          get: function get() {
            if (this._isPaused) {
              return this._startOffset;
            } else {
              return this._calculateCurrentTime();
            }
          }
        }]);

        return AudioTimer;
      }();

      var AudioBufferManager = function () {
        function AudioBufferManager() {
          this._audioBufferDataMap = {};
        }

        var _proto = AudioBufferManager.prototype;

        _proto.addCache = function addCache(url, audioBuffer) {
          var audioBufferData = this._audioBufferDataMap[url];

          if (audioBufferData) {
            console.warn("Audio buffer " + url + " has been cached");
            return;
          }

          this._audioBufferDataMap[url] = {
            usedCount: 1,
            audioBuffer: audioBuffer
          };
        };

        _proto.retainCache = function retainCache(url) {
          var audioBufferData = this._audioBufferDataMap[url];

          if (!audioBufferData) {
            console.warn("Audio buffer cache " + url + " has not been added.");
            return;
          }

          audioBufferData.usedCount++;
        };

        _proto.getCache = function getCache(url) {
          var audioBufferData = this._audioBufferDataMap[url];
          return audioBufferData === null || audioBufferData === void 0 ? void 0 : audioBufferData.audioBuffer;
        };

        _proto.tryReleasingCache = function tryReleasingCache(url) {
          var audioBufferData = this._audioBufferDataMap[url];

          if (!audioBufferData) {
            console.warn("Audio buffer cache " + url + " has not been added.");
            return;
          }

          if (--audioBufferData.usedCount <= 0) {
            delete this._audioBufferDataMap[url];
          }
        };

        return AudioBufferManager;
      }();

      var audioBufferManager = new AudioBufferManager();

      var _class$K, _temp$I;
      var AudioContextClass = window.AudioContext || window.webkitAudioContext || window.mozAudioContext;
      var AudioContextAgent = function () {
        function AudioContextAgent() {
          this._context = void 0;
          this._context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
        }

        var _proto = AudioContextAgent.prototype;

        _proto.decodeAudioData = function decodeAudioData(audioData) {
          var _this = this;

          return new Promise(function (resolve) {
            var promise = _this._context.decodeAudioData(audioData, function (audioBuffer) {
              resolve(audioBuffer);
            }, function (err) {
              console.error('failed to load Web Audio', err);
            });

            promise === null || promise === void 0 ? void 0 : promise["catch"](function (e) {});
          });
        };

        _proto.runContext = function runContext() {
          var _this2 = this;

          return new Promise(function (resolve) {
            var context = _this2._context;

            if (!context.resume) {
              resolve();
              return;
            }

            if (context.state === 'running') {
              resolve();
              return;
            }

            var canvas = document.getElementById('GameCanvas');

            var onGesture = function onGesture() {
              context.resume().then(resolve)["catch"](function (e) {});
            };

            canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('touchend', onGesture, {
              once: true,
              capture: true
            });
            canvas === null || canvas === void 0 ? void 0 : canvas.addEventListener('mouseup', onGesture, {
              once: true,
              capture: true
            });
          });
        };

        _proto.createBufferSource = function createBufferSource(audioBuffer, loop) {
          var sourceBufferNode = this._context.createBufferSource();

          if (audioBuffer !== undefined) {
            sourceBufferNode.buffer = audioBuffer;
          }

          if (loop !== undefined) {
            sourceBufferNode.loop = loop;
          }

          return sourceBufferNode;
        };

        _proto.createGain = function createGain(volume) {
          if (volume === void 0) {
            volume = 1;
          }

          var gainNode = this._context.createGain();

          this.setGainValue(gainNode, volume);
          return gainNode;
        };

        _proto.setGainValue = function setGainValue(gain, volume) {
          if (gain.gain.setTargetAtTime) {
            try {
              gain.gain.setTargetAtTime(volume, this._context.currentTime, 0);
            } catch (e) {
              gain.gain.setTargetAtTime(volume, this._context.currentTime, 0.01);
            }
          } else {
            gain.gain.value = volume;
          }
        };

        _proto.connectContext = function connectContext(audioNode) {
          if (!this._context) {
            return;
          }

          audioNode.connect(this._context.destination);
        };

        _createClass(AudioContextAgent, [{
          key: "currentTime",
          get: function get() {
            return this._context.currentTime;
          }
        }]);

        return AudioContextAgent;
      }();
      AudioContextAgent.support = !!AudioContextClass;
      var audioContextAgent;

      if (AudioContextAgent.support) {
        audioContextAgent = new AudioContextAgent();
      }

      var OneShotAudioWeb = function () {
        function OneShotAudioWeb(audioBuffer, volume, url) {
          this._duration = void 0;
          this._bufferSourceNode = void 0;
          this._onPlayCb = void 0;
          this._currentTimer = 0;
          this._url = void 0;
          this._onEndCb = void 0;
          this._duration = audioBuffer.duration;
          this._url = url;
          this._bufferSourceNode = audioContextAgent.createBufferSource(audioBuffer, false);
          var gainNode = audioContextAgent.createGain(volume);

          this._bufferSourceNode.connect(gainNode);

          audioContextAgent.connectContext(gainNode);
        }

        var _proto2 = OneShotAudioWeb.prototype;

        _proto2.play = function play() {
          var _this3 = this;

          this._bufferSourceNode.start();

          audioContextAgent.runContext().then(function () {
            var _this3$onPlay;

            (_this3$onPlay = _this3.onPlay) === null || _this3$onPlay === void 0 ? void 0 : _this3$onPlay.call(_this3);
            _this3._currentTimer = window.setTimeout(function () {
              var _this3$onEnd;

              audioBufferManager.tryReleasingCache(_this3._url);
              (_this3$onEnd = _this3.onEnd) === null || _this3$onEnd === void 0 ? void 0 : _this3$onEnd.call(_this3);
            }, _this3._duration * 1000);
          })["catch"](function (e) {});
        };

        _proto2.stop = function stop() {
          clearTimeout(this._currentTimer);
          audioBufferManager.tryReleasingCache(this._url);

          this._bufferSourceNode.stop();

          this._bufferSourceNode.buffer = null;
        };

        _createClass(OneShotAudioWeb, [{
          key: "onPlay",
          get: function get() {
            return this._onPlayCb;
          },
          set: function set(cb) {
            this._onPlayCb = cb;
          }
        }, {
          key: "onEnd",
          get: function get() {
            return this._onEndCb;
          },
          set: function set(cb) {
            this._onEndCb = cb;
          }
        }]);

        return OneShotAudioWeb;
      }();
      var AudioPlayerWeb = (_class$K = (_temp$I = function () {
        function AudioPlayerWeb(audioBuffer, url) {
          this._src = void 0;
          this._audioBuffer = void 0;
          this._sourceNode = void 0;
          this._gainNode = void 0;
          this._currentTimer = 0;
          this._volume = 1;
          this._loop = false;
          this._state = AudioState.INIT;
          this._audioTimer = void 0;
          this._eventTarget = new EventTarget();
          this._operationQueue = [];
          this._audioBuffer = audioBuffer;
          this._audioTimer = new AudioTimer(audioBuffer);
          this._gainNode = audioContextAgent.createGain();
          audioContextAgent.connectContext(this._gainNode);
          this._src = url;
          systemInfo.on('hide', this._onHide, this);
          systemInfo.on('show', this._onShow, this);
        }

        var _proto3 = AudioPlayerWeb.prototype;

        _proto3.destroy = function destroy() {
          this._audioTimer.destroy();

          if (this._audioBuffer) {
            this._audioBuffer = null;
          }

          audioBufferManager.tryReleasingCache(this._src);
          systemInfo.off('hide', this._onHide, this);
          systemInfo.off('show', this._onShow, this);
        };

        AudioPlayerWeb.load = function load(url) {
          return new Promise(function (resolve) {
            AudioPlayerWeb.loadNative(url).then(function (audioBuffer) {
              resolve(new AudioPlayerWeb(audioBuffer, url));
            })["catch"](function (e) {});
          });
        };

        AudioPlayerWeb.loadNative = function loadNative(url) {
          return new Promise(function (resolve, reject) {
            var cachedAudioBuffer = audioBufferManager.getCache(url);

            if (cachedAudioBuffer) {
              audioBufferManager.retainCache(url);
              resolve(cachedAudioBuffer);
              return;
            }

            var xhr = new XMLHttpRequest();
            var errInfo = "load audio failed: " + url + ", status: ";
            xhr.open('GET', url, true);
            xhr.responseType = 'arraybuffer';

            xhr.onload = function () {
              if (xhr.status === 200 || xhr.status === 0) {
                audioContextAgent.decodeAudioData(xhr.response).then(function (decodedAudioBuffer) {
                  audioBufferManager.addCache(url, decodedAudioBuffer);
                  resolve(decodedAudioBuffer);
                })["catch"](function (e) {});
              } else {
                reject(new Error("" + errInfo + xhr.status + "(no response)"));
              }
            };

            xhr.onerror = function () {
              reject(new Error("" + errInfo + xhr.status + "(error)"));
            };

            xhr.ontimeout = function () {
              reject(new Error("" + errInfo + xhr.status + "(time out)"));
            };

            xhr.onabort = function () {
              reject(new Error("" + errInfo + xhr.status + "(abort)"));
            };

            xhr.send(null);
          });
        };

        AudioPlayerWeb.loadOneShotAudio = function loadOneShotAudio(url, volume) {
          return new Promise(function (resolve, reject) {
            AudioPlayerWeb.loadNative(url).then(function (audioBuffer) {
              var oneShotAudio = new OneShotAudioWeb(audioBuffer, volume, url);
              resolve(oneShotAudio);
            })["catch"](reject);
          });
        };

        _proto3._onHide = function _onHide() {
          var _this4 = this;

          if (this._state === AudioState.PLAYING) {
            this.pause().then(function () {
              _this4._state = AudioState.INTERRUPTED;

              _this4._eventTarget.emit(AudioEvent.INTERRUPTION_BEGIN);
            })["catch"](function (e) {});
          }
        };

        _proto3._onShow = function _onShow() {
          var _this5 = this;

          if (this._state === AudioState.INTERRUPTED) {
            this.play().then(function () {
              _this5._eventTarget.emit(AudioEvent.INTERRUPTION_END);
            })["catch"](function (e) {});
          }
        };

        _proto3.seek = function seek(time) {
          var _this6 = this;

          return new Promise(function (resolve) {
            _this6._audioTimer.seek(time);

            if (_this6._state === AudioState.PLAYING) {
              _this6._doPlay().then(resolve)["catch"](function (e) {});
            } else {
              resolve();
            }
          });
        };

        _proto3.play = function play() {

          return this._doPlay();
        };

        _proto3._doPlay = function _doPlay() {
          var _this7 = this;

          return new Promise(function (resolve) {
            _this7._stopSourceNode();

            _this7._sourceNode = audioContextAgent.createBufferSource(_this7._audioBuffer, _this7.loop);

            _this7._sourceNode.connect(_this7._gainNode);

            _this7._sourceNode.start(0, _this7._audioTimer.currentTime);

            audioContextAgent.runContext().then(function () {
              _this7._state = AudioState.PLAYING;

              _this7._audioTimer.start();

              var checkEnded = function checkEnded() {
                if (_this7.loop) {
                  _this7._currentTimer = window.setTimeout(checkEnded, _this7._audioBuffer.duration * 1000);
                } else {
                  _this7._audioTimer.stop();

                  _this7._eventTarget.emit(AudioEvent.ENDED);

                  _this7._state = AudioState.INIT;
                }
              };

              window.clearTimeout(_this7._currentTimer);
              _this7._currentTimer = window.setTimeout(checkEnded, (_this7._audioBuffer.duration - _this7._audioTimer.currentTime) * 1000);
              resolve();
            })["catch"](function (e) {});
          });
        };

        _proto3._stopSourceNode = function _stopSourceNode() {
          try {
            if (this._sourceNode) {
              this._sourceNode.stop();

              this._sourceNode.buffer = null;
            }
          } catch (e) {}
        };

        _proto3.pause = function pause() {
          if (this._state !== AudioState.PLAYING || !this._sourceNode) {
            return Promise.resolve();
          }

          this._audioTimer.pause();

          this._state = AudioState.PAUSED;
          window.clearTimeout(this._currentTimer);

          this._stopSourceNode();

          return Promise.resolve();
        };

        _proto3.stop = function stop() {
          if (!this._sourceNode) {
            return Promise.resolve();
          }

          this._audioTimer.stop();

          this._state = AudioState.STOPPED;
          window.clearTimeout(this._currentTimer);

          this._stopSourceNode();

          return Promise.resolve();
        };

        _proto3.onInterruptionBegin = function onInterruptionBegin(cb) {
          this._eventTarget.on(AudioEvent.INTERRUPTION_BEGIN, cb);
        };

        _proto3.offInterruptionBegin = function offInterruptionBegin(cb) {
          this._eventTarget.off(AudioEvent.INTERRUPTION_BEGIN, cb);
        };

        _proto3.onInterruptionEnd = function onInterruptionEnd(cb) {
          this._eventTarget.on(AudioEvent.INTERRUPTION_END, cb);
        };

        _proto3.offInterruptionEnd = function offInterruptionEnd(cb) {
          this._eventTarget.off(AudioEvent.INTERRUPTION_END, cb);
        };

        _proto3.onEnded = function onEnded(cb) {
          this._eventTarget.on(AudioEvent.ENDED, cb);
        };

        _proto3.offEnded = function offEnded(cb) {
          this._eventTarget.off(AudioEvent.ENDED, cb);
        };

        _createClass(AudioPlayerWeb, [{
          key: "src",
          get: function get() {
            return this._src;
          }
        }, {
          key: "type",
          get: function get() {
            return AudioType.WEB_AUDIO;
          }
        }, {
          key: "state",
          get: function get() {
            return this._state;
          }
        }, {
          key: "loop",
          get: function get() {
            return this._loop;
          },
          set: function set(val) {
            this._loop = val;

            if (this._sourceNode) {
              this._sourceNode.loop = val;
            }
          }
        }, {
          key: "volume",
          get: function get() {
            return this._volume;
          },
          set: function set(val) {
            val = clamp01(val);
            this._volume = val;
            audioContextAgent.setGainValue(this._gainNode, val);
          }
        }, {
          key: "duration",
          get: function get() {
            return this._audioBuffer.duration;
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._audioTimer.currentTime;
          }
        }]);

        return AudioPlayerWeb;
      }(), _temp$I), (_applyDecoratedDescriptor(_class$K.prototype, "seek", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$K.prototype, "seek"), _class$K.prototype), _applyDecoratedDescriptor(_class$K.prototype, "play", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$K.prototype, "play"), _class$K.prototype), _applyDecoratedDescriptor(_class$K.prototype, "pause", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$K.prototype, "pause"), _class$K.prototype), _applyDecoratedDescriptor(_class$K.prototype, "stop", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$K.prototype, "stop"), _class$K.prototype)), _class$K);

      var OneShotAudio = function () {
        function OneShotAudio(audio) {
          this._audio = void 0;
          this._audio = audio;
        }

        var _proto = OneShotAudio.prototype;

        _proto.play = function play() {
          this._audio.play();
        };

        _proto.stop = function stop() {
          this._audio.stop();
        };

        _createClass(OneShotAudio, [{
          key: "onPlay",
          get: function get() {
            return this._audio.onPlay;
          },
          set: function set(v) {
            this._audio.onPlay = v;
          }
        }, {
          key: "onEnd",
          get: function get() {
            return this._audio.onEnd;
          },
          set: function set(v) {
            this._audio.onEnd = v;
          }
        }]);

        return OneShotAudio;
      }();
      var AudioPlayer = function () {
        function AudioPlayer(player) {
          this._player = void 0;
          this._player = player;
        }

        AudioPlayer.load = function load(url, opts) {
          return new Promise(function (resolve) {
            if ((opts === null || opts === void 0 ? void 0 : opts.audioLoadMode) === AudioType.DOM_AUDIO || !AudioContextAgent.support) {
              if (!AudioContextAgent.support) {
                warnID(5201);
              }

              AudioPlayerDOM.load(url).then(function (domPlayer) {
                resolve(new AudioPlayer(domPlayer));
              })["catch"](function (e) {});
            } else {
              AudioPlayerWeb.load(url).then(function (webPlayer) {
                resolve(new AudioPlayer(webPlayer));
              })["catch"](function (e) {});
            }
          });
        };

        var _proto2 = AudioPlayer.prototype;

        _proto2.destroy = function destroy() {
          this._player.destroy();
        };

        AudioPlayer.loadNative = function loadNative(url, opts) {
          if ((opts === null || opts === void 0 ? void 0 : opts.audioLoadMode) === AudioType.DOM_AUDIO || !AudioContextAgent.support) {
            if (!AudioContextAgent.support) {
              warnID(5201);
            }

            return AudioPlayerDOM.loadNative(url);
          }

          return AudioPlayerWeb.loadNative(url);
        };

        AudioPlayer.loadOneShotAudio = function loadOneShotAudio(url, volume, opts) {
          return new Promise(function (resolve, reject) {
            if ((opts === null || opts === void 0 ? void 0 : opts.audioLoadMode) === AudioType.DOM_AUDIO || !AudioContextAgent.support) {
              if (!AudioContextAgent.support) {
                warnID(5201);
              }

              AudioPlayerDOM.loadOneShotAudio(url, volume).then(function (oneShotAudioDOM) {
                resolve(new OneShotAudio(oneShotAudioDOM));
              })["catch"](reject);
            } else {
              AudioPlayerWeb.loadOneShotAudio(url, volume).then(function (oneShotAudioWeb) {
                resolve(new OneShotAudio(oneShotAudioWeb));
              })["catch"](reject);
            }
          });
        };

        _proto2.seek = function seek(time) {
          return this._player.seek(time);
        };

        _proto2.play = function play() {
          return this._player.play();
        };

        _proto2.pause = function pause() {
          return this._player.pause();
        };

        _proto2.stop = function stop() {
          return this._player.stop();
        };

        _proto2.onInterruptionBegin = function onInterruptionBegin(cb) {
          this._player.onInterruptionBegin(cb);
        };

        _proto2.offInterruptionBegin = function offInterruptionBegin(cb) {
          this._player.offInterruptionBegin(cb);
        };

        _proto2.onInterruptionEnd = function onInterruptionEnd(cb) {
          this._player.onInterruptionEnd(cb);
        };

        _proto2.offInterruptionEnd = function offInterruptionEnd(cb) {
          this._player.offInterruptionEnd(cb);
        };

        _proto2.onEnded = function onEnded(cb) {
          this._player.onEnded(cb);
        };

        _proto2.offEnded = function offEnded(cb) {
          this._player.offEnded(cb);
        };

        _createClass(AudioPlayer, [{
          key: "src",
          get: function get() {
            return this._player.src;
          }
        }, {
          key: "type",
          get: function get() {
            return this._player.type;
          }
        }, {
          key: "state",
          get: function get() {
            return this._player.state;
          }
        }, {
          key: "loop",
          get: function get() {
            return this._player.loop;
          },
          set: function set(val) {
            this._player.loop = val;
          }
        }, {
          key: "volume",
          get: function get() {
            return this._player.volume;
          },
          set: function set(val) {
            this._player.volume = val;
          }
        }, {
          key: "duration",
          get: function get() {
            return this._player.duration;
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._player.currentTime;
          }
        }]);

        return AudioPlayer;
      }();
      AudioPlayer.maxAudioChannel = 24;

      var _dec$J, _class$L, _class2$F, _descriptor$y, _class3$g, _temp$J;
      var AudioClip = exports('AudioClip', (_dec$J = ccclass('cc.AudioClip'), _dec$J(_class$L = (_class2$F = (_temp$J = _class3$g = function (_Asset) {
        _inheritsLoose(AudioClip, _Asset);

        function AudioClip() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_duration", _descriptor$y, _assertThisInitialized(_this));

          _this._loadMode = AudioType.UNKNOWN_AUDIO;
          _this._meta = null;
          _this._player = null;
          return _this;
        }

        var _proto = AudioClip.prototype;

        _proto.destroy = function destroy() {
          var _this$_player;

          var destroyResult = _Asset.prototype.destroy.call(this);

          (_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.destroy();
          this._player = null;

          if (this._meta) {
            this._meta.player = null;
          }

          return destroyResult;
        };

        _proto.validate = function validate() {
          return !!this._meta;
        };

        _proto.getDuration = function getDuration() {
          if (this._duration) {
            return this._duration;
          }

          return this._meta ? this._meta.duration : 0;
        };

        _proto.getCurrentTime = function getCurrentTime() {
          return this._player ? this._player.currentTime : 0;
        };

        _proto.getVolume = function getVolume() {
          return this._player ? this._player.volume : 0;
        };

        _proto.getLoop = function getLoop() {
          return this._player ? this._player.loop : false;
        };

        _proto.setCurrentTime = function setCurrentTime(time) {
          var _this$_player2;

          (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.seek(time)["catch"](function (e) {});
        };

        _proto.setVolume = function setVolume(volume) {
          if (this._player) {
            this._player.volume = volume;
          }
        };

        _proto.setLoop = function setLoop(loop) {
          if (this._player) {
            this._player.loop = loop;
          }
        };

        _proto.play = function play() {
          var _this$_player3;

          (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.play()["catch"](function (e) {});
        };

        _proto.pause = function pause() {
          var _this$_player4;

          (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.pause()["catch"](function (e) {});
        };

        _proto.stop = function stop() {
          var _this$_player5;

          (_this$_player5 = this._player) === null || _this$_player5 === void 0 ? void 0 : _this$_player5.stop()["catch"](function (e) {});
        };

        _proto.playOneShot = function playOneShot(volume) {
          if (volume === void 0) {
            volume = 1;
          }

          if (this._nativeAsset) {
            AudioPlayer.loadOneShotAudio(this._nativeAsset.url, volume).then(function (oneShotAudio) {
              oneShotAudio.play();
            })["catch"](function (e) {});
          }
        };

        _createClass(AudioClip, [{
          key: "_nativeAsset",
          get: function get() {
            return this._meta;
          },
          set: function set(meta) {
            this._meta = meta;

            if (meta) {
              this._loadMode = meta.type;
              this._player = meta.player;
            } else {
              this._meta = null;
              this._loadMode = AudioType.UNKNOWN_AUDIO;
              this._duration = 0;
            }
          }
        }, {
          key: "_nativeDep",
          get: function get() {
            return {
              uuid: this._uuid,
              audioLoadMode: this.loadMode,
              ext: this._native,
              __isNative__: true
            };
          }
        }, {
          key: "loadMode",
          get: function get() {
            return this._loadMode;
          }
        }, {
          key: "state",
          get: function get() {
            return this._player ? this._player.state : AudioState.INIT;
          }
        }]);

        return AudioClip;
      }(Asset), _class3$g.AudioType = AudioType, _temp$J), (_descriptor$y = _applyDecoratedDescriptor(_class2$F.prototype, "_duration", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2$F.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$F.prototype, "_nativeDep"), _class2$F.prototype)), _class2$F)) || _class$L));
      legacyCC.AudioClip = AudioClip;

      function loadAudioPlayer(url, options, onComplete) {
        AudioPlayer.load(url, {
          audioLoadMode: options.audioLoadMode
        }).then(function (player) {
          var audioMeta = {
            player: player,
            url: url,
            duration: player.duration,
            type: player.type
          };
          onComplete(null, audioMeta);
        })["catch"](function (err) {
          onComplete(err);
        });
      }

      function createAudioClip(id, data, options, onComplete) {
        var out = new AudioClip();
        out._nativeUrl = id;
        out._nativeAsset = data;
        out._duration = data.duration;
        onComplete(null, out);
      }

      downloader.register({
        '.mp3': loadAudioPlayer,
        '.ogg': loadAudioPlayer,
        '.wav': loadAudioPlayer,
        '.m4a': loadAudioPlayer
      });
      factory.register({
        '.mp3': createAudioClip,
        '.ogg': createAudioClip,
        '.wav': createAudioClip,
        '.m4a': createAudioClip
      });

      var AudioManager = function () {
        function AudioManager() {
          this._oneShotAudioInfoList = [];
          this._audioPlayerInfoList = [];
        }

        var _proto = AudioManager.prototype;

        _proto._findIndex = function _findIndex(audioInfoList, audio) {
          return audioInfoList.findIndex(function (item) {
            return item.audio === audio;
          });
        };

        _proto._tryAddPlaying = function _tryAddPlaying(audioInfoList, audio) {
          var idx = this._findIndex(audioInfoList, audio);

          if (idx > -1) {
            audioInfoList[idx].playTime = performance.now();
            return false;
          }

          audioInfoList.push({
            audio: audio,
            playTime: performance.now()
          });
          return true;
        };

        _proto.addPlaying = function addPlaying(audio) {
          if (audio instanceof AudioPlayer) {
            if (this._tryAddPlaying(this._audioPlayerInfoList, audio)) {
              return;
            }
          } else {
            this._tryAddPlaying(this._oneShotAudioInfoList, audio);
          }
        };

        _proto._tryRemovePlaying = function _tryRemovePlaying(audioInfoList, audio) {
          var idx = this._findIndex(audioInfoList, audio);

          if (idx === -1) {
            return false;
          }

          fastRemoveAt(audioInfoList, idx);
          return true;
        };

        _proto.removePlaying = function removePlaying(audio) {
          if (audio instanceof AudioPlayer) {
            if (this._tryRemovePlaying(this._audioPlayerInfoList, audio)) {
              return;
            }
          } else {
            this._tryRemovePlaying(this._oneShotAudioInfoList, audio);
          }
        };

        _proto.discardOnePlayingIfNeeded = function discardOnePlayingIfNeeded() {
          if (this._audioPlayerInfoList.length + this._oneShotAudioInfoList.length < AudioPlayer.maxAudioChannel) {
            return;
          }

          var audioInfoToDiscard;

          if (this._oneShotAudioInfoList.length > 0) {
            this._oneShotAudioInfoList.forEach(function (audioInfo) {
              if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                audioInfoToDiscard = audioInfo;
              }
            });
          } else {
            this._audioPlayerInfoList.forEach(function (audioInfo) {
              if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                audioInfoToDiscard = audioInfo;
              }
            });
          }

          if (audioInfoToDiscard) {
            audioInfoToDiscard.audio.stop();
            this.removePlaying(audioInfoToDiscard.audio);
          }
        };

        return AudioManager;
      }();
      var audioManager = new AudioManager();

      var _dec$K, _dec2$o, _dec3$j, _dec4$c, _dec5$9, _dec6$6, _dec7$4, _dec8$4, _dec9$4, _dec10$4, _class$M, _class2$G, _descriptor$z, _descriptor2$m, _descriptor3$g, _descriptor4$d, _class3$h, _temp$K;
      var AudioSourceEventType;

      (function (AudioSourceEventType) {
        AudioSourceEventType["STARTED"] = "started";
        AudioSourceEventType["ENDED"] = "ended";
      })(AudioSourceEventType || (AudioSourceEventType = {}));

      var AudioSource = function (v) { return exports({ AudioSource: v, AudioSourceComponent: v }), v; }((_dec$K = ccclass('cc.AudioSource'), _dec2$o = help(), _dec3$j = menu(), _dec4$c = type(AudioClip), _dec5$9 = type(AudioClip), _dec6$6 = tooltip(), _dec7$4 = tooltip(), _dec8$4 = tooltip(), _dec9$4 = range(), _dec10$4 = tooltip(), _dec$K(_class$M = _dec2$o(_class$M = _dec3$j(_class$M = (_class2$G = (_temp$K = _class3$h = function (_Component) {
        _inheritsLoose(AudioSource, _Component);

        function AudioSource() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_clip", _descriptor$z, _assertThisInitialized(_this));

          _this._player = null;

          _initializerDefineProperty(_this, "_loop", _descriptor2$m, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_playOnAwake", _descriptor3$g, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_volume", _descriptor4$d, _assertThisInitialized(_this));

          _this._cachedCurrentTime = 0;
          _this._operationsBeforeLoading = [];
          _this._isLoaded = false;
          _this._lastSetClip = null;
          return _this;
        }

        var _proto = AudioSource.prototype;

        _proto._syncPlayer = function _syncPlayer() {
          var _this2 = this;

          var clip = this._clip;
          this._isLoaded = false;

          if (this._lastSetClip === clip) {
            return;
          }

          if (!clip) {
            this._lastSetClip = null;
            return;
          }

          if (!clip._nativeAsset) {
            console.error('Invalid audio clip');
            return;
          }

          this._lastSetClip = clip;
          AudioPlayer.load(clip._nativeAsset.url, {
            audioLoadMode: clip.loadMode
          }).then(function (player) {
            if (_this2._lastSetClip !== clip) {
              player.destroy();
              return;
            }

            _this2._isLoaded = true;

            if (_this2._player) {
              audioManager.removePlaying(_this2._player);

              _this2._player.offEnded();

              _this2._player.offInterruptionBegin();

              _this2._player.offInterruptionEnd();

              _this2._player.destroy();
            }

            _this2._player = player;
            player.onEnded(function () {
              audioManager.removePlaying(player);

              _this2.node.emit(AudioSourceEventType.ENDED, _this2);
            });
            player.onInterruptionBegin(function () {
              audioManager.removePlaying(player);
            });
            player.onInterruptionEnd(function () {
              audioManager.addPlaying(player);
            });

            _this2._syncStates();
          })["catch"](function (e) {});
        };

        _proto.onLoad = function onLoad() {
          this._syncPlayer();
        };

        _proto.onEnable = function onEnable() {
          if (this._playOnAwake && !this.playing) {
            this.play();
          }
        };

        _proto.onDisable = function onDisable() {
          var rootNode = this._getRootNode();

          if (rootNode === null || rootNode === void 0 ? void 0 : rootNode._persistNode) {
            return;
          }

          this.pause();
        };

        _proto.onDestroy = function onDestroy() {
          var _this$_player;

          this.stop();
          (_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.destroy();
          this._player = null;
        };

        _proto._getRootNode = function _getRootNode() {
          var _currentNode, _currentNode$parent;

          var currentNode = this.node;
          var currentGrandparentNode = (_currentNode = currentNode) === null || _currentNode === void 0 ? void 0 : (_currentNode$parent = _currentNode.parent) === null || _currentNode$parent === void 0 ? void 0 : _currentNode$parent.parent;

          while (currentGrandparentNode) {
            var _currentNode2, _currentNode3, _currentNode3$parent;

            currentNode = (_currentNode2 = currentNode) === null || _currentNode2 === void 0 ? void 0 : _currentNode2.parent;
            currentGrandparentNode = (_currentNode3 = currentNode) === null || _currentNode3 === void 0 ? void 0 : (_currentNode3$parent = _currentNode3.parent) === null || _currentNode3$parent === void 0 ? void 0 : _currentNode3$parent.parent;
          }

          return currentNode;
        };

        _proto.play = function play() {
          var _this$_player3,
              _this3 = this;

          if (!this._isLoaded) {
            this._operationsBeforeLoading.push('play');

            return;
          }

          audioManager.discardOnePlayingIfNeeded();

          if (this.state === AudioState.PLAYING) {
            var _this$_player2;

            (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.stop()["catch"](function (e) {});
          }

          (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.play().then(function () {
            audioManager.addPlaying(_this3._player);

            _this3.node.emit(AudioSourceEventType.STARTED, _this3);
          })["catch"](function (e) {});
        };

        _proto.pause = function pause() {
          var _this$_player4,
              _this4 = this;

          if (!this._isLoaded) {
            this._operationsBeforeLoading.push('pause');

            return;
          }

          (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.pause().then(function () {
            audioManager.removePlaying(_this4._player);
          })["catch"](function (e) {});
        };

        _proto.stop = function stop() {
          var _this$_player5,
              _this5 = this;

          if (!this._isLoaded) {
            this._operationsBeforeLoading.push('stop');

            return;
          }

          (_this$_player5 = this._player) === null || _this$_player5 === void 0 ? void 0 : _this$_player5.stop().then(function () {
            audioManager.removePlaying(_this5._player);
          })["catch"](function (e) {});
        };

        _proto.playOneShot = function playOneShot(clip, volumeScale) {
          if (volumeScale === void 0) {
            volumeScale = 1;
          }

          if (!clip._nativeAsset) {
            console.error('Invalid audio clip');
            return;
          }

          AudioPlayer.loadOneShotAudio(clip._nativeAsset.url, this._volume * volumeScale, {
            audioLoadMode: clip.loadMode
          }).then(function (oneShotAudio) {
            audioManager.discardOnePlayingIfNeeded();

            oneShotAudio.onPlay = function () {
              audioManager.addPlaying(oneShotAudio);
            };

            oneShotAudio.onEnd = function () {
              audioManager.removePlaying(oneShotAudio);
            };

            oneShotAudio.play();
          })["catch"](function (e) {});
        };

        _proto._syncStates = function _syncStates() {
          var _this6 = this;

          if (!this._player) {
            return;
          }

          this._player.seek(this._cachedCurrentTime).then(function () {
            if (_this6._player) {
              _this6._player.loop = _this6._loop;
              _this6._player.volume = _this6._volume;

              _this6._operationsBeforeLoading.forEach(function (opName) {
                var _this6$opName;

                (_this6$opName = _this6[opName]) === null || _this6$opName === void 0 ? void 0 : _this6$opName.call(_this6);
              });

              _this6._operationsBeforeLoading.length = 0;
            }
          })["catch"](function (e) {});
        };

        _createClass(AudioSource, [{
          key: "clip",
          get: function get() {
            return this._clip;
          },
          set: function set(val) {
            if (val === this._clip) {
              return;
            }

            this._clip = val;

            this._syncPlayer();
          }
        }, {
          key: "loop",
          get: function get() {
            return this._loop;
          },
          set: function set(val) {
            this._loop = val;
            this._player && (this._player.loop = val);
          }
        }, {
          key: "playOnAwake",
          get: function get() {
            return this._playOnAwake;
          },
          set: function set(val) {
            this._playOnAwake = val;
          }
        }, {
          key: "volume",
          get: function get() {
            return this._volume;
          },
          set: function set(val) {
            if (Number.isNaN(val)) {
              console.warn('illegal audio volume!');
              return;
            }

            val = clamp(val, 0, 1);

            if (this._player) {
              this._player.volume = val;
              this._volume = this._player.volume;
            } else {
              this._volume = val;
            }
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._player ? this._player.currentTime : this._cachedCurrentTime;
          },
          set: function set(num) {
            var _this$_player6;

            if (Number.isNaN(num)) {
              console.warn('illegal audio time!');
              return;
            }

            num = clamp(num, 0, this.duration);
            this._cachedCurrentTime = num;
            (_this$_player6 = this._player) === null || _this$_player6 === void 0 ? void 0 : _this$_player6.seek(this._cachedCurrentTime)["catch"](function (e) {});
          }
        }, {
          key: "duration",
          get: function get() {
            var _this$_clip$getDurati, _this$_clip;

            return (_this$_clip$getDurati = (_this$_clip = this._clip) === null || _this$_clip === void 0 ? void 0 : _this$_clip.getDuration()) !== null && _this$_clip$getDurati !== void 0 ? _this$_clip$getDurati : this._player ? this._player.duration : 0;
          }
        }, {
          key: "state",
          get: function get() {
            return this._player ? this._player.state : AudioState.INIT;
          }
        }, {
          key: "playing",
          get: function get() {
            return this.state === AudioSource.AudioState.PLAYING;
          }
        }], [{
          key: "maxAudioChannel",
          get: function get() {
            return AudioPlayer.maxAudioChannel;
          }
        }]);

        return AudioSource;
      }(Component), _class3$h.AudioState = AudioState, _class3$h.EventType = AudioSourceEventType, _temp$K), (_descriptor$z = _applyDecoratedDescriptor(_class2$G.prototype, "_clip", [_dec4$c], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$m = _applyDecoratedDescriptor(_class2$G.prototype, "_loop", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor3$g = _applyDecoratedDescriptor(_class2$G.prototype, "_playOnAwake", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor4$d = _applyDecoratedDescriptor(_class2$G.prototype, "_volume", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _applyDecoratedDescriptor(_class2$G.prototype, "clip", [_dec5$9, _dec6$6], Object.getOwnPropertyDescriptor(_class2$G.prototype, "clip"), _class2$G.prototype), _applyDecoratedDescriptor(_class2$G.prototype, "loop", [_dec7$4], Object.getOwnPropertyDescriptor(_class2$G.prototype, "loop"), _class2$G.prototype), _applyDecoratedDescriptor(_class2$G.prototype, "playOnAwake", [_dec8$4], Object.getOwnPropertyDescriptor(_class2$G.prototype, "playOnAwake"), _class2$G.prototype), _applyDecoratedDescriptor(_class2$G.prototype, "volume", [_dec9$4, _dec10$4], Object.getOwnPropertyDescriptor(_class2$G.prototype, "volume"), _class2$G.prototype)), _class2$G)) || _class$M) || _class$M) || _class$M));

      replaceProperty(AudioClip, 'AudioClip', [{
        name: 'PlayingState',
        newName: 'AudioState',
        target: AudioSource,
        targetName: 'AudioSource'
      }]);
      markAsWarning(AudioClip.prototype, 'AudioClip.prototype', ['state', 'play', 'pause', 'stop', 'playOneShot', 'setCurrentTime', 'setVolume', 'setLoop', 'getCurrentTime', 'getVolume', 'getLoop'].map(function (item) {
        return {
          name: item,
          suggest: "please use AudioSource.prototype." + item + " instead"
        };
      }));

      legacyCC.AudioSourceComponent = AudioSource;
      js.setClassAlias(AudioSource, 'cc.AudioSourceComponent');

      legacyCC.log = log;
      legacyCC.warn = warn;
      legacyCC.error = error;
      legacyCC.assert = assert;
      legacyCC._throw = _throw;
      legacyCC.logID = logID;
      legacyCC.warnID = warnID;
      legacyCC.errorID = errorID;
      legacyCC.assertID = assertID;
      legacyCC.debug = debug$1;
      legacyCC.path = {
        join: join,
        extname: extname,
        mainFileName: mainFileName,
        basename: basename,
        dirname: dirname,
        changeExtname: changeExtname,
        changeBasename: changeBasename,
        _normalize: _normalize,
        stripSep: stripSep,

        get sep() {
          return getSeperator();
        }

      };

      var NodePool$1 = exports('NodePool', function () {
        function NodePool(poolHandlerComp) {
          this.poolHandlerComp = void 0;
          this._pool = void 0;
          this.poolHandlerComp = poolHandlerComp;
          this._pool = [];
        }

        var _proto = NodePool.prototype;

        _proto.size = function size() {
          return this._pool.length;
        };

        _proto.clear = function clear() {
          var count = this._pool.length;

          for (var i = 0; i < count; ++i) {
            this._pool[i].destroy();
          }

          this._pool.length = 0;
        };

        _proto.put = function put(obj) {
          if (obj && this._pool.indexOf(obj) === -1) {
            obj.removeFromParent();
            var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

            if (handler && handler.unuse) {
              handler.unuse();
            }

            this._pool.push(obj);
          }
        };

        _proto.get = function get() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var last = this._pool.length - 1;

          if (last < 0) {
            return null;
          } else {
            var obj = this._pool[last];
            this._pool.length = last;
            var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

            if (handler && handler.reuse) {
              handler.reuse(arguments);
            }

            return obj;
          }
        };

        return NodePool;
      }());
      legacyCC.NodePool = NodePool$1;

      legacyCC.renderer = renderer;

      var WebGLDescriptorSet = function (_DescriptorSet) {
        _inheritsLoose(WebGLDescriptorSet, _DescriptorSet);

        function WebGLDescriptorSet() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _DescriptorSet.call.apply(_DescriptorSet, [this].concat(args)) || this;
          _this._gpuDescriptorSet = null;
          return _this;
        }

        var _proto = WebGLDescriptorSet.prototype;

        _proto.initialize = function initialize(info) {
          this._layout = info.layout;
          var _gpuDescriptorSetLayo = info.layout.gpuDescriptorSetLayout,
              bindings = _gpuDescriptorSetLayo.bindings,
              descriptorIndices = _gpuDescriptorSetLayo.descriptorIndices,
              descriptorCount = _gpuDescriptorSetLayo.descriptorCount;
          this._buffers = Array(descriptorCount).fill(null);
          this._textures = Array(descriptorCount).fill(null);
          this._samplers = Array(descriptorCount).fill(null);
          var gpuDescriptors = [];
          this._gpuDescriptorSet = {
            gpuDescriptors: gpuDescriptors,
            descriptorIndices: descriptorIndices
          };

          for (var i = 0; i < bindings.length; ++i) {
            var binding = bindings[i];

            for (var j = 0; j < binding.count; j++) {
              gpuDescriptors.push({
                type: binding.descriptorType,
                gpuBuffer: null,
                gpuTexture: null,
                gpuSampler: null
              });
            }
          }
        };

        _proto.destroy = function destroy() {
          this._layout = null;
          this._gpuDescriptorSet = null;
        };

        _proto.update = function update() {
          if (this._isDirty && this._gpuDescriptorSet) {
            var descriptors = this._gpuDescriptorSet.gpuDescriptors;

            for (var i = 0; i < descriptors.length; ++i) {
              if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                var buffer = this._buffers[i];

                if (buffer) {
                  descriptors[i].gpuBuffer = buffer.gpuBuffer || buffer.gpuBufferView;
                }
              } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                if (this._textures[i]) {
                  descriptors[i].gpuTexture = this._textures[i].gpuTexture;
                }

                if (this._samplers[i]) {
                  descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                }
              }
            }

            this._isDirty = false;
          }
        };

        _createClass(WebGLDescriptorSet, [{
          key: "gpuDescriptorSet",
          get: function get() {
            return this._gpuDescriptorSet;
          }
        }]);

        return WebGLDescriptorSet;
      }(DescriptorSet);

      var WebGLEXT;

      (function (WebGLEXT) {
        WebGLEXT[WebGLEXT["RGBA16F_EXT"] = 34842] = "RGBA16F_EXT";
        WebGLEXT[WebGLEXT["RGB16F_EXT"] = 34843] = "RGB16F_EXT";
        WebGLEXT[WebGLEXT["RGBA32F_EXT"] = 34836] = "RGBA32F_EXT";
        WebGLEXT[WebGLEXT["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
        WebGLEXT[WebGLEXT["UNSIGNED_NORMALIZED_EXT"] = 35863] = "UNSIGNED_NORMALIZED_EXT";
        WebGLEXT[WebGLEXT["UNSIGNED_INT_24_8_WEBGL"] = 34042] = "UNSIGNED_INT_24_8_WEBGL";
        WebGLEXT[WebGLEXT["HALF_FLOAT_OES"] = 36193] = "HALF_FLOAT_OES";
        WebGLEXT[WebGLEXT["SRGB_EXT"] = 35904] = "SRGB_EXT";
        WebGLEXT[WebGLEXT["SRGB_ALPHA_EXT"] = 35906] = "SRGB_ALPHA_EXT";
        WebGLEXT[WebGLEXT["SRGB8_ALPHA8_EXT"] = 35907] = "SRGB8_ALPHA8_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
        WebGLEXT[WebGLEXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
        WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
      })(WebGLEXT || (WebGLEXT = {}));

      var WebGLDeviceManager = function () {
        function WebGLDeviceManager() {}

        WebGLDeviceManager.setInstance = function setInstance(instance) {
          WebGLDeviceManager._instance = instance;
        };

        _createClass(WebGLDeviceManager, null, [{
          key: "instance",
          get: function get() {
            return WebGLDeviceManager._instance;
          }
        }]);

        return WebGLDeviceManager;
      }();
      WebGLDeviceManager._instance = null;

      function GFXFormatToWebGLType(format, gl) {
        switch (format) {
          case Format.R8:
            return gl.UNSIGNED_BYTE;

          case Format.R8SN:
            return gl.BYTE;

          case Format.R8UI:
            return gl.UNSIGNED_BYTE;

          case Format.R8I:
            return gl.BYTE;

          case Format.R16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case Format.R16UI:
            return gl.UNSIGNED_SHORT;

          case Format.R16I:
            return gl.SHORT;

          case Format.R32F:
            return gl.FLOAT;

          case Format.R32UI:
            return gl.UNSIGNED_INT;

          case Format.R32I:
            return gl.INT;

          case Format.RG8:
            return gl.UNSIGNED_BYTE;

          case Format.RG8SN:
            return gl.BYTE;

          case Format.RG8UI:
            return gl.UNSIGNED_BYTE;

          case Format.RG8I:
            return gl.BYTE;

          case Format.RG16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case Format.RG16UI:
            return gl.UNSIGNED_SHORT;

          case Format.RG16I:
            return gl.SHORT;

          case Format.RG32F:
            return gl.FLOAT;

          case Format.RG32UI:
            return gl.UNSIGNED_INT;

          case Format.RG32I:
            return gl.INT;

          case Format.RGB8:
            return gl.UNSIGNED_BYTE;

          case Format.SRGB8:
            return gl.UNSIGNED_BYTE;

          case Format.RGB8SN:
            return gl.BYTE;

          case Format.RGB8UI:
            return gl.UNSIGNED_BYTE;

          case Format.RGB8I:
            return gl.BYTE;

          case Format.RGB16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case Format.RGB16UI:
            return gl.UNSIGNED_SHORT;

          case Format.RGB16I:
            return gl.SHORT;

          case Format.RGB32F:
            return gl.FLOAT;

          case Format.RGB32UI:
            return gl.UNSIGNED_INT;

          case Format.RGB32I:
            return gl.INT;

          case Format.BGRA8:
            return gl.UNSIGNED_BYTE;

          case Format.RGBA8:
            return gl.UNSIGNED_BYTE;

          case Format.SRGB8_A8:
            return gl.UNSIGNED_BYTE;

          case Format.RGBA8SN:
            return gl.BYTE;

          case Format.RGBA8UI:
            return gl.UNSIGNED_BYTE;

          case Format.RGBA8I:
            return gl.BYTE;

          case Format.RGBA16F:
            return WebGLEXT.HALF_FLOAT_OES;

          case Format.RGBA16UI:
            return gl.UNSIGNED_SHORT;

          case Format.RGBA16I:
            return gl.SHORT;

          case Format.RGBA32F:
            return gl.FLOAT;

          case Format.RGBA32UI:
            return gl.UNSIGNED_INT;

          case Format.RGBA32I:
            return gl.INT;

          case Format.R5G6B5:
            return gl.UNSIGNED_SHORT_5_6_5;

          case Format.R11G11B10F:
            return gl.FLOAT;

          case Format.RGB5A1:
            return gl.UNSIGNED_SHORT_5_5_5_1;

          case Format.RGBA4:
            return gl.UNSIGNED_SHORT_4_4_4_4;

          case Format.RGB10A2:
            return gl.UNSIGNED_BYTE;

          case Format.RGB10A2UI:
            return gl.UNSIGNED_INT;

          case Format.RGB9E5:
            return gl.UNSIGNED_BYTE;

          case Format.DEPTH:
            return gl.UNSIGNED_INT;

          case Format.DEPTH_STENCIL:
            return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

          case Format.BC1:
            return gl.UNSIGNED_BYTE;

          case Format.BC1_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.BC2:
            return gl.UNSIGNED_BYTE;

          case Format.BC2_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.BC3:
            return gl.UNSIGNED_BYTE;

          case Format.BC3_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.BC4:
            return gl.UNSIGNED_BYTE;

          case Format.BC4_SNORM:
            return gl.BYTE;

          case Format.BC5:
            return gl.UNSIGNED_BYTE;

          case Format.BC5_SNORM:
            return gl.BYTE;

          case Format.BC6H_SF16:
            return gl.FLOAT;

          case Format.BC6H_UF16:
            return gl.FLOAT;

          case Format.BC7:
            return gl.UNSIGNED_BYTE;

          case Format.BC7_SRGB:
            return gl.UNSIGNED_BYTE;

          case Format.ETC_RGB8:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_RGB8:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_SRGB8:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_RGB8_A1:
            return gl.UNSIGNED_BYTE;

          case Format.ETC2_SRGB8_A1:
            return gl.UNSIGNED_BYTE;

          case Format.EAC_R11:
            return gl.UNSIGNED_BYTE;

          case Format.EAC_R11SN:
            return gl.BYTE;

          case Format.EAC_RG11:
            return gl.UNSIGNED_BYTE;

          case Format.EAC_RG11SN:
            return gl.BYTE;

          case Format.PVRTC_RGB2:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC_RGBA2:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC_RGB4:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC_RGBA4:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC2_2BPP:
            return gl.UNSIGNED_BYTE;

          case Format.PVRTC2_4BPP:
            return gl.UNSIGNED_BYTE;

          case Format.ASTC_RGBA_4X4:
          case Format.ASTC_RGBA_5X4:
          case Format.ASTC_RGBA_5X5:
          case Format.ASTC_RGBA_6X5:
          case Format.ASTC_RGBA_6X6:
          case Format.ASTC_RGBA_8X5:
          case Format.ASTC_RGBA_8X6:
          case Format.ASTC_RGBA_8X8:
          case Format.ASTC_RGBA_10X5:
          case Format.ASTC_RGBA_10X6:
          case Format.ASTC_RGBA_10X8:
          case Format.ASTC_RGBA_10X10:
          case Format.ASTC_RGBA_12X10:
          case Format.ASTC_RGBA_12X12:
          case Format.ASTC_SRGBA_4X4:
          case Format.ASTC_SRGBA_5X4:
          case Format.ASTC_SRGBA_5X5:
          case Format.ASTC_SRGBA_6X5:
          case Format.ASTC_SRGBA_6X6:
          case Format.ASTC_SRGBA_8X5:
          case Format.ASTC_SRGBA_8X6:
          case Format.ASTC_SRGBA_8X8:
          case Format.ASTC_SRGBA_10X5:
          case Format.ASTC_SRGBA_10X6:
          case Format.ASTC_SRGBA_10X8:
          case Format.ASTC_SRGBA_10X10:
          case Format.ASTC_SRGBA_12X10:
          case Format.ASTC_SRGBA_12X12:
            return gl.UNSIGNED_BYTE;

          default:
            {
              return gl.UNSIGNED_BYTE;
            }
        }
      }
      function GFXFormatToWebGLInternalFormat(format, gl) {
        switch (format) {
          case Format.R5G6B5:
            return gl.RGB565;

          case Format.RGB5A1:
            return gl.RGB5_A1;

          case Format.RGBA4:
            return gl.RGBA4;

          case Format.RGBA16F:
            return WebGLEXT.RGBA16F_EXT;

          case Format.RGBA32F:
            return WebGLEXT.RGBA32F_EXT;

          case Format.SRGB8_A8:
            return WebGLEXT.SRGB8_ALPHA8_EXT;

          case Format.DEPTH:
            return gl.DEPTH_COMPONENT16;

          case Format.DEPTH_STENCIL:
            return gl.DEPTH_STENCIL;

          default:
            {
              console.error('Unsupported Format, convert to WebGL internal format failed.');
              return gl.RGBA;
            }
        }
      }
      function GFXFormatToWebGLFormat(format, gl) {
        switch (format) {
          case Format.A8:
            return gl.ALPHA;

          case Format.L8:
            return gl.LUMINANCE;

          case Format.LA8:
            return gl.LUMINANCE_ALPHA;

          case Format.RGB8:
            return gl.RGB;

          case Format.RGB16F:
            return gl.RGB;

          case Format.RGB32F:
            return gl.RGB;

          case Format.BGRA8:
            return gl.RGBA;

          case Format.RGBA8:
            return gl.RGBA;

          case Format.SRGB8_A8:
            return gl.RGBA;

          case Format.RGBA16F:
            return gl.RGBA;

          case Format.RGBA32F:
            return gl.RGBA;

          case Format.R5G6B5:
            return gl.RGB;

          case Format.RGB5A1:
            return gl.RGBA;

          case Format.RGBA4:
            return gl.RGBA;

          case Format.DEPTH:
            return gl.DEPTH_COMPONENT;

          case Format.DEPTH_STENCIL:
            return gl.DEPTH_STENCIL;

          case Format.BC1:
            return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

          case Format.BC1_ALPHA:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

          case Format.BC1_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

          case Format.BC1_SRGB_ALPHA:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

          case Format.BC2:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

          case Format.BC2_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

          case Format.BC3:
            return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

          case Format.BC3_SRGB:
            return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

          case Format.ETC_RGB8:
            return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

          case Format.ETC2_RGB8:
            return WebGLEXT.COMPRESSED_RGB8_ETC2;

          case Format.ETC2_SRGB8:
            return WebGLEXT.COMPRESSED_SRGB8_ETC2;

          case Format.ETC2_RGB8_A1:
            return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case Format.ETC2_SRGB8_A1:
            return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

          case Format.ETC2_RGBA8:
            return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

          case Format.ETC2_SRGB8_A8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

          case Format.EAC_R11:
            return WebGLEXT.COMPRESSED_R11_EAC;

          case Format.EAC_R11SN:
            return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

          case Format.EAC_RG11:
            return WebGLEXT.COMPRESSED_RG11_EAC;

          case Format.EAC_RG11SN:
            return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

          case Format.PVRTC_RGB2:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

          case Format.PVRTC_RGBA2:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

          case Format.PVRTC_RGB4:
            return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

          case Format.PVRTC_RGBA4:
            return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

          case Format.ASTC_RGBA_4X4:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

          case Format.ASTC_RGBA_5X4:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

          case Format.ASTC_RGBA_5X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

          case Format.ASTC_RGBA_6X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

          case Format.ASTC_RGBA_6X6:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

          case Format.ASTC_RGBA_8X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

          case Format.ASTC_RGBA_8X6:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

          case Format.ASTC_RGBA_8X8:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

          case Format.ASTC_RGBA_10X5:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

          case Format.ASTC_RGBA_10X6:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

          case Format.ASTC_RGBA_10X8:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

          case Format.ASTC_RGBA_10X10:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

          case Format.ASTC_RGBA_12X10:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

          case Format.ASTC_RGBA_12X12:
            return WebGLEXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

          case Format.ASTC_SRGBA_4X4:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

          case Format.ASTC_SRGBA_5X4:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

          case Format.ASTC_SRGBA_5X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

          case Format.ASTC_SRGBA_6X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

          case Format.ASTC_SRGBA_6X6:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

          case Format.ASTC_SRGBA_8X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

          case Format.ASTC_SRGBA_8X6:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

          case Format.ASTC_SRGBA_8X8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

          case Format.ASTC_SRGBA_10X5:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

          case Format.ASTC_SRGBA_10X6:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

          case Format.ASTC_SRGBA_10X8:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

          case Format.ASTC_SRGBA_10X10:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

          case Format.ASTC_SRGBA_12X10:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

          case Format.ASTC_SRGBA_12X12:
            return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

          default:
            {
              console.error('Unsupported Format, convert to WebGL format failed.');
              return gl.RGBA;
            }
        }
      }

      function GFXTypeToWebGLType(type, gl) {
        switch (type) {
          case Type.BOOL:
            return gl.BOOL;

          case Type.BOOL2:
            return gl.BOOL_VEC2;

          case Type.BOOL3:
            return gl.BOOL_VEC3;

          case Type.BOOL4:
            return gl.BOOL_VEC4;

          case Type.INT:
            return gl.INT;

          case Type.INT2:
            return gl.INT_VEC2;

          case Type.INT3:
            return gl.INT_VEC3;

          case Type.INT4:
            return gl.INT_VEC4;

          case Type.UINT:
            return gl.UNSIGNED_INT;

          case Type.FLOAT:
            return gl.FLOAT;

          case Type.FLOAT2:
            return gl.FLOAT_VEC2;

          case Type.FLOAT3:
            return gl.FLOAT_VEC3;

          case Type.FLOAT4:
            return gl.FLOAT_VEC4;

          case Type.MAT2:
            return gl.FLOAT_MAT2;

          case Type.MAT3:
            return gl.FLOAT_MAT3;

          case Type.MAT4:
            return gl.FLOAT_MAT4;

          case Type.SAMPLER2D:
            return gl.SAMPLER_2D;

          case Type.SAMPLER_CUBE:
            return gl.SAMPLER_CUBE;

          default:
            {
              console.error('Unsupported GLType, convert to GL type failed.');
              return Type.UNKNOWN;
            }
        }
      }

      function GFXTypeToTypedArrayCtor(type) {
        switch (type) {
          case Type.BOOL:
          case Type.BOOL2:
          case Type.BOOL3:
          case Type.BOOL4:
          case Type.INT:
          case Type.INT2:
          case Type.INT3:
          case Type.INT4:
          case Type.UINT:
            return Int32Array;

          case Type.FLOAT:
          case Type.FLOAT2:
          case Type.FLOAT3:
          case Type.FLOAT4:
          case Type.MAT2:
          case Type.MAT3:
          case Type.MAT4:
            return Float32Array;

          default:
            {
              console.error('Unsupported GLType, convert to TypedArrayConstructor failed.');
              return Float32Array;
            }
        }
      }

      function WebGLTypeToGFXType(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return Type.BOOL;

          case gl.BOOL_VEC2:
            return Type.BOOL2;

          case gl.BOOL_VEC3:
            return Type.BOOL3;

          case gl.BOOL_VEC4:
            return Type.BOOL4;

          case gl.INT:
            return Type.INT;

          case gl.INT_VEC2:
            return Type.INT2;

          case gl.INT_VEC3:
            return Type.INT3;

          case gl.INT_VEC4:
            return Type.INT4;

          case gl.UNSIGNED_INT:
            return Type.UINT;

          case gl.FLOAT:
            return Type.FLOAT;

          case gl.FLOAT_VEC2:
            return Type.FLOAT2;

          case gl.FLOAT_VEC3:
            return Type.FLOAT3;

          case gl.FLOAT_VEC4:
            return Type.FLOAT4;

          case gl.FLOAT_MAT2:
            return Type.MAT2;

          case gl.FLOAT_MAT3:
            return Type.MAT3;

          case gl.FLOAT_MAT4:
            return Type.MAT4;

          case gl.SAMPLER_2D:
            return Type.SAMPLER2D;

          case gl.SAMPLER_CUBE:
            return Type.SAMPLER_CUBE;

          default:
            {
              console.error('Unsupported GLType, convert to Type failed.');
              return Type.UNKNOWN;
            }
        }
      }

      function WebGLGetTypeSize(glType, gl) {
        switch (glType) {
          case gl.BOOL:
            return 4;

          case gl.BOOL_VEC2:
            return 8;

          case gl.BOOL_VEC3:
            return 12;

          case gl.BOOL_VEC4:
            return 16;

          case gl.INT:
            return 4;

          case gl.INT_VEC2:
            return 8;

          case gl.INT_VEC3:
            return 12;

          case gl.INT_VEC4:
            return 16;

          case gl.UNSIGNED_INT:
            return 4;

          case gl.FLOAT:
            return 4;

          case gl.FLOAT_VEC2:
            return 8;

          case gl.FLOAT_VEC3:
            return 12;

          case gl.FLOAT_VEC4:
            return 16;

          case gl.FLOAT_MAT2:
            return 16;

          case gl.FLOAT_MAT3:
            return 36;

          case gl.FLOAT_MAT4:
            return 64;

          case gl.SAMPLER_2D:
            return 4;

          case gl.SAMPLER_CUBE:
            return 4;

          default:
            {
              console.error('Unsupported GLType, get type failed.');
              return 0;
            }
        }
      }

      function WebGLGetComponentCount(glType, gl) {
        switch (glType) {
          case gl.FLOAT_MAT2:
            return 2;

          case gl.FLOAT_MAT3:
            return 3;

          case gl.FLOAT_MAT4:
            return 4;

          default:
            {
              return 1;
            }
        }
      }

      var WebGLCmpFuncs = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
      var WebGLStencilOps = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
      var WebGLBlendOps = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
      var WebGLBlendFactors = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
      var WebGLCmd;

      (function (WebGLCmd) {
        WebGLCmd[WebGLCmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
        WebGLCmd[WebGLCmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
        WebGLCmd[WebGLCmd["BIND_STATES"] = 2] = "BIND_STATES";
        WebGLCmd[WebGLCmd["DRAW"] = 3] = "DRAW";
        WebGLCmd[WebGLCmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
        WebGLCmd[WebGLCmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
        WebGLCmd[WebGLCmd["COUNT"] = 6] = "COUNT";
      })(WebGLCmd || (WebGLCmd = {}));

      var WebGLCmdObject = function WebGLCmdObject(type) {
        this.cmdType = void 0;
        this.refCount = 0;
        this.cmdType = type;
      };
      var WebGLCmdBeginRenderPass = function (_WebGLCmdObject) {
        _inheritsLoose(WebGLCmdBeginRenderPass, _WebGLCmdObject);

        function WebGLCmdBeginRenderPass() {
          var _this;

          _this = _WebGLCmdObject.call(this, WebGLCmd.BEGIN_RENDER_PASS) || this;
          _this.gpuRenderPass = null;
          _this.gpuFramebuffer = null;
          _this.renderArea = new Rect$1();
          _this.clearFlag = ClearFlagBit.NONE;
          _this.clearColors = [];
          _this.clearDepth = 1.0;
          _this.clearStencil = 0;
          return _this;
        }

        var _proto = WebGLCmdBeginRenderPass.prototype;

        _proto.clear = function clear() {
          this.gpuFramebuffer = null;
          this.clearColors.length = 0;
        };

        return WebGLCmdBeginRenderPass;
      }(WebGLCmdObject);
      var WebGLCmdBindStates = function (_WebGLCmdObject2) {
        _inheritsLoose(WebGLCmdBindStates, _WebGLCmdObject2);

        function WebGLCmdBindStates() {
          var _this2;

          _this2 = _WebGLCmdObject2.call(this, WebGLCmd.BIND_STATES) || this;
          _this2.gpuPipelineState = null;
          _this2.gpuInputAssembler = null;
          _this2.gpuDescriptorSets = [];
          _this2.dynamicOffsets = [];
          _this2.dynamicStates = new DynamicStates();
          return _this2;
        }

        var _proto2 = WebGLCmdBindStates.prototype;

        _proto2.clear = function clear() {
          this.gpuPipelineState = null;
          this.gpuDescriptorSets.length = 0;
          this.gpuInputAssembler = null;
          this.dynamicOffsets.length = 0;
        };

        return WebGLCmdBindStates;
      }(WebGLCmdObject);
      var WebGLCmdDraw = function (_WebGLCmdObject3) {
        _inheritsLoose(WebGLCmdDraw, _WebGLCmdObject3);

        function WebGLCmdDraw() {
          var _this3;

          _this3 = _WebGLCmdObject3.call(this, WebGLCmd.DRAW) || this;
          _this3.drawInfo = new DrawInfo();
          return _this3;
        }

        var _proto3 = WebGLCmdDraw.prototype;

        _proto3.clear = function clear() {};

        return WebGLCmdDraw;
      }(WebGLCmdObject);
      var WebGLCmdUpdateBuffer = function (_WebGLCmdObject4) {
        _inheritsLoose(WebGLCmdUpdateBuffer, _WebGLCmdObject4);

        function WebGLCmdUpdateBuffer() {
          var _this4;

          _this4 = _WebGLCmdObject4.call(this, WebGLCmd.UPDATE_BUFFER) || this;
          _this4.gpuBuffer = null;
          _this4.buffer = null;
          _this4.offset = 0;
          _this4.size = 0;
          return _this4;
        }

        var _proto4 = WebGLCmdUpdateBuffer.prototype;

        _proto4.clear = function clear() {
          this.gpuBuffer = null;
          this.buffer = null;
        };

        return WebGLCmdUpdateBuffer;
      }(WebGLCmdObject);
      var WebGLCmdCopyBufferToTexture = function (_WebGLCmdObject5) {
        _inheritsLoose(WebGLCmdCopyBufferToTexture, _WebGLCmdObject5);

        function WebGLCmdCopyBufferToTexture() {
          var _this5;

          _this5 = _WebGLCmdObject5.call(this, WebGLCmd.COPY_BUFFER_TO_TEXTURE) || this;
          _this5.gpuTexture = null;
          _this5.buffers = [];
          _this5.regions = [];
          return _this5;
        }

        var _proto5 = WebGLCmdCopyBufferToTexture.prototype;

        _proto5.clear = function clear() {
          this.gpuTexture = null;
          this.buffers.length = 0;
          this.regions.length = 0;
        };

        return WebGLCmdCopyBufferToTexture;
      }(WebGLCmdObject);
      var WebGLCmdPackage = function () {
        function WebGLCmdPackage() {
          this.cmds = new CachedArray(1);
          this.beginRenderPassCmds = new CachedArray(1);
          this.bindStatesCmds = new CachedArray(1);
          this.drawCmds = new CachedArray(1);
          this.updateBufferCmds = new CachedArray(1);
          this.copyBufferToTextureCmds = new CachedArray(1);
        }

        var _proto6 = WebGLCmdPackage.prototype;

        _proto6.clearCmds = function clearCmds(allocator) {
          if (this.beginRenderPassCmds.length) {
            allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
            this.beginRenderPassCmds.clear();
          }

          if (this.bindStatesCmds.length) {
            allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
            this.bindStatesCmds.clear();
          }

          if (this.drawCmds.length) {
            allocator.drawCmdPool.freeCmds(this.drawCmds);
            this.drawCmds.clear();
          }

          if (this.updateBufferCmds.length) {
            allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
            this.updateBufferCmds.clear();
          }

          if (this.copyBufferToTextureCmds.length) {
            allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
            this.copyBufferToTextureCmds.clear();
          }

          this.cmds.clear();
        };

        return WebGLCmdPackage;
      }();
      function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
        var gl = device.gl;
        var cache = device.stateCache;
        var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          gpuBuffer.glTarget = gl.ARRAY_BUFFER;
          var glBuffer = gl.createBuffer();

          if (glBuffer) {
            gpuBuffer.glBuffer = glBuffer;

            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  cache.glVAO = null;
                }
              }

              gfxStateCache.gpuInputAssembler = null;

              if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
              }

              gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;

          var _glBuffer = gl.createBuffer();

          if (_glBuffer) {
            gpuBuffer.glBuffer = _glBuffer;

            if (gpuBuffer.size > 0) {
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  cache.glVAO = null;
                }
              }

              gfxStateCache.gpuInputAssembler = null;

              if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
              }

              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
            }
          }
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          gpuBuffer.glTarget = gl.NONE;

          if (gpuBuffer.buffer) {
            gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
          gpuBuffer.glTarget = gl.NONE;
        } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          console.error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
        var gl = device.gl;
        var cache = device.stateCache;

        if (gpuBuffer.glBuffer) {
          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  device.stateCache.glVAO = null;
                }
              }

              gfxStateCache.gpuInputAssembler = null;
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              device.stateCache.glArrayBuffer = null;
              break;

            case gl.ELEMENT_ARRAY_BUFFER:
              if (device.extensions.useVAO) {
                if (cache.glVAO) {
                  device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                  device.stateCache.glVAO = null;
                }
              }

              gfxStateCache.gpuInputAssembler = null;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              device.stateCache.glElementArrayBuffer = null;
              break;
          }

          gl.deleteBuffer(gpuBuffer.glBuffer);
          gpuBuffer.glBuffer = null;
        }
      }
      function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
        var gl = device.gl;
        var cache = device.stateCache;
        var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

        if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
              cache.glVAO = null;
            }
          }

          gfxStateCache.gpuInputAssembler = null;

          if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
          }

          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }

          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          device.stateCache.glArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
          if (device.extensions.useVAO) {
            if (cache.glVAO) {
              device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
              cache.glVAO = null;
            }
          }

          gfxStateCache.gpuInputAssembler = null;

          if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
          }

          if (gpuBuffer.buffer) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
          } else {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
          }

          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          device.stateCache.glElementArrayBuffer = null;
        } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          if (gpuBuffer.buffer) {
            gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
          gpuBuffer.glTarget = gl.NONE;
        } else {
          console.error('Unsupported BufferType, create buffer failed.');
          gpuBuffer.glTarget = gl.NONE;
        }
      }
      function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
        if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
          if (ArrayBuffer.isView(buffer)) {
            gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT);
          } else {
            gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT);
          }
        } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
          gpuBuffer.indirects.clearDraws();
          var drawInfos = buffer.drawInfos;

          for (var i = 0; i < drawInfos.length; ++i) {
            gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
          }
        } else {
          var buff = buffer;
          var gl = device.gl;
          var cache = device.stateCache;

          switch (gpuBuffer.glTarget) {
            case gl.ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache.gpuInputAssembler = null;

                if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                  device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                }

                break;
              }

            case gl.ELEMENT_ARRAY_BUFFER:
              {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache.gpuInputAssembler = null;

                if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                  device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                }

                break;
              }

            default:
              {
                console.error('Unsupported BufferType, update buffer failed.');
                return;
              }
          }

          if (size === buff.byteLength) {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
          } else {
            gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
          }
        }
      }
      function WebGLCmdFuncCreateTexture(device, gpuTexture) {
        var gl = device.gl;
        gpuTexture.glFormat = gpuTexture.glInternalFmt = GFXFormatToWebGLFormat(gpuTexture.format, gl);
        gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
        var w = gpuTexture.width;
        var h = gpuTexture.height;

        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              if (gpuTexture.isSwapchainTexture) break;
              var maxSize = Math.max(w, h);

              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }

              if (!device.textureExclusive[gpuTexture.format] && !device.extensions.WEBGL_depth_texture && FormatInfos[gpuTexture.format].hasDepth) {
                gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl);
                gpuTexture.glRenderbuffer = gl.createRenderbuffer();

                if (gpuTexture.size > 0) {
                  if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                    gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                    device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                  }

                  gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
                }
              } else {
                gpuTexture.glTexture = gl.createTexture();

                if (gpuTexture.size > 0) {
                  var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                  if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                    gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                    glTexUnit.glTexture = gpuTexture.glTexture;
                  }

                  if (FormatInfos[gpuTexture.format].isCompressed) {
                    for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                      var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                      var view = new Uint8Array(imgSize);
                      gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  } else {
                    for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                      gl.texImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  }

                  if (gpuTexture.isPowerOf2) {
                    gpuTexture.glWrapS = gl.REPEAT;
                    gpuTexture.glWrapT = gl.REPEAT;
                  } else {
                    gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                    gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                  }

                  gpuTexture.glMinFilter = gl.LINEAR;
                  gpuTexture.glMagFilter = gl.LINEAR;
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                }
              }

              break;
            }

          case TextureType.CUBE:
            {
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

              var _maxSize = Math.max(w, h);

              if (_maxSize > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, _maxSize, device.capabilities.maxTextureSize);
              }

              gpuTexture.glTexture = gl.createTexture();

              if (gpuTexture.size > 0) {
                var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                if (_glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                  _glTexUnit.glTexture = gpuTexture.glTexture;
                }

                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (var f = 0; f < 6; ++f) {
                    w = gpuTexture.width;
                    h = gpuTexture.height;

                    for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) {
                      var _imgSize = FormatSize(gpuTexture.format, w, h, 1);

                      var _view = new Uint8Array(_imgSize);

                      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternalFmt, w, h, 0, _view);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  }
                } else {
                  for (var _f = 0; _f < 6; ++_f) {
                    w = gpuTexture.width;
                    h = gpuTexture.height;

                    for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                      w = Math.max(1, w >> 1);
                      h = Math.max(1, h >> 1);
                    }
                  }
                }

                if (gpuTexture.isPowerOf2) {
                  gpuTexture.glWrapS = gl.REPEAT;
                  gpuTexture.glWrapT = gl.REPEAT;
                } else {
                  gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                  gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                }

                gpuTexture.glMinFilter = gl.LINEAR;
                gpuTexture.glMagFilter = gl.LINEAR;
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
              }

              break;
            }

          default:
            {
              console.error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
        var gl = device.gl;

        if (gpuTexture.glTexture) {
          var glTexUnits = device.stateCache.glTexUnits;
          var texUnit = device.stateCache.texUnit;
          gl.deleteTexture(gpuTexture.glTexture);

          for (var i = 0; i < glTexUnits.length; i++) {
            if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
              gl.activeTexture(gl.TEXTURE0 + i);
              texUnit = i;
              gl.bindTexture(gpuTexture.glTarget, null);
              glTexUnits[i].glTexture = null;
            }
          }

          device.stateCache.texUnit = texUnit;
          gpuTexture.glTexture = null;
        }

        if (gpuTexture.glRenderbuffer) {
          var glRenderbuffer = device.stateCache.glRenderbuffer;
          gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);

          if (glRenderbuffer === gpuTexture.glRenderbuffer) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            glRenderbuffer = null;
          }

          gpuTexture.glRenderbuffer = null;
        }
      }
      function WebGLCmdFuncResizeTexture(device, gpuTexture) {
        if (!gpuTexture.size) return;
        var gl = device.gl;
        var w = gpuTexture.width;
        var h = gpuTexture.height;

        switch (gpuTexture.type) {
          case TextureType.TEX2D:
            {
              gpuTexture.glTarget = gl.TEXTURE_2D;
              var maxSize = Math.max(w, h);

              if (maxSize > device.capabilities.maxTextureSize) {
                errorID(9100, maxSize, device.capabilities.maxTextureSize);
              }

              if (gpuTexture.glRenderbuffer) {
                if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                  device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                }

                gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
              } else if (gpuTexture.glTexture) {
                var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                  glTexUnit.glTexture = gpuTexture.glTexture;
                }

                if (FormatInfos[gpuTexture.format].isCompressed) {
                  for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                    var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                    var view = new Uint8Array(imgSize);
                    gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                } else {
                  for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                    gl.texImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              }

              break;
            }

          case TextureType.CUBE:
            {
              gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

              var _maxSize2 = Math.max(w, h);

              if (_maxSize2 > device.capabilities.maxCubeMapTextureSize) {
                errorID(9100, _maxSize2, device.capabilities.maxTextureSize);
              }

              var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (_glTexUnit2.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                _glTexUnit2.glTexture = gpuTexture.glTexture;
              }

              if (FormatInfos[gpuTexture.format].isCompressed) {
                for (var f = 0; f < 6; ++f) {
                  w = gpuTexture.width;
                  h = gpuTexture.height;

                  for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) {
                    var _imgSize2 = FormatSize(gpuTexture.format, w, h, 1);

                    var _view2 = new Uint8Array(_imgSize2);

                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternalFmt, w, h, 0, _view2);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              } else {
                for (var _f2 = 0; _f2 < 6; ++_f2) {
                  w = gpuTexture.width;
                  h = gpuTexture.height;

                  for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, _i6, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                    w = Math.max(1, w >> 1);
                    h = Math.max(1, h >> 1);
                  }
                }
              }

              break;
            }

          default:
            {
              console.error('Unsupported TextureType, create texture failed.');
              gpuTexture.type = TextureType.TEX2D;
              gpuTexture.glTarget = gl.TEXTURE_2D;
            }
        }
      }
      function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
        for (var i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
          var tex = gpuFramebuffer.gpuColorTextures[i];

          if (tex.isSwapchainTexture) {
            gpuFramebuffer.isOffscreen = false;
            return;
          }
        }

        var gl = device.gl;
        var attachments = [];
        var glFramebuffer = gl.createFramebuffer();

        if (glFramebuffer) {
          gpuFramebuffer.glFramebuffer = glFramebuffer;

          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
          }

          for (var _i7 = 0; _i7 < gpuFramebuffer.gpuColorTextures.length; ++_i7) {
            var gpuTexture = gpuFramebuffer.gpuColorTextures[_i7];

            if (gpuTexture) {
              if (gpuTexture.glTexture) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i7, gpuTexture.glTarget, gpuTexture.glTexture, 0);
              } else {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i7, gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
              }

              attachments.push(gl.COLOR_ATTACHMENT0 + _i7);
              gpuFramebuffer.width = Math.min(gpuFramebuffer.width, gpuTexture.width);
              gpuFramebuffer.height = Math.min(gpuFramebuffer.height, gpuTexture.height);
            }
          }

          var dst = gpuFramebuffer.gpuDepthStencilTexture;

          if (dst) {
            var glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

            if (dst.glTexture) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, 0);
            } else {
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
            }

            gpuFramebuffer.width = Math.min(gpuFramebuffer.width, dst.width);
            gpuFramebuffer.height = Math.min(gpuFramebuffer.height, dst.height);
          }

          if (device.extensions.WEBGL_draw_buffers) {
            device.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
          }

          var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

          if (status !== gl.FRAMEBUFFER_COMPLETE) {
            switch (status) {
              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                  break;
                }

              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                  break;
                }

              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                  break;
                }

              case gl.FRAMEBUFFER_UNSUPPORTED:
                {
                  console.error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                  break;
                }
            }
          }

          if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
          }
        }
      }
      function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
        if (gpuFramebuffer.glFramebuffer) {
          device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);

          if (device.stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
            device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, null);
            device.stateCache.glFramebuffer = null;
          }

          gpuFramebuffer.glFramebuffer = null;
        }
      }
      function WebGLCmdFuncCreateShader(device, gpuShader) {
        var gl = device.gl;

        var _loop = function _loop(k) {
          var gpuStage = gpuShader.gpuStages[k];
          var glShaderType = 0;
          var shaderTypeStr = '';
          var lineNumber = 1;

          switch (gpuStage.type) {
            case ShaderStageFlagBit.VERTEX:
              {
                shaderTypeStr = 'VertexShader';
                glShaderType = gl.VERTEX_SHADER;
                break;
              }

            case ShaderStageFlagBit.FRAGMENT:
              {
                shaderTypeStr = 'FragmentShader';
                glShaderType = gl.FRAGMENT_SHADER;
                break;
              }

            default:
              {
                console.error('Unsupported ShaderType.');
                return {
                  v: void 0
                };
              }
          }

          var glShader = gl.createShader(glShaderType);

          if (glShader) {
            gpuStage.glShader = glShader;
            gl.shaderSource(gpuStage.glShader, gpuStage.source);
            gl.compileShader(gpuStage.glShader);

            if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
              console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed.");
              console.error('Shader source dump:', gpuStage.source.replace(/^|\n/g, function () {
                return "\n" + lineNumber++ + " ";
              }));
              console.error(gl.getShaderInfoLog(gpuStage.glShader));

              for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                var stage = gpuShader.gpuStages[k];

                if (stage.glShader) {
                  gl.deleteShader(stage.glShader);
                  stage.glShader = null;
                }
              }

              return {
                v: void 0
              };
            }
          }
        };

        for (var k = 0; k < gpuShader.gpuStages.length; k++) {
          var _ret = _loop(k);

          if (typeof _ret === "object") return _ret.v;
        }

        var glProgram = gl.createProgram();

        if (!glProgram) {
          return;
        }

        gpuShader.glProgram = glProgram;

        for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
          var gpuStage = gpuShader.gpuStages[_k];
          gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
        }

        gl.linkProgram(gpuShader.glProgram);

        if (device.extensions.destroyShadersImmediately) {
          for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
            var _gpuStage = gpuShader.gpuStages[_k2];

            if (_gpuStage.glShader) {
              gl.detachShader(gpuShader.glProgram, _gpuStage.glShader);
              gl.deleteShader(_gpuStage.glShader);
              _gpuStage.glShader = null;
            }
          }
        }

        if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
          debug("Shader '" + gpuShader.name + "' compilation succeeded.");
        } else {
          console.error("Failed to link shader '" + gpuShader.name + "'.");
          console.error(gl.getProgramInfoLog(gpuShader.glProgram));
          return;
        }

        var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
        gpuShader.glInputs = new Array(activeAttribCount);

        for (var i = 0; i < activeAttribCount; ++i) {
          var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);

          if (attribInfo) {
            var varName = void 0;
            var nameOffset = attribInfo.name.indexOf('[');

            if (nameOffset !== -1) {
              varName = attribInfo.name.substr(0, nameOffset);
            } else {
              varName = attribInfo.name;
            }

            var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
            var type = WebGLTypeToGFXType(attribInfo.type, gl);
            var stride = WebGLGetTypeSize(attribInfo.type, gl);
            gpuShader.glInputs[i] = {
              binding: glLoc,
              name: varName,
              type: type,
              stride: stride,
              count: attribInfo.size,
              size: stride * attribInfo.size,
              glType: attribInfo.type,
              glLoc: glLoc
            };
          }
        }

        if (gpuShader.blocks.length > 0) {
          gpuShader.glBlocks = new Array(gpuShader.blocks.length);

          for (var _i8 = 0; _i8 < gpuShader.blocks.length; ++_i8) {
            var block = gpuShader.blocks[_i8];
            var glBlock = {
              set: block.set,
              binding: block.binding,
              name: block.name,
              size: 0,
              glUniforms: new Array(block.members.length),
              glActiveUniforms: []
            };
            gpuShader.glBlocks[_i8] = glBlock;

            for (var u = 0; u < block.members.length; ++u) {
              var uniform = block.members[u];
              var glType = GFXTypeToWebGLType(uniform.type, gl);

              var _stride = WebGLGetTypeSize(glType, gl);

              var size = _stride * uniform.count;
              glBlock.glUniforms[u] = {
                binding: -1,
                name: uniform.name,
                type: uniform.type,
                stride: _stride,
                count: uniform.count,
                size: size,
                offset: 0,
                glType: glType,
                glLoc: null,
                array: null
              };
            }
          }
        }

        for (var _i9 = 0; _i9 < gpuShader.subpassInputs.length; ++_i9) {
          var subpassInput = gpuShader.subpassInputs[_i9];
          gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, Type.SAMPLER2D, subpassInput.count));
        }

        if (gpuShader.samplerTextures.length > 0) {
          gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);

          for (var _i10 = 0; _i10 < gpuShader.samplerTextures.length; ++_i10) {
            var sampler = gpuShader.samplerTextures[_i10];
            gpuShader.glSamplerTextures[_i10] = {
              set: sampler.set,
              binding: sampler.binding,
              name: sampler.name,
              type: sampler.type,
              count: sampler.count,
              units: [],
              glUnits: null,
              glType: GFXTypeToWebGLType(sampler.type, gl),
              glLoc: null
            };
          }
        }

        var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS);

        for (var _i11 = 0; _i11 < activeUniformCount; ++_i11) {
          var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i11);

          if (uniformInfo) {
            var isSampler = uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE;

            if (!isSampler) {
              var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);

              if (device.extensions.isLocationActive(_glLoc)) {
                var _varName = void 0;

                var _nameOffset = uniformInfo.name.indexOf('[');

                if (_nameOffset !== -1) {
                  _varName = uniformInfo.name.substr(0, _nameOffset);
                } else {
                  _varName = uniformInfo.name;
                }

                for (var j = 0; j < gpuShader.glBlocks.length; j++) {
                  var _glBlock = gpuShader.glBlocks[j];

                  for (var _k3 = 0; _k3 < _glBlock.glUniforms.length; _k3++) {
                    var glUniform = _glBlock.glUniforms[_k3];

                    if (glUniform.name === _varName) {
                      glUniform.glLoc = _glLoc;
                      glUniform.count = uniformInfo.size;
                      glUniform.size = glUniform.stride * glUniform.count;
                      glUniform.array = new (GFXTypeToTypedArrayCtor(glUniform.type))(glUniform.size / 4);

                      _glBlock.glActiveUniforms.push(glUniform);

                      break;
                    }
                  }
                }
              }
            }
          }
        }

        for (var _j = 0; _j < gpuShader.glBlocks.length; _j++) {
          var _glBlock2 = gpuShader.glBlocks[_j];

          for (var _k4 = 0; _k4 < _glBlock2.glUniforms.length; _k4++) {
            var _glUniform = _glBlock2.glUniforms[_k4];
            _glUniform.offset = _glBlock2.size / 4;
            _glBlock2.size += _glUniform.size;
          }
        }

        var glActiveSamplers = [];
        var glActiveSamplerLocations = [];
        var bindingMappings = device.bindingMappings;
        var texUnitCacheMap = device.stateCache.texUnitCacheMap;
        var flexibleSetBaseOffset = 0;

        for (var _i12 = 0; _i12 < gpuShader.blocks.length; ++_i12) {
          if (gpuShader.blocks[_i12].set === bindingMappings.flexibleSet) {
            flexibleSetBaseOffset++;
          }
        }

        var arrayOffset = 0;

        for (var _i13 = 0; _i13 < gpuShader.samplerTextures.length; ++_i13) {
          var _sampler = gpuShader.samplerTextures[_i13];

          var _glLoc2 = gl.getUniformLocation(gpuShader.glProgram, _sampler.name);

          if (device.extensions.isLocationActive(_glLoc2)) {
            glActiveSamplers.push(gpuShader.glSamplerTextures[_i13]);
            glActiveSamplerLocations.push(_glLoc2);
          }

          if (texUnitCacheMap[_sampler.name] === undefined) {
            var binding = _sampler.binding + bindingMappings.samplerTextureOffsets[_sampler.set] + arrayOffset;

            if (_sampler.set === bindingMappings.flexibleSet) {
              binding -= flexibleSetBaseOffset;
            }

            texUnitCacheMap[_sampler.name] = binding % device.capabilities.maxTextureUnits;
            arrayOffset += _sampler.count - 1;
          }
        }

        if (glActiveSamplers.length) {
          var usedTexUnits = [];

          for (var _i14 = 0; _i14 < glActiveSamplers.length; ++_i14) {
            var glSampler = glActiveSamplers[_i14];
            var cachedUnit = texUnitCacheMap[glSampler.name];

            if (cachedUnit !== undefined) {
              glSampler.glLoc = glActiveSamplerLocations[_i14];

              for (var t = 0; t < glSampler.count; ++t) {
                while (usedTexUnits[cachedUnit]) {
                  cachedUnit = (cachedUnit + 1) % device.capabilities.maxTextureUnits;
                }

                glSampler.units.push(cachedUnit);
                usedTexUnits[cachedUnit] = true;
              }
            }
          }

          var unitIdx = 0;

          for (var _i15 = 0; _i15 < glActiveSamplers.length; ++_i15) {
            var _glSampler = glActiveSamplers[_i15];

            if (!device.extensions.isLocationActive(_glSampler.glLoc)) {
              _glSampler.glLoc = glActiveSamplerLocations[_i15];

              for (var _t = 0; _t < _glSampler.count; ++_t) {
                while (usedTexUnits[unitIdx]) {
                  unitIdx = (unitIdx + 1) % device.capabilities.maxTextureUnits;
                }

                if (texUnitCacheMap[_glSampler.name] === undefined) {
                  texUnitCacheMap[_glSampler.name] = unitIdx;
                }

                _glSampler.units.push(unitIdx);

                usedTexUnits[unitIdx] = true;
              }
            }
          }

          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(gpuShader.glProgram);
          }

          for (var _i16 = 0; _i16 < glActiveSamplers.length; _i16++) {
            var _glSampler2 = glActiveSamplers[_i16];
            _glSampler2.glUnits = new Int32Array(_glSampler2.units);
            gl.uniform1iv(_glSampler2.glLoc, _glSampler2.glUnits);
          }

          if (device.stateCache.glProgram !== gpuShader.glProgram) {
            gl.useProgram(device.stateCache.glProgram);
          }
        }

        for (var _i17 = 0; _i17 < gpuShader.glBlocks.length;) {
          if (gpuShader.glBlocks[_i17].glActiveUniforms.length) {
            _i17++;
          } else {
            gpuShader.glBlocks[_i17] = gpuShader.glBlocks[gpuShader.glBlocks.length - 1];
            gpuShader.glBlocks.length--;
          }
        }

        gpuShader.glSamplerTextures = glActiveSamplers;
      }
      function WebGLCmdFuncDestroyShader(device, gpuShader) {
        if (gpuShader.glProgram) {
          var gl = device.gl;

          if (!device.extensions.destroyShadersImmediately) {
            for (var k = 0; k < gpuShader.gpuStages.length; k++) {
              var gpuStage = gpuShader.gpuStages[k];

              if (gpuStage.glShader) {
                gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
                gl.deleteShader(gpuStage.glShader);
                gpuStage.glShader = null;
              }
            }
          }

          gl.deleteProgram(gpuShader.glProgram);

          if (device.stateCache.glProgram === gpuShader.glProgram) {
            device.gl.useProgram(null);
            device.stateCache.glProgram = null;
          }

          gpuShader.glProgram = null;
        }
      }
      function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
        var gl = device.gl;
        gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
        var offsets = [0, 0, 0, 0, 0, 0, 0, 0];

        for (var i = 0; i < gpuInputAssembler.attributes.length; ++i) {
          var attrib = gpuInputAssembler.attributes[i];
          var stream = attrib.stream !== undefined ? attrib.stream : 0;
          var gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
          var glType = GFXFormatToWebGLType(attrib.format, gl);
          var size = FormatInfos[attrib.format].size;
          gpuInputAssembler.glAttribs[i] = {
            name: attrib.name,
            glBuffer: gpuBuffer.glBuffer,
            glType: glType,
            size: size,
            count: FormatInfos[attrib.format].count,
            stride: gpuBuffer.stride,
            componentCount: WebGLGetComponentCount(glType, gl),
            isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
            isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
            offset: offsets[stream]
          };
          offsets[stream] += size;
        }
      }
      function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
        var it = gpuInputAssembler.glVAOs.values();
        var res = it.next();
        var OES_vertex_array_object = device.extensions.OES_vertex_array_object;
        var glVAO = device.stateCache.glVAO;

        while (!res.done) {
          OES_vertex_array_object.deleteVertexArrayOES(res.value);

          if (glVAO === res.value) {
            OES_vertex_array_object.bindVertexArrayOES(null);
            glVAO = null;
          }

          res = it.next();
        }

        device.stateCache.glVAO = glVAO;
        gpuInputAssembler.glVAOs.clear();
      }
      var gfxStateCache = {
        gpuPipelineState: null,
        gpuInputAssembler: null,
        glPrimitive: 0
      };
      var realRenderArea = new Rect$1();
      function WebGLCmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
        var gl = device.gl;
        var cache = device.stateCache;
        var clears = 0;

        if (gpuFramebuffer) {
          realRenderArea.x = renderArea.x << gpuFramebuffer.lodLevel;
          realRenderArea.y = renderArea.y << gpuFramebuffer.lodLevel;
          realRenderArea.width = renderArea.width << gpuFramebuffer.lodLevel;
          realRenderArea.height = renderArea.height << gpuFramebuffer.lodLevel;
        }

        if (gpuFramebuffer && gpuRenderPass) {
          if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
            cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
          }

          if (cache.viewport.left !== realRenderArea.x || cache.viewport.top !== realRenderArea.y || cache.viewport.width !== realRenderArea.width || cache.viewport.height !== realRenderArea.height) {
            gl.viewport(realRenderArea.x, realRenderArea.y, realRenderArea.width, realRenderArea.height);
            cache.viewport.left = realRenderArea.x;
            cache.viewport.top = realRenderArea.y;
            cache.viewport.width = realRenderArea.width;
            cache.viewport.height = realRenderArea.height;
          }

          if (cache.scissorRect.x !== realRenderArea.x || cache.scissorRect.y !== realRenderArea.y || cache.scissorRect.width !== realRenderArea.width || cache.scissorRect.height !== realRenderArea.height) {
            gl.scissor(realRenderArea.x, realRenderArea.y, realRenderArea.width, realRenderArea.height);
            cache.scissorRect.x = realRenderArea.x;
            cache.scissorRect.y = realRenderArea.y;
            cache.scissorRect.width = realRenderArea.width;
            cache.scissorRect.height = realRenderArea.height;
          }

          var clearCount = clearColors.length;

          if (!device.extensions.WEBGL_draw_buffers) {
            clearCount = 1;
          }

          for (var j = 0; j < clearCount; ++j) {
            var colorAttachment = gpuRenderPass.colorAttachments[j];

            if (colorAttachment.format !== Format.UNKNOWN) {
              switch (colorAttachment.loadOp) {
                case LoadOp.LOAD:
                  break;

                case LoadOp.CLEAR:
                  {
                    if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                      gl.colorMask(true, true, true, true);
                    }

                    var clearColor = clearColors[0];
                    gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                    clears |= gl.COLOR_BUFFER_BIT;
                    break;
                  }

                case LoadOp.DISCARD:
                  {
                    break;
                  }
              }
            }
          }

          if (gpuRenderPass.depthStencilAttachment) {
            if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
              switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                case LoadOp.LOAD:
                  break;

                case LoadOp.CLEAR:
                  {
                    if (!cache.dss.depthWrite) {
                      gl.depthMask(true);
                    }

                    gl.clearDepth(clearDepth);
                    clears |= gl.DEPTH_BUFFER_BIT;
                    break;
                  }

                case LoadOp.DISCARD:
                  {
                    break;
                  }
              }

              if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                  case LoadOp.LOAD:
                    break;

                  case LoadOp.CLEAR:
                    {
                      if (!cache.dss.stencilWriteMaskFront) {
                        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                      }

                      if (!cache.dss.stencilWriteMaskBack) {
                        gl.stencilMaskSeparate(gl.BACK, 0xffff);
                      }

                      gl.clearStencil(clearStencil);
                      clears |= gl.STENCIL_BUFFER_BIT;
                      break;
                    }

                  case LoadOp.DISCARD:
                    {
                      break;
                    }
                }
              }
            }
          }

          if (clears) {
            gl.clear(clears);
          }

          if (clears & gl.COLOR_BUFFER_BIT) {
            var colorMask = cache.bs.targets[0].blendColorMask;

            if (colorMask !== ColorMask.ALL) {
              var r = (colorMask & ColorMask.R) !== ColorMask.NONE;
              var g = (colorMask & ColorMask.G) !== ColorMask.NONE;
              var b = (colorMask & ColorMask.B) !== ColorMask.NONE;
              var a = (colorMask & ColorMask.A) !== ColorMask.NONE;
              gl.colorMask(r, g, b, a);
            }
          }

          if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
            gl.depthMask(false);
          }

          if (clears & gl.STENCIL_BUFFER_BIT) {
            if (!cache.dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, 0);
            }

            if (!cache.dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, 0);
            }
          }
        }
      }
      function WebGLCmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
        var gl = device.gl;
        var cache = device.stateCache;
        var gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
        var isShaderChanged = false;
        var glWrapS;
        var glWrapT;
        var glMinFilter;

        if (gpuPipelineState && gfxStateCache.gpuPipelineState !== gpuPipelineState) {
          gfxStateCache.gpuPipelineState = gpuPipelineState;
          gfxStateCache.glPrimitive = gpuPipelineState.glPrimitive;

          if (gpuPipelineState.gpuShader) {
            var glProgram = gpuPipelineState.gpuShader.glProgram;

            if (cache.glProgram !== glProgram) {
              gl.useProgram(glProgram);
              cache.glProgram = glProgram;
              isShaderChanged = true;
            }
          }

          var rs = gpuPipelineState.rs;

          if (rs) {
            if (cache.rs.cullMode !== rs.cullMode) {
              switch (rs.cullMode) {
                case CullMode.NONE:
                  {
                    gl.disable(gl.CULL_FACE);
                    break;
                  }

                case CullMode.FRONT:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.FRONT);
                    break;
                  }

                case CullMode.BACK:
                  {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                    break;
                  }
              }

              cache.rs.cullMode = rs.cullMode;
            }

            var isFrontFaceCCW = rs.isFrontFaceCCW;

            if (cache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
              gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
              cache.rs.isFrontFaceCCW = isFrontFaceCCW;
            }

            if (cache.rs.depthBias !== rs.depthBias || cache.rs.depthBiasSlop !== rs.depthBiasSlop) {
              gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
              cache.rs.depthBias = rs.depthBias;
              cache.rs.depthBiasSlop = rs.depthBiasSlop;
            }

            if (cache.rs.lineWidth !== rs.lineWidth) {
              gl.lineWidth(rs.lineWidth);
              cache.rs.lineWidth = rs.lineWidth;
            }
          }

          var dss = gpuPipelineState.dss;

          if (dss) {
            if (cache.dss.depthTest !== dss.depthTest) {
              if (dss.depthTest) {
                gl.enable(gl.DEPTH_TEST);
              } else {
                gl.disable(gl.DEPTH_TEST);
              }

              cache.dss.depthTest = dss.depthTest;
            }

            if (cache.dss.depthWrite !== dss.depthWrite) {
              gl.depthMask(dss.depthWrite);
              cache.dss.depthWrite = dss.depthWrite;
            }

            if (cache.dss.depthFunc !== dss.depthFunc) {
              gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]);
              cache.dss.depthFunc = dss.depthFunc;
            }

            if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
              if (dss.stencilTestFront || dss.stencilTestBack) {
                gl.enable(gl.STENCIL_TEST);
              } else {
                gl.disable(gl.STENCIL_TEST);
              }

              cache.dss.stencilTestFront = dss.stencilTestFront;
              cache.dss.stencilTestBack = dss.stencilTestBack;
            }

            if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
              gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
              cache.dss.stencilFuncFront = dss.stencilFuncFront;
              cache.dss.stencilRefFront = dss.stencilRefFront;
              cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
            }

            if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
              gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]);
              cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
              cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
              cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
            }

            if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
              gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
              cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
            }

            if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
              gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
              cache.dss.stencilFuncBack = dss.stencilFuncBack;
              cache.dss.stencilRefBack = dss.stencilRefBack;
              cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
            }

            if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
              gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]);
              cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
              cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
              cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
            }

            if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
              gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
              cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
            }
          }

          var bs = gpuPipelineState.bs;

          if (bs) {
            if (cache.bs.isA2C !== bs.isA2C) {
              if (bs.isA2C) {
                gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              } else {
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              }

              cache.bs.isA2C = bs.isA2C;
            }

            if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
              gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
              cache.bs.blendColor.x = bs.blendColor.x;
              cache.bs.blendColor.y = bs.blendColor.y;
              cache.bs.blendColor.z = bs.blendColor.z;
              cache.bs.blendColor.w = bs.blendColor.w;
            }

            var target0 = bs.targets[0];
            var target0Cache = cache.bs.targets[0];

            if (target0Cache.blend !== target0.blend) {
              if (target0.blend) {
                gl.enable(gl.BLEND);
              } else {
                gl.disable(gl.BLEND);
              }

              target0Cache.blend = target0.blend;
            }

            if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
              gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]);
              target0Cache.blendEq = target0.blendEq;
              target0Cache.blendAlphaEq = target0.blendAlphaEq;
            }

            if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
              gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]);
              target0Cache.blendSrc = target0.blendSrc;
              target0Cache.blendDst = target0.blendDst;
              target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
              target0Cache.blendDstAlpha = target0.blendDstAlpha;
            }

            if (target0Cache.blendColorMask !== target0.blendColorMask) {
              gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
              target0Cache.blendColorMask = target0.blendColorMask;
            }
          }
        }

        if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
          var blockLen = gpuShader.glBlocks.length;
          var dynamicOffsetIndices = gpuPipelineState.gpuPipelineLayout.dynamicOffsetIndices;

          for (var j = 0; j < blockLen; j++) {
            var glBlock = gpuShader.glBlocks[j];
            var gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
            var descriptorIdx = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
            var gpuDescriptor = descriptorIdx >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIdx];
            var vf32 = null;
            var offset = 0;

            if (gpuDescriptor && gpuDescriptor.gpuBuffer) {
              var gpuBuffer = gpuDescriptor.gpuBuffer;
              var dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
              var dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];

              if (dynamicOffsetIndex >= 0) {
                offset = dynamicOffsets[dynamicOffsetIndex];
              }

              if ('vf32' in gpuBuffer) {
                vf32 = gpuBuffer.vf32;
              } else {
                offset += gpuBuffer.offset;
                vf32 = gpuBuffer.gpuBuffer.vf32;
              }

              offset >>= 2;
            }

            if (!vf32) {
              error("Buffer binding '" + glBlock.name + "' at set " + glBlock.set + " binding " + glBlock.binding + " is not bounded");
              continue;
            }

            var uniformLen = glBlock.glActiveUniforms.length;

            for (var l = 0; l < uniformLen; l++) {
              var glUniform = glBlock.glActiveUniforms[l];

              switch (glUniform.glType) {
                case gl.BOOL:
                case gl.INT:
                  {
                    for (var u = 0; u < glUniform.array.length; ++u) {
                      var idx = glUniform.offset + offset + u;

                      if (vf32[idx] !== glUniform.array[u]) {
                        for (var n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                          glUniform.array[n] = vf32[m];
                        }

                        gl.uniform1iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.BOOL_VEC2:
                case gl.INT_VEC2:
                  {
                    for (var _u = 0; _u < glUniform.array.length; ++_u) {
                      var _idx = glUniform.offset + offset + _u;

                      if (vf32[_idx] !== glUniform.array[_u]) {
                        for (var _n = _u, _m = _idx; _n < glUniform.array.length; ++_n, ++_m) {
                          glUniform.array[_n] = vf32[_m];
                        }

                        gl.uniform2iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.BOOL_VEC3:
                case gl.INT_VEC3:
                  {
                    for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                      var _idx2 = glUniform.offset + offset + _u2;

                      if (vf32[_idx2] !== glUniform.array[_u2]) {
                        for (var _n2 = _u2, _m2 = _idx2; _n2 < glUniform.array.length; ++_n2, ++_m2) {
                          glUniform.array[_n2] = vf32[_m2];
                        }

                        gl.uniform3iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.BOOL_VEC4:
                case gl.INT_VEC4:
                  {
                    for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                      var _idx3 = glUniform.offset + offset + _u3;

                      if (vf32[_idx3] !== glUniform.array[_u3]) {
                        for (var _n3 = _u3, _m3 = _idx3; _n3 < glUniform.array.length; ++_n3, ++_m3) {
                          glUniform.array[_n3] = vf32[_m3];
                        }

                        gl.uniform4iv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT:
                  {
                    for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                      var _idx4 = glUniform.offset + offset + _u4;

                      if (vf32[_idx4] !== glUniform.array[_u4]) {
                        for (var _n4 = _u4, _m4 = _idx4; _n4 < glUniform.array.length; ++_n4, ++_m4) {
                          glUniform.array[_n4] = vf32[_m4];
                        }

                        gl.uniform1fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_VEC2:
                  {
                    for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                      var _idx5 = glUniform.offset + offset + _u5;

                      if (vf32[_idx5] !== glUniform.array[_u5]) {
                        for (var _n5 = _u5, _m5 = _idx5; _n5 < glUniform.array.length; ++_n5, ++_m5) {
                          glUniform.array[_n5] = vf32[_m5];
                        }

                        gl.uniform2fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_VEC3:
                  {
                    for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                      var _idx6 = glUniform.offset + offset + _u6;

                      if (vf32[_idx6] !== glUniform.array[_u6]) {
                        for (var _n6 = _u6, _m6 = _idx6; _n6 < glUniform.array.length; ++_n6, ++_m6) {
                          glUniform.array[_n6] = vf32[_m6];
                        }

                        gl.uniform3fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_VEC4:
                  {
                    for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                      var _idx7 = glUniform.offset + offset + _u7;

                      if (vf32[_idx7] !== glUniform.array[_u7]) {
                        for (var _n7 = _u7, _m7 = _idx7; _n7 < glUniform.array.length; ++_n7, ++_m7) {
                          glUniform.array[_n7] = vf32[_m7];
                        }

                        gl.uniform4fv(glUniform.glLoc, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_MAT2:
                  {
                    for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                      var _idx8 = glUniform.offset + offset + _u8;

                      if (vf32[_idx8] !== glUniform.array[_u8]) {
                        for (var _n8 = _u8, _m8 = _idx8; _n8 < glUniform.array.length; ++_n8, ++_m8) {
                          glUniform.array[_n8] = vf32[_m8];
                        }

                        gl.uniformMatrix2fv(glUniform.glLoc, false, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_MAT3:
                  {
                    for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                      var _idx9 = glUniform.offset + offset + _u9;

                      if (vf32[_idx9] !== glUniform.array[_u9]) {
                        for (var _n9 = _u9, _m9 = _idx9; _n9 < glUniform.array.length; ++_n9, ++_m9) {
                          glUniform.array[_n9] = vf32[_m9];
                        }

                        gl.uniformMatrix3fv(glUniform.glLoc, false, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }

                case gl.FLOAT_MAT4:
                  {
                    for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                      var _idx10 = glUniform.offset + offset + _u10;

                      if (vf32[_idx10] !== glUniform.array[_u10]) {
                        for (var _n10 = _u10, _m10 = _idx10; _n10 < glUniform.array.length; ++_n10, ++_m10) {
                          glUniform.array[_n10] = vf32[_m10];
                        }

                        gl.uniformMatrix4fv(glUniform.glLoc, false, glUniform.array);
                        break;
                      }
                    }

                    break;
                  }
              }
            }

            continue;
          }

          var samplerLen = gpuShader.glSamplerTextures.length;

          for (var i = 0; i < samplerLen; i++) {
            var glSampler = gpuShader.glSamplerTextures[i];
            var _gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
            var descriptorIndex = _gpuDescriptorSet && _gpuDescriptorSet.descriptorIndices[glSampler.binding];

            var _gpuDescriptor = descriptorIndex >= 0 && _gpuDescriptorSet.gpuDescriptors[descriptorIndex];

            var texUnitLen = glSampler.units.length;

            for (var _l = 0; _l < texUnitLen; _l++) {
              var texUnit = glSampler.units[_l];

              if (!_gpuDescriptor || !_gpuDescriptor.gpuSampler) {
                error("Sampler binding '" + glSampler.name + "' at set " + glSampler.set + " binding " + glSampler.binding + " index " + _l + " is not bounded");
                continue;
              }

              if (_gpuDescriptor.gpuTexture && _gpuDescriptor.gpuTexture.size > 0) {
                var _gpuDescriptor2 = _gpuDescriptor,
                    gpuTexture = _gpuDescriptor2.gpuTexture;
                var glTexUnit = cache.glTexUnits[texUnit];

                if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  if (gpuTexture.glTexture) {
                    gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                  } else {
                    gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                  }

                  glTexUnit.glTexture = gpuTexture.glTexture;
                }

                var _gpuDescriptor3 = _gpuDescriptor,
                    gpuSampler = _gpuDescriptor3.gpuSampler;

                if (gpuTexture.isPowerOf2) {
                  glWrapS = gpuSampler.glWrapS;
                  glWrapT = gpuSampler.glWrapT;
                } else {
                  glWrapS = gl.CLAMP_TO_EDGE;
                  glWrapT = gl.CLAMP_TO_EDGE;
                }

                if (gpuTexture.isPowerOf2) {
                  if (gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR)) {
                    glMinFilter = gl.LINEAR;
                  } else {
                    glMinFilter = gpuSampler.glMinFilter;
                  }
                } else if (gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR) {
                  glMinFilter = gl.LINEAR;
                } else {
                  glMinFilter = gl.NEAREST;
                }

                if (gpuTexture.glWrapS !== glWrapS) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS);
                  gpuTexture.glWrapS = glWrapS;
                }

                if (gpuTexture.glWrapT !== glWrapT) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT);
                  gpuTexture.glWrapT = glWrapT;
                }

                if (gpuTexture.glMinFilter !== glMinFilter) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter);
                  gpuTexture.glMinFilter = glMinFilter;
                }

                if (gpuTexture.glMagFilter !== gpuSampler.glMagFilter) {
                  if (cache.texUnit !== texUnit) {
                    gl.activeTexture(gl.TEXTURE0 + texUnit);
                    cache.texUnit = texUnit;
                  }

                  gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter);
                  gpuTexture.glMagFilter = gpuSampler.glMagFilter;
                }
              }

              _gpuDescriptor = _gpuDescriptorSet.gpuDescriptors[++descriptorIndex];
            }
          }
        }

        if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache.gpuInputAssembler !== gpuInputAssembler)) {
          gfxStateCache.gpuInputAssembler = gpuInputAssembler;
          var ia = device.extensions.ANGLE_instanced_arrays;

          if (device.extensions.useVAO) {
            var vao = device.extensions.OES_vertex_array_object;
            var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);

            if (!glVAO) {
              glVAO = vao.createVertexArrayOES();
              gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
              vao.bindVertexArrayOES(glVAO);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
              var glAttrib;
              var inputLen = gpuShader.glInputs.length;

              for (var _j2 = 0; _j2 < inputLen; _j2++) {
                var glInput = gpuShader.glInputs[_j2];
                glAttrib = null;
                var attribLen = gpuInputAssembler.glAttribs.length;

                for (var k = 0; k < attribLen; k++) {
                  var attrib = gpuInputAssembler.glAttribs[k];

                  if (attrib.name === glInput.name) {
                    glAttrib = attrib;
                    break;
                  }
                }

                if (glAttrib) {
                  if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                    cache.glArrayBuffer = glAttrib.glBuffer;
                  }

                  for (var c = 0; c < glAttrib.componentCount; ++c) {
                    var glLoc = glInput.glLoc + c;
                    var attribOffset = glAttrib.offset + glAttrib.size * c;
                    gl.enableVertexAttribArray(glLoc);
                    cache.glCurrentAttribLocs[glLoc] = true;
                    gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);

                    if (ia) {
                      ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                    }
                  }
                }
              }

              var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

              if (_gpuBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer);
              }

              vao.bindVertexArrayOES(null);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              cache.glArrayBuffer = null;
              cache.glElementArrayBuffer = null;
            }

            if (cache.glVAO !== glVAO) {
              vao.bindVertexArrayOES(glVAO);
              cache.glVAO = glVAO;
            }
          } else {
            for (var a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
              cache.glCurrentAttribLocs[a] = false;
            }

            var _inputLen = gpuShader.glInputs.length;

            for (var _j3 = 0; _j3 < _inputLen; _j3++) {
              var _glInput = gpuShader.glInputs[_j3];
              var _glAttrib = null;
              var _attribLen = gpuInputAssembler.glAttribs.length;

              for (var _k5 = 0; _k5 < _attribLen; _k5++) {
                var _attrib = gpuInputAssembler.glAttribs[_k5];

                if (_attrib.name === _glInput.name) {
                  _glAttrib = _attrib;
                  break;
                }
              }

              if (_glAttrib) {
                if (cache.glArrayBuffer !== _glAttrib.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer);
                  cache.glArrayBuffer = _glAttrib.glBuffer;
                }

                for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                  var _glLoc3 = _glInput.glLoc + _c;

                  var _attribOffset = _glAttrib.offset + _glAttrib.size * _c;

                  if (!cache.glEnabledAttribLocs[_glLoc3] && _glLoc3 >= 0) {
                    gl.enableVertexAttribArray(_glLoc3);
                    cache.glEnabledAttribLocs[_glLoc3] = true;
                  }

                  cache.glCurrentAttribLocs[_glLoc3] = true;
                  gl.vertexAttribPointer(_glLoc3, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);

                  if (ia) {
                    ia.vertexAttribDivisorANGLE(_glLoc3, _glAttrib.isInstanced ? 1 : 0);
                  }
                }
              }
            }

            var _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;

            if (_gpuBuffer2) {
              if (cache.glElementArrayBuffer !== _gpuBuffer2.glBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer2.glBuffer);
                cache.glElementArrayBuffer = _gpuBuffer2.glBuffer;
              }
            }

            for (var _a = 0; _a < device.capabilities.maxVertexAttributes; ++_a) {
              if (cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a]) {
                gl.disableVertexAttribArray(_a);
                cache.glEnabledAttribLocs[_a] = false;
              }
            }
          }
        }

        if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
          var dsLen = gpuPipelineState.dynamicStates.length;

          for (var _j4 = 0; _j4 < dsLen; _j4++) {
            var dynamicState = gpuPipelineState.dynamicStates[_j4];

            switch (dynamicState) {
              case DynamicStateFlagBit.LINE_WIDTH:
                {
                  if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                    gl.lineWidth(dynamicStates.lineWidth);
                    cache.rs.lineWidth = dynamicStates.lineWidth;
                  }

                  break;
                }

              case DynamicStateFlagBit.DEPTH_BIAS:
                {
                  if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                    gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                    cache.rs.depthBias = dynamicStates.depthBiasConstant;
                    cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                  }

                  break;
                }

              case DynamicStateFlagBit.BLEND_CONSTANTS:
                {
                  var blendConstant = dynamicStates.blendConstant;

                  if (cache.bs.blendColor.x !== blendConstant.x || cache.bs.blendColor.y !== blendConstant.y || cache.bs.blendColor.z !== blendConstant.z || cache.bs.blendColor.w !== blendConstant.w) {
                    gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                    cache.bs.blendColor.copy(blendConstant);
                  }

                  break;
                }

              case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                {
                  var front = dynamicStates.stencilStatesFront;
                  var back = dynamicStates.stencilStatesBack;

                  if (cache.dss.stencilWriteMaskFront !== front.writeMask) {
                    gl.stencilMaskSeparate(gl.FRONT, front.writeMask);
                    cache.dss.stencilWriteMaskFront = front.writeMask;
                  }

                  if (cache.dss.stencilWriteMaskBack !== back.writeMask) {
                    gl.stencilMaskSeparate(gl.BACK, back.writeMask);
                    cache.dss.stencilWriteMaskBack = back.writeMask;
                  }

                  break;
                }

              case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                {
                  var _front = dynamicStates.stencilStatesFront;
                  var _back = dynamicStates.stencilStatesBack;

                  if (cache.dss.stencilRefFront !== _front.reference || cache.dss.stencilReadMaskFront !== _front.compareMask) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], _front.reference, _front.compareMask);
                    cache.dss.stencilRefFront = _front.reference;
                    cache.dss.stencilReadMaskFront = _front.compareMask;
                  }

                  if (cache.dss.stencilRefBack !== _back.reference || cache.dss.stencilReadMaskBack !== _back.compareMask) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], _back.reference, _back.compareMask);
                    cache.dss.stencilRefBack = _back.reference;
                    cache.dss.stencilReadMaskBack = _back.compareMask;
                  }

                  break;
                }
            }
          }
        }
      }
      function WebGLCmdFuncDraw(device, drawInfo) {
        var gl = device.gl;
        var _device$extensions = device.extensions,
            ia = _device$extensions.ANGLE_instanced_arrays,
            md = _device$extensions.WEBGL_multi_draw;
        var gpuInputAssembler = gfxStateCache.gpuInputAssembler,
            glPrimitive = gfxStateCache.glPrimitive;

        if (gpuInputAssembler) {
          var indexBuffer = gpuInputAssembler.gpuIndexBuffer;

          if (gpuInputAssembler.gpuIndirectBuffer) {
            var indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;

            if (indirects.drawByIndex) {
              for (var j = 0; j < indirects.drawCount; j++) {
                indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
              }

              if (md) {
                if (indirects.instancedDraw) {
                  md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                } else {
                  md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                }
              } else {
                for (var _j5 = 0; _j5 < indirects.drawCount; _j5++) {
                  if (indirects.instances[_j5] && ia) {
                    ia.drawElementsInstancedANGLE(glPrimitive, indirects.counts[_j5], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j5], indirects.instances[_j5]);
                  } else {
                    gl.drawElements(glPrimitive, indirects.counts[_j5], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j5]);
                  }
                }
              }
            } else if (md) {
              if (indirects.instancedDraw) {
                md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
              } else {
                md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
              }
            } else {
              for (var _j6 = 0; _j6 < indirects.drawCount; _j6++) {
                if (indirects.instances[_j6] && ia) {
                  ia.drawArraysInstancedANGLE(glPrimitive, indirects.offsets[_j6], indirects.counts[_j6], indirects.instances[_j6]);
                } else {
                  gl.drawArrays(glPrimitive, indirects.offsets[_j6], indirects.counts[_j6]);
                }
              }
            }
          } else if (drawInfo.instanceCount && ia) {
            if (indexBuffer) {
              if (drawInfo.indexCount > 0) {
                var offset = drawInfo.firstIndex * indexBuffer.stride;
                ia.drawElementsInstancedANGLE(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
              }
            } else if (drawInfo.vertexCount > 0) {
              ia.drawArraysInstancedANGLE(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
            }
          } else if (indexBuffer) {
            if (drawInfo.indexCount > 0) {
              var _offset = drawInfo.firstIndex * indexBuffer.stride;

              gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
            }
          } else if (drawInfo.vertexCount > 0) {
            gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
          }
        }
      }
      var cmdIds = new Array(WebGLCmd.COUNT);
      function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
        cmdIds.fill(0);

        for (var i = 0; i < cmdPackage.cmds.length; ++i) {
          var cmd = cmdPackage.cmds.array[i];
          var cmdId = cmdIds[cmd]++;

          switch (cmd) {
            case WebGLCmd.BEGIN_RENDER_PASS:
              {
                var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                WebGLCmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                break;
              }

            case WebGLCmd.BIND_STATES:
              {
                var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                WebGLCmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.dynamicStates);
                break;
              }

            case WebGLCmd.DRAW:
              {
                var cmd3 = cmdPackage.drawCmds.array[cmdId];
                WebGLCmdFuncDraw(device, cmd3.drawInfo);
                break;
              }

            case WebGLCmd.UPDATE_BUFFER:
              {
                var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                break;
              }

            case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
              {
                var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                WebGLCmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                break;
              }
          }
        }
      }
      function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
        var gl = device.gl;
        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }

        var n = 0;
        var f = 0;

        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (var i = 0; i < regions.length; i++) {
                var region = regions[i];
                gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
              }

              break;
            }

          case gl.TEXTURE_CUBE_MAP:
            {
              for (var _i18 = 0; _i18 < regions.length; _i18++) {
                var _region = regions[_i18];
                var fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;

                for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                  gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region.texSubres.mipLevel, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                }
              }

              break;
            }

          default:
            {
              console.error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }

        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
        var gl = device.gl;
        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
          glTexUnit.glTexture = gpuTexture.glTexture;
        }

        var n = 0;
        var w = 1;
        var h = 1;
        var f = 0;
        var fmtInfo = FormatInfos[gpuTexture.format];
        var isCompressed = fmtInfo.isCompressed;

        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (var i = 0; i < regions.length; i++) {
                var region = regions[i];
                w = region.texExtent.width;
                h = region.texExtent.height;
                var pixels = buffers[n++];

                if (!isCompressed) {
                  gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels);
                } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                  gl.compressedTexSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels);
                } else {
                  gl.compressedTexImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, pixels);
                }
              }

              break;
            }

          case gl.TEXTURE_CUBE_MAP:
            {
              for (var _i19 = 0; _i19 < regions.length; _i19++) {
                var _region2 = regions[_i19];
                var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;

                for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                  w = _region2.texExtent.width;
                  h = _region2.texExtent.height;
                  var _pixels = buffers[n++];

                  if (!isCompressed) {
                    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region2.texSubres.mipLevel, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels);
                  } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                    gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region2.texSubres.mipLevel, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels);
                  } else {
                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region2.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, _pixels);
                  }
                }
              }

              break;
            }

          default:
            {
              console.error('Unsupported GL texture type, copy buffer to texture failed.');
            }
        }

        if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
          gl.generateMipmap(gpuTexture.glTarget);
        }
      }
      function WebGLCmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
        var gl = device.gl;
        var cache = device.stateCache;
        var framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        var x = 0;
        var y = 0;
        var w = 1;
        var h = 1;

        switch (gpuTexture.glTarget) {
          case gl.TEXTURE_2D:
            {
              for (var k = 0; k < regions.length; k++) {
                var region = regions[k];
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                x = region.texOffset.x;
                y = region.texOffset.y;
                w = region.texExtent.width;
                h = region.texExtent.height;
                gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
              }

              break;
            }

          default:
            {
              console.error('Unsupported GL texture type, copy texture to buffers failed.');
            }
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        cache.glFramebuffer = null;
        gl.deleteFramebuffer(framebuffer);
      }

      var WebGLIndirectDrawInfos = function () {
        function WebGLIndirectDrawInfos() {
          this.counts = void 0;
          this.offsets = void 0;
          this.instances = void 0;
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
          this.byteOffsets = void 0;
          this._capacity = 4;
          this.counts = new Int32Array(this._capacity);
          this.offsets = new Int32Array(this._capacity);
          this.instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
        }

        var _proto = WebGLIndirectDrawInfos.prototype;

        _proto.clearDraws = function clearDraws() {
          this.drawCount = 0;
          this.drawByIndex = false;
          this.instancedDraw = false;
        };

        _proto.setDrawInfo = function setDrawInfo(idx, info) {
          this._ensureCapacity(idx);

          this.drawByIndex = info.indexCount > 0;
          this.instancedDraw = !!info.instanceCount;
          this.drawCount = Math.max(idx + 1, this.drawCount);

          if (this.drawByIndex) {
            this.counts[idx] = info.indexCount;
            this.offsets[idx] = info.firstIndex;
          } else {
            this.counts[idx] = info.vertexCount;
            this.offsets[idx] = info.firstVertex;
          }

          this.instances[idx] = Math.max(1, info.instanceCount);
        };

        _proto._ensureCapacity = function _ensureCapacity(target) {
          if (this._capacity > target) return;
          this._capacity = nextPow2(target);
          var counts = new Int32Array(this._capacity);
          var offsets = new Int32Array(this._capacity);
          var instances = new Int32Array(this._capacity);
          this.byteOffsets = new Int32Array(this._capacity);
          counts.set(this.counts);
          offsets.set(this.offsets);
          instances.set(this.instances);
          this.counts = counts;
          this.offsets = offsets;
          this.instances = instances;
        };

        return WebGLIndirectDrawInfos;
      }();

      var WebGLBuffer = function (_Buffer) {
        _inheritsLoose(WebGLBuffer, _Buffer);

        function WebGLBuffer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Buffer.call.apply(_Buffer, [this].concat(args)) || this;
          _this._gpuBuffer = null;
          _this._gpuBufferView = null;
          _this._uniformBuffer = null;
          return _this;
        }

        var _proto = WebGLBuffer.prototype;

        _proto.initialize = function initialize(info) {
          if ('buffer' in info) {
            this._isBufferView = true;
            var buffer = info.buffer;
            this._usage = buffer.usage;
            this._memUsage = buffer.memUsage;
            this._size = this._stride = info.range;
            this._count = 1;
            this._flags = buffer.flags;
            this._gpuBufferView = {
              gpuBuffer: buffer.gpuBuffer,
              offset: info.offset,
              range: info.range
            };
          } else {
            this._usage = info.usage;
            this._memUsage = info.memUsage;
            this._size = info.size;
            this._stride = Math.max(info.stride || this._size, 1);
            this._count = this._size / this._stride;
            this._flags = info.flags;

            if (this._usage & BufferUsageBit.UNIFORM && this._size > 0) {
              this._uniformBuffer = new Uint8Array(this._size);
            }

            this._gpuBuffer = {
              usage: this._usage,
              memUsage: this._memUsage,
              size: this._size,
              stride: this._stride,
              buffer: null,
              vf32: null,
              indirects: new WebGLIndirectDrawInfos(),
              glTarget: 0,
              glBuffer: null
            };

            if (this._usage & BufferUsageBit.UNIFORM) {
              this._gpuBuffer.buffer = this._uniformBuffer;
            }

            WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
            WebGLDeviceManager.instance.memoryStatus.bufferSize += this._size;
          }
        };

        _proto.destroy = function destroy() {
          if (this._gpuBuffer) {
            WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
            WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._size;
            this._gpuBuffer = null;
          }

          if (this._gpuBufferView) {
            this._gpuBufferView = null;
          }
        };

        _proto.resize = function resize(size) {
          if (this._isBufferView) {
            console.warn('cannot resize buffer views!');
            return;
          }

          var oldSize = this._size;

          if (oldSize === size) {
            return;
          }

          this._size = size;
          this._count = this._size / this._stride;

          if (this._uniformBuffer) {
            this._uniformBuffer = new Uint8Array(size);
          }

          if (this._gpuBuffer) {
            if (this._uniformBuffer) {
              this._gpuBuffer.buffer = this._uniformBuffer;
            }

            this._gpuBuffer.size = size;

            if (size > 0) {
              WebGLCmdFuncResizeBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
              WebGLDeviceManager.instance.memoryStatus.bufferSize -= oldSize;
              WebGLDeviceManager.instance.memoryStatus.bufferSize += size;
            }
          }
        };

        _proto.update = function update(buffer, size) {
          if (this._isBufferView) {
            console.warn('cannot update through buffer views!');
            return;
          }

          var buffSize;

          if (size !== undefined) {
            buffSize = size;
          } else if (this._usage & BufferUsageBit.INDIRECT) {
            buffSize = 0;
          } else {
            buffSize = buffer.byteLength;
          }

          WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
        };

        _createClass(WebGLBuffer, [{
          key: "gpuBuffer",
          get: function get() {
            return this._gpuBuffer;
          }
        }, {
          key: "gpuBufferView",
          get: function get() {
            return this._gpuBufferView;
          }
        }]);

        return WebGLBuffer;
      }(Buffer);

      var WebGLCommandPool = function () {
        function WebGLCommandPool(Clazz, count) {
          this._frees = void 0;
          this._freeIdx = 0;
          this._freeCmds = void 0;
          this._frees = new Array(count);
          this._freeCmds = new CachedArray(count);

          for (var i = 0; i < count; ++i) {
            this._frees[i] = new Clazz();
          }

          this._freeIdx = count - 1;
        }

        var _proto = WebGLCommandPool.prototype;

        _proto.alloc = function alloc(Clazz) {
          if (this._freeIdx < 0) {
            var size = this._frees.length * 2;
            var temp = this._frees;
            this._frees = new Array(size);
            var increase = size - temp.length;

            for (var i = 0; i < increase; ++i) {
              this._frees[i] = new Clazz();
            }

            for (var _i = increase, j = 0; _i < size; ++_i, ++j) {
              this._frees[_i] = temp[j];
            }

            this._freeIdx += increase;
          }

          var cmd = this._frees[this._freeIdx];
          this._frees[this._freeIdx--] = null;
          ++cmd.refCount;
          return cmd;
        };

        _proto.free = function free(cmd) {
          if (--cmd.refCount === 0) {
            this._freeCmds.push(cmd);
          }
        };

        _proto.freeCmds = function freeCmds(cmds) {
          for (var i = 0; i < cmds.length; ++i) {
            if (--cmds.array[i].refCount === 0) {
              this._freeCmds.push(cmds.array[i]);
            }
          }
        };

        _proto.release = function release() {
          for (var i = 0; i < this._freeCmds.length; ++i) {
            var cmd = this._freeCmds.array[i];
            cmd.clear();
            this._frees[++this._freeIdx] = cmd;
          }

          this._freeCmds.clear();
        };

        return WebGLCommandPool;
      }();
      var WebGLCommandAllocator = function () {
        function WebGLCommandAllocator() {
          this.beginRenderPassCmdPool = void 0;
          this.bindStatesCmdPool = void 0;
          this.drawCmdPool = void 0;
          this.updateBufferCmdPool = void 0;
          this.copyBufferToTextureCmdPool = void 0;
          this.beginRenderPassCmdPool = new WebGLCommandPool(WebGLCmdBeginRenderPass, 1);
          this.bindStatesCmdPool = new WebGLCommandPool(WebGLCmdBindStates, 1);
          this.drawCmdPool = new WebGLCommandPool(WebGLCmdDraw, 1);
          this.updateBufferCmdPool = new WebGLCommandPool(WebGLCmdUpdateBuffer, 1);
          this.copyBufferToTextureCmdPool = new WebGLCommandPool(WebGLCmdCopyBufferToTexture, 1);
        }

        var _proto2 = WebGLCommandAllocator.prototype;

        _proto2.clearCmds = function clearCmds(cmdPackage) {
          if (cmdPackage.beginRenderPassCmds.length) {
            this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
            cmdPackage.beginRenderPassCmds.clear();
          }

          if (cmdPackage.bindStatesCmds.length) {
            this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
            cmdPackage.bindStatesCmds.clear();
          }

          if (cmdPackage.drawCmds.length) {
            this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
            cmdPackage.drawCmds.clear();
          }

          if (cmdPackage.updateBufferCmds.length) {
            this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
            cmdPackage.updateBufferCmds.clear();
          }

          if (cmdPackage.copyBufferToTextureCmds.length) {
            this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
            cmdPackage.copyBufferToTextureCmds.clear();
          }

          cmdPackage.cmds.clear();
        };

        _proto2.releaseCmds = function releaseCmds() {
          this.beginRenderPassCmdPool.release();
          this.bindStatesCmdPool.release();
          this.drawCmdPool.release();
          this.updateBufferCmdPool.release();
          this.copyBufferToTextureCmdPool.release();
        };

        return WebGLCommandAllocator;
      }();

      var WebGLCommandBuffer = function (_CommandBuffer) {
        _inheritsLoose(WebGLCommandBuffer, _CommandBuffer);

        function WebGLCommandBuffer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _CommandBuffer.call.apply(_CommandBuffer, [this].concat(args)) || this;
          _this.cmdPackage = new WebGLCmdPackage();
          _this._cmdAllocator = new WebGLCommandAllocator();
          _this._isInRenderPass = false;
          _this._curGPUPipelineState = null;
          _this._curGPUInputAssembler = null;
          _this._curGPUDescriptorSets = [];
          _this._curDynamicOffsets = Array(8).fill(0);
          _this._curDynamicStates = new DynamicStates();
          _this._isStateInvalied = false;
          return _this;
        }

        var _proto = WebGLCommandBuffer.prototype;

        _proto.initialize = function initialize(info) {
          this._type = info.type;
          this._queue = info.queue;
          var setCount = WebGLDeviceManager.instance.bindingMappings.blockOffsets.length;

          for (var i = 0; i < setCount; i++) {
            this._curGPUDescriptorSets.push(null);
          }
        };

        _proto.destroy = function destroy() {
          this._cmdAllocator.clearCmds(this.cmdPackage);
        };

        _proto.begin = function begin(renderPass, subpass, frameBuffer) {

          this._cmdAllocator.clearCmds(this.cmdPackage);

          this._curGPUPipelineState = null;
          this._curGPUInputAssembler = null;
          this._curGPUDescriptorSets.length = 0;
          this._numDrawCalls = 0;
          this._numInstances = 0;
          this._numTris = 0;
        };

        _proto.end = function end() {
          if (this._isStateInvalied) {
            this.bindStates();
          }

          this._isInRenderPass = false;
        };

        _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          var cmd = this._cmdAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);

          cmd.gpuRenderPass = renderPass.gpuRenderPass;
          cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
          cmd.renderArea.copy(renderArea);
          cmd.clearColors.length = clearColors.length;

          for (var i = 0; i < clearColors.length; ++i) {
            cmd.clearColors[i] = clearColors[i];
          }

          cmd.clearDepth = clearDepth;
          cmd.clearStencil = clearStencil;
          this.cmdPackage.beginRenderPassCmds.push(cmd);
          this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS);
          this._isInRenderPass = true;
        };

        _proto.endRenderPass = function endRenderPass() {
          this._isInRenderPass = false;
        };

        _proto.bindPipelineState = function bindPipelineState(pipelineState) {
          var gpuPipelineState = pipelineState.gpuPipelineState;

          if (gpuPipelineState !== this._curGPUPipelineState) {
            this._curGPUPipelineState = gpuPipelineState;
            this._isStateInvalied = true;
          }
        };

        _proto.bindDescriptorSet = function bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
          var gpuDescriptorSet = descriptorSet.gpuDescriptorSet;

          if (gpuDescriptorSet !== this._curGPUDescriptorSets[set]) {
            this._curGPUDescriptorSets[set] = gpuDescriptorSet;
            this._isStateInvalied = true;
          }

          if (dynamicOffsets) {
            var _this$_curGPUPipeline;

            var gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) === null || _this$_curGPUPipeline === void 0 ? void 0 : _this$_curGPUPipeline.gpuPipelineLayout;

            if (gpuPipelineLayout) {
              var offsets = this._curDynamicOffsets;
              var idx = gpuPipelineLayout.dynamicOffsetOffsets[set];

              for (var i = 0; i < dynamicOffsets.length; i++) {
                offsets[idx + i] = dynamicOffsets[i];
              }

              this._isStateInvalied = true;
            }
          }
        };

        _proto.bindInputAssembler = function bindInputAssembler(inputAssembler) {
          var gpuInputAssembler = inputAssembler.gpuInputAssembler;
          this._curGPUInputAssembler = gpuInputAssembler;
          this._isStateInvalied = true;
        };

        _proto.setViewport = function setViewport(viewport) {
          var cache = this._curDynamicStates.viewport;

          if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
            cache.left = viewport.left;
            cache.top = viewport.top;
            cache.width = viewport.width;
            cache.height = viewport.height;
            cache.minDepth = viewport.minDepth;
            cache.maxDepth = viewport.maxDepth;
            this._isStateInvalied = true;
          }
        };

        _proto.setScissor = function setScissor(scissor) {
          var cache = this._curDynamicStates.scissor;

          if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
            cache.x = scissor.x;
            cache.y = scissor.y;
            cache.width = scissor.width;
            cache.height = scissor.height;
            this._isStateInvalied = true;
          }
        };

        _proto.setLineWidth = function setLineWidth(lineWidth) {
          if (this._curDynamicStates.lineWidth !== lineWidth) {
            this._curDynamicStates.lineWidth = lineWidth;
            this._isStateInvalied = true;
          }
        };

        _proto.setDepthBias = function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
          var cache = this._curDynamicStates;

          if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
            cache.depthBiasConstant = depthBiasConstantFactor;
            cache.depthBiasClamp = depthBiasClamp;
            cache.depthBiasSlope = depthBiasSlopeFactor;
            this._isStateInvalied = true;
          }
        };

        _proto.setBlendConstants = function setBlendConstants(blendConstants) {
          var cache = this._curDynamicStates.blendConstant;

          if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
            cache.copy(blendConstants);
            this._isStateInvalied = true;
          }
        };

        _proto.setDepthBound = function setDepthBound(minDepthBounds, maxDepthBounds) {
          var cache = this._curDynamicStates;

          if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
            cache.depthMinBounds = minDepthBounds;
            cache.depthMaxBounds = maxDepthBounds;
            this._isStateInvalied = true;
          }
        };

        _proto.setStencilWriteMask = function setStencilWriteMask(face, writeMask) {
          var front = this._curDynamicStates.stencilStatesFront;
          var back = this._curDynamicStates.stencilStatesBack;

          if (face & StencilFace.FRONT) {
            if (front.writeMask !== writeMask) {
              front.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }

          if (face & StencilFace.BACK) {
            if (back.writeMask !== writeMask) {
              back.writeMask = writeMask;
              this._isStateInvalied = true;
            }
          }
        };

        _proto.setStencilCompareMask = function setStencilCompareMask(face, reference, compareMask) {
          var front = this._curDynamicStates.stencilStatesFront;
          var back = this._curDynamicStates.stencilStatesBack;

          if (face & StencilFace.FRONT) {
            if (front.compareMask !== compareMask || front.reference !== reference) {
              front.reference = reference;
              front.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }

          if (face & StencilFace.BACK) {
            if (back.compareMask !== compareMask || back.reference !== reference) {
              back.reference = reference;
              back.compareMask = compareMask;
              this._isStateInvalied = true;
            }
          }
        };

        _proto.draw = function draw(infoOrAssembler) {
          if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            if (this._isStateInvalied) {
              this.bindStates();
            }

            var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;

            var cmd = this._cmdAllocator.drawCmdPool.alloc(WebGLCmdDraw);

            cmd.drawInfo.copy(info);
            this.cmdPackage.drawCmds.push(cmd);
            this.cmdPackage.cmds.push(WebGLCmd.DRAW);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            var indexCount = info.indexCount || info.vertexCount;

            if (this._curGPUPipelineState) {
              var glPrimitive = this._curGPUPipelineState.glPrimitive;

              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }

                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        };

        _proto.updateBuffer = function updateBuffer(buffer, data, size) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            var gpuBuffer = buffer.gpuBuffer;

            if (gpuBuffer) {
              var cmd = this._cmdAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);

              var buffSize = 0;
              var buff = null;

              if (buffer.usage & BufferUsageBit.INDIRECT) {
                buff = data;
              } else {
                if (size !== undefined) {
                  buffSize = size;
                } else {
                  buffSize = data.byteLength;
                }

                buff = data;
              }

              cmd.gpuBuffer = gpuBuffer;
              cmd.buffer = buff;
              cmd.offset = 0;
              cmd.size = buffSize;
              this.cmdPackage.updateBufferCmds.push(cmd);
              this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        };

        _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
          if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
            var gpuTexture = texture.gpuTexture;

            if (gpuTexture) {
              var cmd = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);

              if (cmd) {
                cmd.gpuTexture = gpuTexture;
                cmd.regions = regions;
                cmd.buffers = buffers;
                this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE);
              }
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        };

        _proto.execute = function execute(cmdBuffs, count) {
          for (var i = 0; i < count; ++i) {
            var webGLCmdBuff = cmdBuffs[i];

            for (var c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
              var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
              ++cmd.refCount;
              this.cmdPackage.beginRenderPassCmds.push(cmd);
            }

            for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
              var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
              ++_cmd.refCount;
              this.cmdPackage.bindStatesCmds.push(_cmd);
            }

            for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
              var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
              ++_cmd2.refCount;
              this.cmdPackage.drawCmds.push(_cmd2);
            }

            for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
              var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
              ++_cmd3.refCount;
              this.cmdPackage.updateBufferCmds.push(_cmd3);
            }

            for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
              var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
              ++_cmd4.refCount;
              this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
            }

            this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds.array);
            this._numDrawCalls += webGLCmdBuff._numDrawCalls;
            this._numInstances += webGLCmdBuff._numInstances;
            this._numTris += webGLCmdBuff._numTris;
          }
        };

        _proto.pipelineBarrier = function pipelineBarrier(GeneralBarrier, textureBarriers, textures) {};

        _proto.bindStates = function bindStates() {
          var bindStatesCmd = this._cmdAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);

          if (bindStatesCmd) {
            bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
            Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);
            Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets);
            bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
            bindStatesCmd.dynamicStates.copy(this._curDynamicStates);
            this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
            this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES);
            this._isStateInvalied = false;
          }
        };

        return WebGLCommandBuffer;
      }(CommandBuffer);

      var WebGLFramebuffer = function (_Framebuffer) {
        _inheritsLoose(WebGLFramebuffer, _Framebuffer);

        function WebGLFramebuffer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Framebuffer.call.apply(_Framebuffer, [this].concat(args)) || this;
          _this._gpuFramebuffer = null;
          return _this;
        }

        var _proto = WebGLFramebuffer.prototype;

        _proto.initialize = function initialize(info) {
          this._renderPass = info.renderPass;
          this._colorTextures = info.colorTextures || [];
          this._depthStencilTexture = info.depthStencilTexture || null;
          var lodLevel = 0;
          var gpuColorTextures = [];

          for (var i = 0; i < info.colorTextures.length; ++i) {
            var colorTexture = info.colorTextures[i];

            if (colorTexture) {
              gpuColorTextures.push(colorTexture.gpuTexture);
              lodLevel = colorTexture.lodLevel;
            }
          }

          var gpuDepthStencilTexture = null;

          if (info.depthStencilTexture) {
            gpuDepthStencilTexture = info.depthStencilTexture.gpuTexture;
            lodLevel = info.depthStencilTexture.lodLevel;
          }

          var width = Number.MAX_SAFE_INTEGER;
          var height = Number.MAX_SAFE_INTEGER;
          this._gpuFramebuffer = {
            gpuRenderPass: info.renderPass.gpuRenderPass,
            gpuColorTextures: gpuColorTextures,
            gpuDepthStencilTexture: gpuDepthStencilTexture,
            glFramebuffer: null,
            isOffscreen: true,

            get width() {
              return this.isOffscreen ? width : this.gpuColorTextures[0].width;
            },

            set width(val) {
              width = val;
            },

            get height() {
              return this.isOffscreen ? height : this.gpuColorTextures[0].height;
            },

            set height(val) {
              height = val;
            },

            lodLevel: lodLevel
          };
          WebGLCmdFuncCreateFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
        };

        _proto.destroy = function destroy() {
          if (this._gpuFramebuffer) {
            WebGLCmdFuncDestroyFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
            this._gpuFramebuffer = null;
          }
        };

        _createClass(WebGLFramebuffer, [{
          key: "gpuFramebuffer",
          get: function get() {
            return this._gpuFramebuffer;
          }
        }]);

        return WebGLFramebuffer;
      }(Framebuffer);

      var WebGLInputAssembler = function (_InputAssembler) {
        _inheritsLoose(WebGLInputAssembler, _InputAssembler);

        function WebGLInputAssembler() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _InputAssembler.call.apply(_InputAssembler, [this].concat(args)) || this;
          _this._gpuInputAssembler = null;
          return _this;
        }

        var _proto = WebGLInputAssembler.prototype;

        _proto.initialize = function initialize(info) {
          if (info.vertexBuffers.length === 0) {
            console.error('InputAssemblerInfo.vertexBuffers is null.');
            return;
          }

          this._attributes = info.attributes;
          this._attributesHash = this.computeAttributesHash();
          this._vertexBuffers = info.vertexBuffers;

          if (info.indexBuffer) {
            this._indexBuffer = info.indexBuffer;
            this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
            this._drawInfo.firstIndex = 0;
          } else {
            var vertBuff = this._vertexBuffers[0];
            this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
            this._drawInfo.firstVertex = 0;
            this._drawInfo.vertexOffset = 0;
          }

          this._drawInfo.instanceCount = 0;
          this._drawInfo.firstInstance = 0;
          this._indirectBuffer = info.indirectBuffer || null;
          var gpuVertexBuffers = new Array(info.vertexBuffers.length);

          for (var i = 0; i < info.vertexBuffers.length; ++i) {
            var vb = info.vertexBuffers[i];

            if (vb.gpuBuffer) {
              gpuVertexBuffers[i] = vb.gpuBuffer;
            }
          }

          var gpuIndexBuffer = null;
          var glIndexType = 0;

          if (info.indexBuffer) {
            gpuIndexBuffer = info.indexBuffer.gpuBuffer;

            if (gpuIndexBuffer) {
              switch (gpuIndexBuffer.stride) {
                case 1:
                  glIndexType = 0x1401;
                  break;

                case 2:
                  glIndexType = 0x1403;
                  break;

                case 4:
                  glIndexType = 0x1405;
                  break;

                default:
                  {
                    console.error('Error index buffer stride.');
                  }
              }
            }
          }

          var gpuIndirectBuffer = null;

          if (info.indirectBuffer) {
            gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
          }

          this._gpuInputAssembler = {
            attributes: info.attributes,
            gpuVertexBuffers: gpuVertexBuffers,
            gpuIndexBuffer: gpuIndexBuffer,
            gpuIndirectBuffer: gpuIndirectBuffer,
            glAttribs: [],
            glIndexType: glIndexType,
            glVAOs: new Map()
          };
          WebGLCmdFuncCreateInputAssember(WebGLDeviceManager.instance, this._gpuInputAssembler);
        };

        _proto.destroy = function destroy() {
          var device = WebGLDeviceManager.instance;

          if (this._gpuInputAssembler && device.extensions.useVAO) {
            WebGLCmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
          }

          this._gpuInputAssembler = null;
        };

        _createClass(WebGLInputAssembler, [{
          key: "gpuInputAssembler",
          get: function get() {
            return this._gpuInputAssembler;
          }
        }]);

        return WebGLInputAssembler;
      }(InputAssembler);

      var WebGLDescriptorSetLayout = function (_DescriptorSetLayout) {
        _inheritsLoose(WebGLDescriptorSetLayout, _DescriptorSetLayout);

        function WebGLDescriptorSetLayout() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _DescriptorSetLayout.call.apply(_DescriptorSetLayout, [this].concat(args)) || this;
          _this._gpuDescriptorSetLayout = null;
          return _this;
        }

        var _proto = WebGLDescriptorSetLayout.prototype;

        _proto.initialize = function initialize(info) {
          Array.prototype.push.apply(this._bindings, info.bindings);
          var descriptorCount = 0;
          var maxBinding = -1;
          var flattenedIndices = [];

          for (var i = 0; i < this._bindings.length; i++) {
            var binding = this._bindings[i];
            flattenedIndices.push(descriptorCount);
            descriptorCount += binding.count;
            if (binding.binding > maxBinding) maxBinding = binding.binding;
          }

          this._bindingIndices = Array(maxBinding + 1).fill(-1);
          var descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);

          for (var _i = 0; _i < this._bindings.length; _i++) {
            var _binding = this._bindings[_i];
            this._bindingIndices[_binding.binding] = _i;
            descriptorIndices[_binding.binding] = flattenedIndices[_i];
          }

          var dynamicBindings = [];

          for (var _i2 = 0; _i2 < this._bindings.length; _i2++) {
            var _binding2 = this._bindings[_i2];

            if (_binding2.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
              for (var j = 0; j < _binding2.count; j++) {
                dynamicBindings.push(_binding2.binding);
              }
            }
          }

          this._gpuDescriptorSetLayout = {
            bindings: this._bindings,
            dynamicBindings: dynamicBindings,
            descriptorIndices: descriptorIndices,
            descriptorCount: descriptorCount
          };
        };

        _proto.destroy = function destroy() {
          this._bindings.length = 0;
        };

        _createClass(WebGLDescriptorSetLayout, [{
          key: "gpuDescriptorSetLayout",
          get: function get() {
            return this._gpuDescriptorSetLayout;
          }
        }]);

        return WebGLDescriptorSetLayout;
      }(DescriptorSetLayout);

      var WebGLPipelineLayout = function (_PipelineLayout) {
        _inheritsLoose(WebGLPipelineLayout, _PipelineLayout);

        function WebGLPipelineLayout() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _PipelineLayout.call.apply(_PipelineLayout, [this].concat(args)) || this;
          _this._gpuPipelineLayout = null;
          return _this;
        }

        var _proto = WebGLPipelineLayout.prototype;

        _proto.initialize = function initialize(info) {
          Array.prototype.push.apply(this._setLayouts, info.setLayouts);
          var dynamicOffsetIndices = [];
          var gpuSetLayouts = [];
          var dynamicOffsetCount = 0;
          var dynamicOffsetOffsets = [];

          for (var i = 0; i < this._setLayouts.length; i++) {
            var setLayout = this._setLayouts[i];
            var dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
            var indices = Array(setLayout.bindingIndices.length).fill(-1);

            for (var j = 0; j < dynamicBindings.length; j++) {
              var binding = dynamicBindings[j];
              if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
            }

            gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
            dynamicOffsetIndices.push(indices);
            dynamicOffsetOffsets.push(dynamicOffsetCount);
            dynamicOffsetCount += dynamicBindings.length;
          }

          this._gpuPipelineLayout = {
            gpuSetLayouts: gpuSetLayouts,
            dynamicOffsetIndices: dynamicOffsetIndices,
            dynamicOffsetCount: dynamicOffsetCount,
            dynamicOffsetOffsets: dynamicOffsetOffsets
          };
        };

        _proto.destroy = function destroy() {
          this._setLayouts.length = 0;
        };

        _createClass(WebGLPipelineLayout, [{
          key: "gpuPipelineLayout",
          get: function get() {
            return this._gpuPipelineLayout;
          }
        }]);

        return WebGLPipelineLayout;
      }(PipelineLayout);

      var WebGLPrimitives = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
      var WebGLPipelineState = function (_PipelineState) {
        _inheritsLoose(WebGLPipelineState, _PipelineState);

        function WebGLPipelineState() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _PipelineState.call.apply(_PipelineState, [this].concat(args)) || this;
          _this._gpuPipelineState = null;
          return _this;
        }

        var _proto = WebGLPipelineState.prototype;

        _proto.initialize = function initialize(info) {
          this._primitive = info.primitive;
          this._shader = info.shader;
          this._pipelineLayout = info.pipelineLayout;
          var bs = this._bs;

          if (info.blendState) {
            var bsInfo = info.blendState;
            var targets = bsInfo.targets;

            if (targets) {
              targets.forEach(function (t, i) {
                bs.setTarget(i, t);
              });
            }

            if (bsInfo.isA2C !== undefined) {
              bs.isA2C = bsInfo.isA2C;
            }

            if (bsInfo.isIndepend !== undefined) {
              bs.isIndepend = bsInfo.isIndepend;
            }

            if (bsInfo.blendColor !== undefined) {
              bs.blendColor = bsInfo.blendColor;
            }
          }

          Object.assign(this._rs, info.rasterizerState);
          Object.assign(this._dss, info.depthStencilState);
          this._is = info.inputState;
          this._renderPass = info.renderPass;
          this._dynamicStates = info.dynamicStates;
          var dynamicStates = [];

          for (var i = 0; i < 31; i++) {
            if (this._dynamicStates & 1 << i) {
              dynamicStates.push(1 << i);
            }
          }

          this._gpuPipelineState = {
            glPrimitive: WebGLPrimitives[info.primitive],
            gpuShader: info.shader.gpuShader,
            gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
            rs: info.rasterizerState,
            dss: info.depthStencilState,
            bs: info.blendState,
            gpuRenderPass: info.renderPass.gpuRenderPass,
            dynamicStates: dynamicStates
          };
        };

        _proto.destroy = function destroy() {
          this._gpuPipelineState = null;
        };

        _createClass(WebGLPipelineState, [{
          key: "gpuPipelineState",
          get: function get() {
            return this._gpuPipelineState;
          }
        }]);

        return WebGLPipelineState;
      }(PipelineState);

      var WebGLPrimaryCommandBuffer = function (_WebGLCommandBuffer) {
        _inheritsLoose(WebGLPrimaryCommandBuffer, _WebGLCommandBuffer);

        function WebGLPrimaryCommandBuffer() {
          return _WebGLCommandBuffer.apply(this, arguments) || this;
        }

        var _proto = WebGLPrimaryCommandBuffer.prototype;

        _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
          WebGLCmdFuncBeginRenderPass(WebGLDeviceManager.instance, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
          this._isInRenderPass = true;
        };

        _proto.draw = function draw(infoOrAssembler) {
          if (this._isInRenderPass) {
            if (this._isStateInvalied) {
              this.bindStates();
            }

            var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
            WebGLCmdFuncDraw(WebGLDeviceManager.instance, info);
            ++this._numDrawCalls;
            this._numInstances += info.instanceCount;
            var indexCount = info.indexCount || info.vertexCount;

            if (this._curGPUPipelineState) {
              var glPrimitive = this._curGPUPipelineState.glPrimitive;

              switch (glPrimitive) {
                case 0x0004:
                  {
                    this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                    break;
                  }

                case 0x0005:
                case 0x0006:
                  {
                    this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                    break;
                  }
              }
            }
          } else {
            console.error('Command \'draw\' must be recorded inside a render pass.');
          }
        };

        _proto.setViewport = function setViewport(viewport) {
          var _WebGLDeviceManager$i = WebGLDeviceManager.instance,
              cache = _WebGLDeviceManager$i.stateCache,
              gl = _WebGLDeviceManager$i.gl;

          if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
            gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
            cache.viewport.left = viewport.left;
            cache.viewport.top = viewport.top;
            cache.viewport.width = viewport.width;
            cache.viewport.height = viewport.height;
          }
        };

        _proto.setScissor = function setScissor(scissor) {
          var _WebGLDeviceManager$i2 = WebGLDeviceManager.instance,
              cache = _WebGLDeviceManager$i2.stateCache,
              gl = _WebGLDeviceManager$i2.gl;

          if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
            gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
            cache.scissorRect.x = scissor.x;
            cache.scissorRect.y = scissor.y;
            cache.scissorRect.width = scissor.width;
            cache.scissorRect.height = scissor.height;
          }
        };

        _proto.updateBuffer = function updateBuffer(buffer, data, size) {
          if (!this._isInRenderPass) {
            var gpuBuffer = buffer.gpuBuffer;

            if (gpuBuffer) {
              var buffSize;

              if (size !== undefined) {
                buffSize = size;
              } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                buffSize = 0;
              } else {
                buffSize = data.byteLength;
              }

              WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, gpuBuffer, data, 0, buffSize);
            }
          } else {
            console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
          }
        };

        _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
          if (!this._isInRenderPass) {
            var gpuTexture = texture.gpuTexture;

            if (gpuTexture) {
              WebGLCmdFuncCopyBuffersToTexture(WebGLDeviceManager.instance, buffers, gpuTexture, regions);
            }
          } else {
            console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
          }
        };

        _proto.execute = function execute(cmdBuffs, count) {
          for (var i = 0; i < count; ++i) {
            var webGLCmdBuff = cmdBuffs[i];
            WebGLCmdFuncExecuteCmds(WebGLDeviceManager.instance, webGLCmdBuff.cmdPackage);
            this._numDrawCalls += webGLCmdBuff._numDrawCalls;
            this._numInstances += webGLCmdBuff._numInstances;
            this._numTris += webGLCmdBuff._numTris;
          }
        };

        _proto.bindStates = function bindStates() {
          WebGLCmdFuncBindStates(WebGLDeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
          this._isStateInvalied = false;
        };

        return WebGLPrimaryCommandBuffer;
      }(WebGLCommandBuffer);

      var WebGLQueue = function (_Queue) {
        _inheritsLoose(WebGLQueue, _Queue);

        function WebGLQueue() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Queue.call.apply(_Queue, [this].concat(args)) || this;
          _this.numDrawCalls = 0;
          _this.numInstances = 0;
          _this.numTris = 0;
          return _this;
        }

        var _proto = WebGLQueue.prototype;

        _proto.initialize = function initialize(info) {
          this._type = info.type;
        };

        _proto.destroy = function destroy() {};

        _proto.submit = function submit(cmdBuffs) {
          var len = cmdBuffs.length;

          for (var i = 0; i < len; i++) {
            var cmdBuff = cmdBuffs[i];
            this.numDrawCalls += cmdBuff.numDrawCalls;
            this.numInstances += cmdBuff.numInstances;
            this.numTris += cmdBuff.numTris;
          }
        };

        _proto.clear = function clear() {
          this.numDrawCalls = 0;
          this.numInstances = 0;
          this.numTris = 0;
        };

        return WebGLQueue;
      }(Queue);

      var WebGLRenderPass = function (_RenderPass) {
        _inheritsLoose(WebGLRenderPass, _RenderPass);

        function WebGLRenderPass() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
          _this._gpuRenderPass = null;
          return _this;
        }

        var _proto = WebGLRenderPass.prototype;

        _proto.initialize = function initialize(info) {
          this._colorInfos = info.colorAttachments;
          this._depthStencilInfo = info.depthStencilAttachment;
          this._subpasses = info.subpasses;
          this._gpuRenderPass = {
            colorAttachments: this._colorInfos,
            depthStencilAttachment: this._depthStencilInfo
          };
          this._hash = this.computeHash();
        };

        _proto.destroy = function destroy() {
          this._gpuRenderPass = null;
        };

        _createClass(WebGLRenderPass, [{
          key: "gpuRenderPass",
          get: function get() {
            return this._gpuRenderPass;
          }
        }]);

        return WebGLRenderPass;
      }(RenderPass);

      var WebGLWraps = [0x2901, 0x8370, 0x812F, 0x812F];
      var WebGLSampler = function (_Sampler) {
        _inheritsLoose(WebGLSampler, _Sampler);

        function WebGLSampler(info, hash) {
          var _this;

          _this = _Sampler.call(this, info, hash) || this;
          _this._gpuSampler = null;
          var glMinFilter = 0;
          var glMagFilter = 0;
          var minFilter = _this._info.minFilter;
          var magFilter = _this._info.magFilter;
          var mipFilter = _this._info.mipFilter;

          if (minFilter === Filter.LINEAR || minFilter === Filter.ANISOTROPIC) {
            if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
              glMinFilter = 0x2703;
            } else if (mipFilter === Filter.POINT) {
              glMinFilter = 0x2701;
            } else {
              glMinFilter = 0x2601;
            }
          } else if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
            glMinFilter = 0x2702;
          } else if (mipFilter === Filter.POINT) {
            glMinFilter = 0x2700;
          } else {
            glMinFilter = 0x2600;
          }

          if (magFilter === Filter.LINEAR || magFilter === Filter.ANISOTROPIC) {
            glMagFilter = 0x2601;
          } else {
            glMagFilter = 0x2600;
          }

          var glWrapS = WebGLWraps[_this._info.addressU];
          var glWrapT = WebGLWraps[_this._info.addressV];
          var glWrapR = WebGLWraps[_this._info.addressW];
          _this._gpuSampler = {
            glMinFilter: glMinFilter,
            glMagFilter: glMagFilter,
            glWrapS: glWrapS,
            glWrapT: glWrapT,
            glWrapR: glWrapR
          };
          return _this;
        }

        _createClass(WebGLSampler, [{
          key: "gpuSampler",
          get: function get() {
            return this._gpuSampler;
          }
        }]);

        return WebGLSampler;
      }(Sampler);

      var WebGLShader = function (_Shader) {
        _inheritsLoose(WebGLShader, _Shader);

        function WebGLShader() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Shader.call.apply(_Shader, [this].concat(args)) || this;
          _this._gpuShader = null;
          return _this;
        }

        var _proto = WebGLShader.prototype;

        _proto.initialize = function initialize(info) {
          this._name = info.name;
          this._stages = info.stages;
          this._attributes = info.attributes;
          this._blocks = info.blocks;
          this._samplers = info.samplers;
          this._gpuShader = {
            name: info.name,
            blocks: info.blocks.slice(),
            samplerTextures: info.samplerTextures.slice(),
            subpassInputs: info.subpassInputs.slice(),
            gpuStages: new Array(info.stages.length),
            glProgram: null,
            glInputs: [],
            glUniforms: [],
            glBlocks: [],
            glSamplerTextures: []
          };

          for (var i = 0; i < info.stages.length; ++i) {
            var stage = info.stages[i];
            this._gpuShader.gpuStages[i] = {
              type: stage.stage,
              source: stage.source,
              glShader: null
            };
          }

          WebGLCmdFuncCreateShader(WebGLDeviceManager.instance, this._gpuShader);
        };

        _proto.destroy = function destroy() {
          if (this._gpuShader) {
            WebGLCmdFuncDestroyShader(WebGLDeviceManager.instance, this._gpuShader);
            this._gpuShader = null;
          }
        };

        _createClass(WebGLShader, [{
          key: "gpuShader",
          get: function get() {
            return this._gpuShader;
          }
        }]);

        return WebGLShader;
      }(Shader);

      var WebGLStateCache = function () {
        function WebGLStateCache() {
          this.glArrayBuffer = null;
          this.glElementArrayBuffer = null;
          this.glVAO = null;
          this.texUnit = 0;
          this.glTexUnits = [];
          this.glRenderbuffer = null;
          this.glFramebuffer = null;
          this.viewport = new Viewport();
          this.scissorRect = new Rect$1(0, 0, 0, 0);
          this.rs = new RasterizerState();
          this.dss = new DepthStencilState();
          this.bs = new BlendState();
          this.glProgram = null;
          this.glEnabledAttribLocs = [];
          this.glCurrentAttribLocs = [];
          this.texUnitCacheMap = {};
        }

        var _proto = WebGLStateCache.prototype;

        _proto.initialize = function initialize(texUnit, vertexAttributes) {
          for (var i = 0; i < texUnit; ++i) {
            this.glTexUnits.push({
              glTexture: null
            });
          }

          this.glEnabledAttribLocs.length = vertexAttributes;
          this.glEnabledAttribLocs.fill(false);
          this.glCurrentAttribLocs.length = vertexAttributes;
          this.glCurrentAttribLocs.fill(false);
        };

        return WebGLStateCache;
      }();

      var WebGLTexture = function (_Texture) {
        _inheritsLoose(WebGLTexture, _Texture);

        function WebGLTexture() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Texture.call.apply(_Texture, [this].concat(args)) || this;
          _this._gpuTexture = null;
          _this._lodLevel = 0;
          return _this;
        }

        var _proto = WebGLTexture.prototype;

        _proto.initialize = function initialize(info, isSwapchainTexture) {
          var texInfo = info;
          var viewInfo = info;

          if ('texture' in info) {
            texInfo = viewInfo.texture.info;
            this._isTextureView = true;
          }

          this._info.copy(texInfo);

          this._isPowerOf2 = IsPowerOf2(this._info.width) && IsPowerOf2(this._info.height);
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

          if (!this._isTextureView) {
            this._gpuTexture = {
              type: texInfo.type,
              format: texInfo.format,
              usage: texInfo.usage,
              width: texInfo.width,
              height: texInfo.height,
              depth: texInfo.depth,
              size: this._size,
              arrayLayer: texInfo.layerCount,
              mipLevel: texInfo.levelCount,
              samples: texInfo.samples,
              flags: texInfo.flags,
              isPowerOf2: this._isPowerOf2,
              glTarget: 0,
              glInternalFmt: 0,
              glFormat: 0,
              glType: 0,
              glUsage: 0,
              glTexture: null,
              glRenderbuffer: null,
              glWrapS: 0,
              glWrapT: 0,
              glMinFilter: 0,
              glMagFilter: 0,
              isSwapchainTexture: isSwapchainTexture || false
            };
            WebGLCmdFuncCreateTexture(WebGLDeviceManager.instance, this._gpuTexture);
            WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
            this._viewInfo.texture = this;
            this._viewInfo.type = info.type;
            this._viewInfo.format = info.format;
            this._viewInfo.baseLevel = 0;
            this._viewInfo.levelCount = info.levelCount;
            this._viewInfo.baseLayer = 0;
            this._viewInfo.layerCount = info.layerCount;
          } else {
            this._viewInfo.copy(viewInfo);

            this._lodLevel = viewInfo.baseLevel;
            this._gpuTexture = viewInfo.texture._gpuTexture;
          }
        };

        _proto.destroy = function destroy() {
          if (!this._isTextureView && this._gpuTexture) {
            WebGLCmdFuncDestroyTexture(WebGLDeviceManager.instance, this._gpuTexture);
            WebGLDeviceManager.instance.memoryStatus.textureSize -= this._size;
            this._gpuTexture = null;
          }
        };

        _proto.resize = function resize(width, height) {
          if (this._info.width === width && this._info.height === height) {
            return;
          }

          if (this._info.levelCount === WebGLTexture.getLevelCount(this._info.width, this._info.height)) {
            this._info.levelCount = WebGLTexture.getLevelCount(width, height);
          } else if (this._info.levelCount > 1) {
            this._info.levelCount = Math.min(this._info.levelCount, WebGLTexture.getLevelCount(width, height));
          }

          var oldSize = this._size;
          this._info.width = width;
          this._info.height = height;
          this._size = FormatSurfaceSize(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount;

          if (!this._isTextureView && this._gpuTexture) {
            this._gpuTexture.width = width;
            this._gpuTexture.height = height;
            this._gpuTexture.size = this._size;
            WebGLCmdFuncResizeTexture(WebGLDeviceManager.instance, this._gpuTexture);
            WebGLDeviceManager.instance.memoryStatus.textureSize -= oldSize;
            WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
          }
        };

        _proto.initAsSwapchainTexture = function initAsSwapchainTexture(info) {
          var texInfo = new TextureInfo();
          texInfo.format = info.format;
          texInfo.usage = FormatInfos[info.format].hasDepth ? TextureUsageBit.DEPTH_STENCIL_ATTACHMENT : TextureUsageBit.COLOR_ATTACHMENT;
          texInfo.width = info.width;
          texInfo.height = info.height;
          this.initialize(texInfo, true);
        };

        _createClass(WebGLTexture, [{
          key: "gpuTexture",
          get: function get() {
            return this._gpuTexture;
          }
        }, {
          key: "lodLevel",
          get: function get() {
            return this._lodLevel;
          }
        }]);

        return WebGLTexture;
      }(Texture);

      var eventWebGLContextLost = 'webglcontextlost';

      function initStates(gl) {
        gl.activeTexture(gl.TEXTURE0);
        gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.enable(gl.SCISSOR_TEST);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.frontFace(gl.CCW);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(0.0, 0.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
        gl.depthRange(0.0, 1.0);
        gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.FRONT, 0xffff);
        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
        gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMaskSeparate(gl.BACK, 0xffff);
        gl.disable(gl.STENCIL_TEST);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        gl.disable(gl.BLEND);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.colorMask(true, true, true, true);
        gl.blendColor(0.0, 0.0, 0.0, 0.0);
      }

      function getExtension(gl, ext) {
        var prefixes = ['', 'WEBKIT_', 'MOZ_'];

        for (var i = 0; i < prefixes.length; ++i) {
          var _ext = gl.getExtension(prefixes[i] + ext);

          if (_ext) {
            return _ext;
          }
        }

        return null;
      }

      function getExtensions(gl) {
        var res = {
          EXT_texture_filter_anisotropic: getExtension(gl, 'EXT_texture_filter_anisotropic'),
          EXT_blend_minmax: getExtension(gl, 'EXT_blend_minmax'),
          EXT_frag_depth: getExtension(gl, 'EXT_frag_depth'),
          EXT_shader_texture_lod: getExtension(gl, 'EXT_shader_texture_lod'),
          EXT_sRGB: getExtension(gl, 'EXT_sRGB'),
          OES_vertex_array_object: getExtension(gl, 'OES_vertex_array_object'),
          EXT_color_buffer_half_float: getExtension(gl, 'EXT_color_buffer_half_float'),
          WEBGL_color_buffer_float: getExtension(gl, 'WEBGL_color_buffer_float'),
          WEBGL_compressed_texture_etc1: getExtension(gl, 'WEBGL_compressed_texture_etc1'),
          WEBGL_compressed_texture_etc: getExtension(gl, 'WEBGL_compressed_texture_etc'),
          WEBGL_compressed_texture_pvrtc: getExtension(gl, 'WEBGL_compressed_texture_pvrtc'),
          WEBGL_compressed_texture_s3tc: getExtension(gl, 'WEBGL_compressed_texture_s3tc'),
          WEBGL_compressed_texture_s3tc_srgb: getExtension(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
          WEBGL_debug_shaders: getExtension(gl, 'WEBGL_debug_shaders'),
          WEBGL_draw_buffers: getExtension(gl, 'WEBGL_draw_buffers'),
          WEBGL_lose_context: getExtension(gl, 'WEBGL_lose_context'),
          WEBGL_depth_texture: getExtension(gl, 'WEBGL_depth_texture'),
          OES_texture_half_float: getExtension(gl, 'OES_texture_half_float'),
          OES_texture_half_float_linear: getExtension(gl, 'OES_texture_half_float_linear'),
          OES_texture_float: getExtension(gl, 'OES_texture_float'),
          OES_texture_float_linear: getExtension(gl, 'OES_texture_float_linear'),
          OES_standard_derivatives: getExtension(gl, 'OES_standard_derivatives'),
          OES_element_index_uint: getExtension(gl, 'OES_element_index_uint'),
          ANGLE_instanced_arrays: getExtension(gl, 'ANGLE_instanced_arrays'),
          WEBGL_debug_renderer_info: getExtension(gl, 'WEBGL_debug_renderer_info'),
          WEBGL_multi_draw: null,
          WEBGL_compressed_texture_astc: null,
          destroyShadersImmediately: true,
          noCompressedTexSubImage2D: false,
          isLocationActive: function isLocationActive(glLoc) {
            return !!glLoc;
          },
          useVAO: false
        };
        {
          if (systemInfo.os !== OS.IOS || systemInfo.osMainVersion !== 14 || !systemInfo.isBrowser) {
            res.WEBGL_compressed_texture_astc = getExtension(gl, 'WEBGL_compressed_texture_astc');
          }

          if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
            res.WEBGL_multi_draw = getExtension(gl, 'WEBGL_multi_draw');
          }

          if (systemInfo.browserType === BrowserType.UC) {
            res.ANGLE_instanced_arrays = null;
          }

          if (systemInfo.os === OS.IOS && systemInfo.osMainVersion <= 10 || WECHAT ) {
            res.destroyShadersImmediately = false;
          }
        }

        if (res.OES_vertex_array_object) {
          res.useVAO = true;
        }

        return res;
      }
      function getContext(canvas) {
        var context = null;

        try {
          var webGLCtxAttribs = {
            alpha: macro.ENABLE_TRANSPARENT_CANVAS,
            antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
            depth: true,
            stencil: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'default',
            failIfMajorPerformanceCaveat: false
          };
          context = canvas.getContext('webgl', webGLCtxAttribs);
        } catch (err) {
          return null;
        }

        return context;
      }
      var WebGLSwapchain = function (_Swapchain) {
        _inheritsLoose(WebGLSwapchain, _Swapchain);

        function WebGLSwapchain() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Swapchain.call.apply(_Swapchain, [this].concat(args)) || this;
          _this.stateCache = new WebGLStateCache();
          _this.cmdAllocator = new WebGLCommandAllocator();
          _this.nullTex2D = null;
          _this.nullTexCube = null;
          _this._canvas = null;
          _this._webGLContextLostHandler = null;
          _this._extensions = null;
          return _this;
        }

        var _proto = WebGLSwapchain.prototype;

        _proto.initialize = function initialize(info) {
          this._canvas = info.windowHandle;
          this._webGLContextLostHandler = this._onWebGLContextLost.bind(this);

          this._canvas.addEventListener(eventWebGLContextLost, this._onWebGLContextLost);

          var gl = WebGLDeviceManager.instance.gl;
          this.stateCache.initialize(WebGLDeviceManager.instance.capabilities.maxTextureUnits, WebGLDeviceManager.instance.capabilities.maxVertexAttributes);
          this._extensions = getExtensions(gl);
          initStates(gl);
          var colorFmt = Format.RGBA8;
          var depthStencilFmt = Format.DEPTH_STENCIL;
          var depthBits = gl.getParameter(gl.DEPTH_BITS);
          var stencilBits = gl.getParameter(gl.STENCIL_BITS);

          if (depthBits && stencilBits) depthStencilFmt = Format.DEPTH_STENCIL;else if (depthBits) depthStencilFmt = Format.DEPTH;
          this._colorTexture = new WebGLTexture();

          this._colorTexture.initAsSwapchainTexture({
            swapchain: this,
            format: colorFmt,
            width: info.width,
            height: info.height
          });

          this._depthStencilTexture = new WebGLTexture();

          this._depthStencilTexture.initAsSwapchainTexture({
            swapchain: this,
            format: depthStencilFmt,
            width: info.width,
            height: info.height
          });

          this.nullTex2D = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP));
          this.nullTexCube = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP, 6));
          var nullTexRegion = new BufferTextureCopy();
          nullTexRegion.texExtent.width = 2;
          nullTexRegion.texExtent.height = 2;
          var nullTexBuff = new Uint8Array(this.nullTex2D.size);
          nullTexBuff.fill(0);
          WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
          nullTexRegion.texSubres.layerCount = 6;
          WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
        };

        _proto.destroy = function destroy() {
          if (this._canvas && this._webGLContextLostHandler) {
            this._canvas.removeEventListener(eventWebGLContextLost, this._webGLContextLostHandler);

            this._webGLContextLostHandler = null;
          }

          if (this.nullTex2D) {
            this.nullTex2D.destroy();
            this.nullTex2D = null;
          }

          if (this.nullTexCube) {
            this.nullTexCube.destroy();
            this.nullTexCube = null;
          }

          this._extensions = null;
          this._canvas = null;
        };

        _proto.resize = function resize(width, height, surfaceTransform) {
          if (this._colorTexture.width !== width || this._colorTexture.height !== height) {
            debug("Resizing swapchain: " + width + "x" + height);
            this._canvas.width = width;
            this._canvas.height = height;

            this._colorTexture.resize(width, height);

            this._depthStencilTexture.resize(width, height);
          }
        };

        _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
          warnID(11000);
          warn(event);
        };

        _createClass(WebGLSwapchain, [{
          key: "extensions",
          get: function get() {
            return this._extensions;
          }
        }]);

        return WebGLSwapchain;
      }(Swapchain);

      var WebGLDevice = exports('WebGLDevice', function (_Device) {
        _inheritsLoose(WebGLDevice, _Device);

        function WebGLDevice() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Device.call.apply(_Device, [this].concat(args)) || this;
          _this._swapchain = null;
          _this._context = null;
          _this._bindingMappings = null;
          _this._textureExclusive = new Array(Format.COUNT);
          return _this;
        }

        var _proto = WebGLDevice.prototype;

        _proto.initialize = function initialize(info) {
          WebGLDeviceManager.setInstance(this);
          this._gfxAPI = API.WEBGL;
          var mapping = this._bindingMappingInfo = info.bindingMappingInfo;
          var blockOffsets = [];
          var samplerTextureOffsets = [];
          var firstSet = mapping.setIndices[0];
          blockOffsets[firstSet] = 0;
          samplerTextureOffsets[firstSet] = 0;

          for (var i = 1; i < mapping.setIndices.length; ++i) {
            var curSet = mapping.setIndices[i];
            var prevSet = mapping.setIndices[i - 1];
            blockOffsets[curSet] = mapping.maxBlockCounts[prevSet] + blockOffsets[prevSet];
            samplerTextureOffsets[curSet] = mapping.maxSamplerTextureCounts[prevSet] + samplerTextureOffsets[prevSet];
          }

          for (var _i = 0; _i < mapping.setIndices.length; ++_i) {
            var _curSet = mapping.setIndices[_i];
            samplerTextureOffsets[_curSet] -= mapping.maxBlockCounts[_curSet];
          }

          this._bindingMappings = {
            blockOffsets: blockOffsets,
            samplerTextureOffsets: samplerTextureOffsets,
            flexibleSet: mapping.setIndices[mapping.setIndices.length - 1]
          };
          var gl = this._context = getContext(Device.canvas);

          if (!gl) {
            console.error('This device does not support WebGL.');
            return false;
          }

          this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
          this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
          this._caps.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
          this._caps.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
          this._caps.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
          this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          this._caps.maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
          this._caps.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          this._caps.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
          this._caps.maxUniformBufferBindings = 16;
          var extensions = gl.getSupportedExtensions();
          var extStr = '';

          if (extensions) {
            for (var _iterator = _createForOfIteratorHelperLoose(extensions), _step; !(_step = _iterator()).done;) {
              var ext = _step.value;
              extStr += ext + " ";
            }
          }

          var exts = getExtensions(gl);

          if (exts.WEBGL_debug_renderer_info) {
            this._renderer = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
            this._vendor = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
          } else {
            this._renderer = gl.getParameter(gl.RENDERER);
            this._vendor = gl.getParameter(gl.VENDOR);
          }

          var version = gl.getParameter(gl.VERSION);

          this._features.fill(false);

          this.initFormatFeatures(exts);

          if (exts.EXT_blend_minmax) {
            this._features[Feature.BLEND_MINMAX] = true;
          }

          if (exts.OES_element_index_uint) {
            this._features[Feature.ELEMENT_INDEX_UINT] = true;
          }

          if (exts.ANGLE_instanced_arrays) {
            this._features[Feature.INSTANCED_ARRAYS] = true;
          }

          if (exts.WEBGL_draw_buffers) {
            this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
          }

          var compressedFormat = '';

          if (this.getFormatFeatures(Format.ETC_RGB8)) {
            compressedFormat += 'etc1 ';
          }

          if (this.getFormatFeatures(Format.ETC2_RGB8)) {
            compressedFormat += 'etc2 ';
          }

          if (this.getFormatFeatures(Format.BC1)) {
            compressedFormat += 'dxt ';
          }

          if (this.getFormatFeatures(Format.PVRTC_RGB2)) {
            compressedFormat += 'pvrtc ';
          }

          if (this.getFormatFeatures(Format.ASTC_RGBA_4X4)) {
            compressedFormat += 'astc ';
          }

          debug('WebGL device initialized.');
          debug("RENDERER: " + this._renderer);
          debug("VENDOR: " + this._vendor);
          debug("VERSION: " + version);
          debug("COMPRESSED_FORMAT: " + compressedFormat);
          debug("EXTENSIONS: " + extStr);
          return true;
        };

        _proto.destroy = function destroy() {
          if (this._queue) {
            this._queue.destroy();

            this._queue = null;
          }

          if (this._cmdBuff) {
            this._cmdBuff.destroy();

            this._cmdBuff = null;
          }
        };

        _proto.flushCommands = function flushCommands(cmdBuffs) {};

        _proto.acquire = function acquire(swapchains) {};

        _proto.present = function present() {
          var queue = this._queue;
          this._numDrawCalls = queue.numDrawCalls;
          this._numInstances = queue.numInstances;
          this._numTris = queue.numTris;
          queue.clear();
        };

        _proto.initFormatFeatures = function initFormatFeatures(exts) {
          this._formatFeatures.fill(FormatFeatureBit.NONE);

          this._textureExclusive.fill(true);

          var tempFeature = FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;
          this._formatFeatures[Format.RGB8] = tempFeature;
          this._formatFeatures[Format.R5G6B5] = tempFeature;
          this._textureExclusive[Format.R5G6B5] = false;
          this._formatFeatures[Format.RGBA8] = tempFeature;
          this._formatFeatures[Format.RGBA4] = tempFeature;
          this._textureExclusive[Format.RGBA4] = false;
          this._formatFeatures[Format.RGB5A1] = tempFeature;
          this._textureExclusive[Format.RGB5A1] = false;
          this._formatFeatures[Format.DEPTH] = FormatFeatureBit.RENDER_TARGET;
          this._textureExclusive[Format.DEPTH] = false;
          this._formatFeatures[Format.DEPTH_STENCIL] = FormatFeatureBit.RENDER_TARGET;
          this._textureExclusive[Format.DEPTH_STENCIL] = false;
          this._formatFeatures[Format.R8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8I] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA8UI] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.R32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RG32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;
          this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.VERTEX_ATTRIBUTE;

          if (exts.EXT_sRGB) {
            this._formatFeatures[Format.SRGB8] = tempFeature;
            this._formatFeatures[Format.SRGB8_A8] = tempFeature;
            this._textureExclusive[Format.SRGB8_A8] = false;
          }

          if (exts.WEBGL_depth_texture) {
            this._formatFeatures[Format.DEPTH] |= tempFeature;
            this._formatFeatures[Format.DEPTH_STENCIL] |= tempFeature;
          }

          if (exts.WEBGL_color_buffer_float) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET;
            this._textureExclusive[Format.RGB32F] = false;
            this._textureExclusive[Format.RGBA32F] = false;
          }

          if (exts.EXT_color_buffer_half_float) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.RENDER_TARGET;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.RENDER_TARGET;
            this._textureExclusive[Format.RGB16F] = false;
            this._textureExclusive[Format.RGBA16F] = false;
          }

          if (exts.OES_texture_float) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
          }

          if (exts.OES_texture_half_float) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE;
          }

          if (exts.OES_texture_float_linear) {
            this._formatFeatures[Format.RGB32F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA32F] |= FormatFeatureBit.LINEAR_FILTER;
          }

          if (exts.OES_texture_half_float_linear) {
            this._formatFeatures[Format.RGB16F] |= FormatFeatureBit.LINEAR_FILTER;
            this._formatFeatures[Format.RGBA16F] |= FormatFeatureBit.LINEAR_FILTER;
          }

          var compressedFeature = FormatFeatureBit.SAMPLED_TEXTURE | FormatFeatureBit.LINEAR_FILTER;

          if (exts.WEBGL_compressed_texture_etc1) {
            this._formatFeatures[Format.ETC_RGB8] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_etc) {
            this._formatFeatures[Format.ETC2_RGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGBA8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A8] = compressedFeature;
            this._formatFeatures[Format.ETC2_RGB8_A1] = compressedFeature;
            this._formatFeatures[Format.ETC2_SRGB8_A1] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_s3tc) {
            this._formatFeatures[Format.BC1] = compressedFeature;
            this._formatFeatures[Format.BC1_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC1_SRGB_ALPHA] = compressedFeature;
            this._formatFeatures[Format.BC2] = compressedFeature;
            this._formatFeatures[Format.BC2_SRGB] = compressedFeature;
            this._formatFeatures[Format.BC3] = compressedFeature;
            this._formatFeatures[Format.BC3_SRGB] = compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_pvrtc) {
            this._formatFeatures[Format.PVRTC_RGB2] |= compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA2] |= compressedFeature;
            this._formatFeatures[Format.PVRTC_RGB4] |= compressedFeature;
            this._formatFeatures[Format.PVRTC_RGBA4] |= compressedFeature;
          }

          if (exts.WEBGL_compressed_texture_astc) {
            this._formatFeatures[Format.ASTC_RGBA_4X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_5X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_6X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_8X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_10X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_RGBA_12X12] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_4X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X4] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_5X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_6X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_8X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X5] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X6] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X8] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_10X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X10] |= compressedFeature;
            this._formatFeatures[Format.ASTC_SRGBA_12X12] |= compressedFeature;
          }
        };

        _proto.createCommandBuffer = function createCommandBuffer(info) {
          var Ctor = info.type === CommandBufferType.PRIMARY ? WebGLPrimaryCommandBuffer : WebGLCommandBuffer;
          var cmdBuff = new Ctor();
          cmdBuff.initialize(info);
          return cmdBuff;
        };

        _proto.createSwapchain = function createSwapchain(info) {
          var swapchain = new WebGLSwapchain();
          this._swapchain = swapchain;
          swapchain.initialize(info);
          return swapchain;
        };

        _proto.createBuffer = function createBuffer(info) {
          var buffer = new WebGLBuffer();
          buffer.initialize(info);
          return buffer;
        };

        _proto.createTexture = function createTexture(info) {
          var texture = new WebGLTexture();
          texture.initialize(info);
          return texture;
        };

        _proto.createDescriptorSet = function createDescriptorSet(info) {
          var descriptorSet = new WebGLDescriptorSet();
          descriptorSet.initialize(info);
          return descriptorSet;
        };

        _proto.createShader = function createShader(info) {
          var shader = new WebGLShader();
          shader.initialize(info);
          return shader;
        };

        _proto.createInputAssembler = function createInputAssembler(info) {
          var inputAssembler = new WebGLInputAssembler();
          inputAssembler.initialize(info);
          return inputAssembler;
        };

        _proto.createRenderPass = function createRenderPass(info) {
          var renderPass = new WebGLRenderPass();
          renderPass.initialize(info);
          return renderPass;
        };

        _proto.createFramebuffer = function createFramebuffer(info) {
          var framebuffer = new WebGLFramebuffer();
          framebuffer.initialize(info);
          return framebuffer;
        };

        _proto.createDescriptorSetLayout = function createDescriptorSetLayout(info) {
          var descriptorSetLayout = new WebGLDescriptorSetLayout();
          descriptorSetLayout.initialize(info);
          return descriptorSetLayout;
        };

        _proto.createPipelineLayout = function createPipelineLayout(info) {
          var pipelineLayout = new WebGLPipelineLayout();
          pipelineLayout.initialize(info);
          return pipelineLayout;
        };

        _proto.createPipelineState = function createPipelineState(info) {
          var pipelineState = new WebGLPipelineState();
          pipelineState.initialize(info);
          return pipelineState;
        };

        _proto.createQueue = function createQueue(info) {
          var queue = new WebGLQueue();
          queue.initialize(info);
          return queue;
        };

        _proto.getSampler = function getSampler(info) {
          var hash = Sampler.computeHash(info);

          if (!this._samplers.has(hash)) {
            this._samplers.set(hash, new WebGLSampler(info, hash));
          }

          return this._samplers.get(hash);
        };

        _proto.getGeneralBarrier = function getGeneralBarrier(info) {
          var hash = GeneralBarrier.computeHash(info);

          if (!this._generalBarrierss.has(hash)) {
            this._generalBarrierss.set(hash, new GeneralBarrier(info, hash));
          }

          return this._generalBarrierss.get(hash);
        };

        _proto.getTextureBarrier = function getTextureBarrier(info) {
          var hash = TextureBarrier.computeHash(info);

          if (!this._textureBarriers.has(hash)) {
            this._textureBarriers.set(hash, new TextureBarrier(info, hash));
          }

          return this._textureBarriers.get(hash);
        };

        _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
          WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
        };

        _proto.copyTextureToBuffers = function copyTextureToBuffers(texture, buffers, regions) {
          WebGLCmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
        };

        _proto.copyTexImagesToTexture = function copyTexImagesToTexture(texImages, texture, regions) {
          WebGLCmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
        };

        _createClass(WebGLDevice, [{
          key: "gl",
          get: function get() {
            return this._context;
          }
        }, {
          key: "extensions",
          get: function get() {
            return this._swapchain.extensions;
          }
        }, {
          key: "stateCache",
          get: function get() {
            return this._swapchain.stateCache;
          }
        }, {
          key: "nullTex2D",
          get: function get() {
            return this._swapchain.nullTex2D;
          }
        }, {
          key: "nullTexCube",
          get: function get() {
            return this._swapchain.nullTexCube;
          }
        }, {
          key: "textureExclusive",
          get: function get() {
            return this._textureExclusive;
          }
        }, {
          key: "bindingMappings",
          get: function get() {
            return this._bindingMappings;
          }
        }]);

        return WebGLDevice;
      }(Device));

      legacyCC.WebGLDevice = WebGLDevice;

      var space = 2;
      var Atlas = function () {
        function Atlas(width, height) {
          this._texture = void 0;
          this._width = void 0;
          this._height = void 0;
          this._x = void 0;
          this._y = void 0;
          this._nexty = void 0;
          this._innerTextureInfos = {};
          this._innerSpriteFrames = void 0;
          this._count = void 0;
          var texture = new DynamicAtlasTexture();
          texture.initWithSize(width, height);
          this._texture = texture;
          this._width = width;
          this._height = height;
          this._x = space;
          this._y = space;
          this._nexty = space;
          this._innerTextureInfos = {};
          this._innerSpriteFrames = [];
          this._count = 0;
        }

        var _proto = Atlas.prototype;

        _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
          var rect = spriteFrame.rect;
          var texture = spriteFrame.texture;

          var info = this._innerTextureInfos[texture.getId()];

          var sx = rect.x;
          var sy = rect.y;

          if (info) {
            sx += info.x;
            sy += info.y;
          } else {
            var width = texture.width;
            var height = texture.height;

            if (this._x + width + space > this._width) {
              this._x = space;
              this._y = this._nexty;
            }

            if (this._y + height + space > this._nexty) {
              this._nexty = this._y + height + space;
            }

            if (this._nexty > this._height) {
              return null;
            }

            if (legacyCC.internal.dynamicAtlasManager.textureBleeding) {
              if (width <= 8 || height <= 8) {
                this._texture.drawTextureAt(texture.image, this._x - 1, this._y - 1);

                this._texture.drawTextureAt(texture.image, this._x - 1, this._y + 1);

                this._texture.drawTextureAt(texture.image, this._x + 1, this._y - 1);

                this._texture.drawTextureAt(texture.image, this._x + 1, this._y + 1);
              }

              this._texture.drawTextureAt(texture.image, this._x - 1, this._y);

              this._texture.drawTextureAt(texture.image, this._x + 1, this._y);

              this._texture.drawTextureAt(texture.image, this._x, this._y - 1);

              this._texture.drawTextureAt(texture.image, this._x, this._y + 1);
            }

            this._texture.drawTextureAt(texture.image, this._x, this._y);

            this._innerTextureInfos[texture.getId()] = {
              x: this._x,
              y: this._y,
              texture: texture
            };
            this._count++;
            sx += this._x;
            sy += this._y;
            this._x += width + space;
          }

          var frame = {
            x: sx,
            y: sy,
            texture: this._texture
          };

          this._innerSpriteFrames.push(spriteFrame);

          return frame;
        };

        _proto.deleteInnerTexture = function deleteInnerTexture(texture) {
          if (texture && this._innerTextureInfos[texture.getId()]) {
            delete this._innerTextureInfos[texture.getId()];
            this._count--;
          }
        };

        _proto.isEmpty = function isEmpty() {
          return this._count <= 0;
        };

        _proto.reset = function reset() {
          this._x = space;
          this._y = space;
          this._nexty = space;
          var frames = this._innerSpriteFrames;

          for (var i = 0, l = frames.length; i < l; i++) {
            var frame = frames[i];

            if (!frame.isValid) {
              continue;
            }

            frame._resetDynamicAtlasFrame();
          }

          this._innerSpriteFrames.length = 0;
          this._innerTextureInfos = {};
        };

        _proto.destroy = function destroy() {
          this.reset();

          this._texture.destroy();
        };

        return Atlas;
      }();
      var DynamicAtlasTexture = function (_Texture2D) {
        _inheritsLoose(DynamicAtlasTexture, _Texture2D);

        function DynamicAtlasTexture() {
          return _Texture2D.apply(this, arguments) || this;
        }

        var _proto2 = DynamicAtlasTexture.prototype;

        _proto2.initWithSize = function initWithSize(width, height, format) {
          if (format === void 0) {
            format = PixelFormat.RGBA8888;
          }

          this.reset({
            width: width,
            height: height,
            format: format
          });
        };

        _proto2.drawTextureAt = function drawTextureAt(image, x, y) {
          var gfxTexture = this.getGFXTexture();

          if (!image || !gfxTexture) {
            return;
          }

          var gfxDevice = this._getGFXDevice();

          if (!gfxDevice) {
            console.warn('Unable to get device');
            return;
          }

          var region = new BufferTextureCopy();
          region.texOffset.x = x;
          region.texOffset.y = y;
          region.texExtent.width = image.width;
          region.texExtent.height = image.height;
          gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
        };

        return DynamicAtlasTexture;
      }(Texture2D);

      var DynamicAtlasManager = function () {
        function DynamicAtlasManager() {
          this._atlases = [];
          this._atlasIndex = -1;
          this._maxAtlasCount = 5;
          this._textureSize = 2048;
          this._maxFrameSize = 512;
          this._textureBleeding = true;
          this._enabled = false;
        }

        var _proto = DynamicAtlasManager.prototype;

        _proto.newAtlas = function newAtlas() {
          var atlas = this._atlases[++this._atlasIndex];

          if (!atlas) {
            atlas = new Atlas(this._textureSize, this._textureSize);

            this._atlases.push(atlas);
          }

          return atlas;
        };

        _proto.beforeSceneLoad = function beforeSceneLoad() {
          this.reset();
        };

        _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
          if (!this._enabled || this._atlasIndex === this._maxAtlasCount || !spriteFrame || spriteFrame._original) return null;
          if (!spriteFrame.packable) return null;
          var sampler = spriteFrame.texture.getSamplerInfo();

          if (sampler.minFilter !== Filter$1.LINEAR || sampler.magFilter !== Filter$1.LINEAR || sampler.mipFilter !== Filter$1.NONE) {
            return null;
          }

          var atlas = this._atlases[this._atlasIndex];

          if (!atlas) {
            atlas = this.newAtlas();
          }

          var frame = atlas.insertSpriteFrame(spriteFrame);

          if (!frame && this._atlasIndex !== this._maxAtlasCount) {
            atlas = this.newAtlas();
            return atlas.insertSpriteFrame(spriteFrame);
          }

          return frame;
        };

        _proto.reset = function reset() {
          for (var i = 0, l = this._atlases.length; i < l; i++) {
            this._atlases[i].destroy();
          }

          this._atlases.length = 0;
          this._atlasIndex = -1;
        };

        _proto.deleteAtlasSpriteFrame = function deleteAtlasSpriteFrame(spriteFrame) {
          if (!spriteFrame._original) return;
          var atlas;

          for (var i = this._atlases.length - 1; i >= 0; i--) {
            atlas = this._atlases[i];
            js.array.fastRemove(atlas._innerSpriteFrames, spriteFrame);
          }

          var texture = spriteFrame._original._texture;
          this.deleteAtlasTexture(texture);
        };

        _proto.deleteAtlasTexture = function deleteAtlasTexture(texture) {
          if (texture) {
            for (var i = this._atlases.length - 1; i >= 0; i--) {
              this._atlases[i].deleteInnerTexture(texture);

              if (this._atlases[i].isEmpty()) {
                this._atlases[i].destroy();

                this._atlases.splice(i, 1);

                this._atlasIndex--;
              }
            }
          }
        };

        _proto.packToDynamicAtlas = function packToDynamicAtlas(comp, frame) {

          if (frame && !frame._original && frame.packable && frame.texture && frame.texture.width > 0 && frame.texture.height > 0) {
            var packedFrame = this.insertSpriteFrame(frame);

            if (packedFrame) {
              frame._setDynamicAtlasFrame(packedFrame);
            }
          }
        };

        _createClass(DynamicAtlasManager, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(value) {
            if (this._enabled === value) return;

            if (value) {
              this.reset();
              legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
            } else {
              this.reset();
              legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
            }

            this._enabled = value;
          }
        }, {
          key: "maxAtlasCount",
          get: function get() {
            return this._maxAtlasCount;
          },
          set: function set(value) {
            this._maxAtlasCount = value;
          }
        }, {
          key: "atlasCount",
          get: function get() {
            return this._atlases.length;
          }
        }, {
          key: "textureBleeding",
          get: function get() {
            return this._textureBleeding;
          },
          set: function set(enable) {
            this._textureBleeding = enable;
          }
        }, {
          key: "textureSize",
          get: function get() {
            return this._textureSize;
          },
          set: function set(value) {
            this._textureSize = value;
          }
        }, {
          key: "maxFrameSize",
          get: function get() {
            return this._maxFrameSize;
          },
          set: function set(value) {
            this._maxFrameSize = value;
          }
        }]);

        return DynamicAtlasManager;
      }();
      DynamicAtlasManager.instance = void 0;
      var dynamicAtlasManager = exports('dynamicAtlasManager', DynamicAtlasManager.instance = new DynamicAtlasManager());
      legacyCC.internal.dynamicAtlasManager = dynamicAtlasManager;

      var _dec$L, _class$N, _class2$H, _temp$L;
      var INSET_LEFT = 0;
      var INSET_TOP = 1;
      var INSET_RIGHT = 2;
      var INSET_BOTTOM = 3;
      var temp_uvs = [{
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }];
      var SpriteFrame = exports('SpriteFrame', (_dec$L = ccclass('cc.SpriteFrame'), _dec$L(_class$N = (_temp$L = _class2$H = function (_Asset) {
        _inheritsLoose(SpriteFrame, _Asset);

        SpriteFrame.createWithImage = function createWithImage(imageSourceOrImageAsset) {
          var img = imageSourceOrImageAsset instanceof ImageAsset ? imageSourceOrImageAsset : new ImageAsset(imageSourceOrImageAsset);
          var tex = new Texture2D();
          tex.image = img;
          var spf = new SpriteFrame();
          spf.texture = tex;
          return spf;
        };

        function SpriteFrame() {
          var _this;

          _this = _Asset.call(this) || this;
          _this.vertices = null;
          _this.uv = [];
          _this.unbiasUV = [];
          _this.uvSliced = [];
          _this._rect = new Rect();
          _this._offset = new Vec2();
          _this._originalSize = new Size();
          _this._rotated = false;
          _this._capInsets = [0, 0, 0, 0];
          _this._atlasUuid = '';
          _this._texture = void 0;
          _this._isFlipUVY = false;
          _this._isFlipUVX = false;
          _this._original = null;
          _this._packable = true;

          return _this;
        }

        var _proto = SpriteFrame.prototype;

        _proto.textureLoaded = function textureLoaded() {
          return !!this.texture;
        };

        _proto.isRotated = function isRotated() {
          return this._rotated;
        };

        _proto.setRotated = function setRotated(rotated) {
          this.rotated = rotated;
        };

        _proto.getRect = function getRect(out) {
          if (out) {
            out.set(this._rect);
            return out;
          }

          return this._rect.clone();
        };

        _proto.setRect = function setRect(rect) {
          this.rect = rect;
        };

        _proto.getOriginalSize = function getOriginalSize(out) {
          if (out) {
            out.set(this._originalSize);
            return out;
          }

          return this._originalSize.clone();
        };

        _proto.setOriginalSize = function setOriginalSize(size) {
          this.originalSize = size;
        };

        _proto.getOffset = function getOffset(out) {
          if (out) {
            out.set(this._offset);
            return out;
          }

          return this._offset.clone();
        };

        _proto.setOffset = function setOffset(offset) {
          this.offset = offset;
        };

        _proto.getGFXTexture = function getGFXTexture() {
          return this._texture.getGFXTexture();
        };

        _proto.getGFXSampler = function getGFXSampler() {
          return this._texture.getGFXSampler();
        };

        _proto.getHash = function getHash() {
          return this._texture.getHash();
        };

        _proto.getSamplerInfo = function getSamplerInfo() {
          return this._texture.getSamplerInfo();
        };

        _proto.reset = function reset(info, clearData) {
          if (clearData === void 0) {
            clearData = false;
          }

          var calUV = false;

          if (clearData) {
            this._originalSize.set(0, 0);

            this._rect.set(0, 0, 0, 0);

            this._offset.set(0, 0);

            this._capInsets = [0, 0, 0, 0];
            this._rotated = false;
            calUV = true;
          }

          if (info) {
            if (info.texture) {
              this._rect.x = this._rect.y = 0;
              this._rect.width = info.texture.width;
              this._rect.height = info.texture.height;

              this._refreshTexture(info.texture);

              this.checkRect(this._texture);
            }

            if (info.originalSize) {
              this._originalSize.set(info.originalSize);
            }

            if (info.rect) {
              this._rect.set(info.rect);
            }

            if (info.offset) {
              this._offset.set(info.offset);
            }

            if (info.borderTop !== undefined) {
              this._capInsets[INSET_TOP] = info.borderTop;
            }

            if (info.borderBottom !== undefined) {
              this._capInsets[INSET_BOTTOM] = info.borderBottom;
            }

            if (info.borderLeft !== undefined) {
              this._capInsets[INSET_LEFT] = info.borderLeft;
            }

            if (info.borderRight !== undefined) {
              this._capInsets[INSET_RIGHT] = info.borderRight;
            }

            if (info.isRotate !== undefined) {
              this._rotated = !!info.isRotate;
            }

            if (info.isFlipUv !== undefined) {
              this._isFlipUVY = !!info.isFlipUv;
            }

            calUV = true;
          }

          if (calUV && this.texture) {
            this._calculateUV();
          }
        };

        _proto.checkRect = function checkRect(texture) {
          var rect = this._rect;
          var maxX = rect.x;
          var maxY = rect.y;

          if (this._rotated) {
            maxX += rect.height;
            maxY += rect.width;
          } else {
            maxX += rect.width;
            maxY += rect.height;
          }

          if (maxX > texture.width) {
            errorID(3300, this.name + "/" + texture.name, maxX, texture.width);
            return false;
          }

          if (maxY > texture.height) {
            errorID(3301, this.name + "/" + texture.name, maxY, texture.height);
            return false;
          }

          return true;
        };

        _proto.destroy = function destroy() {
          if (this._packable && dynamicAtlasManager) {
            dynamicAtlasManager.deleteAtlasSpriteFrame(this);
          }

          return _Asset.prototype.destroy.call(this);
        };

        _proto._calculateSlicedUV = function _calculateSlicedUV() {
          var rect = this._rect;
          var tex = this.texture;
          var atlasWidth = tex.width;
          var atlasHeight = tex.height;
          var leftWidth = this._capInsets[INSET_LEFT];
          var rightWidth = this._capInsets[INSET_RIGHT];
          var centerWidth = rect.width - leftWidth - rightWidth;
          var topHeight = this._capInsets[INSET_TOP];
          var bottomHeight = this._capInsets[INSET_BOTTOM];
          var centerHeight = rect.height - topHeight - bottomHeight;
          var uvSliced = this.uvSliced;
          uvSliced.length = 0;

          if (this._rotated) {
            temp_uvs[0].u = rect.x / atlasWidth;
            temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
            temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
            temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
            temp_uvs[3].v = rect.y / atlasHeight;
            temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
            temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
            temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;

            for (var row = 0; row < 4; ++row) {
              var rowD = temp_uvs[row];

              for (var col = 0; col < 4; ++col) {
                var colD = temp_uvs[3 - col];
                uvSliced.push({
                  u: rowD.u,
                  v: colD.v
                });
              }
            }
          } else {
            temp_uvs[0].u = rect.x / atlasWidth;
            temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
            temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
            temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
            temp_uvs[3].v = rect.y / atlasHeight;
            temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
            temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
            temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;

            for (var _row = 0; _row < 4; ++_row) {
              var _rowD = temp_uvs[_row];

              for (var _col = 0; _col < 4; ++_col) {
                var _colD = temp_uvs[_col];
                uvSliced.push({
                  u: _colD.u,
                  v: _rowD.v
                });
              }
            }
          }

          this.emit(SpriteFrame.EVENT_UV_UPDATED, this);
        };

        _proto._calculateUV = function _calculateUV() {
          var rect = this._rect;
          var uv = this.uv;
          var unbiasUV = this.unbiasUV;
          var tex = this.texture;
          var texw = tex.width;
          var texh = tex.height;

          if (this._rotated) {
            var l = texw === 0 ? 0 : rect.x / texw;
            var r = texw === 0 ? 1 : (rect.x + rect.height) / texw;
            var t = texh === 0 ? 0 : rect.y / texh;
            var b = texh === 0 ? 1 : (rect.y + rect.width) / texh;

            if (this._isFlipUVX && this._isFlipUVY) {
              uv[0] = r;
              uv[1] = b;
              uv[2] = r;
              uv[3] = t;
              uv[4] = l;
              uv[5] = b;
              uv[6] = l;
              uv[7] = t;
            } else if (this._isFlipUVX) {
              uv[0] = r;
              uv[1] = t;
              uv[2] = r;
              uv[3] = b;
              uv[4] = l;
              uv[5] = t;
              uv[6] = l;
              uv[7] = b;
            } else if (this._isFlipUVY) {
              uv[0] = l;
              uv[1] = b;
              uv[2] = l;
              uv[3] = t;
              uv[4] = r;
              uv[5] = b;
              uv[6] = r;
              uv[7] = t;
            } else {
              uv[0] = l;
              uv[1] = t;
              uv[2] = l;
              uv[3] = b;
              uv[4] = r;
              uv[5] = t;
              uv[6] = r;
              uv[7] = b;
            }

            var ul = texw === 0 ? 0 : rect.x / texw;
            var ur = texw === 0 ? 1 : (rect.x + rect.height) / texw;
            var ut = texh === 0 ? 0 : rect.y / texh;
            var ub = texh === 0 ? 1 : (rect.y + rect.width) / texh;

            if (this._isFlipUVX && this._isFlipUVY) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ub;
              unbiasUV[2] = ur;
              unbiasUV[3] = ut;
              unbiasUV[4] = ul;
              unbiasUV[5] = ub;
              unbiasUV[6] = ul;
              unbiasUV[7] = ut;
            } else if (this._isFlipUVX) {
              unbiasUV[0] = ur;
              unbiasUV[1] = ut;
              unbiasUV[2] = ur;
              unbiasUV[3] = ub;
              unbiasUV[4] = ul;
              unbiasUV[5] = ut;
              unbiasUV[6] = ul;
              unbiasUV[7] = ub;
            } else if (this._isFlipUVY) {
              unbiasUV[0] = ul;
              unbiasUV[1] = ub;
              unbiasUV[2] = ul;
              unbiasUV[3] = ut;
              unbiasUV[4] = ur;
              unbiasUV[5] = ub;
              unbiasUV[6] = ur;
              unbiasUV[7] = ut;
            } else {
              unbiasUV[0] = ul;
              unbiasUV[1] = ut;
              unbiasUV[2] = ul;
              unbiasUV[3] = ub;
              unbiasUV[4] = ur;
              unbiasUV[5] = ut;
              unbiasUV[6] = ur;
              unbiasUV[7] = ub;
            }
          } else {
            var _l = texw === 0 ? 0 : rect.x / texw;

            var _r = texw === 0 ? 1 : (rect.x + rect.width) / texw;

            var _b = texh === 0 ? 1 : (rect.y + rect.height) / texh;

            var _t = texh === 0 ? 0 : rect.y / texh;

            if (this._isFlipUVX && this._isFlipUVY) {
              uv[0] = _r;
              uv[1] = _t;
              uv[2] = _l;
              uv[3] = _t;
              uv[4] = _r;
              uv[5] = _b;
              uv[6] = _l;
              uv[7] = _b;
            } else if (this._isFlipUVX) {
              uv[0] = _r;
              uv[1] = _b;
              uv[2] = _l;
              uv[3] = _b;
              uv[4] = _r;
              uv[5] = _t;
              uv[6] = _l;
              uv[7] = _t;
            } else if (this._isFlipUVY) {
              uv[0] = _l;
              uv[1] = _t;
              uv[2] = _r;
              uv[3] = _t;
              uv[4] = _l;
              uv[5] = _b;
              uv[6] = _r;
              uv[7] = _b;
            } else {
              uv[0] = _l;
              uv[1] = _b;
              uv[2] = _r;
              uv[3] = _b;
              uv[4] = _l;
              uv[5] = _t;
              uv[6] = _r;
              uv[7] = _t;
            }

            var _ul = texw === 0 ? 0 : rect.x / texw;

            var _ur = texw === 0 ? 1 : (rect.x + rect.width) / texw;

            var _ub = texh === 0 ? 1 : (rect.y + rect.height) / texh;

            var _ut = texh === 0 ? 0 : rect.y / texh;

            if (this._isFlipUVX && this._isFlipUVY) {
              unbiasUV[0] = _ur;
              unbiasUV[1] = _ut;
              unbiasUV[2] = _ul;
              unbiasUV[3] = _ut;
              unbiasUV[4] = _ur;
              unbiasUV[5] = _ub;
              unbiasUV[6] = _ul;
              unbiasUV[7] = _ub;
            } else if (this._isFlipUVX) {
              unbiasUV[0] = _ur;
              unbiasUV[1] = _ub;
              unbiasUV[2] = _ul;
              unbiasUV[3] = _ub;
              unbiasUV[4] = _ur;
              unbiasUV[5] = _ut;
              unbiasUV[6] = _ul;
              unbiasUV[7] = _ut;
            } else if (this._isFlipUVY) {
              unbiasUV[0] = _ul;
              unbiasUV[1] = _ut;
              unbiasUV[2] = _ur;
              unbiasUV[3] = _ut;
              unbiasUV[4] = _ul;
              unbiasUV[5] = _ub;
              unbiasUV[6] = _ur;
              unbiasUV[7] = _ub;
            } else {
              unbiasUV[0] = _ul;
              unbiasUV[1] = _ub;
              unbiasUV[2] = _ur;
              unbiasUV[3] = _ub;
              unbiasUV[4] = _ul;
              unbiasUV[5] = _ut;
              unbiasUV[6] = _ur;
              unbiasUV[7] = _ut;
            }
          }

          var vertices = this.vertices;

          if (vertices) {
            vertices.nu.length = 0;
            vertices.nv.length = 0;

            for (var i = 0; i < vertices.u.length; i++) {
              vertices.nu[i] = vertices.u[i] / texw;
              vertices.nv[i] = vertices.v[i] / texh;
            }
          }

          this._calculateSlicedUV();
        };

        _proto._setDynamicAtlasFrame = function _setDynamicAtlasFrame(frame) {
          if (!frame) return;
          this._original = {
            _texture: this._texture,
            _x: this._rect.x,
            _y: this._rect.y
          };
          this._texture = frame.texture;
          this._rect.x = frame.x;
          this._rect.y = frame.y;

          this._calculateUV();
        };

        _proto._resetDynamicAtlasFrame = function _resetDynamicAtlasFrame() {
          if (!this._original) return;
          this._rect.x = this._original._x;
          this._rect.y = this._original._y;
          this._texture = this._original._texture;
          this._original = null;

          this._calculateUV();
        };

        _proto._checkPackable = function _checkPackable() {
          var dynamicAtlas = dynamicAtlasManager;
          if (!dynamicAtlas) return;
          var texture = this._texture;

          if (!(texture instanceof Texture2D) || texture.isCompressed) {
            this._packable = false;
            return;
          }

          var w = this.width;
          var h = this.height;

          if (!texture.image || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize) {
            this._packable = false;
            return;
          }

          if (texture.image && texture.image instanceof HTMLCanvasElement) {
            this._packable = true;
          }
        };

        _proto._serialize = function _serialize(ctxForExporting) {

          return null;
        };

        _proto._deserialize = function _deserialize(serializeData, handle) {
          var data = serializeData;
          var rect = data.rect;

          if (rect) {
            this._rect = new Rect(rect.x, rect.y, rect.width, rect.height);
          }

          var offset = data.offset;

          if (data.offset) {
            this._offset = new Vec2(offset.x, offset.y);
          }

          var originalSize = data.originalSize;

          if (data.originalSize) {
            this._originalSize = new Size(originalSize.width, originalSize.height);
          }

          this._rotated = !!data.rotated;
          this._name = data.name;
          this._packable = !!data.packable;
          var capInsets = data.capInsets;

          if (capInsets) {
            this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
            this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
            this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
            this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
          }

          this.vertices = data.vertices;

          if (this.vertices) {
            this.vertices.nu = [];
            this.vertices.nv = [];
          }
        };

        _proto.clone = function clone() {
          var _v$nu, _v$u, _v$nv, _v$v, _sp$uv, _sp$unbiasUV, _sp$uvSliced, _sp$_capInsets;

          var sp = new SpriteFrame();
          var v = this.vertices;
          sp.vertices = v ? {
            x: v.x,
            y: v.y,
            triangles: v.triangles,
            nu: (_v$nu = v.nu) === null || _v$nu === void 0 ? void 0 : _v$nu.slice(0),
            u: (_v$u = v.u) === null || _v$u === void 0 ? void 0 : _v$u.slice(0),
            nv: (_v$nv = v.nv) === null || _v$nv === void 0 ? void 0 : _v$nv.slice(0),
            v: (_v$v = v.v) === null || _v$v === void 0 ? void 0 : _v$v.slice(0)
          } : null;

          (_sp$uv = sp.uv).splice.apply(_sp$uv, [0, sp.uv.length].concat(this.uv));

          (_sp$unbiasUV = sp.unbiasUV).splice.apply(_sp$unbiasUV, [0, sp.unbiasUV.length].concat(this.unbiasUV));

          (_sp$uvSliced = sp.uvSliced).splice.apply(_sp$uvSliced, [0, sp.uvSliced.length].concat(this.uvSliced));

          sp._rect.set(this._rect);

          sp._offset.set(this._offset);

          sp._originalSize.set(this._originalSize);

          sp._rotated = this._rotated;

          (_sp$_capInsets = sp._capInsets).splice.apply(_sp$_capInsets, [0, sp._capInsets.length].concat(this._capInsets));

          sp._atlasUuid = this._atlasUuid;
          sp._texture = this._texture;
          sp._isFlipUVX = this._isFlipUVX;
          sp._isFlipUVY = this._isFlipUVY;
          return sp;
        };

        _proto._refreshTexture = function _refreshTexture(texture) {
          this._texture = texture;
          var tex = this._texture;
          var config = {};
          var isReset = false;

          if (this._rect.width === 0 || this._rect.height === 0 || !this.checkRect(tex)) {
            config.rect = new Rect(0, 0, tex.width, tex.height);
            isReset = true;
          }

          if (this._originalSize.width === 0 || this._originalSize.height === 0 || isReset) {
            config.originalSize = new Size(tex.width, tex.height);
            isReset = true;
          }

          if (isReset) {
            this.reset(config);
            this.onLoaded();
          }

          this._checkPackable();
        };

        _proto.initDefault = function initDefault(uuid) {
          _Asset.prototype.initDefault.call(this, uuid);

          var texture = new Texture2D();
          texture.initDefault();

          this._refreshTexture(texture);

          this._calculateUV();
        };

        _proto.validate = function validate() {
          return this._texture && this._rect && this._rect.width !== 0 && this._rect.height !== 0;
        };

        _createClass(SpriteFrame, [{
          key: "insetTop",
          get: function get() {
            return this._capInsets[INSET_TOP];
          },
          set: function set(value) {
            if (this._capInsets[INSET_TOP] === value) {
              return;
            }

            this._capInsets[INSET_TOP] = value;

            if (this._texture) {
              this._calculateSlicedUV();
            }
          }
        }, {
          key: "insetBottom",
          get: function get() {
            return this._capInsets[INSET_BOTTOM];
          },
          set: function set(value) {
            if (this._capInsets[INSET_BOTTOM] === value) {
              return;
            }

            this._capInsets[INSET_BOTTOM] = value;

            if (this._texture) {
              this._calculateSlicedUV();
            }
          }
        }, {
          key: "insetLeft",
          get: function get() {
            return this._capInsets[INSET_LEFT];
          },
          set: function set(value) {
            if (this._capInsets[INSET_LEFT] === value) {
              return;
            }

            this._capInsets[INSET_LEFT] = value;

            if (this._texture) {
              this._calculateSlicedUV();
            }
          }
        }, {
          key: "insetRight",
          get: function get() {
            return this._capInsets[INSET_RIGHT];
          },
          set: function set(value) {
            if (this._capInsets[INSET_RIGHT] === value) {
              return;
            }

            this._capInsets[INSET_RIGHT] = value;

            if (this._texture) {
              this._calculateSlicedUV();
            }
          }
        }, {
          key: "rect",
          get: function get() {
            return this._rect;
          },
          set: function set(value) {
            if (this._rect.equals(value)) {
              return;
            }

            this._rect.set(value);

            if (this._texture) {
              this._calculateUV();
            }
          }
        }, {
          key: "originalSize",
          get: function get() {
            return this._originalSize;
          },
          set: function set(value) {
            if (this._originalSize.equals(value)) {
              return;
            }

            this._originalSize.set(value);

            if (this._texture) {
              this._calculateUV();
            }
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(value) {
            this._offset.set(value);
          }
        }, {
          key: "rotated",
          get: function get() {
            return this._rotated;
          },
          set: function set(rotated) {
            if (this._rotated === rotated) {
              return;
            }

            this._rotated = rotated;

            if (this._texture) {
              this._calculateUV();
            }
          }
        }, {
          key: "texture",
          get: function get() {
            return this._texture;
          },
          set: function set(value) {
            if (!value) {
              warnID(3122, this.name);
              return;
            }

            if (value === this._texture) {
              return;
            }

            this.reset({
              texture: value
            }, true);
          }
        }, {
          key: "atlasUuid",
          get: function get() {
            return this._atlasUuid;
          },
          set: function set(value) {
            this._atlasUuid = value;
          }
        }, {
          key: "width",
          get: function get() {
            return this._texture.width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._texture.height;
          }
        }, {
          key: "_textureSource",
          set: function set(value) {
            if (window.Build) {
              this._texture = value;
              return;
            }

            if (value) {
              this._refreshTexture(value);

              this._calculateUV();
            }
          }
        }, {
          key: "flipUVX",
          get: function get() {
            return this._isFlipUVX;
          },
          set: function set(value) {
            this._isFlipUVX = value;

            this._calculateUV();
          }
        }, {
          key: "flipUVY",
          get: function get() {
            return this._isFlipUVY;
          },
          set: function set(value) {
            this._isFlipUVY = value;

            this._calculateUV();
          }
        }, {
          key: "packable",
          get: function get() {
            return this._packable;
          },
          set: function set(value) {
            this._packable = value;
          }
        }, {
          key: "original",
          get: function get() {
            return this._original;
          }
        }]);

        return SpriteFrame;
      }(Asset), _class2$H.EVENT_UV_UPDATED = 'uv_updated', _temp$L)) || _class$N));
      legacyCC.SpriteFrame = SpriteFrame;

      var _dec$M, _class$O, _class2$I, _descriptor$A, _temp$M;
      var SpriteAtlas = exports('SpriteAtlas', (_dec$M = ccclass('cc.SpriteAtlas'), _dec$M(_class$O = (_class2$I = (_temp$M = function (_Asset) {
        _inheritsLoose(SpriteAtlas, _Asset);

        function SpriteAtlas() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "spriteFrames", _descriptor$A, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = SpriteAtlas.prototype;

        _proto.getTexture = function getTexture() {
          var keys = Object.keys(this.spriteFrames);

          if (keys.length > 0) {
            var spriteFrame = this.spriteFrames[keys[0]];
            return spriteFrame && spriteFrame.texture;
          } else {
            return null;
          }
        };

        _proto.getSpriteFrame = function getSpriteFrame(key) {
          var sf = this.spriteFrames[key];

          if (!sf) {
            return null;
          }

          if (!sf.name) {
            sf.name = key;
          }

          return sf;
        };

        _proto.getSpriteFrames = function getSpriteFrames() {
          var frames = [];
          var spriteFrames = this.spriteFrames;

          for (var _i = 0, _Object$keys = Object.keys(spriteFrames); _i < _Object$keys.length; _i++) {
            var _key2 = _Object$keys[_i];
            frames.push(spriteFrames[_key2]);
          }

          return frames;
        };

        _proto._serialize = function _serialize(ctxForExporting) {
        };

        _proto._deserialize = function _deserialize(serializeData, handle) {
          var data = serializeData;
          this._name = data.name;
          var frames = data.spriteFrames;
          this.spriteFrames = createMap();

          for (var i = 0; i < frames.length; i += 2) {
            handle.result.push(this.spriteFrames, frames[i], frames[i + 1], _getClassId(SpriteFrame));
          }
        };

        return SpriteAtlas;
      }(Asset), _temp$M), (_descriptor$A = _applyDecoratedDescriptor(_class2$I.prototype, "spriteFrames", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return createMap();
        }
      })), _class2$I)) || _class$O));
      legacyCC.SpriteAtlas = SpriteAtlas;

      var _dec$N, _class$P;
      var Font = exports('Font', (_dec$N = ccclass('cc.Font'), _dec$N(_class$P = function (_Asset) {
        _inheritsLoose(Font, _Asset);

        function Font() {
          return _Asset.apply(this, arguments) || this;
        }

        return Font;
      }(Asset)) || _class$P));
      legacyCC.Font = Font;

      var _dec$O, _class$Q, _class2$J, _descriptor$B, _temp$N;
      var TTFFont = exports('TTFFont', (_dec$O = ccclass('cc.TTFFont'), _dec$O(_class$Q = (_class2$J = (_temp$N = function (_Font) {
        _inheritsLoose(TTFFont, _Font);

        function TTFFont() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Font.call.apply(_Font, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_fontFamily", _descriptor$B, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = TTFFont.prototype;

        _proto.initDefault = function initDefault(uuid) {
          this._fontFamily = 'Arial';

          _Font.prototype.initDefault.call(this, uuid);
        };

        _createClass(TTFFont, [{
          key: "_nativeAsset",
          get: function get() {
            return this._fontFamily;
          },
          set: function set(value) {
            this._fontFamily = value || 'Arial';
          }
        }, {
          key: "_nativeDep",
          get: function get() {
            return {
              uuid: this._uuid,
              __nativeName__: this._native,
              ext: extname(this._native),
              __isNative__: true
            };
          }
        }]);

        return TTFFont;
      }(Font), _temp$N), (_descriptor$B = _applyDecoratedDescriptor(_class2$J.prototype, "_fontFamily", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$J.prototype, "_nativeAsset", [override, string], Object.getOwnPropertyDescriptor(_class2$J.prototype, "_nativeAsset"), _class2$J.prototype), _applyDecoratedDescriptor(_class2$J.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$J.prototype, "_nativeDep"), _class2$J.prototype)), _class2$J)) || _class$Q));
      legacyCC.TTFFont = TTFFont;

      var _dec$P, _dec2$p, _class$R, _class2$K, _descriptor$C, _descriptor2$n, _descriptor3$h, _descriptor4$e, _temp$O;
      var FontLetterDefinition = function FontLetterDefinition() {
        this.u = 0;
        this.v = 0;
        this.w = 0;
        this.h = 0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.textureID = 0;
        this.valid = false;
        this.xAdvance = 0;
      };
      var FontAtlas = function () {
        function FontAtlas(texture) {
          this.letterDefinitions = {};
          this.texture = texture;
        }

        var _proto = FontAtlas.prototype;

        _proto.addLetterDefinitions = function addLetterDefinitions(letter, letterDefinition) {
          this.letterDefinitions[letter] = letterDefinition;
        };

        _proto.cloneLetterDefinition = function cloneLetterDefinition() {
          var copyLetterDefinitions = {};

          for (var _i = 0, _Object$keys = Object.keys(this.letterDefinitions); _i < _Object$keys.length; _i++) {
            var _key = _Object$keys[_i];
            var value = new FontLetterDefinition();
            mixin(value, this.letterDefinitions[_key]);
            copyLetterDefinitions[_key] = value;
          }

          return copyLetterDefinitions;
        };

        _proto.getTexture = function getTexture() {
          return this.texture;
        };

        _proto.getLetter = function getLetter(key) {
          return this.letterDefinitions[key];
        };

        _proto.getLetterDefinitionForChar = function getLetterDefinitionForChar(_char, labelInfo) {
          var key = _char.charCodeAt(0);

          var hasKey = this.letterDefinitions.hasOwnProperty(key);
          var letter;

          if (hasKey) {
            letter = this.letterDefinitions[key];
          } else {
            letter = null;
          }

          return letter;
        };

        _proto.clear = function clear() {
          this.letterDefinitions = {};
        };

        return FontAtlas;
      }();
      var BitmapFont = exports('BitmapFont', (_dec$P = ccclass('cc.BitmapFont'), _dec2$p = type(SpriteFrame), _dec$P(_class$R = (_class2$K = (_temp$O = function (_Font) {
        _inheritsLoose(BitmapFont, _Font);

        function BitmapFont() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            args[_key2] = arguments[_key2];
          }

          _this = _Font.call.apply(_Font, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "fntDataStr", _descriptor$C, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "spriteFrame", _descriptor2$n, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "fontSize", _descriptor3$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "fntConfig", _descriptor4$e, _assertThisInitialized(_this));

          return _this;
        }

        var _proto2 = BitmapFont.prototype;

        _proto2.onLoaded = function onLoaded() {
          var spriteFrame = this.spriteFrame;

          if (!this.fontDefDictionary && spriteFrame) {
            this.fontDefDictionary = new FontAtlas(spriteFrame.texture);
          }

          var fntConfig = this.fntConfig;

          if (!fntConfig) {
            warn('The fnt config is not exists!');
            return;
          }

          var fontDict = fntConfig.fontDefDictionary;

          for (var fontDef in fontDict) {
            var letter = new FontLetterDefinition();
            var rect = fontDict[fontDef].rect;
            letter.offsetX = fontDict[fontDef].xOffset;
            letter.offsetY = fontDict[fontDef].yOffset;
            letter.w = rect.width;
            letter.h = rect.height;
            letter.u = rect.x;
            letter.v = rect.y;
            letter.textureID = 0;
            letter.valid = true;
            letter.xAdvance = fontDict[fontDef].xAdvance;
            this.fontDefDictionary.addLetterDefinitions(fontDef, letter);
          }
        };

        return BitmapFont;
      }(Font), _temp$O), (_descriptor$C = _applyDecoratedDescriptor(_class2$K.prototype, "fntDataStr", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor2$n = _applyDecoratedDescriptor(_class2$K.prototype, "spriteFrame", [_dec2$p], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$h = _applyDecoratedDescriptor(_class2$K.prototype, "fontSize", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -1;
        }
      }), _descriptor4$e = _applyDecoratedDescriptor(_class2$K.prototype, "fntConfig", [serializable, editable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$K)) || _class$R));
      legacyCC.BitmapFont = BitmapFont;

      var _dec$Q, _class$S;
      var LabelAtlas = exports('LabelAtlas', (_dec$Q = ccclass('cc.LabelAtlas'), _dec$Q(_class$S = function (_BitmapFont) {
        _inheritsLoose(LabelAtlas, _BitmapFont);

        function LabelAtlas() {
          return _BitmapFont.apply(this, arguments) || this;
        }

        return LabelAtlas;
      }(BitmapFont)) || _class$S));
      legacyCC.LabelAtlas = LabelAtlas;

      var _dec$R, _dec2$q, _dec3$k, _dec4$d, _dec5$a, _dec6$7, _dec7$5, _dec8$5, _class$T, _class2$L, _descriptor$D, _descriptor2$o, _class3$i, _temp$P;

      var _vec2a = new Vec2();

      var _vec2b = new Vec2();

      var _vec3a = new Vec3();

      var _mat4_temp = new Mat4();

      var _matrix = new Mat4();

      var _worldMatrix = new Mat4();

      var _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

      var _rect = new Rect();

      var UITransform = function (v) { return exports({ UITransform: v, UITransformComponent: v }), v; }((_dec$R = ccclass('cc.UITransform'), _dec2$q = help(), _dec3$k = executionOrder(110), _dec4$d = menu(), _dec5$a = displayOrder(), _dec6$7 = tooltip(), _dec7$5 = displayOrder(), _dec8$5 = tooltip(), _dec$R(_class$T = _dec2$q(_class$T = _dec3$k(_class$T = _dec4$d(_class$T = disallowMultiple(_class$T = executeInEditMode(_class$T = (_class2$L = (_temp$P = _class3$i = function (_Component) {
        _inheritsLoose(UITransform, _Component);

        function UITransform() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._priority = 0;

          _initializerDefineProperty(_this, "_contentSize", _descriptor$D, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_anchorPoint", _descriptor2$o, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = UITransform.prototype;

        _proto.__preload = function __preload() {
          this.node._uiProps.uiTransformComp = this;
        };

        _proto.onLoad = function onLoad() {
          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        };

        _proto.onEnable = function onEnable() {
          this.node.on(NodeEventType.PARENT_CHANGED, this._parentChanged, this);

          this._markRenderDataDirty();
        };

        _proto.onDisable = function onDisable() {
          this.node.off(NodeEventType.PARENT_CHANGED, this._parentChanged, this);
        };

        _proto.onDestroy = function onDestroy() {
          this.node._uiProps.uiTransformComp = null;
        };

        _proto.setContentSize = function setContentSize(size, height) {
          var locContentSize = this._contentSize;

          if (height === undefined) {
            size = size;

            if (approx(size.width, locContentSize.width, EPSILON) && approx(size.height, locContentSize.height, EPSILON)) {
              return;
            }

            locContentSize.width = size.width;
            locContentSize.height = size.height;
          } else {
            size = size;

            if (approx(size, locContentSize.width, EPSILON) && approx(height, locContentSize.height, EPSILON)) {
              return;
            }

            locContentSize.width = size;
            locContentSize.height = height;
          }

          {
            this.node.emit(NodeEventType.SIZE_CHANGED);
          }

          this._markRenderDataDirty();
        };

        _proto.setAnchorPoint = function setAnchorPoint(point, y) {
          var locAnchorPoint = this._anchorPoint;

          if (y === undefined) {
            point = point;

            if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
              return;
            }

            locAnchorPoint.x = point.x;
            locAnchorPoint.y = point.y;
          } else {
            if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
              return;
            }

            locAnchorPoint.x = point;
            locAnchorPoint.y = y;
          }

          this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

          this._markRenderDataDirty();
        };

        _proto.isHit = function isHit(uiPoint) {
          var w = this._contentSize.width;
          var h = this._contentSize.height;
          var v2WorldPt = _vec2a;
          var testPt = _vec2b;

          var cameras = this._getRenderScene().cameras;

          for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];
            if (!(camera.visibility & this.node.layer)) continue;
            camera.node.getWorldRT(_mat4_temp);
            var m12 = _mat4_temp.m12;
            var m13 = _mat4_temp.m13;
            var center = visibleRect.center;
            _mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13);
            _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13);
            Mat4.invert(_mat4_temp, _mat4_temp);
            Vec2.transformMat4(v2WorldPt, uiPoint, _mat4_temp);
            this.node.getWorldMatrix(_worldMatrix);
            Mat4.invert(_mat4_temp, _worldMatrix);

            if (Mat4.strictEquals(_mat4_temp, _zeroMatrix)) {
              continue;
            }

            Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp);
            testPt.x += this._anchorPoint.x * w;
            testPt.y += this._anchorPoint.y * h;
            var hit = false;

            if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
              hit = this._maskTest(v2WorldPt);
            }

            if (hit) {
              return true;
            }
          }

          return false;
        };

        _proto.hitTest = function hitTest(screenPoint) {
          var w = this._contentSize.width;
          var h = this._contentSize.height;
          var v3WorldPt = _vec3a;
          var v2WorldPt = _vec2a;
          var testPt = _vec2b;

          var cameras = this._getRenderScene().cameras;

          for (var i = 0; i < cameras.length; i++) {
            var camera = cameras[i];
            if (!(camera.visibility & this.node.layer)) continue;
            Vec3.set(v3WorldPt, screenPoint.x, screenPoint.y, 0);
            camera.screenToWorld(v3WorldPt, v3WorldPt);
            Vec2.set(v2WorldPt, v3WorldPt.x, v3WorldPt.y);
            this.node.getWorldMatrix(_worldMatrix);
            Mat4.invert(_mat4_temp, _worldMatrix);

            if (Mat4.strictEquals(_mat4_temp, _zeroMatrix)) {
              continue;
            }

            Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp);
            testPt.x += this._anchorPoint.x * w;
            testPt.y += this._anchorPoint.y * h;
            var hit = false;

            if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
              hit = this._maskTest(v2WorldPt);
            }

            if (hit) {
              return true;
            }
          }

          return false;
        };

        _proto._maskTest = function _maskTest(pointInWorldSpace) {
          var _this$node, _this$node$eventProce;

          var maskList = (_this$node = this.node) === null || _this$node === void 0 ? void 0 : (_this$node$eventProce = _this$node.eventProcessor) === null || _this$node$eventProce === void 0 ? void 0 : _this$node$eventProce.maskList;

          if (maskList) {
            var parent = this.node;
            var length = maskList.length;

            for (var i = 0, j = 0; parent && j < length; ++i, parent = parent.parent) {
              var temp = maskList[j];

              if (i === temp.index) {
                if (parent === temp.comp.node) {
                  var comp = temp.comp;

                  if (comp && comp._enabled && !comp.isHit(pointInWorldSpace)) {
                    return false;
                  }

                  j++;
                } else {
                  maskList.length = j;
                  break;
                }
              } else if (i > temp.index) {
                maskList.length = j;
                break;
              }
            }
          }

          return true;
        };

        _proto.convertToNodeSpaceAR = function convertToNodeSpaceAR(worldPoint, out) {
          this.node.getWorldMatrix(_worldMatrix);
          Mat4.invert(_mat4_temp, _worldMatrix);

          if (!out) {
            out = new Vec3();
          }

          return Vec3.transformMat4(out, worldPoint, _mat4_temp);
        };

        _proto.convertToWorldSpaceAR = function convertToWorldSpaceAR(nodePoint, out) {
          this.node.getWorldMatrix(_worldMatrix);

          if (!out) {
            out = new Vec3();
          }

          return Vec3.transformMat4(out, nodePoint, _worldMatrix);
        };

        _proto.getBoundingBox = function getBoundingBox() {
          Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
          var width = this._contentSize.width;
          var height = this._contentSize.height;
          var rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
          rect.transformMat4(_matrix);
          return rect;
        };

        _proto.getBoundingBoxToWorld = function getBoundingBoxToWorld() {
          if (this.node.parent) {
            this.node.parent.getWorldMatrix(_worldMatrix);
            return this.getBoundingBoxTo(_worldMatrix);
          }

          return this.getBoundingBox();
        };

        _proto.getBoundingBoxTo = function getBoundingBoxTo(parentMat) {
          Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
          var width = this._contentSize.width;
          var height = this._contentSize.height;
          var rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
          Mat4.multiply(_worldMatrix, parentMat, _matrix);
          rect.transformMat4(_worldMatrix);

          if (!this.node.children) {
            return rect;
          }

          var locChildren = this.node.children;

          for (var _iterator = _createForOfIteratorHelperLoose(locChildren), _step; !(_step = _iterator()).done;) {
            var child = _step.value;

            if (child && child.active) {
              var uiTransform = child.getComponent(UITransform);

              if (uiTransform) {
                var childRect = uiTransform.getBoundingBoxTo(parentMat);

                if (childRect) {
                  Rect.union(rect, rect, childRect);
                }
              }
            }
          }

          return rect;
        };

        _proto.getComputeAABB = function getComputeAABB(out) {
          var width = this._contentSize.width;
          var height = this._contentSize.height;

          _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);

          _rect.transformMat4(this.node.worldMatrix);

          var px = _rect.x + _rect.width * 0.5;
          var py = _rect.y + _rect.height * 0.5;
          var pz = this.node.worldPosition.z;
          var w = _rect.width / 2;
          var h = _rect.height / 2;
          var l = 0.001;

          if (out != null) {
            AABB.set(out, px, py, pz, w, h, l);
            return out;
          } else {
            return new AABB(px, py, pz, w, h, l);
          }
        };

        _proto._parentChanged = function _parentChanged(node) {
          if (this.node.getComponent('cc.RenderRoot2D')) {
            return;
          }

          if (this.node.parent) {
            UITransform.insertChangeMap(this.node.parent);
          }
        };

        _proto._markRenderDataDirty = function _markRenderDataDirty() {
          var uiComp = this.node._uiProps.uiComp;

          if (uiComp) {
            uiComp.markForUpdateRenderData();

            if (uiComp.renderData) {
              uiComp.renderData.vertDirty = true;
            }
          }
        };

        UITransform.insertChangeMap = function insertChangeMap(node) {
          var key = node.uuid;

          if (!UITransform.priorityChangeNodeMap.has(key)) {
            UITransform.priorityChangeNodeMap.set(key, node);
          }
        };

        UITransform._sortChildrenSibling = function _sortChildrenSibling(node) {
          var siblings = node.children;

          if (siblings) {
            siblings.sort(function (a, b) {
              var aComp = a._uiProps.uiTransformComp;
              var bComp = b._uiProps.uiTransformComp;
              var ca = aComp ? aComp._priority : 0;
              var cb = bComp ? bComp._priority : 0;
              var diff = ca - cb;
              if (diff === 0) return a.getSiblingIndex() - b.getSiblingIndex();
              return diff;
            });
          }
        };

        UITransform._sortSiblings = function _sortSiblings() {
          UITransform.priorityChangeNodeMap.forEach(function (node, ID) {
            UITransform._sortChildrenSibling(node);

            node._updateSiblingIndex();

            node.emit('childrenSiblingOrderChanged');
          });
          UITransform.priorityChangeNodeMap.clear();
        };

        UITransform._cleanChangeMap = function _cleanChangeMap() {
          UITransform.priorityChangeNodeMap.clear();
        };

        _createClass(UITransform, [{
          key: "contentSize",
          get: function get() {
            return this._contentSize;
          },
          set: function set(value) {
            if (this._contentSize.equals(value)) {
              return;
            }

            this._contentSize.set(value);

            {
              this.node.emit(NodeEventType.SIZE_CHANGED);
            }

            this._markRenderDataDirty();
          }
        }, {
          key: "width",
          get: function get() {
            return this._contentSize.width;
          },
          set: function set(value) {
            if (this._contentSize.width === value) {
              return;
            }

            this._contentSize.width = value;

            {
              this.node.emit(NodeEventType.SIZE_CHANGED);
            }

            this._markRenderDataDirty();
          }
        }, {
          key: "height",
          get: function get() {
            return this._contentSize.height;
          },
          set: function set(value) {
            if (this.contentSize.height === value) {
              return;
            }

            this._contentSize.height = value;

            {
              this.node.emit(NodeEventType.SIZE_CHANGED);
            }

            this._markRenderDataDirty();
          }
        }, {
          key: "anchorPoint",
          get: function get() {
            return this._anchorPoint;
          },
          set: function set(value) {
            if (this._anchorPoint.equals(value)) {
              return;
            }

            this._anchorPoint.set(value);

            this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

            this._markRenderDataDirty();
          }
        }, {
          key: "anchorX",
          get: function get() {
            return this._anchorPoint.x;
          },
          set: function set(value) {
            if (this._anchorPoint.x === value) {
              return;
            }

            this._anchorPoint.x = value;
            this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

            this._markRenderDataDirty();
          }
        }, {
          key: "anchorY",
          get: function get() {
            return this._anchorPoint.y;
          },
          set: function set(value) {
            if (this._anchorPoint.y === value) {
              return;
            }

            this._anchorPoint.y = value;
            this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

            this._markRenderDataDirty();
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(value) {
            if (this._priority === value) {
              return;
            }

            if (this.node.getComponent('cc.RenderRoot2D')) {
              warnID(6706);
              return;
            }

            this._priority = value;

            if (this.node.parent) {
              UITransform.insertChangeMap(this.node.parent);
            }
          }
        }, {
          key: "visibility",
          get: function get() {
            var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
            return camera ? camera.visibility : 0;
          }
        }, {
          key: "cameraPriority",
          get: function get() {
            var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
            return camera ? camera.priority : 0;
          }
        }]);

        return UITransform;
      }(Component), _class3$i.EventType = NodeEventType, _class3$i.priorityChangeNodeMap = new Map(), _temp$P), (_applyDecoratedDescriptor(_class2$L.prototype, "contentSize", [_dec5$a, _dec6$7], Object.getOwnPropertyDescriptor(_class2$L.prototype, "contentSize"), _class2$L.prototype), _applyDecoratedDescriptor(_class2$L.prototype, "anchorPoint", [_dec7$5, _dec8$5], Object.getOwnPropertyDescriptor(_class2$L.prototype, "anchorPoint"), _class2$L.prototype), _descriptor$D = _applyDecoratedDescriptor(_class2$L.prototype, "_contentSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Size(100, 100);
        }
      }), _descriptor2$o = _applyDecoratedDescriptor(_class2$L.prototype, "_anchorPoint", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(0.5, 0.5);
        }
      })), _class2$L)) || _class$T) || _class$T) || _class$T) || _class$T) || _class$T) || _class$T));
      director.on(Director.EVENT_AFTER_UPDATE, UITransform._sortSiblings);
      director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, UITransform._cleanChangeMap);

      var _dec$S, _dec2$r, _dec3$l, _dec4$e, _class$U;
      var RenderRoot2D = exports('RenderRoot2D', (_dec$S = ccclass('cc.RenderRoot2D'), _dec2$r = executionOrder(100), _dec3$l = menu(), _dec4$e = requireComponent(UITransform), _dec$S(_class$U = _dec2$r(_class$U = _dec3$l(_class$U = _dec4$e(_class$U = disallowMultiple(_class$U = executeInEditMode(_class$U = function (_Component) {
        _inheritsLoose(RenderRoot2D, _Component);

        function RenderRoot2D() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = RenderRoot2D.prototype;

        _proto.onEnable = function onEnable() {
          legacyCC.director.root.batcher2D.addScreen(this);
        };

        _proto.onDisable = function onDisable() {
          legacyCC.director.root.batcher2D.removeScreen(this);
        };

        _proto.onDestroy = function onDestroy() {
          legacyCC.director.root.batcher2D.removeScreen(this);
        };

        return RenderRoot2D;
      }(Component)) || _class$U) || _class$U) || _class$U) || _class$U) || _class$U) || _class$U));

      var _dec$T, _dec2$s, _dec3$m, _dec4$f, _dec5$b, _dec6$8, _dec7$6, _dec8$6, _class$V, _class2$M, _descriptor$E, _descriptor2$p, _temp$Q;

      var _worldPos = new Vec3();

      var RenderMode = Enum({
        OVERLAY: 0,
        INTERSPERSE: 1
      });
      var Canvas = function (v) { return exports({ Canvas: v, CanvasComponent: v }), v; }((_dec$T = ccclass('cc.Canvas'), _dec2$s = help(), _dec3$m = executionOrder(100), _dec4$f = menu(), _dec5$b = type(Camera$1), _dec6$8 = tooltip(), _dec7$6 = tooltip(), _dec8$6 = type(Camera$1), _dec$T(_class$V = _dec2$s(_class$V = _dec3$m(_class$V = _dec4$f(_class$V = executeInEditMode(_class$V = disallowMultiple(_class$V = (_class2$M = (_temp$Q = function (_RenderRoot2D) {
        _inheritsLoose(Canvas, _RenderRoot2D);

        function Canvas() {
          var _this;

          _this = _RenderRoot2D.call(this) || this;

          _initializerDefineProperty(_this, "_cameraComponent", _descriptor$E, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_alignCanvasWithScreen", _descriptor2$p, _assertThisInitialized(_this));

          _this._thisOnCameraResized = void 0;
          _this._fitDesignResolution = void 0;
          _this._pos = new Vec3();
          _this._renderMode = RenderMode.OVERLAY;
          _this._thisOnCameraResized = _this._onResizeCamera.bind(_assertThisInitialized(_this));

          return _this;
        }

        var _proto = Canvas.prototype;

        _proto.__preload = function __preload() {
          var widget = this.getComponent('cc.Widget');

          if (widget) {
            widget.updateAlignment();
          }

          {
            if (this._cameraComponent) {
              this._cameraComponent._createCamera();

              this._cameraComponent.node.on(Camera$1.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
            }
          }

          this._onResizeCamera();

          {
            this.node.on(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
          }
        };

        _proto.onEnable = function onEnable() {
          _RenderRoot2D.prototype.onEnable.call(this);

          if ( this._cameraComponent) {
            this._cameraComponent.node.on(Camera$1.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
          }
        };

        _proto.onDisable = function onDisable() {
          _RenderRoot2D.prototype.onDisable.call(this);

          if (this._cameraComponent) {
            this._cameraComponent.node.off(Camera$1.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
          }
        };

        _proto.onDestroy = function onDestroy() {
          _RenderRoot2D.prototype.onDestroy.call(this);

          {
            this.node.off(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
          }
        };

        _proto._onResizeCamera = function _onResizeCamera() {
          if (this._cameraComponent && this._alignCanvasWithScreen) {
            if (this._cameraComponent.targetTexture) {
              this._cameraComponent.orthoHeight = visibleRect.height / 2;
            } else {
              var size = screen.windowSize;
              this._cameraComponent.orthoHeight = size.height / view.getScaleY() / 2;
            }

            this.node.getWorldPosition(_worldPos);

            this._cameraComponent.node.setWorldPosition(_worldPos.x, _worldPos.y, 1000);
          }
        };

        _proto._getViewPriority = function _getViewPriority() {
          if (this._cameraComponent) {
            var _this$cameraComponent;

            var priority = (_this$cameraComponent = this.cameraComponent) === null || _this$cameraComponent === void 0 ? void 0 : _this$cameraComponent.priority;
            priority = this._renderMode === RenderMode.OVERLAY ? priority | 1 << 30 : priority & ~(1 << 30);
            return priority;
          }

          return 0;
        };

        _createClass(Canvas, [{
          key: "renderMode",
          get: function get() {
            return this._renderMode;
          },
          set: function set(val) {
            this._renderMode = val;

            if (this._cameraComponent) {
              this._cameraComponent.priority = this._getViewPriority();
            }
          }
        }, {
          key: "cameraComponent",
          get: function get() {
            return this._cameraComponent;
          },
          set: function set(value) {
            if (this._cameraComponent === value) {
              return;
            }

            this._cameraComponent = value;

            this._onResizeCamera();
          }
        }, {
          key: "alignCanvasWithScreen",
          get: function get() {
            return this._alignCanvasWithScreen;
          },
          set: function set(value) {
            this._alignCanvasWithScreen = value;

            this._onResizeCamera();
          }
        }]);

        return Canvas;
      }(RenderRoot2D), _temp$Q), (_applyDecoratedDescriptor(_class2$M.prototype, "cameraComponent", [_dec5$b, _dec6$8], Object.getOwnPropertyDescriptor(_class2$M.prototype, "cameraComponent"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "alignCanvasWithScreen", [_dec7$6], Object.getOwnPropertyDescriptor(_class2$M.prototype, "alignCanvasWithScreen"), _class2$M.prototype), _descriptor$E = _applyDecoratedDescriptor(_class2$M.prototype, "_cameraComponent", [_dec8$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$p = _applyDecoratedDescriptor(_class2$M.prototype, "_alignCanvasWithScreen", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      })), _class2$M)) || _class$V) || _class$V) || _class$V) || _class$V) || _class$V) || _class$V));
      legacyCC.Canvas = Canvas;

      var Stage;

      (function (Stage) {
        Stage[Stage["DISABLED"] = 0] = "DISABLED";
        Stage[Stage["CLEAR"] = 1] = "CLEAR";
        Stage[Stage["ENTER_LEVEL"] = 2] = "ENTER_LEVEL";
        Stage[Stage["ENABLED"] = 3] = "ENABLED";
        Stage[Stage["EXIT_LEVEL"] = 4] = "EXIT_LEVEL";
        Stage[Stage["CLEAR_INVERTED"] = 5] = "CLEAR_INVERTED";
        Stage[Stage["ENTER_LEVEL_INVERTED"] = 6] = "ENTER_LEVEL_INVERTED";
      })(Stage || (Stage = {}));

      var StencilManager = exports('StencilManager', function () {
        function StencilManager() {
          this.stage = Stage.DISABLED;
          this._maskStack = [];
          this._stencilPattern = {
            stencilTest: true,
            func: ComparisonFunc.ALWAYS,
            stencilMask: 0xffff,
            writeMask: 0xffff,
            failOp: StencilOp.KEEP,
            zFailOp: StencilOp.KEEP,
            passOp: StencilOp.KEEP,
            ref: 1
          };
          this.stencilStateMap = new Map();
          this.stencilStateMapWithDepth = new Map();
        }

        var _proto = StencilManager.prototype;

        _proto.pushMask = function pushMask(mask) {
          this._maskStack.push(mask);
        };

        _proto.clear = function clear(comp) {
          comp.stencilStage = comp.inverted ? Stage.CLEAR_INVERTED : Stage.CLEAR;
        };

        _proto.enterLevel = function enterLevel(comp) {
          comp.graphics.stencilStage = comp.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
        };

        _proto.enableMask = function enableMask() {
          this.stage = Stage.ENABLED;
        };

        _proto.exitMask = function exitMask() {
          if (this._maskStack.length === 0) {
            return;
          }

          this._maskStack.pop();

          if (this._maskStack.length === 0) {
            this.stage = Stage.DISABLED;
          } else {
            this.stage = Stage.ENABLED;
          }
        };

        _proto.getWriteMask = function getWriteMask() {
          return 1 << this._maskStack.length - 1;
        };

        _proto.getExitWriteMask = function getExitWriteMask() {
          return 1 << this._maskStack.length;
        };

        _proto.getStencilRef = function getStencilRef() {
          var result = 0;

          for (var i = 0; i < this._maskStack.length; ++i) {
            result += 0x00000001 << i;
          }

          return result;
        };

        _proto.reset = function reset() {
          this._maskStack.length = 0;
          this.stage = Stage.DISABLED;
        };

        _proto.destroy = function destroy() {
          this.stencilStateMap.forEach(function (value, key) {
            value.destroy();
          });
          this.stencilStateMap.clear();
        };

        _proto.getStencilStage = function getStencilStage(stage, mat) {
          var key = 0;
          var depthTest = false;
          var depthWrite = false;
          var depthFunc = ComparisonFunc.LESS;
          var cacheMap = this.stencilStateMap;

          if (mat && mat.passes[0]) {
            var pass = mat.passes[0];
            var dss = pass.depthStencilState;
            var depthTestValue = 0;
            var depthWriteValue = 0;
            if (dss.depthTest) depthTestValue = 1;
            if (dss.depthWrite) depthWriteValue = 1;
            key = depthTestValue | depthWriteValue << 1 | dss.depthFunc << 2 | stage << 6 | this._maskStack.length << 9;
            depthTest = dss.depthTest;
            depthWrite = dss.depthWrite;
            depthFunc = dss.depthFunc;
            cacheMap = this.stencilStateMapWithDepth;
          } else {
            key = stage << 16 | this._maskStack.length;
          }

          if (cacheMap && cacheMap.has(key)) {
            return cacheMap.get(key);
          }

          this.setStateFromStage(stage);
          var depthStencilState = new DepthStencilState(depthTest, depthWrite, depthFunc, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref);
          cacheMap.set(key, depthStencilState);
          return depthStencilState;
        };

        _proto.getStencilHash = function getStencilHash(stage) {
          return stage << 8 | this._maskStack.length;
        };

        _proto.setStateFromStage = function setStateFromStage(stage) {
          var pattern = this._stencilPattern;

          if (stage === Stage.DISABLED) {
            pattern.stencilTest = false;
            pattern.func = ComparisonFunc.ALWAYS;
            pattern.failOp = StencilOp.KEEP;
            pattern.stencilMask = pattern.writeMask = 0xffff;
            pattern.ref = 1;
          } else {
            pattern.stencilTest = true;

            if (stage === Stage.ENABLED) {
              pattern.func = ComparisonFunc.EQUAL;
              pattern.failOp = StencilOp.KEEP;
              pattern.stencilMask = pattern.ref = this.getStencilRef();
              pattern.writeMask = this.getWriteMask();
            } else if (stage === Stage.CLEAR) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.ZERO;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.CLEAR_INVERTED) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.REPLACE;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.ENTER_LEVEL) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.REPLACE;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (stage === Stage.ENTER_LEVEL_INVERTED) {
              pattern.func = ComparisonFunc.NEVER;
              pattern.failOp = StencilOp.ZERO;
              pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            }
          }
        };

        _createClass(StencilManager, [{
          key: "pattern",
          get: function get() {
            return this._stencilPattern;
          }
        }]);

        return StencilManager;
      }());
      StencilManager.sharedManager = null;
      StencilManager.sharedManager = new StencilManager();

      var _dec$U, _dec2$t, _dec3$n, _class$W, _temp$R;
      var UIComponent = exports('UIComponent', (_dec$U = ccclass('cc.UIComponent'), _dec2$t = requireComponent(UITransform), _dec3$n = executionOrder(110), _dec$U(_class$W = _dec2$t(_class$W = _dec3$n(_class$W = disallowMultiple(_class$W = executeInEditMode(_class$W = (_temp$R = function (_Component) {
        _inheritsLoose(UIComponent, _Component);

        function UIComponent() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._lastParent = null;
          _this.stencilStage = Stage.DISABLED;
          return _this;
        }

        var _proto = UIComponent.prototype;

        _proto.__preload = function __preload() {
          this.node._uiProps.uiComp = this;
        };

        _proto.onEnable = function onEnable() {};

        _proto.onDisable = function onDisable() {};

        _proto.onDestroy = function onDestroy() {
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }
        };

        _proto.updateAssembler = function updateAssembler(render) {};

        _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

        _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
        };

        _proto.setNodeDirty = function setNodeDirty() {};

        _proto.setTextureDirty = function setTextureDirty() {};

        return UIComponent;
      }(Component), _temp$R)) || _class$W) || _class$W) || _class$W) || _class$W) || _class$W));

      var vfmt = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F)];
      var vfmtPosColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
      var vfmtPosUvColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
      var vfmtPosUvTwoColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA32F)];
      function getComponentPerVertex(attrs) {
        var count = 0;

        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          var info = FormatInfos[attr.format];
          count += info.count;
        }

        return count;
      }
      function getAttributeStride(attrs) {
        var count = 0;

        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          var info = FormatInfos[attr.format];
          count += info.size;
        }

        return count;
      }
      legacyCC.internal.vfmtPosUvColor = vfmtPosUvColor;
      legacyCC.internal.vfmtPosUvTwoColor = vfmtPosUvTwoColor;

      var vertexFormat = /*#__PURE__*/Object.freeze({
        __proto__: null,
        vfmt: vfmt,
        vfmtPosColor: vfmtPosColor,
        vfmtPosUvColor: vfmtPosUvColor,
        vfmtPosUvTwoColor: vfmtPosUvTwoColor,
        getComponentPerVertex: getComponentPerVertex,
        getAttributeStride: getAttributeStride
      });
      exports('UIVertexFormat', vertexFormat);

      var DEFAULT_STRIDE = getAttributeStride(vfmtPosUvColor) >> 2;

      var _dataPool = new Pool$1(function () {
        return {
          x: 0,
          y: 0,
          z: 0,
          u: 0,
          v: 0,
          color: Color.WHITE.clone()
        };
      }, 128);

      var _pool = null;
      var BaseRenderData = exports('BaseRenderData', function () {
        function BaseRenderData(vertexFormat) {
          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          this.material = null;
          this.chunk = null;
          this.dataHash = 0;
          this.isMeshBuffer = false;
          this._vc = 0;
          this._ic = 0;
          this._floatStride = 0;
          this._vertexFormat = vfmtPosUvColor;
          this._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
          this._vertexFormat = vertexFormat;
        }

        var _proto = BaseRenderData.prototype;

        _proto.isValid = function isValid() {
          return this._ic > 0 && this.chunk.vertexAccessor;
        };

        _createClass(BaseRenderData, [{
          key: "vertexCount",
          get: function get() {
            return this._vc;
          }
        }, {
          key: "indexCount",
          get: function get() {
            return this._ic;
          }
        }, {
          key: "stride",
          get: function get() {
            return this._floatStride << 2;
          }
        }, {
          key: "floatStride",
          get: function get() {
            return this._floatStride;
          }
        }, {
          key: "vertexFormat",
          get: function get() {
            return this._vertexFormat;
          }
        }]);

        return BaseRenderData;
      }());
      var RenderData = exports('RenderData', function (_BaseRenderData) {
        _inheritsLoose(RenderData, _BaseRenderData);

        RenderData.add = function add(vertexFormat, accessor) {
          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          if (!_pool) {
            _pool = new RecyclePool(function () {
              return new RenderData();
            }, 32);
          }

          var rd = _pool.add();

          rd._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
          rd._vertexFormat = vertexFormat;

          if (!accessor) {
            var batcher = director.root.batcher2D;
            accessor = batcher.switchBufferAccessor(rd._vertexFormat);
          }

          rd._accessor = accessor;
          return rd;
        };

        RenderData.remove = function remove(data) {
          var idx = _pool.data.indexOf(data);

          if (idx === -1) {
            return;
          }

          data.clear();
          data._accessor = null;

          _pool.removeAt(idx);
        };

        function RenderData(vertexFormat, accessor) {
          var _this;

          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          _this = _BaseRenderData.call(this, vertexFormat) || this;
          _this.indices = null;
          _this.vertDirty = true;
          _this.frame = void 0;
          _this.layer = 0;
          _this.blendHash = -1;
          _this.textureHash = 0;
          _this.nodeDirty = true;
          _this.passDirty = true;
          _this.textureDirty = true;
          _this.hashDirty = true;
          _this._data = [];
          _this._pivotX = 0;
          _this._pivotY = 0;
          _this._width = 0;
          _this._height = 0;
          _this._accessor = null;

          if (!accessor) {
            var batcher = director.root.batcher2D;
            accessor = batcher.switchBufferAccessor(_this._vertexFormat);
          }

          _this._accessor = accessor;
          return _this;
        }

        var _proto2 = RenderData.prototype;

        _proto2.resize = function resize(vertexCount, indexCount) {
          if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
          this._vc = vertexCount;
          this._ic = indexCount;

          if (this.chunk) {
            this._accessor.recycleChunk(this.chunk);

            this.chunk = null;
          }

          this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);
          this.updateHash();
        };

        _proto2.resizeAndCopy = function resizeAndCopy(vertexCount, indexCount) {
          if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
          this._vc = vertexCount;
          this._ic = indexCount;
          var oldChunk = this.chunk;
          this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);

          if (oldChunk) {
            this.chunk.vb.set(oldChunk.vb);

            this._accessor.recycleChunk(oldChunk);
          }

          this.updateHash();
        };

        _proto2.getMeshBuffer = function getMeshBuffer() {
          if (this.chunk && this._accessor) {
            return this._accessor.getMeshBuffer(this.chunk.bufferId);
          } else {
            return null;
          }
        };

        _proto2.updateNode = function updateNode(comp) {
          this.layer = comp.node.layer;
          this.nodeDirty = false;
          this.hashDirty = true;
        };

        _proto2.updatePass = function updatePass(comp) {
          this.material = comp.getRenderMaterial(0);
          this.blendHash = comp.blendHash;
          this.passDirty = false;
          this.hashDirty = true;
        };

        _proto2.updateTexture = function updateTexture(frame) {
          this.frame = frame;
          this.textureHash = frame.getHash();
          this.textureDirty = false;
          this.hashDirty = true;
        };

        _proto2.updateHash = function updateHash() {
          var bid = this.chunk ? this.chunk.bufferId : -1;
          var hashString = "" + bid + this.layer + " " + this.blendHash + " " + this.textureHash;
          this.dataHash = murmurhash2_32_gc(hashString, 666);
          this.hashDirty = false;
        };

        _proto2.updateRenderData = function updateRenderData(comp, frame) {
          if (this.passDirty) {
            this.material = comp.getRenderMaterial(0);
            this.blendHash = comp.blendHash;
            this.passDirty = false;
            this.hashDirty = true;
          }

          if (this.nodeDirty) {
            var renderScene = comp.node.scene ? comp._getRenderScene() : null;
            this.layer = comp.node.layer;

            if (renderScene !== null) {
              this.nodeDirty = false;
            }

            this.hashDirty = true;
          }

          if (this.textureDirty) {
            this.frame = frame;
            this.textureHash = frame.getHash();
            this.textureDirty = false;
            this.hashDirty = true;
          }

          if (this.hashDirty) {
            this.updateHash();
          }
        };

        _proto2.updateSizeNPivot = function updateSizeNPivot(width, height, pivotX, pivotY) {
          if (width !== this._width || height !== this._height || pivotX !== this._pivotX || pivotY !== this._pivotY) {
            this._width = width;
            this._height = height;
            this._pivotX = pivotX;
            this._pivotY = pivotY;
            this.vertDirty = true;
          }
        };

        _proto2.clear = function clear() {
          this.resize(0, 0);
          this._data.length = 0;
          this._pivotX = 0;
          this._pivotY = 0;
          this._width = 0;
          this._height = 0;
          this.indices = null;
          this.vertDirty = true;
          this.material = null;
          this.nodeDirty = true;
          this.passDirty = true;
          this.textureDirty = true;
          this.hashDirty = true;
          this.layer = 0;
          this.blendHash = -1;
          this.frame = null;
          this.textureHash = 0;
          this.dataHash = 0;
        };

        _createClass(RenderData, [{
          key: "dataLength",
          get: function get() {
            return this._data.length;
          },
          set: function set(length) {
            var data = this._data;

            if (data.length !== length) {
              var value = data.length;
              var i = 0;

              for (i = length; i < value; i++) {
                _dataPool.free(data[i]);
              }

              for (i = value; i < length; i++) {
                data[i] = _dataPool.alloc();
              }

              data.length = length;
            }
          }
        }, {
          key: "data",
          get: function get() {
            return this._data;
          }
        }]);

        return RenderData;
      }(BaseRenderData));
      var MeshRenderData = exports('MeshRenderData', function (_BaseRenderData2) {
        _inheritsLoose(MeshRenderData, _BaseRenderData2);

        MeshRenderData.add = function add(vertexFormat) {
          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          var rd = _meshDataPool.add();

          rd._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
          rd._vertexFormat = vertexFormat;
          return rd;
        };

        MeshRenderData.remove = function remove(data) {
          var idx = _meshDataPool.data.indexOf(data);

          if (idx === -1) {
            return;
          }

          _meshDataPool.data[idx].clear();

          _meshDataPool.removeAt(idx);
        };

        function MeshRenderData(vertexFormat) {
          var _this2;

          if (vertexFormat === void 0) {
            vertexFormat = vfmtPosUvColor;
          }

          _this2 = _BaseRenderData2.call(this, vertexFormat) || this;
          _this2.isMeshBuffer = true;
          _this2.vData = void 0;
          _this2.iData = void 0;
          _this2.vertexStart = 0;
          _this2.vertexRange = 0;
          _this2.indexStart = 0;
          _this2.indexRange = 0;
          _this2.lastFilledIndex = 0;
          _this2.lastFilledVertex = 0;
          _this2._byteLength = 0;
          _this2._vertexBuffers = [];
          _this2._indexBuffer = null;
          _this2._iaPool = null;
          _this2._iaInfo = null;
          _this2.vData = new Float32Array(256 * _this2.stride);
          _this2.iData = new Uint16Array(256 * 6);
          return _this2;
        }

        var _proto3 = MeshRenderData.prototype;

        _proto3.request = function request(vertexCount, indexCount) {
          var byteOffset = this._byteLength + vertexCount * this.stride;
          var succeed = this.reserve(vertexCount, indexCount);
          if (!succeed) return false;
          this._vc += vertexCount;
          this._ic += indexCount;
          this._byteLength = byteOffset;
          this.vertexRange = this._vc;
          this.indexRange = this._ic;
          return true;
        };

        _proto3.reserve = function reserve(vertexCount, indexCount) {
          var newVBytes = this._byteLength + vertexCount * this.stride;
          var newICount = this.indexCount + indexCount;

          if (vertexCount + this.vertexCount > 65535) {
            return false;
          }

          var byteLength = this.vData.byteLength;
          var indicesLength = this.iData.length;
          var vCount = this.vData.length;
          var iCount = this.iData.length;

          if (newVBytes > byteLength || newICount > indicesLength) {
            while (byteLength < newVBytes || indicesLength < newICount) {
              vCount *= 2;
              iCount *= 2;
              byteLength = vCount * 4;
              indicesLength = iCount;
            }

            this._reallocBuffer(vCount, iCount);
          }

          return true;
        };

        _proto3.resize = function resize(vertexCount, indexCount) {
          var byteLength = vertexCount * this.stride;
          assertIsTrue(vertexCount >= 0 && indexCount >= 0 && byteLength <= this.vData.byteLength && indexCount <= this.iData.length);
          this._vc = vertexCount;
          this._ic = indexCount;
          this._byteLength = byteLength;
          this.updateRange(0, vertexCount, 0, indexCount);
        };

        _proto3.updateRange = function updateRange(vertOffset, vertexCount, indexOffset, indexCount) {
          assertIsTrue(vertexCount >= 0 && indexCount >= 0 && vertexCount <= this._vc && indexCount <= this._ic);
          this.vertexStart = vertOffset;
          this.indexStart = indexOffset;
          this.vertexRange = vertexCount;
          this.indexRange = indexCount;
        };

        _proto3.requestIA = function requestIA(device) {
          this._initIAInfo(device);

          var ia = this._iaPool.add();

          ia.firstIndex = this.indexStart;
          ia.indexCount = this.indexRange;
          return ia;
        };

        _proto3.uploadBuffers = function uploadBuffers() {
          if (this._byteLength === 0 || !this._vertexBuffers[0] || !this._indexBuffer) {
            return;
          }

          var indexCount = this._ic;
          var verticesData = new Float32Array(this.vData.buffer, 0, this._byteLength >> 2);
          var indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
          var vertexBuffer = this._vertexBuffers[0];

          if (this._byteLength > vertexBuffer.size) {
            vertexBuffer.resize(this._byteLength);
          }

          vertexBuffer.update(verticesData);
          var indexBytes = indexCount << 1;

          if (indexBytes > this._indexBuffer.size) {
            this._indexBuffer.resize(indexBytes);
          }

          this._indexBuffer.update(indicesData);
        };

        _proto3.freeIAPool = function freeIAPool() {
          if (this._iaPool) {
            this._iaPool.reset();
          }
        };

        _proto3.reset = function reset() {
          this._vc = 0;
          this._ic = 0;
          this._byteLength = 0;
          this.vertexStart = 0;
          this.vertexRange = 0;
          this.indexStart = 0;
          this.indexRange = 0;
          this.lastFilledIndex = 0;
          this.lastFilledVertex = 0;
          this.material = null;
          this.freeIAPool();
        };

        _proto3.clear = function clear() {
          this.reset();

          if (this._iaPool) {
            this._iaPool.destroy();
          }

          if (this._vertexBuffers[0]) {
            this._vertexBuffers[0].destroy();

            this._vertexBuffers = [];
          }

          this._iaInfo = null;
          this.vData = new Float32Array(256 * this.stride);
          this.iData = new Uint16Array(256 * 6);
        };

        _proto3._initIAInfo = function _initIAInfo(device) {
          var _this3 = this;

          if (!this._iaInfo) {
            var vbStride = this.stride;
            var vbs = this._vertexBuffers;

            if (!vbs.length) {
              vbs.push(device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbStride, vbStride)));
            }

            var ibStride = Uint16Array.BYTES_PER_ELEMENT;

            if (!this._indexBuffer) {
              this._indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibStride, ibStride));
            }

            this._iaInfo = new InputAssemblerInfo(this._vertexFormat, vbs, this._indexBuffer);
            this._iaPool = new RecyclePool(function () {
              return device.createInputAssembler(_this3._iaInfo);
            }, 1, function (ia) {
              ia.destroy();
            });
          }
        };

        _proto3._reallocBuffer = function _reallocBuffer(vCount, iCount) {
          var oldVData = this.vData;
          this.vData = new Float32Array(vCount);

          if (oldVData) {
            this.vData.set(oldVData, 0);
          }

          var oldIData = this.iData;
          this.iData = new Uint16Array(iCount);

          if (oldIData) {
            this.iData.set(oldIData, 0);
          }
        };

        _createClass(MeshRenderData, [{
          key: "formatByte",
          get: function get() {
            return this.stride;
          },
          set: function set(value) {}
        }, {
          key: "floatStride",
          get: function get() {
            return this._floatStride;
          }
        }, {
          key: "vDataOffset",
          get: function get() {
            return this._byteLength >>> 2;
          }
        }]);

        return MeshRenderData;
      }(BaseRenderData));

      var _meshDataPool = new RecyclePool(function () {
        return new MeshRenderData();
      }, 32);

      var _dec$V, _dec2$u, _dec3$o, _dec4$g, _dec5$c, _dec6$9, _dec7$7, _dec8$7, _dec9$5, _dec10$5, _class$X, _class2$N, _descriptor$F, _descriptor2$q, _descriptor3$i, _descriptor4$f, _descriptor5$a, _class3$j, _temp$S;
      ccenum(BlendFactor);
      var InstanceMaterialType;

      (function (InstanceMaterialType) {
        InstanceMaterialType[InstanceMaterialType["ADD_COLOR"] = 0] = "ADD_COLOR";
        InstanceMaterialType[InstanceMaterialType["ADD_COLOR_AND_TEXTURE"] = 1] = "ADD_COLOR_AND_TEXTURE";
        InstanceMaterialType[InstanceMaterialType["GRAYSCALE"] = 2] = "GRAYSCALE";
        InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED"] = 3] = "USE_ALPHA_SEPARATED";
        InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED_AND_GRAY"] = 4] = "USE_ALPHA_SEPARATED_AND_GRAY";
      })(InstanceMaterialType || (InstanceMaterialType = exports('InstanceMaterialType', {})));

      var Renderable2D = function (v) { return exports({ Renderable2D: v, RenderComponent: v, UIRenderable: v }), v; }((_dec$V = ccclass('cc.Renderable2D'), _dec2$u = requireComponent(UITransform), _dec3$o = visible(), _dec4$g = type(Material), _dec5$c = type(Material), _dec6$9 = displayOrder(), _dec7$7 = tooltip(), _dec8$7 = displayName(), _dec9$5 = displayOrder(), _dec10$5 = tooltip(), _dec$V(_class$X = _dec2$u(_class$X = disallowMultiple(_class$X = executeInEditMode(_class$X = (_class2$N = (_temp$S = _class3$j = function (_RenderableComponent) {
        _inheritsLoose(Renderable2D, _RenderableComponent);

        function Renderable2D() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _RenderableComponent.call.apply(_RenderableComponent, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_materials", _descriptor$F, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_customMaterial", _descriptor2$q, _assertThisInitialized(_this));

          _this.stencilStage = Stage.DISABLED;

          _initializerDefineProperty(_this, "_srcBlendFactor", _descriptor3$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_dstBlendFactor", _descriptor4$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_color", _descriptor5$a, _assertThisInitialized(_this));

          _this._assembler = null;
          _this._postAssembler = null;
          _this._renderData = null;
          _this._renderDataFlag = true;
          _this._renderFlag = true;
          _this._delegateSrc = null;
          _this._instanceMaterialType = -1;
          _this._blendState = new BlendState();
          _this._blendHash = 0;
          _this._useVertexOpacity = false;
          _this._lastParent = null;
          return _this;
        }

        var _proto = Renderable2D.prototype;

        _proto.updateBlendHash = function updateBlendHash() {
          var dst = this._blendState.targets[0].blendDst << 4;
          this._blendHash = dst | this._blendState.targets[0].blendSrc;
        };

        _proto.__preload = function __preload() {
          this.node._uiProps.uiComp = this;

          if (this._flushAssembler) {
            this._flushAssembler();
          }
        };

        _proto.onEnable = function onEnable() {
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
          this.node.on(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
          this.updateMaterial();
          this._renderFlag = this._canRender();

          this._colorDirty();
        };

        _proto.onRestore = function onRestore() {
          this.updateMaterial();
          this.markForUpdateRenderData();
        };

        _proto.onDisable = function onDisable() {
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
          this.node.off(NodeEventType.PARENT_CHANGED, this._colorDirty, this);
          this._renderFlag = false;
        };

        _proto.onDestroy = function onDestroy() {
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }

          this.destroyRenderData();

          if (this._materialInstances) {
            for (var i = 0; i < this._materialInstances.length; i++) {
              var instance = this._materialInstances[i];

              if (instance) {
                instance.destroy();
              }
            }
          }

          if (this._blendState) {
            this._blendState.destroy();
          }
        };

        _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
          if (enable === void 0) {
            enable = true;
          }

          this._renderFlag = this._canRender();

          if (enable) {
            var renderData = this._renderData;

            if (renderData) {
              renderData.vertDirty = true;
            }

            this._renderDataFlag = enable;
          } else {
            this._renderDataFlag = enable;
          }
        };

        _proto.requestRenderData = function requestRenderData() {
          var data = RenderData.add();
          this._renderData = data;
          return data;
        };

        _proto.destroyRenderData = function destroyRenderData() {
          if (!this._renderData) {
            return;
          }

          RenderData.remove(this._renderData);
          this._renderData = null;
        };

        _proto.updateAssembler = function updateAssembler(render) {
          if (this._renderDataFlag) {
            this._assembler.updateRenderData(this, render);

            this._renderDataFlag = false;
          }

          if (this._renderFlag) {
            this._render(render);
          }
        };

        _proto.postUpdateAssembler = function postUpdateAssembler(render) {
          if (this._postAssembler && this._renderFlag) {
            this._postRender(render);
          }
        };

        _proto._render = function _render(render) {};

        _proto._postRender = function _postRender(render) {};

        _proto._canRender = function _canRender() {
          return this.isValid && this.getMaterial(0) !== null && this.enabled && (this._delegateSrc ? this._delegateSrc.activeInHierarchy : this.enabledInHierarchy) && this._color.a > 0;
        };

        _proto._postCanRender = function _postCanRender() {};

        _proto.updateMaterial = function updateMaterial() {
          if (this._customMaterial) {
            this.setMaterial(this._customMaterial, 0);

            if (this._renderData) {
              this._renderData.material = this._customMaterial;
              this.markForUpdateRenderData();
              this._renderData.passDirty = true;
            }

            this._blendHash = -1;
            return;
          }

          var mat = this._updateBuiltinMaterial();

          this.setMaterial(mat, 0);

          if (this._renderData) {
            this._renderData.material = mat;
            this.markForUpdateRenderData();
          }

          this._updateBlendFunc();
        };

        _proto._updateColor = function _updateColor() {
          this.node._uiProps.colorDirty = true;

          if (this._assembler) {
            this._assembler.updateColor(this);

            this._renderFlag = this._canRender();
          }
        };

        _proto._updateBlendFunc = function _updateBlendFunc() {
          var target = this._blendState.targets[0];

          if (!target) {
            target = new BlendTarget();

            this._blendState.setTarget(0, target);
          }

          if (target.blendDst !== this._dstBlendFactor || target.blendSrc !== this._srcBlendFactor) {
            target.blend = true;
            target.blendDstAlpha = BlendFactor.ONE_MINUS_SRC_ALPHA;
            target.blendDst = this._dstBlendFactor;
            target.blendSrc = this._srcBlendFactor;

            if (this.renderData) {
              this.renderData.passDirty = true;
            }
          }

          this.updateBlendHash();
        };

        _proto.getBlendState = function getBlendState() {
          return this._blendState;
        };

        _proto._nodeStateChange = function _nodeStateChange(transformType) {
          if (this._renderData) {
            this.markForUpdateRenderData();
          }

          for (var i = 0; i < this.node.children.length; ++i) {
            var child = this.node.children[i];
            var renderComp = child.getComponent(Renderable2D);

            if (renderComp) {
              renderComp.markForUpdateRenderData();
            }
          }
        };

        _proto._colorDirty = function _colorDirty() {
          this.node._uiProps.colorDirty = true;
        };

        _proto._onMaterialModified = function _onMaterialModified(idx, material) {
          if (this._renderData) {
            this.markForUpdateRenderData();
            this._renderData.passDirty = true;
          }

          _RenderableComponent.prototype._onMaterialModified.call(this, idx, material);
        };

        _proto._updateBuiltinMaterial = function _updateBuiltinMaterial() {
          var mat;

          switch (this._instanceMaterialType) {
            case InstanceMaterialType.ADD_COLOR:
              mat = builtinResMgr.get("ui-base-material");
              break;

            case InstanceMaterialType.GRAYSCALE:
              mat = builtinResMgr.get("ui-sprite-gray-material");
              break;

            case InstanceMaterialType.USE_ALPHA_SEPARATED:
              mat = builtinResMgr.get("ui-sprite-alpha-sep-material");
              break;

            case InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY:
              mat = builtinResMgr.get("ui-sprite-gray-alpha-sep-material");
              break;

            default:
              mat = builtinResMgr.get("ui-sprite-material");
              break;
          }

          return mat;
        };

        _proto.setNodeDirty = function setNodeDirty() {
          if (this.renderData) {
            this.renderData.nodeDirty = true;
          }
        };

        _proto.setTextureDirty = function setTextureDirty() {
          if (this.renderData) {
            this.renderData.textureDirty = true;
          }
        };

        _createClass(Renderable2D, [{
          key: "sharedMaterials",
          get: function get() {
            return  this._materials;
          },
          set: function set(val) {
            for (var i = 0; i < val.length; i++) {
              if (val[i] !== this._materials[i]) {
                this.setMaterial(val[i], i);
              }
            }

            if (val.length < this._materials.length) {
              for (var _i = val.length; _i < this._materials.length; _i++) {
                this.setMaterial(null, _i);
              }

              this._materials.splice(val.length);
            }
          }
        }, {
          key: "customMaterial",
          get: function get() {
            return this._customMaterial;
          },
          set: function set(val) {
            this._customMaterial = val;
            this.updateMaterial();
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color.equals(value)) {
              return;
            }

            this._color.set(value);

            this._updateColor();
          }
        }, {
          key: "renderData",
          get: function get() {
            return this._renderData;
          }
        }, {
          key: "delegateSrc",
          set: function set(value) {
            this._delegateSrc = value;
          }
        }, {
          key: "blendHash",
          get: function get() {
            return this._blendHash;
          }
        }, {
          key: "useVertexOpacity",
          get: function get() {
            return this._useVertexOpacity;
          }
        }]);

        return Renderable2D;
      }(RenderableComponent), _class3$j.BlendState = BlendFactor, _class3$j.Assembler = null, _class3$j.PostAssembler = null, _temp$S), (_descriptor$F = _applyDecoratedDescriptor(_class2$N.prototype, "_materials", [override], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _applyDecoratedDescriptor(_class2$N.prototype, "sharedMaterials", [override, _dec3$o], Object.getOwnPropertyDescriptor(_class2$N.prototype, "sharedMaterials"), _class2$N.prototype), _descriptor2$q = _applyDecoratedDescriptor(_class2$N.prototype, "_customMaterial", [_dec4$g], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2$N.prototype, "customMaterial", [_dec5$c, _dec6$9, _dec7$7, _dec8$7, disallowAnimation], Object.getOwnPropertyDescriptor(_class2$N.prototype, "customMaterial"), _class2$N.prototype), _applyDecoratedDescriptor(_class2$N.prototype, "color", [_dec9$5, _dec10$5], Object.getOwnPropertyDescriptor(_class2$N.prototype, "color"), _class2$N.prototype), _descriptor3$i = _applyDecoratedDescriptor(_class2$N.prototype, "_srcBlendFactor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return BlendFactor.SRC_ALPHA;
        }
      }), _descriptor4$f = _applyDecoratedDescriptor(_class2$N.prototype, "_dstBlendFactor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return BlendFactor.ONE_MINUS_SRC_ALPHA;
        }
      }), _descriptor5$a = _applyDecoratedDescriptor(_class2$N.prototype, "_color", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      })), _class2$N)) || _class$X) || _class$X) || _class$X) || _class$X));
      legacyCC.internal.Renderable2D = Renderable2D;

      removeProperty(UIComponent.prototype, 'UIComponent', [{
        name: '_visibility'
      }, {
        name: 'setVisibility'
      }]);
      removeProperty(Renderable2D.prototype, 'Renderable2D.prototype', [{
        name: 'srcBlendFactor'
      }, {
        name: 'dstBlendFactor'
      }]);
      replaceProperty(Canvas.prototype, 'Canvas.prototype', [{
        name: 'camera',
        newName: 'cameraComponent.camera',
        customGetter: function customGetter() {
          return this._cameraComponent.camera;
        }
      }, {
        name: 'clearFlag',
        newName: 'cameraComponent.clearFlags',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearFlags : 0;
        },
        customSetter: function customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.clearFlags = val;
        }
      }, {
        name: 'color',
        newName: 'cameraComponent.clearColor',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearColor : Color.BLACK;
        },
        customSetter: function customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.clearColor = val;
        }
      }, {
        name: 'priority',
        newName: 'cameraComponent.priority',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.priority : 0;
        },
        customSetter: function customSetter(val) {
          if (this._cameraComponent) this._cameraComponent.priority = val;
        }
      }, {
        name: 'targetTexture',
        newName: 'cameraComponent.targetTexture',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.targetTexture : null;
        },
        customSetter: function customSetter(value) {
          if (this._cameraComponent) this._cameraComponent.targetTexture = value;
        }
      }, {
        name: 'visibility',
        newName: 'cameraComponent.visibility',
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.visibility : 0;
        }
      }]);
      markAsWarning(UITransform.prototype, 'UITransform.prototype', [{
        name: 'priority',
        suggest: "Please use setSiblingIndex to change index of the current node in its parent's children array."
      }]);
      legacyCC.UITransformComponent = UITransform;
      js.setClassAlias(UITransform, 'cc.UITransformComponent');
      js.setClassAlias(Renderable2D, 'cc.RenderComponent');
      legacyCC.CanvasComponent = Canvas;
      js.setClassAlias(Canvas, 'cc.CanvasComponent');

      var _dec$W, _dec2$v, _dec3$p, _dec4$h, _dec5$d, _dec6$a, _dec7$8, _dec8$8, _dec9$6, _dec10$6, _dec11$4, _dec12$4, _dec13$4, _dec14$4, _dec15$4, _dec16$4, _dec17$4, _dec18$4, _dec19$4, _dec20$4, _dec21$4, _dec22$4, _dec23$4, _dec24$4, _dec25$4, _dec26$3, _dec27$3, _dec28$3, _dec29$3, _dec30$3, _dec31$3, _dec32$2, _class$Y, _class2$O, _descriptor$G, _descriptor2$r, _descriptor3$j, _descriptor4$g, _descriptor5$b, _descriptor6$5, _descriptor7$5, _descriptor8$5, _descriptor9$4, _descriptor10$4, _class3$k, _temp$T;
      var SpriteType;

      (function (SpriteType) {
        SpriteType[SpriteType["SIMPLE"] = 0] = "SIMPLE";
        SpriteType[SpriteType["SLICED"] = 1] = "SLICED";
        SpriteType[SpriteType["TILED"] = 2] = "TILED";
        SpriteType[SpriteType["FILLED"] = 3] = "FILLED";
      })(SpriteType || (SpriteType = {}));

      ccenum(SpriteType);
      var FillType;

      (function (FillType) {
        FillType[FillType["HORIZONTAL"] = 0] = "HORIZONTAL";
        FillType[FillType["VERTICAL"] = 1] = "VERTICAL";
        FillType[FillType["RADIAL"] = 2] = "RADIAL";
      })(FillType || (FillType = {}));

      ccenum(FillType);
      var SizeMode;

      (function (SizeMode) {
        SizeMode[SizeMode["CUSTOM"] = 0] = "CUSTOM";
        SizeMode[SizeMode["TRIMMED"] = 1] = "TRIMMED";
        SizeMode[SizeMode["RAW"] = 2] = "RAW";
      })(SizeMode || (SizeMode = {}));

      ccenum(SizeMode);
      var EventType;

      (function (EventType) {
        EventType["SPRITE_FRAME_CHANGED"] = "spriteframe-changed";
      })(EventType || (EventType = {}));

      var Sprite = function (v) { return exports({ Sprite: v, SpriteComponent: v }), v; }((_dec$W = ccclass('cc.Sprite'), _dec2$v = help(), _dec3$p = executionOrder(110), _dec4$h = menu(), _dec5$d = type(SpriteAtlas), _dec6$a = displayOrder(), _dec7$8 = tooltip(), _dec8$8 = type(SpriteFrame), _dec9$6 = displayOrder(), _dec10$6 = tooltip(), _dec11$4 = type(SpriteType), _dec12$4 = displayOrder(), _dec13$4 = tooltip(), _dec14$4 = type(FillType), _dec15$4 = displayOrder(), _dec16$4 = tooltip(), _dec17$4 = displayOrder(), _dec18$4 = tooltip(), _dec19$4 = range(), _dec20$4 = displayOrder(), _dec21$4 = tooltip(), _dec22$4 = range(), _dec23$4 = displayOrder(), _dec24$4 = tooltip(), _dec25$4 = visible(), _dec26$3 = displayOrder(), _dec27$3 = tooltip(), _dec28$3 = displayOrder(), _dec29$3 = tooltip(), _dec30$3 = type(SizeMode), _dec31$3 = displayOrder(), _dec32$2 = tooltip(), _dec$W(_class$Y = _dec2$v(_class$Y = _dec3$p(_class$Y = _dec4$h(_class$Y = (_class2$O = (_temp$T = _class3$k = function (_Renderable2D) {
        _inheritsLoose(Sprite, _Renderable2D);

        function Sprite() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Renderable2D.call.apply(_Renderable2D, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_spriteFrame", _descriptor$G, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_type", _descriptor2$r, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillType", _descriptor3$j, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_sizeMode", _descriptor4$g, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillCenter", _descriptor5$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillStart", _descriptor6$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillRange", _descriptor7$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isTrimmedMode", _descriptor8$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_useGrayscale", _descriptor9$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_atlas", _descriptor10$4, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = Sprite.prototype;

        _proto.__preload = function __preload() {
          this.changeMaterialForDefine();

          _Renderable2D.prototype.__preload.call(this);
        };

        _proto.onEnable = function onEnable() {
          _Renderable2D.prototype.onEnable.call(this);

          this._activateMaterial();

          var spriteFrame = this._spriteFrame;

          if (spriteFrame) {
            this._updateUVs();

            if (this._type === SpriteType.SLICED) {
              spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        };

        _proto.onDisable = function onDisable() {
          if (this._spriteFrame && this._type === SpriteType.SLICED) {
            this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
          }
        };

        _proto.onDestroy = function onDestroy() {

          _Renderable2D.prototype.onDestroy.call(this);
        };

        _proto.changeSpriteFrameFromAtlas = function changeSpriteFrameFromAtlas(name) {
          if (!this._atlas) {
            console.warn('SpriteAtlas is null.');
            return;
          }

          var sprite = this._atlas.getSpriteFrame(name);

          this.spriteFrame = sprite;
        };

        _proto.changeMaterialForDefine = function changeMaterialForDefine() {
          var texture;
          var lastInstanceMaterialType = this._instanceMaterialType;

          if (this._spriteFrame) {
            texture = this._spriteFrame.texture;
          }

          var value = false;

          if (texture instanceof TextureBase) {
            var format = texture.getPixelFormat();
            value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
          }

          if (value && this.grayscale) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY;
          } else if (value) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
          } else if (this.grayscale) {
            this._instanceMaterialType = InstanceMaterialType.GRAYSCALE;
          } else {
            this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
          }

          if (lastInstanceMaterialType !== this._instanceMaterialType) {
            this.updateMaterial();
          }
        };

        _proto._updateBuiltinMaterial = function _updateBuiltinMaterial() {
          var mat = _Renderable2D.prototype._updateBuiltinMaterial.call(this);

          if (this.spriteFrame && this.spriteFrame.texture instanceof RenderTexture) {
            var defines = _extends({
              SAMPLE_FROM_RT: true
            }, mat.passes[0].defines);

            var renderMat = new Material();
            renderMat.initialize({
              effectAsset: mat.effectAsset,
              defines: defines
            });
            mat = renderMat;
          }

          return mat;
        };

        _proto._render = function _render(render) {
          render.commitComp(this, this.renderData, this._spriteFrame, this._assembler, null);
        };

        _proto._canRender = function _canRender() {
          if (!_Renderable2D.prototype._canRender.call(this)) {
            return false;
          }

          var spriteFrame = this._spriteFrame;

          if (!spriteFrame || !spriteFrame.texture) {
            return false;
          }

          return true;
        };

        _proto._flushAssembler = function _flushAssembler() {
          var assembler = Sprite.Assembler.getAssembler(this);

          if (this._assembler !== assembler) {
            this.destroyRenderData();
            this._assembler = assembler;
          }

          if (!this._renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this._renderData.material = this.getRenderMaterial(0);
              this.markForUpdateRenderData();

              if (this.spriteFrame) {
                this._assembler.updateUVs(this);
              }

              this._updateColor();
            }
          }

          if (this._spriteFrame) {
            if (this._type === SpriteType.SLICED) {
              this._spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            } else {
              this._spriteFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        };

        _proto._applySpriteSize = function _applySpriteSize() {
          if (this._spriteFrame) {
            if (!this._spriteFrame.isDefault) {
              if (SizeMode.RAW === this._sizeMode) {
                var size = this._spriteFrame.originalSize;

                this.node._uiProps.uiTransformComp.setContentSize(size);
              } else if (SizeMode.TRIMMED === this._sizeMode) {
                var rect = this._spriteFrame.rect;

                this.node._uiProps.uiTransformComp.setContentSize(rect.width, rect.height);
              }
            }

            this._activateMaterial();
          }
        };

        _proto._resized = function _resized() {
          {
            return;
          }
        };

        _proto._activateMaterial = function _activateMaterial() {
          var spriteFrame = this._spriteFrame;
          var material = this.getRenderMaterial(0);

          if (spriteFrame) {
            if (material) {
              this.markForUpdateRenderData();
            }
          }

          if (this._renderData) {
            this._renderData.material = material;
          }
        };

        _proto._updateUVs = function _updateUVs() {
          if (this._assembler) {
            this._assembler.updateUVs(this);
          }
        };

        _proto._applySpriteFrame = function _applySpriteFrame(oldFrame) {
          var spriteFrame = this._spriteFrame;

          if (oldFrame && this._type === SpriteType.SLICED) {
            oldFrame.off(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
          }

          this._updateUVs();

          var textureChanged = false;

          if (spriteFrame) {
            if (!oldFrame || oldFrame.texture !== spriteFrame.texture) {
              textureChanged = true;
            }

            if (textureChanged) {
              if (this._renderData) this._renderData.textureDirty = true;
              this.changeMaterialForDefine();
            }

            this._applySpriteSize();

            if (this._type === SpriteType.SLICED) {
              spriteFrame.on(SpriteFrame.EVENT_UV_UPDATED, this._updateUVs, this);
            }
          }
        };

        _createClass(Sprite, [{
          key: "spriteAtlas",
          get: function get() {
            return this._atlas;
          },
          set: function set(value) {
            if (this._atlas === value) {
              return;
            }

            this._atlas = value;
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value) {
            if (this._spriteFrame === value) {
              return;
            }

            var lastSprite = this._spriteFrame;
            this._spriteFrame = value;
            this.markForUpdateRenderData(false);

            this._applySpriteFrame(lastSprite);
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(value) {
            if (this._type !== value) {
              this._type = value;

              this._flushAssembler();
            }
          }
        }, {
          key: "fillType",
          get: function get() {
            return this._fillType;
          },
          set: function set(value) {
            if (this._fillType !== value) {
              if (value === FillType.RADIAL || this._fillType === FillType.RADIAL) {
                this.destroyRenderData();
                this._renderData = null;
              } else if (this._renderData) {
                this.markForUpdateRenderData(true);
              }
            }

            this._fillType = value;

            this._flushAssembler();
          }
        }, {
          key: "fillCenter",
          get: function get() {
            return this._fillCenter;
          },
          set: function set(value) {
            this._fillCenter.x = value.x;
            this._fillCenter.y = value.y;

            if (this._type === SpriteType.FILLED && this._renderData) {
              this.markForUpdateRenderData();
            }
          }
        }, {
          key: "fillStart",
          get: function get() {
            return this._fillStart;
          },
          set: function set(value) {
            this._fillStart = clamp(value, 0, 1);

            if (this._type === SpriteType.FILLED && this._renderData) {
              this.markForUpdateRenderData();

              this._updateUVs();
            }
          }
        }, {
          key: "fillRange",
          get: function get() {
            return this._fillRange;
          },
          set: function set(value) {
            this._fillRange = clamp(value, -1, 1);

            if (this._type === SpriteType.FILLED && this._renderData) {
              this.markForUpdateRenderData();

              this._updateUVs();
            }
          }
        }, {
          key: "trim",
          get: function get() {
            return this._isTrimmedMode;
          },
          set: function set(value) {
            if (this._isTrimmedMode === value) {
              return;
            }

            this._isTrimmedMode = value;

            if (this._type === SpriteType.SIMPLE && this._renderData) {
              this.markForUpdateRenderData(true);
            }
          }
        }, {
          key: "grayscale",
          get: function get() {
            return this._useGrayscale;
          },
          set: function set(value) {
            if (this._useGrayscale === value) {
              return;
            }

            this._useGrayscale = value;
            this.changeMaterialForDefine();
            this.updateMaterial();
          }
        }, {
          key: "sizeMode",
          get: function get() {
            return this._sizeMode;
          },
          set: function set(value) {
            if (this._sizeMode === value) {
              return;
            }

            this._sizeMode = value;

            if (value !== SizeMode.CUSTOM) {
              this._applySpriteSize();
            }
          }
        }]);

        return Sprite;
      }(Renderable2D), _class3$k.FillType = FillType, _class3$k.Type = SpriteType, _class3$k.SizeMode = SizeMode, _class3$k.EventType = EventType, _temp$T), (_applyDecoratedDescriptor(_class2$O.prototype, "spriteAtlas", [_dec5$d, _dec6$a, _dec7$8], Object.getOwnPropertyDescriptor(_class2$O.prototype, "spriteAtlas"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "spriteFrame", [_dec8$8, _dec9$6, _dec10$6], Object.getOwnPropertyDescriptor(_class2$O.prototype, "spriteFrame"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "type", [_dec11$4, _dec12$4, _dec13$4], Object.getOwnPropertyDescriptor(_class2$O.prototype, "type"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "fillType", [_dec14$4, _dec15$4, _dec16$4], Object.getOwnPropertyDescriptor(_class2$O.prototype, "fillType"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "fillCenter", [_dec17$4, _dec18$4], Object.getOwnPropertyDescriptor(_class2$O.prototype, "fillCenter"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "fillStart", [_dec19$4, _dec20$4, _dec21$4], Object.getOwnPropertyDescriptor(_class2$O.prototype, "fillStart"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "fillRange", [_dec22$4, _dec23$4, _dec24$4], Object.getOwnPropertyDescriptor(_class2$O.prototype, "fillRange"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "trim", [_dec25$4, _dec26$3, _dec27$3], Object.getOwnPropertyDescriptor(_class2$O.prototype, "trim"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "grayscale", [editable, _dec28$3, _dec29$3], Object.getOwnPropertyDescriptor(_class2$O.prototype, "grayscale"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "sizeMode", [_dec30$3, _dec31$3, _dec32$2], Object.getOwnPropertyDescriptor(_class2$O.prototype, "sizeMode"), _class2$O.prototype), _descriptor$G = _applyDecoratedDescriptor(_class2$O.prototype, "_spriteFrame", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$r = _applyDecoratedDescriptor(_class2$O.prototype, "_type", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return SpriteType.SIMPLE;
        }
      }), _descriptor3$j = _applyDecoratedDescriptor(_class2$O.prototype, "_fillType", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return FillType.HORIZONTAL;
        }
      }), _descriptor4$g = _applyDecoratedDescriptor(_class2$O.prototype, "_sizeMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return SizeMode.TRIMMED;
        }
      }), _descriptor5$b = _applyDecoratedDescriptor(_class2$O.prototype, "_fillCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(0, 0);
        }
      }), _descriptor6$5 = _applyDecoratedDescriptor(_class2$O.prototype, "_fillStart", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$5 = _applyDecoratedDescriptor(_class2$O.prototype, "_fillRange", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor8$5 = _applyDecoratedDescriptor(_class2$O.prototype, "_isTrimmedMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor9$4 = _applyDecoratedDescriptor(_class2$O.prototype, "_useGrayscale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor10$4 = _applyDecoratedDescriptor(_class2$O.prototype, "_atlas", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$O)) || _class$Y) || _class$Y) || _class$Y) || _class$Y));
      legacyCC.Sprite = Sprite;

      var _dec$X, _dec2$w, _dec3$q, _dec4$i, _dec5$e, _dec6$b, _dec7$9, _dec8$9, _dec9$7, _dec10$7, _dec11$5, _dec12$5, _dec13$5, _dec14$5, _dec15$5, _dec16$5, _dec17$5, _dec18$5, _dec19$5, _dec20$5, _dec21$5, _dec22$5, _dec23$5, _dec24$5, _dec25$5, _dec26$4, _dec27$4, _dec28$4, _dec29$4, _dec30$4, _dec31$4, _dec32$3, _dec33$2, _dec34$2, _dec35$2, _dec36$2, _dec37$2, _dec38$2, _dec39$2, _dec40$2, _dec41$2, _dec42$2, _class$Z, _class2$P, _descriptor$H, _descriptor2$s, _descriptor3$k, _descriptor4$h, _descriptor5$c, _descriptor6$6, _descriptor7$6, _descriptor8$6, _descriptor9$5, _descriptor10$5, _descriptor11$4, _descriptor12$4, _descriptor13$4, _descriptor14$4, _class3$l, _temp$U;

      var _tempColor = new Color();

      var Transition;

      (function (Transition) {
        Transition[Transition["NONE"] = 0] = "NONE";
        Transition[Transition["COLOR"] = 1] = "COLOR";
        Transition[Transition["SPRITE"] = 2] = "SPRITE";
        Transition[Transition["SCALE"] = 3] = "SCALE";
      })(Transition || (Transition = {}));

      ccenum(Transition);
      var State;

      (function (State) {
        State["NORMAL"] = "normal";
        State["HOVER"] = "hover";
        State["PRESSED"] = "pressed";
        State["DISABLED"] = "disabled";
      })(State || (State = {}));

      var EventType$1;

      (function (EventType) {
        EventType["CLICK"] = "click";
      })(EventType$1 || (EventType$1 = {}));

      var Button = function (v) { return exports({ Button: v, ButtonComponent: v }), v; }((_dec$X = ccclass('cc.Button'), _dec2$w = help(), _dec3$q = executionOrder(110), _dec4$i = menu(), _dec5$e = requireComponent(UITransform), _dec6$b = type(Node$1), _dec7$9 = displayOrder(), _dec8$9 = tooltip(), _dec9$7 = displayOrder(), _dec10$7 = tooltip(), _dec11$5 = type(Transition), _dec12$5 = displayOrder(), _dec13$5 = tooltip(), _dec14$5 = displayOrder(), _dec15$5 = tooltip(), _dec16$5 = displayOrder(), _dec17$5 = tooltip(), _dec18$5 = displayOrder(), _dec19$5 = tooltip(), _dec20$5 = displayOrder(), _dec21$5 = tooltip(), _dec22$5 = rangeMin(), _dec23$5 = rangeMax(), _dec24$5 = displayOrder(), _dec25$5 = tooltip(), _dec26$4 = displayOrder(), _dec27$4 = tooltip(), _dec28$4 = type(SpriteFrame), _dec29$4 = displayOrder(), _dec30$4 = tooltip(), _dec31$4 = type(SpriteFrame), _dec32$3 = displayOrder(), _dec33$2 = tooltip(), _dec34$2 = type(SpriteFrame), _dec35$2 = displayOrder(), _dec36$2 = tooltip(), _dec37$2 = type(SpriteFrame), _dec38$2 = displayOrder(), _dec39$2 = tooltip(), _dec40$2 = type([EventHandler]), _dec41$2 = displayOrder(), _dec42$2 = tooltip(), _dec$X(_class$Z = _dec2$w(_class$Z = _dec3$q(_class$Z = _dec4$i(_class$Z = _dec5$e(_class$Z = executeInEditMode(_class$Z = (_class2$P = (_temp$U = _class3$l = function (_Component) {
        _inheritsLoose(Button, _Component);

        function Button() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "clickEvents", _descriptor$H, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_interactable", _descriptor2$s, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_transition", _descriptor3$k, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_normalColor", _descriptor4$h, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_hoverColor", _descriptor5$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_pressedColor", _descriptor6$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_disabledColor", _descriptor7$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_normalSprite", _descriptor8$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_hoverSprite", _descriptor9$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_pressedSprite", _descriptor10$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_disabledSprite", _descriptor11$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_duration", _descriptor12$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_zoomScale", _descriptor13$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_target", _descriptor14$4, _assertThisInitialized(_this));

          _this._pressed = false;
          _this._hovered = false;
          _this._fromColor = new Color();
          _this._toColor = new Color();
          _this._time = 0;
          _this._transitionFinished = true;
          _this._fromScale = new Vec3();
          _this._toScale = new Vec3();
          _this._originalScale = null;
          _this._sprite = null;
          _this._targetScale = new Vec3();
          return _this;
        }

        var _proto = Button.prototype;

        _proto.__preload = function __preload() {
          if (!this.target) {
            this.target = this.node;
          }

          var sprite = this.node.getComponent(Sprite);

          if (sprite) {
            this._normalSprite = sprite.spriteFrame;
          }

          this._applyTarget();

          this._resetState();
        };

        _proto.onEnable = function onEnable() {

          {
            this._registerNodeEvent();
          }
        };

        _proto.onDisable = function onDisable() {
          this._resetState();

          {
            this._unregisterNodeEvent();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this.target.isValid) {
            this._unregisterTargetEvent(this.target);
          }
        };

        _proto.update = function update(dt) {
          var target = this.target;

          if (this._transitionFinished || !target) {
            return;
          }

          if (this._transition !== Transition.COLOR && this._transition !== Transition.SCALE) {
            return;
          }

          this._time += dt;
          var ratio = 1.0;

          if (this._duration > 0) {
            ratio = this._time / this._duration;
          }

          if (ratio >= 1) {
            ratio = 1;
          }

          if (this._transition === Transition.COLOR) {
            var renderComp = target._uiProps.uiComp;
            Color.lerp(_tempColor, this._fromColor, this._toColor, ratio);

            if (renderComp) {
              renderComp.color = _tempColor;
            }
          } else if (this.transition === Transition.SCALE) {
            target.getScale(this._targetScale);
            this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio);
            this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio);
            target.setScale(this._targetScale);
          }

          if (ratio === 1) {
            this._transitionFinished = true;
          }
        };

        _proto._resizeNodeToTargetNode = function _resizeNodeToTargetNode() {
          if (!this.target) {
            return;
          }

          var targetTrans = this.target._uiProps.uiTransformComp;
        };

        _proto._resetState = function _resetState() {
          this._pressed = false;
          this._hovered = false;
          var target = this.target;

          if (!target) {
            return;
          }

          var transition = this._transition;

          if (transition === Transition.COLOR && this._interactable) {
            var renderComp = target.getComponent(Renderable2D);

            if (renderComp) {
              renderComp.color = this._normalColor;
            }
          } else if (transition === Transition.SCALE && this._originalScale) {
            target.setScale(this._originalScale);
          }

          this._transitionFinished = true;
        };

        _proto._registerNodeEvent = function _registerNodeEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
          this.node.on(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
          this.node.on(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
        };

        _proto._registerTargetEvent = function _registerTargetEvent(target) {

          target.on(NodeEventType.TRANSFORM_CHANGED, this._onTargetTransformChanged, this);
        };

        _proto._unregisterNodeEvent = function _unregisterNodeEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
          this.node.off(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
          this.node.off(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
        };

        _proto._unregisterTargetEvent = function _unregisterTargetEvent(target) {

          target.off(NodeEventType.TRANSFORM_CHANGED);
        };

        _proto._getTargetSprite = function _getTargetSprite(target) {
          var sprite = null;

          if (target) {
            sprite = target.getComponent(Sprite);
          }

          return sprite;
        };

        _proto._applyTarget = function _applyTarget() {
          if (this.target) {
            this._sprite = this._getTargetSprite(this.target);

            if (!this._originalScale) {
              this._originalScale = new Vec3();
            }

            Vec3.copy(this._originalScale, this.target.getScale());

            this._registerTargetEvent(this.target);
          }
        };

        _proto._onTargetSpriteFrameChanged = function _onTargetSpriteFrameChanged(comp) {
          if (this._transition === Transition.SPRITE) {
            this._setCurrentStateSpriteFrame(comp.spriteFrame);
          }
        };

        _proto._setCurrentStateSpriteFrame = function _setCurrentStateSpriteFrame(spriteFrame) {
          if (!spriteFrame) {
            return;
          }

          switch (this._getButtonState()) {
            case State.NORMAL:
              this._normalSprite = spriteFrame;
              break;

            case State.HOVER:
              this._hoverSprite = spriteFrame;
              break;

            case State.PRESSED:
              this._pressedSprite = spriteFrame;
              break;

            case State.DISABLED:
              this._disabledSprite = spriteFrame;
              break;
          }
        };

        _proto._onTargetColorChanged = function _onTargetColorChanged(color) {
          if (this._transition === Transition.COLOR) {
            this._setCurrentStateColor(color);
          }
        };

        _proto._setCurrentStateColor = function _setCurrentStateColor(color) {
          switch (this._getButtonState()) {
            case State.NORMAL:
              this._normalColor = color;
              break;

            case State.HOVER:
              this._hoverColor = color;
              break;

            case State.PRESSED:
              this._pressedColor = color;
              break;

            case State.DISABLED:
              this._disabledColor = color;
              break;
          }
        };

        _proto._onTargetTransformChanged = function _onTargetTransformChanged(transformBit) {
          if (transformBit & TransformBit.SCALE && this._originalScale && this._transition === Transition.SCALE && this._transitionFinished) {
            Vec3.copy(this._originalScale, this.target.getScale());
          }
        };

        _proto._onTouchBegan = function _onTouchBegan(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }

          this._pressed = true;

          this._updateState();

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._onTouchMove = function _onTouchMove(event) {
          if (!this._interactable || !this.enabledInHierarchy || !this._pressed) {
            return;
          }

          if (!event) {
            return;
          }

          var touch = event.touch;

          if (!touch) {
            return;
          }

          var hit = this.node._uiProps.uiTransformComp.hitTest(touch.getLocation());

          if (this._transition === Transition.SCALE && this.target && this._originalScale) {
            if (hit) {
              Vec3.copy(this._fromScale, this._originalScale);
              Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
              this._transitionFinished = false;
            } else {
              this._time = 0;
              this._transitionFinished = true;
              this.target.setScale(this._originalScale);
            }
          } else {
            var state;

            if (hit) {
              state = State.PRESSED;
            } else {
              state = State.NORMAL;
            }

            this._applyTransition(state);
          }

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._onTouchEnded = function _onTouchEnded(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }

          if (this._pressed) {
            EventHandler.emitEvents(this.clickEvents, event);
            this.node.emit(EventType$1.CLICK, this);
          }

          this._pressed = false;

          this._updateState();

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._onTouchCancel = function _onTouchCancel(event) {
          if (!this._interactable || !this.enabledInHierarchy) {
            return;
          }

          this._pressed = false;

          this._updateState();
        };

        _proto._onMouseMoveIn = function _onMouseMoveIn(event) {
          if (this._pressed || !this.interactable || !this.enabledInHierarchy) {
            return;
          }

          if (this._transition === Transition.SPRITE && !this._hoverSprite) {
            return;
          }

          if (!this._hovered) {
            this._hovered = true;

            this._updateState();
          }
        };

        _proto._onMouseMoveOut = function _onMouseMoveOut(event) {
          if (this._hovered) {
            this._hovered = false;

            this._updateState();
          }
        };

        _proto._updateState = function _updateState() {
          var state = this._getButtonState();

          this._applyTransition(state);
        };

        _proto._getButtonState = function _getButtonState() {
          var state = State.NORMAL;

          if (!this._interactable) {
            state = State.DISABLED;
          } else if (this._pressed) {
            state = State.PRESSED;
          } else if (this._hovered) {
            state = State.HOVER;
          }

          return state.toString();
        };

        _proto._updateColorTransition = function _updateColorTransition(state) {
          var _this$target;

          var color = this[state + "Color"];
          var renderComp = (_this$target = this.target) === null || _this$target === void 0 ? void 0 : _this$target.getComponent(Renderable2D);

          if (!renderComp) {
            return;
          }

          if ( state === State.DISABLED) {
            renderComp.color = color;
          } else {
            this._fromColor = renderComp.color.clone();
            this._toColor = color;
            this._time = 0;
            this._transitionFinished = false;
          }
        };

        _proto._updateSpriteTransition = function _updateSpriteTransition(state) {
          var sprite = this[state + "Sprite"];

          if (this._sprite && sprite) {
            this._sprite.spriteFrame = sprite;
          }
        };

        _proto._updateScaleTransition = function _updateScaleTransition(state) {
          if (!this._interactable) {
            return;
          }

          if (state === State.PRESSED) {
            this._zoomUp();
          } else {
            this._zoomBack();
          }
        };

        _proto._zoomUp = function _zoomUp() {
          if (!this._originalScale) {
            return;
          }

          Vec3.copy(this._fromScale, this._originalScale);
          Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
          this._time = 0;
          this._transitionFinished = false;
        };

        _proto._zoomBack = function _zoomBack() {
          if (!this.target || !this._originalScale) {
            return;
          }

          Vec3.copy(this._fromScale, this.target.getScale());
          Vec3.copy(this._toScale, this._originalScale);
          this._time = 0;
          this._transitionFinished = false;
        };

        _proto._applyTransition = function _applyTransition(state) {
          var transition = this._transition;

          if (transition === Transition.COLOR) {
            this._updateColorTransition(state);
          } else if (transition === Transition.SPRITE) {
            this._updateSpriteTransition(state);
          } else if (transition === Transition.SCALE) {
            this._updateScaleTransition(state);
          }
        };

        _createClass(Button, [{
          key: "target",
          get: function get() {
            return this._target || this.node;
          },
          set: function set(value) {
            if (this._target === value) {
              return;
            }

            if (this._target) {
              this._unregisterTargetEvent(this._target);
            }

            this._target = value;

            this._applyTarget();
          }
        }, {
          key: "interactable",
          get: function get() {
            return this._interactable;
          },
          set: function set(value) {
            if (this._interactable === value) {
              return;
            }

            this._interactable = value;

            this._updateState();

            if (!this._interactable) {
              this._resetState();
            }
          }
        }, {
          key: "_resizeToTarget",
          set: function set(value) {
            if (value) {
              this._resizeNodeToTargetNode();
            }
          }
        }, {
          key: "transition",
          get: function get() {
            return this._transition;
          },
          set: function set(value) {
            if (this._transition === value) {
              return;
            }

            if (this._transition === Transition.COLOR) {
              this._updateColorTransition(State.NORMAL);
            } else if (this._transition === Transition.SPRITE) {
              this._updateSpriteTransition(State.NORMAL);
            }

            this._transition = value;

            this._updateState();
          }
        }, {
          key: "normalColor",
          get: function get() {
            return this._normalColor;
          },
          set: function set(value) {
            if (this._normalColor === value) {
              return;
            }

            this._normalColor.set(value);

            this._updateState();
          }
        }, {
          key: "pressedColor",
          get: function get() {
            return this._pressedColor;
          },
          set: function set(value) {
            if (this._pressedColor === value) {
              return;
            }

            this._pressedColor.set(value);
          }
        }, {
          key: "hoverColor",
          get: function get() {
            return this._hoverColor;
          },
          set: function set(value) {
            if (this._hoverColor === value) {
              return;
            }

            this._hoverColor.set(value);
          }
        }, {
          key: "disabledColor",
          get: function get() {
            return this._disabledColor;
          },
          set: function set(value) {
            if (this._disabledColor === value) {
              return;
            }

            this._disabledColor.set(value);

            this._updateState();
          }
        }, {
          key: "duration",
          get: function get() {
            return this._duration;
          },
          set: function set(value) {
            if (this._duration === value) {
              return;
            }

            this._duration = value;
          }
        }, {
          key: "zoomScale",
          get: function get() {
            return this._zoomScale;
          },
          set: function set(value) {
            if (this._zoomScale === value) {
              return;
            }

            this._zoomScale = value;
          }
        }, {
          key: "normalSprite",
          get: function get() {
            return this._normalSprite;
          },
          set: function set(value) {
            if (this._normalSprite === value) {
              return;
            }

            this._normalSprite = value;
            var sprite = this.node.getComponent(Sprite);

            if (sprite) {
              sprite.spriteFrame = value;
            }

            this._updateState();
          }
        }, {
          key: "pressedSprite",
          get: function get() {
            return this._pressedSprite;
          },
          set: function set(value) {
            if (this._pressedSprite === value) {
              return;
            }

            this._pressedSprite = value;

            this._updateState();
          }
        }, {
          key: "hoverSprite",
          get: function get() {
            return this._hoverSprite;
          },
          set: function set(value) {
            if (this._hoverSprite === value) {
              return;
            }

            this._hoverSprite = value;

            this._updateState();
          }
        }, {
          key: "disabledSprite",
          get: function get() {
            return this._disabledSprite;
          },
          set: function set(value) {
            if (this._disabledSprite === value) {
              return;
            }

            this._disabledSprite = value;

            this._updateState();
          }
        }]);

        return Button;
      }(Component), _class3$l.Transition = Transition, _class3$l.EventType = EventType$1, _temp$U), (_applyDecoratedDescriptor(_class2$P.prototype, "target", [_dec6$b, _dec7$9, _dec8$9], Object.getOwnPropertyDescriptor(_class2$P.prototype, "target"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "interactable", [_dec9$7, _dec10$7], Object.getOwnPropertyDescriptor(_class2$P.prototype, "interactable"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "transition", [_dec11$5, _dec12$5, _dec13$5], Object.getOwnPropertyDescriptor(_class2$P.prototype, "transition"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "normalColor", [_dec14$5, _dec15$5], Object.getOwnPropertyDescriptor(_class2$P.prototype, "normalColor"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "pressedColor", [_dec16$5, _dec17$5], Object.getOwnPropertyDescriptor(_class2$P.prototype, "pressedColor"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "hoverColor", [_dec18$5, _dec19$5], Object.getOwnPropertyDescriptor(_class2$P.prototype, "hoverColor"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "disabledColor", [_dec20$5, _dec21$5], Object.getOwnPropertyDescriptor(_class2$P.prototype, "disabledColor"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "duration", [_dec22$5, _dec23$5, _dec24$5, _dec25$5], Object.getOwnPropertyDescriptor(_class2$P.prototype, "duration"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "zoomScale", [_dec26$4, _dec27$4], Object.getOwnPropertyDescriptor(_class2$P.prototype, "zoomScale"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "normalSprite", [_dec28$4, _dec29$4, _dec30$4], Object.getOwnPropertyDescriptor(_class2$P.prototype, "normalSprite"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "pressedSprite", [_dec31$4, _dec32$3, _dec33$2], Object.getOwnPropertyDescriptor(_class2$P.prototype, "pressedSprite"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "hoverSprite", [_dec34$2, _dec35$2, _dec36$2], Object.getOwnPropertyDescriptor(_class2$P.prototype, "hoverSprite"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "disabledSprite", [_dec37$2, _dec38$2, _dec39$2], Object.getOwnPropertyDescriptor(_class2$P.prototype, "disabledSprite"), _class2$P.prototype), _descriptor$H = _applyDecoratedDescriptor(_class2$P.prototype, "clickEvents", [_dec40$2, serializable, _dec41$2, _dec42$2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$s = _applyDecoratedDescriptor(_class2$P.prototype, "_interactable", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor3$k = _applyDecoratedDescriptor(_class2$P.prototype, "_transition", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Transition.NONE;
        }
      }), _descriptor4$h = _applyDecoratedDescriptor(_class2$P.prototype, "_normalColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor5$c = _applyDecoratedDescriptor(_class2$P.prototype, "_hoverColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(211, 211, 211, 255);
        }
      }), _descriptor6$6 = _applyDecoratedDescriptor(_class2$P.prototype, "_pressedColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor7$6 = _applyDecoratedDescriptor(_class2$P.prototype, "_disabledColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(124, 124, 124, 255);
        }
      }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$P.prototype, "_normalSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$P.prototype, "_hoverSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10$5 = _applyDecoratedDescriptor(_class2$P.prototype, "_pressedSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$4 = _applyDecoratedDescriptor(_class2$P.prototype, "_disabledSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12$4 = _applyDecoratedDescriptor(_class2$P.prototype, "_duration", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor13$4 = _applyDecoratedDescriptor(_class2$P.prototype, "_zoomScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.2;
        }
      }), _descriptor14$4 = _applyDecoratedDescriptor(_class2$P.prototype, "_target", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$P)) || _class$Z) || _class$Z) || _class$Z) || _class$Z) || _class$Z) || _class$Z));
      legacyCC.Button = Button;

      var minigame = {};

      var BASELINE_RATIO = exports('BASELINE_RATIO', 0.26);
      var _BASELINE_OFFSET = 0;

      var MIDDLE_RATIO = exports('MIDDLE_RATIO', (BASELINE_RATIO + 1) / 2 - BASELINE_RATIO);
      function getBaselineOffset() {
        return _BASELINE_OFFSET;
      }
      var MAX_CACHE_SIZE = 100;
      var pool = new Pool(2);

      pool.get = function () {
        return this._get() || {
          key: '',
          value: 0,
          prev: null,
          next: null
        };
      };

      var LRUCache = function () {
        function LRUCache(size) {
          this.count = 0;
          this.limit = 0;
          this.datas = {};
          this.limit = size;
        }

        var _proto = LRUCache.prototype;

        _proto.moveToHead = function moveToHead(node) {
          node.next = this.head;
          node.prev = null;
          if (this.head) this.head.prev = node;
          this.head = node;
          if (!this.tail) this.tail = node;
          this.count++;
          this.datas[node.key] = node;
        };

        _proto.put = function put(key, value) {
          var node = pool.get();
          node.key = key;
          node.value = value;

          if (this.count >= this.limit) {
            var discard = this.tail;
            delete this.datas[discard.key];
            this.count--;
            this.tail = discard.prev;
            this.tail.next = null;
            discard.prev = null;
            discard.next = null;
            pool.put(discard);
          }

          this.moveToHead(node);
        };

        _proto.remove = function remove(node) {
          if (node.prev) {
            node.prev.next = node.next;
          } else {
            this.head = node.next;
          }

          if (node.next) {
            node.next.prev = node.prev;
          } else {
            this.tail = node.prev;
          }

          delete this.datas[node.key];
          this.count--;
        };

        _proto.get = function get(key) {
          var node = this.datas[key];

          if (node) {
            this.remove(node);
            this.moveToHead(node);
            return node.value;
          }

          return null;
        };

        _proto.clear = function clear() {
          this.count = 0;
          this.datas = {};
          this.head = null;
          this.tail = null;
        };

        _proto.has = function has(key) {
          return !!this.datas[key];
        };

        _proto["delete"] = function _delete(key) {
          var node = this.datas[key];
          this.remove(node);
        };

        return LRUCache;
      }();

      var measureCache = new LRUCache(MAX_CACHE_SIZE);
      var WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/;
      var SYMBOL_REG = /^[!,.:;'}\]%\?>、‘“》？。，！]/;
      var LAST_WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+|\S)$/;
      var LAST_ENGLISH_REG = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]+$/;
      var FIRST_ENGLISH_REG = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁёáàảạãăắằẳẵặâấầẩẫậéèẻẽẹêếềểễệiíìỉĩịóòỏõọôốồổỗộơớờởỡợúùủũụưứừửữựýỳỷỹỵđÁÀẢẠÃĂẮẰẲẴẶÂẤẦẨẪẬÉÈẺẼẸÊẾỀỂỄỆIÍÌỈĨỊÓÒỎÕỌÔỐỒỔỖỘƠỚỜỞỠỢÚÙỦŨỤƯỨỪỬỮỰÝỲỶỸỴĐ]/;
      function isUnicodeCJK(ch) {
        var __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
        var __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
        var __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
        return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
      }
      function isUnicodeSpace(ch) {
        var chCode = ch.charCodeAt(0);
        return chCode >= 9 && chCode <= 13 || chCode === 32 || chCode === 133 || chCode === 160 || chCode === 5760 || chCode >= 8192 && chCode <= 8202 || chCode === 8232 || chCode === 8233 || chCode === 8239 || chCode === 8287 || chCode === 12288;
      }
      function safeMeasureText(ctx, string, desc) {
        var font = desc || ctx.font;
        var key = font + "\uD83C\uDFAE" + string;
        var cache = measureCache.get(key);

        if (cache !== null) {
          return cache;
        }

        var metric = ctx.measureText(string);
        var width = metric && metric.width || 0;
        measureCache.put(key, width);
        return width;
      }

      function _safeSubstring(targetString, startIndex, endIndex) {
        var newStartIndex = startIndex;
        var newEndIndex = endIndex;
        var startChar = targetString[startIndex];

        if (startChar >= "\uDC00" && startChar <= "\uDFFF") {
          newStartIndex--;
        }

        if (endIndex !== undefined) {
          if (endIndex - 1 !== startIndex) {
            var endChar = targetString[endIndex - 1];

            if (endChar >= "\uD800" && endChar <= "\uDBFF") {
              newEndIndex--;
            }
          } else if (startChar >= "\uD800" && startChar <= "\uDBFF") {
            newEndIndex++;
          }
        }

        return targetString.substring(newStartIndex, newEndIndex);
      }

      function isEnglishWordPartAtFirst(stringToken) {
        return FIRST_ENGLISH_REG.test(stringToken);
      }
      function isEnglishWordPartAtLast(stringToken) {
        return LAST_ENGLISH_REG.test(stringToken);
      }
      function getEnglishWordPartAtFirst(stringToken) {
        var result = FIRST_ENGLISH_REG.exec(stringToken);
        return result;
      }
      function getEnglishWordPartAtLast(stringToken) {
        var result = LAST_ENGLISH_REG.exec(stringToken);
        return result;
      }
      function fragmentText(stringToken, allWidth, maxWidth, measureText) {
        var wrappedWords = [];

        if (stringToken.length === 0 || maxWidth < 0) {
          wrappedWords.push('');
          return wrappedWords;
        }

        var text = stringToken;

        while (allWidth > maxWidth && text.length > 1) {
          var fuzzyLen = text.length * (maxWidth / allWidth) | 0;

          var tmpText = _safeSubstring(text, fuzzyLen);

          var width = allWidth - measureText(tmpText);
          var sLine = tmpText;
          var pushNum = 0;
          var checkWhile = 0;
          var checkCount = 100;

          while (width > maxWidth && checkWhile++ < checkCount) {
            fuzzyLen *= maxWidth / width;
            fuzzyLen |= 0;
            tmpText = _safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }

          checkWhile = 0;

          while (tmpText && width <= maxWidth && checkWhile++ < checkCount) {
            var exec = WORD_REG.exec(tmpText);
            pushNum = exec ? exec[0].length : 1;
            sLine = tmpText;
            fuzzyLen += pushNum;
            tmpText = _safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }

          fuzzyLen -= pushNum;

          if (fuzzyLen === 0) {
            fuzzyLen = 1;
            sLine = _safeSubstring(text, 1);
          } else if (fuzzyLen === 1 && text[0] >= "\uD800" && text[0] <= "\uDBFF") {
            fuzzyLen = 2;
            sLine = _safeSubstring(text, 2);
          }

          var sText = _safeSubstring(text, 0, fuzzyLen);

          var result = void 0;

          {
            if (SYMBOL_REG.test(sLine || tmpText)) {
              result = LAST_WORD_REG.exec(sText);
              fuzzyLen -= result ? result[0].length : 0;

              if (fuzzyLen === 0) {
                fuzzyLen = 1;
              }

              sLine = _safeSubstring(text, fuzzyLen);
              sText = _safeSubstring(text, 0, fuzzyLen);
            }
          }

          if (FIRST_ENGLISH_REG.test(sLine)) {
            result = LAST_ENGLISH_REG.exec(sText);

            if (result && sText !== result[0]) {
              fuzzyLen -= result[0].length;
              sLine = _safeSubstring(text, fuzzyLen);
              sText = _safeSubstring(text, 0, fuzzyLen);
            }
          }

          if (wrappedWords.length === 0) {
            wrappedWords.push(sText);
          } else {
            sText = sText.trim();

            if (sText.length > 0) {
              wrappedWords.push(sText);
            }
          }

          text = sLine || tmpText;
          allWidth = measureText(text);
        }

        if (wrappedWords.length === 0) {
          wrappedWords.push(text);
        } else {
          text = text.trim();

          if (text.length > 0) {
            wrappedWords.push(text);
          }
        }

        return wrappedWords;
      }

      var _canvasPool;

      var CanvasPool = exports('CanvasPool', function () {
        function CanvasPool() {
          this.pool = [];
        }

        CanvasPool.getInstance = function getInstance() {
          if (!_canvasPool) {
            _canvasPool = new CanvasPool();
          }

          return _canvasPool;
        };

        var _proto = CanvasPool.prototype;

        _proto.get = function get() {
          var data = this.pool.pop();

          if (!data) {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            data = {
              canvas: canvas,
              context: context
            };
          }

          return data;
        };

        _proto.put = function put(canvas) {
          if (this.pool.length >= macro.MAX_LABEL_CANVAS_POOL_SIZE) {
            return;
          }

          this.pool.push(canvas);
        };

        return CanvasPool;
      }());
      var WHITE = Color.WHITE.clone();
      var space$1 = 0;
      var bleed = 2;

      var FontLetterDefinition$1 = function FontLetterDefinition() {
        this.u = 0;
        this.v = 0;
        this.w = 0;
        this.h = 0;
        this.texture = null;
        this.offsetX = 0;
        this.offsetY = 0;
        this.valid = false;
        this.xAdvance = 0;
      };

      var _backgroundStyle = "rgba(255, 255, 255, " + (1 / 255).toFixed(3) + ")";

      var BASELINE_OFFSET = getBaselineOffset();

      var LetterTexture = function () {
        function LetterTexture(_char, labelInfo) {
          this.image = null;
          this.labelInfo = void 0;
          this["char"] = void 0;
          this.data = null;
          this.canvas = null;
          this.context = null;
          this.width = 0;
          this.height = 0;
          this.offsetY = 0;
          this.hash = void 0;
          this["char"] = _char;
          this.labelInfo = labelInfo;
          this.hash = _char.charCodeAt(0) + labelInfo.hash;
        }

        var _proto2 = LetterTexture.prototype;

        _proto2.updateRenderData = function updateRenderData() {
          this._updateProperties();

          this._updateTexture();
        };

        _proto2.destroy = function destroy() {
          this.image = null;
        };

        _proto2._updateProperties = function _updateProperties() {
          this.data = CanvasPool.getInstance().get();
          this.canvas = this.data.canvas;
          this.context = this.data.context;

          if (this.context) {
            this.context.font = this.labelInfo.fontDesc;
            var width = safeMeasureText(this.context, this["char"], this.labelInfo.fontDesc);
            var blank = this.labelInfo.margin * 2 + bleed;
            this.width = parseFloat(width.toFixed(2)) + blank;
            this.height = (1 + BASELINE_RATIO) * this.labelInfo.fontSize + blank;
            this.offsetY = -(this.labelInfo.fontSize * BASELINE_RATIO) / 2;
          }

          if (this.canvas.width !== this.width) {
            this.canvas.width = this.width;
          }

          if (this.canvas.height !== this.height) {
            this.canvas.height = this.height;
          }

          if (!this.image) {
            this.image = new ImageAsset();
          }

          this.image.reset(this.canvas);
        };

        _proto2._updateTexture = function _updateTexture() {
          if (!this.context || !this.canvas) {
            return;
          }

          var context = this.context;
          var labelInfo = this.labelInfo;
          var width = this.canvas.width;
          var height = this.canvas.height;
          context.textAlign = 'center';
          context.textBaseline = 'alphabetic';
          context.clearRect(0, 0, width, height);
          context.fillStyle = _backgroundStyle;
          context.fillRect(0, 0, width, height);
          context.font = labelInfo.fontDesc;
          var fontSize = labelInfo.fontSize;
          var startX = width / 2;
          var startY = height / 2 + fontSize * MIDDLE_RATIO + fontSize * BASELINE_OFFSET;
          var color = labelInfo.color;
          context.lineJoin = 'round';
          context.fillStyle = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + 1 + ")";

          if (labelInfo.isOutlined) {
            var strokeColor = labelInfo.out || WHITE;
            context.strokeStyle = "rgba(" + strokeColor.r + ", " + strokeColor.g + ", " + strokeColor.b + ", " + strokeColor.a / 255 + ")";
            context.lineWidth = labelInfo.margin * 2;
            context.strokeText(this["char"], startX, startY);
          }

          context.fillText(this["char"], startX, startY);
        };

        return LetterTexture;
      }();

      var LetterRenderTexture = function (_Texture2D) {
        _inheritsLoose(LetterRenderTexture, _Texture2D);

        function LetterRenderTexture() {
          return _Texture2D.apply(this, arguments) || this;
        }

        var _proto3 = LetterRenderTexture.prototype;

        _proto3.initWithSize = function initWithSize(width, height, format) {
          if (format === void 0) {
            format = PixelFormat.RGBA8888;
          }

          this.reset({
            width: width,
            height: height,
            format: format
          });
        };

        _proto3.drawTextureAt = function drawTextureAt(image, x, y) {
          var gfxTexture = this.getGFXTexture();

          if (!image || !gfxTexture) {
            return;
          }

          var gfxDevice = this._getGFXDevice();

          if (!gfxDevice) {
            console.warn('Unable to get device');
            return;
          }

          var region = new BufferTextureCopy();
          region.texOffset.x = x;
          region.texOffset.y = y;
          region.texExtent.width = image.width;
          region.texExtent.height = image.height;
          gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
        };

        return LetterRenderTexture;
      }(Texture2D);
      var LetterAtlas = function () {
        function LetterAtlas(width, height) {
          this._x = space$1;
          this._y = space$1;
          this._nextY = space$1;
          this._width = 0;
          this._height = 0;
          this._halfBleed = 0;
          this._dirty = false;
          var texture = new LetterRenderTexture();
          texture.initWithSize(width, height);
          this.fontDefDictionary = new FontAtlas(texture);
          this._halfBleed = bleed / 2;
          this._width = width;
          this._height = height;
          director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
        }

        var _proto4 = LetterAtlas.prototype;

        _proto4.insertLetterTexture = function insertLetterTexture(letterTexture) {
          var texture = letterTexture.image;
          var device = director.root.device;

          if (!texture || !this.fontDefDictionary || !device) {
            return null;
          }

          var width = texture.width;
          var height = texture.height;

          if (this._x + width + space$1 > this._width) {
            this._x = space$1;
            this._y = this._nextY;
          }

          if (this._y + height > this._nextY) {
            this._nextY = this._y + height + space$1;
          }

          if (this._nextY > this._height) {
            warnID(12100);
            return null;
          }

          this.fontDefDictionary.texture.drawTextureAt(texture, this._x, this._y);
          this._dirty = true;
          var letterDefinition = new FontLetterDefinition$1();
          letterDefinition.u = this._x + this._halfBleed;
          letterDefinition.v = this._y + this._halfBleed;
          letterDefinition.texture = this.fontDefDictionary.texture;
          letterDefinition.valid = true;
          letterDefinition.w = letterTexture.width - bleed;
          letterDefinition.h = letterTexture.height - bleed;
          letterDefinition.xAdvance = letterDefinition.w;
          letterDefinition.offsetY = letterTexture.offsetY;
          this._x += width + space$1;
          this.fontDefDictionary.addLetterDefinitions(letterTexture.hash, letterDefinition);
          return letterDefinition;
        };

        _proto4.update = function update() {
          if (!this._dirty) {
            return;
          }

          this._dirty = false;
        };

        _proto4.reset = function reset() {
          this._x = space$1;
          this._y = space$1;
          this._nextY = space$1;
          this.fontDefDictionary.clear();
        };

        _proto4.destroy = function destroy() {
          this.reset();

          if (this.fontDefDictionary) {
            this.fontDefDictionary.texture.destroy();
            this.fontDefDictionary.texture = null;
          }
        };

        _proto4.getTexture = function getTexture() {
          return this.fontDefDictionary.getTexture();
        };

        _proto4.beforeSceneLoad = function beforeSceneLoad() {
          this.clearAllCache();
        };

        _proto4.clearAllCache = function clearAllCache() {
          this.destroy();
          var texture = new LetterRenderTexture();
          texture.initWithSize(this._width, this._height);
          this.fontDefDictionary.texture = texture;
        };

        _proto4.getLetter = function getLetter(key) {
          return this.fontDefDictionary.letterDefinitions[key];
        };

        _proto4.getLetterDefinitionForChar = function getLetterDefinitionForChar(_char2, labelInfo) {
          var hash = _char2.charCodeAt(0) + labelInfo.hash;
          var letter = this.fontDefDictionary.letterDefinitions[hash];

          if (!letter) {
            var temp = new LetterTexture(_char2, labelInfo);
            temp.updateRenderData();
            letter = this.insertLetterTexture(temp);
            temp.destroy();
          }

          return letter;
        };

        _createClass(LetterAtlas, [{
          key: "width",
          get: function get() {
            return this._width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          }
        }]);

        return LetterAtlas;
      }();
      var shareLabelInfo = {
        fontAtlas: null,
        fontSize: 0,
        lineHeight: 0,
        hAlign: 0,
        vAlign: 0,
        hash: '',
        fontFamily: '',
        fontDesc: 'Arial',
        color: Color.WHITE.clone(),
        isOutlined: false,
        out: Color.WHITE.clone(),
        margin: 0
      };
      function computeHash(labelInfo) {
        var hashData = '';
        var color = labelInfo.color.toHEX();
        var out = '';

        if (labelInfo.isOutlined && labelInfo.margin > 0) {
          out = out + labelInfo.margin + labelInfo.out.toHEX();
        }

        return hashData + labelInfo.fontSize + labelInfo.fontFamily + color + out;
      }

      var _dec$Y, _dec2$x, _dec3$r, _dec4$j, _dec5$f, _dec6$c, _dec7$a, _dec8$a, _dec9$8, _dec10$8, _dec11$6, _dec12$6, _dec13$6, _dec14$6, _dec15$6, _dec16$6, _dec17$6, _dec18$6, _dec19$6, _dec20$6, _dec21$6, _dec22$6, _dec23$6, _dec24$6, _dec25$6, _dec26$5, _dec27$5, _dec28$5, _dec29$5, _dec30$5, _dec31$5, _dec32$4, _dec33$3, _dec34$3, _dec35$3, _dec36$3, _dec37$3, _dec38$3, _dec39$3, _dec40$3, _dec41$3, _dec42$3, _dec43$2, _dec44$2, _dec45$2, _class$_, _class2$Q, _descriptor$I, _descriptor2$t, _descriptor3$l, _descriptor4$i, _descriptor5$d, _descriptor6$7, _descriptor7$7, _descriptor8$7, _descriptor9$6, _descriptor10$6, _descriptor11$5, _descriptor12$5, _descriptor13$5, _descriptor14$5, _descriptor15$4, _descriptor16$4, _descriptor17$4, _class3$m, _temp$V;
      var HorizontalTextAlignment;

      (function (HorizontalTextAlignment) {
        HorizontalTextAlignment[HorizontalTextAlignment["LEFT"] = 0] = "LEFT";
        HorizontalTextAlignment[HorizontalTextAlignment["CENTER"] = 1] = "CENTER";
        HorizontalTextAlignment[HorizontalTextAlignment["RIGHT"] = 2] = "RIGHT";
      })(HorizontalTextAlignment || (HorizontalTextAlignment = exports('HorizontalTextAlignment', {})));

      ccenum(HorizontalTextAlignment);
      var VerticalTextAlignment;

      (function (VerticalTextAlignment) {
        VerticalTextAlignment[VerticalTextAlignment["TOP"] = 0] = "TOP";
        VerticalTextAlignment[VerticalTextAlignment["CENTER"] = 1] = "CENTER";
        VerticalTextAlignment[VerticalTextAlignment["BOTTOM"] = 2] = "BOTTOM";
      })(VerticalTextAlignment || (VerticalTextAlignment = exports('VerticalTextAlignment', {})));

      ccenum(VerticalTextAlignment);
      var Overflow;

      (function (Overflow) {
        Overflow[Overflow["NONE"] = 0] = "NONE";
        Overflow[Overflow["CLAMP"] = 1] = "CLAMP";
        Overflow[Overflow["SHRINK"] = 2] = "SHRINK";
        Overflow[Overflow["RESIZE_HEIGHT"] = 3] = "RESIZE_HEIGHT";
      })(Overflow || (Overflow = exports('Overflow', {})));

      ccenum(Overflow);
      var CacheMode;

      (function (CacheMode) {
        CacheMode[CacheMode["NONE"] = 0] = "NONE";
        CacheMode[CacheMode["BITMAP"] = 1] = "BITMAP";
        CacheMode[CacheMode["CHAR"] = 2] = "CHAR";
      })(CacheMode || (CacheMode = exports('CacheMode', {})));

      ccenum(CacheMode);
      var Label = function (v) { return exports({ Label: v, LabelComponent: v }), v; }((_dec$Y = ccclass('cc.Label'), _dec2$x = help(), _dec3$r = executionOrder(110), _dec4$j = menu(), _dec5$f = displayOrder(), _dec6$c = tooltip(), _dec7$a = type(HorizontalTextAlignment), _dec8$a = displayOrder(), _dec9$8 = tooltip(), _dec10$8 = type(VerticalTextAlignment), _dec11$6 = displayOrder(), _dec12$6 = tooltip(), _dec13$6 = displayOrder(), _dec14$6 = tooltip(), _dec15$6 = displayOrder(), _dec16$6 = visible(), _dec17$6 = tooltip(), _dec18$6 = displayOrder(), _dec19$6 = tooltip(), _dec20$6 = visible(), _dec21$6 = displayOrder(), _dec22$6 = tooltip(), _dec23$6 = type(Overflow), _dec24$6 = displayOrder(), _dec25$6 = tooltip(), _dec26$5 = displayOrder(), _dec27$5 = tooltip(), _dec28$5 = type(Font), _dec29$5 = displayOrder(), _dec30$5 = visible(), _dec31$5 = tooltip(), _dec32$4 = displayOrder(), _dec33$3 = tooltip(), _dec34$3 = type(CacheMode), _dec35$3 = displayOrder(), _dec36$3 = tooltip(), _dec37$3 = displayOrder(), _dec38$3 = tooltip(), _dec39$3 = displayOrder(), _dec40$3 = tooltip(), _dec41$3 = displayOrder(), _dec42$3 = tooltip(), _dec43$2 = visible(), _dec44$2 = displayOrder(), _dec45$2 = tooltip(), _dec$Y(_class$_ = _dec2$x(_class$_ = _dec3$r(_class$_ = _dec4$j(_class$_ = (_class2$Q = (_temp$V = _class3$m = function (_Renderable2D) {
        _inheritsLoose(Label, _Renderable2D);

        function Label() {
          var _this;

          _this = _Renderable2D.call(this) || this;

          _initializerDefineProperty(_this, "_string", _descriptor$I, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalAlign", _descriptor2$t, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalAlign", _descriptor3$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_actualFontSize", _descriptor4$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fontSize", _descriptor5$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fontFamily", _descriptor6$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lineHeight", _descriptor7$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_overflow", _descriptor8$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_enableWrapText", _descriptor9$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_font", _descriptor10$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor11$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spacingX", _descriptor12$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isItalic", _descriptor13$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isBold", _descriptor14$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isUnderline", _descriptor15$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_underlineHeight", _descriptor16$4, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cacheMode", _descriptor17$4, _assertThisInitialized(_this));

          _this._N$file = null;
          _this._texture = null;
          _this._ttfSpriteFrame = null;
          _this._userDefinedFont = null;
          _this._assemblerData = null;
          _this._fontAtlas = null;
          _this._letterTexture = null;

          _this._ttfSpriteFrame = null;
          return _this;
        }

        var _proto = Label.prototype;

        _proto.onEnable = function onEnable() {
          _Renderable2D.prototype.onEnable.call(this);

          if (!this._font && !this._isSystemFontUsed) {
            this.useSystemFont = true;
          }

          if (this._isSystemFontUsed && !this._fontFamily) {
            this.fontFamily = 'Arial';
          }

          this._applyFontTexture();
        };

        _proto.onDestroy = function onDestroy() {
          if (this._assembler && this._assembler.resetAssemblerData) {
            this._assembler.resetAssemblerData(this._assemblerData);
          }

          this._assemblerData = null;

          if (this._ttfSpriteFrame) {
            this._ttfSpriteFrame._resetDynamicAtlasFrame();

            var tex = this._ttfSpriteFrame.texture;

            this._ttfSpriteFrame.destroy();

            if (tex) {
              var tex2d = tex;

              if (tex2d.image) {
                tex2d.image.destroy();
              }

              tex.destroy();
            }

            this._ttfSpriteFrame = null;
          }

          this._letterTexture = null;

          _Renderable2D.prototype.onDestroy.call(this);
        };

        _proto.updateRenderData = function updateRenderData(force) {
          if (force === void 0) {
            force = false;
          }

          this.markForUpdateRenderData();

          if (force) {
            this._flushAssembler();

            if (this.renderData) this.renderData.vertDirty = true;

            this._applyFontTexture();

            if (this._assembler) {
              this._assembler.updateRenderData(this);
            }
          }
        };

        _proto._render = function _render(render) {
          render.commitComp(this, this.renderData, this._texture, this._assembler, null);
        };

        _proto._updateColor = function _updateColor() {
          _Renderable2D.prototype._updateColor.call(this);

          this.updateRenderData(false);
        };

        _proto._canRender = function _canRender() {
          if (!_Renderable2D.prototype._canRender.call(this) || !this._string) {
            return false;
          }

          var font = this._font;

          if (font && font instanceof BitmapFont) {
            var spriteFrame = font.spriteFrame;

            if (!spriteFrame || !spriteFrame.texture) {
              return false;
            }
          }

          return true;
        };

        _proto._flushAssembler = function _flushAssembler() {
          var assembler = Label.Assembler.getAssembler(this);

          if (this._assembler !== assembler) {
            this.destroyRenderData();
            this._assembler = assembler;
          }

          if (!this._renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this._renderData.material = this.material;
            }
          }
        };

        _proto._applyFontTexture = function _applyFontTexture() {
          this.markForUpdateRenderData();
          var font = this._font;

          if (font instanceof BitmapFont) {
            var spriteFrame = font.spriteFrame;

            if (spriteFrame && spriteFrame.texture) {
              this._texture = spriteFrame;

              if (this.renderData) {
                this.renderData.textureDirty = true;
              }

              this.changeMaterialForDefine();

              if (this._assembler) {
                this._assembler.updateRenderData(this);
              }
            }
          } else {
            if (this.cacheMode === CacheMode.CHAR) {
              this._letterTexture = this._assembler.getAssemblerData();
              this._texture = this._letterTexture;
            } else if (!this._ttfSpriteFrame) {
              this._ttfSpriteFrame = new SpriteFrame();
              this._assemblerData = this._assembler.getAssemblerData();
              var image = new ImageAsset(this._assemblerData.canvas);
              var texture = new Texture2D();
              texture.image = image;
              this._ttfSpriteFrame.texture = texture;
            }

            if (this.cacheMode !== CacheMode.CHAR) {
              this._texture = this._ttfSpriteFrame;
            }

            this.changeMaterialForDefine();
          }
        };

        _proto.changeMaterialForDefine = function changeMaterialForDefine() {
          if (!this._texture) {
            return;
          }

          var value = false;

          if (this.cacheMode !== CacheMode.CHAR) {
            var spriteFrame = this._texture;
            var texture = spriteFrame.texture;

            if (texture instanceof TextureBase) {
              var format = texture.getPixelFormat();
              value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
            }
          }

          if (value) {
            this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
          } else {
            this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
          }

          this.updateMaterial();
        };

        _proto._updateBlendFunc = function _updateBlendFunc() {

          _Renderable2D.prototype._updateBlendFunc.call(this);
        };

        _createClass(Label, [{
          key: "string",
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            if (value === null || value === undefined) {
              value = '';
            } else {
              value = value.toString();
            }

            if (this._string === value) {
              return;
            }

            this._string = value;
            this.updateRenderData();
          }
        }, {
          key: "horizontalAlign",
          get: function get() {
            return this._horizontalAlign;
          },
          set: function set(value) {
            if (this._horizontalAlign === value) {
              return;
            }

            this._horizontalAlign = value;
            this.updateRenderData();
          }
        }, {
          key: "verticalAlign",
          get: function get() {
            return this._verticalAlign;
          },
          set: function set(value) {
            if (this._verticalAlign === value) {
              return;
            }

            this._verticalAlign = value;
            this.updateRenderData();
          }
        }, {
          key: "actualFontSize",
          get: function get() {
            return this._actualFontSize;
          },
          set: function set(value) {
            this._actualFontSize = value;
          }
        }, {
          key: "fontSize",
          get: function get() {
            return this._fontSize;
          },
          set: function set(value) {
            if (this._fontSize === value) {
              return;
            }

            this._fontSize = value;
            this.updateRenderData();
          }
        }, {
          key: "fontFamily",
          get: function get() {
            return this._fontFamily;
          },
          set: function set(value) {
            if (this._fontFamily === value) {
              return;
            }

            this._fontFamily = value;
            this.updateRenderData();
          }
        }, {
          key: "lineHeight",
          get: function get() {
            return this._lineHeight;
          },
          set: function set(value) {
            if (this._lineHeight === value) {
              return;
            }

            this._lineHeight = value;
            this.updateRenderData();
          }
        }, {
          key: "spacingX",
          get: function get() {
            return this._spacingX;
          },
          set: function set(value) {
            if (this._spacingX === value) {
              return;
            }

            this._spacingX = value;
            this.updateRenderData();
          }
        }, {
          key: "overflow",
          get: function get() {
            return this._overflow;
          },
          set: function set(value) {
            if (this._overflow === value) {
              return;
            }

            this._overflow = value;
            this.updateRenderData();
          }
        }, {
          key: "enableWrapText",
          get: function get() {
            return this._enableWrapText;
          },
          set: function set(value) {
            if (this._enableWrapText === value) {
              return;
            }

            this._enableWrapText = value;
            this.updateRenderData();
          }
        }, {
          key: "font",
          get: function get() {
            return this._font;
          },
          set: function set(value) {
            if (this._font === value) {
              return;
            }

            this._isSystemFontUsed = !value;

            this._font = value;

            if (this._renderData) {
              this.destroyRenderData();
              this._renderData = null;
            }

            this._fontAtlas = null;
            this.updateRenderData(true);
          }
        }, {
          key: "useSystemFont",
          get: function get() {
            return this._isSystemFontUsed;
          },
          set: function set(value) {
            if (this._isSystemFontUsed === value) {
              return;
            }

            this.destroyRenderData();
            this._renderData = null;

            this._isSystemFontUsed = !!value;

            if (value) {
              this.font = null;
            }

            this._flushAssembler();

            this.updateRenderData();
          }
        }, {
          key: "cacheMode",
          get: function get() {
            return this._cacheMode;
          },
          set: function set(value) {
            if (this._cacheMode === value) {
              return;
            }

            if (this._cacheMode === CacheMode.BITMAP && !(this._font instanceof BitmapFont) && this._ttfSpriteFrame) {
              this._ttfSpriteFrame._resetDynamicAtlasFrame();
            }

            if (this._cacheMode === CacheMode.CHAR) {
              this._ttfSpriteFrame = null;
            }

            this._cacheMode = value;
            this.updateRenderData(true);
          }
        }, {
          key: "isBold",
          get: function get() {
            return this._isBold;
          },
          set: function set(value) {
            if (this._isBold === value) {
              return;
            }

            this._isBold = value;
            this.updateRenderData();
          }
        }, {
          key: "isItalic",
          get: function get() {
            return this._isItalic;
          },
          set: function set(value) {
            if (this._isItalic === value) {
              return;
            }

            this._isItalic = value;
            this.updateRenderData();
          }
        }, {
          key: "isUnderline",
          get: function get() {
            return this._isUnderline;
          },
          set: function set(value) {
            if (this._isUnderline === value) {
              return;
            }

            this._isUnderline = value;
            this.updateRenderData();
          }
        }, {
          key: "underlineHeight",
          get: function get() {
            return this._underlineHeight;
          },
          set: function set(value) {
            if (this._underlineHeight === value) return;
            this._underlineHeight = value;
            this.updateRenderData();
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            return this._texture;
          }
        }, {
          key: "ttfSpriteFrame",
          get: function get() {
            return this._ttfSpriteFrame;
          }
        }, {
          key: "assemblerData",
          get: function get() {
            return this._assemblerData;
          }
        }, {
          key: "fontAtlas",
          get: function get() {
            return this._fontAtlas;
          },
          set: function set(value) {
            this._fontAtlas = value;
          }
        }, {
          key: "_bmFontOriginalSize",
          get: function get() {
            if (this._font instanceof BitmapFont) {
              return this._font.fontSize;
            } else {
              return -1;
            }
          }
        }]);

        return Label;
      }(Renderable2D), _class3$m.HorizontalAlign = HorizontalTextAlignment, _class3$m.VerticalAlign = VerticalTextAlignment, _class3$m.Overflow = Overflow, _class3$m.CacheMode = CacheMode, _class3$m._canvasPool = CanvasPool.getInstance(), _temp$V), (_applyDecoratedDescriptor(_class2$Q.prototype, "string", [_dec5$f, _dec6$c, multiline], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "string"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "horizontalAlign", [_dec7$a, _dec8$a, _dec9$8], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "horizontalAlign"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "verticalAlign", [_dec10$8, _dec11$6, _dec12$6], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "verticalAlign"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "fontSize", [_dec13$6, _dec14$6], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "fontSize"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "fontFamily", [_dec15$6, _dec16$6, _dec17$6], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "fontFamily"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "lineHeight", [_dec18$6, _dec19$6], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "lineHeight"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "spacingX", [_dec20$6, _dec21$6, _dec22$6], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "spacingX"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "overflow", [_dec23$6, _dec24$6, _dec25$6], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "overflow"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "enableWrapText", [_dec26$5, _dec27$5], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "enableWrapText"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "font", [_dec28$5, _dec29$5, _dec30$5, _dec31$5], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "font"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "useSystemFont", [_dec32$4, _dec33$3], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "useSystemFont"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "cacheMode", [_dec34$3, _dec35$3, _dec36$3], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "cacheMode"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "isBold", [_dec37$3, _dec38$3], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "isBold"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "isItalic", [_dec39$3, _dec40$3], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "isItalic"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "isUnderline", [_dec41$3, _dec42$3], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "isUnderline"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "underlineHeight", [_dec43$2, editable, _dec44$2, _dec45$2], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "underlineHeight"), _class2$Q.prototype), _descriptor$I = _applyDecoratedDescriptor(_class2$Q.prototype, "_string", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'label';
        }
      }), _descriptor2$t = _applyDecoratedDescriptor(_class2$Q.prototype, "_horizontalAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return HorizontalTextAlignment.CENTER;
        }
      }), _descriptor3$l = _applyDecoratedDescriptor(_class2$Q.prototype, "_verticalAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return VerticalTextAlignment.CENTER;
        }
      }), _descriptor4$i = _applyDecoratedDescriptor(_class2$Q.prototype, "_actualFontSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor5$d = _applyDecoratedDescriptor(_class2$Q.prototype, "_fontSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 40;
        }
      }), _descriptor6$7 = _applyDecoratedDescriptor(_class2$Q.prototype, "_fontFamily", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'Arial';
        }
      }), _descriptor7$7 = _applyDecoratedDescriptor(_class2$Q.prototype, "_lineHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 40;
        }
      }), _descriptor8$7 = _applyDecoratedDescriptor(_class2$Q.prototype, "_overflow", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Overflow.NONE;
        }
      }), _descriptor9$6 = _applyDecoratedDescriptor(_class2$Q.prototype, "_enableWrapText", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor10$6 = _applyDecoratedDescriptor(_class2$Q.prototype, "_font", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$5 = _applyDecoratedDescriptor(_class2$Q.prototype, "_isSystemFontUsed", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor12$5 = _applyDecoratedDescriptor(_class2$Q.prototype, "_spacingX", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor13$5 = _applyDecoratedDescriptor(_class2$Q.prototype, "_isItalic", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor14$5 = _applyDecoratedDescriptor(_class2$Q.prototype, "_isBold", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor15$4 = _applyDecoratedDescriptor(_class2$Q.prototype, "_isUnderline", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor16$4 = _applyDecoratedDescriptor(_class2$Q.prototype, "_underlineHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      }), _descriptor17$4 = _applyDecoratedDescriptor(_class2$Q.prototype, "_cacheMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return CacheMode.NONE;
        }
      })), _class2$Q)) || _class$_) || _class$_) || _class$_) || _class$_));
      legacyCC.Label = Label;

      var tabIndexUtil = function () {
        function tabIndexUtil() {}

        tabIndexUtil.add = function add(editBoxImpl) {
          var list = this._tabIndexList;
          var index = list.indexOf(editBoxImpl);

          if (index === -1) {
            list.push(editBoxImpl);
          }
        };

        tabIndexUtil.remove = function remove(editBoxImpl) {
          var list = this._tabIndexList;
          var index = list.indexOf(editBoxImpl);

          if (index !== -1) {
            list.splice(index, 1);
          }
        };

        tabIndexUtil.resort = function resort() {
          this._tabIndexList.sort(function (a, b) {
            return a._delegate.tabIndex - b._delegate.tabIndex;
          });
        };

        tabIndexUtil.next = function next(editBoxImpl) {
          var list = this._tabIndexList;
          var index = list.indexOf(editBoxImpl);
          editBoxImpl.setFocus(false);

          if (index !== -1) {
            var nextImpl = list[index + 1];

            if (nextImpl && nextImpl._delegate.tabIndex >= 0) {
              nextImpl.setFocus(true);
            }
          }
        };

        return tabIndexUtil;
      }();
      tabIndexUtil._tabIndexList = [];

      var KeyboardReturnType;

      (function (KeyboardReturnType) {
        KeyboardReturnType[KeyboardReturnType["DEFAULT"] = 0] = "DEFAULT";
        KeyboardReturnType[KeyboardReturnType["DONE"] = 1] = "DONE";
        KeyboardReturnType[KeyboardReturnType["SEND"] = 2] = "SEND";
        KeyboardReturnType[KeyboardReturnType["SEARCH"] = 3] = "SEARCH";
        KeyboardReturnType[KeyboardReturnType["GO"] = 4] = "GO";
        KeyboardReturnType[KeyboardReturnType["NEXT"] = 5] = "NEXT";
      })(KeyboardReturnType || (KeyboardReturnType = {}));

      Enum(KeyboardReturnType);
      var InputMode;

      (function (InputMode) {
        InputMode[InputMode["ANY"] = 0] = "ANY";
        InputMode[InputMode["EMAIL_ADDR"] = 1] = "EMAIL_ADDR";
        InputMode[InputMode["NUMERIC"] = 2] = "NUMERIC";
        InputMode[InputMode["PHONE_NUMBER"] = 3] = "PHONE_NUMBER";
        InputMode[InputMode["URL"] = 4] = "URL";
        InputMode[InputMode["DECIMAL"] = 5] = "DECIMAL";
        InputMode[InputMode["SINGLE_LINE"] = 6] = "SINGLE_LINE";
      })(InputMode || (InputMode = {}));

      Enum(InputMode);
      var InputFlag;

      (function (InputFlag) {
        InputFlag[InputFlag["PASSWORD"] = 0] = "PASSWORD";
        InputFlag[InputFlag["SENSITIVE"] = 1] = "SENSITIVE";
        InputFlag[InputFlag["INITIAL_CAPS_WORD"] = 2] = "INITIAL_CAPS_WORD";
        InputFlag[InputFlag["INITIAL_CAPS_SENTENCE"] = 3] = "INITIAL_CAPS_SENTENCE";
        InputFlag[InputFlag["INITIAL_CAPS_ALL_CHARACTERS"] = 4] = "INITIAL_CAPS_ALL_CHARACTERS";
        InputFlag[InputFlag["DEFAULT"] = 5] = "DEFAULT";
      })(InputFlag || (InputFlag = {}));

      Enum(InputFlag);

      var EditBoxImplBase = function () {
        function EditBoxImplBase() {
          this._editing = false;
          this._delegate = null;
        }

        var _proto = EditBoxImplBase.prototype;

        _proto.init = function init(delegate) {};

        _proto.onEnable = function onEnable() {};

        _proto.update = function update() {};

        _proto.onDisable = function onDisable() {
          if (this._editing) {
            this.endEditing();
          }
        };

        _proto.clear = function clear() {
          this._delegate = null;
        };

        _proto.setTabIndex = function setTabIndex(index) {};

        _proto.setSize = function setSize(width, height) {};

        _proto.setFocus = function setFocus(value) {
          if (value) {
            this.beginEditing();
          } else {
            this.endEditing();
          }
        };

        _proto.isFocused = function isFocused() {
          return this._editing;
        };

        _proto.beginEditing = function beginEditing() {};

        _proto.endEditing = function endEditing() {};

        return EditBoxImplBase;
      }();

      var SCROLLY = 40;
      var LEFT_PADDING = 2;
      var DELAY_TIME = 400;

      var _matrix$1 = new Mat4();

      var _matrix_temp = new Mat4();

      var _vec3$1 = new Vec3();

      var _currentEditBoxImpl = null;
      var _domCount = 0;
      var EditBoxImpl = function (_EditBoxImplBase) {
        _inheritsLoose(EditBoxImpl, _EditBoxImplBase);

        function EditBoxImpl() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _EditBoxImplBase.call.apply(_EditBoxImplBase, [this].concat(args)) || this;
          _this._delegate = null;
          _this._inputMode = -1;
          _this._inputFlag = -1;
          _this._returnType = -1;
          _this.__eventListeners = {};
          _this.__autoResize = false;
          _this.__orientationChanged = void 0;
          _this._edTxt = null;
          _this._isTextArea = false;
          _this._textLabelFont = null;
          _this._textLabelFontSize = null;
          _this._textLabelFontColor = null;
          _this._textLabelAlign = null;
          _this._placeholderLabelFont = null;
          _this._placeholderLabelFontSize = null;
          _this._placeholderLabelFontColor = null;
          _this._placeholderLabelAlign = null;
          _this._placeholderLineHeight = null;
          _this._placeholderStyleSheet = null;
          _this._domId = "EditBoxId_" + ++_domCount;
          return _this;
        }

        var _proto = EditBoxImpl.prototype;

        _proto.init = function init(delegate) {
          if (!delegate) {
            return;
          }

          this._delegate = delegate;

          if (delegate.inputMode === InputMode.ANY) {
            this._createTextArea();
          } else {
            this._createInput();
          }

          tabIndexUtil.add(this);
          this.setTabIndex(delegate.tabIndex);

          this._initStyleSheet();

          this._registerEventListeners();

          this._addDomToGameContainer();
        };

        _proto.clear = function clear() {
          this._removeEventListeners();

          this._removeDomFromGameContainer();

          tabIndexUtil.remove(this);

          if (_currentEditBoxImpl === this) {
            _currentEditBoxImpl = null;
          }

          this._delegate = null;
        };

        _proto.update = function update() {
          this._updateMatrix();
        };

        _proto.setTabIndex = function setTabIndex(index) {
          this._edTxt.tabIndex = index;
          tabIndexUtil.resort();
        };

        _proto.setSize = function setSize(width, height) {
          var elem = this._edTxt;

          if (elem) {
            elem.style.width = width + "px";
            elem.style.height = height + "px";
          }
        };

        _proto.beginEditing = function beginEditing() {
          if (_currentEditBoxImpl && _currentEditBoxImpl !== this) {
            _currentEditBoxImpl.setFocus(false);
          }

          this._editing = true;
          _currentEditBoxImpl = this;

          this._delegate._editBoxEditingDidBegan();

          this._showDom();

          this._edTxt.focus();
        };

        _proto.endEditing = function endEditing() {
          this._edTxt.blur();
        };

        _proto._createInput = function _createInput() {
          this._isTextArea = false;
          this._edTxt = document.createElement('input');
        };

        _proto._createTextArea = function _createTextArea() {
          this._isTextArea = true;
          this._edTxt = document.createElement('textarea');
        };

        _proto._addDomToGameContainer = function _addDomToGameContainer() {
          if (legacyCC.GAME_VIEW && this._edTxt) {
            legacyCC.gameView.container.appendChild(this._edTxt);
            legacyCC.gameView.head.appendChild(this._placeholderStyleSheet);
          } else if (game.container && this._edTxt) {
            game.container.appendChild(this._edTxt);
            document.head.appendChild(this._placeholderStyleSheet);
          }
        };

        _proto._removeDomFromGameContainer = function _removeDomFromGameContainer() {
          var hasElem = legacyCC.GAME_VIEW ? contains$1(legacyCC.gameView.container, this._edTxt) : contains$1(game.container, this._edTxt);

          if (hasElem && this._edTxt) {
            if (legacyCC.GAME_VIEW) {
              legacyCC.gameView.container.removeChild(this._edTxt);
            } else {
              game.container.removeChild(this._edTxt);
            }
          }

          var hasStyleSheet = legacyCC.GAME_VIEW ? contains$1(legacyCC.gameView.head, this._placeholderStyleSheet) : contains$1(document.head, this._placeholderStyleSheet);

          if (hasStyleSheet) {
            if (legacyCC.GAME_VIEW) {
              legacyCC.gameView.head.removeChild(this._placeholderStyleSheet);
            } else {
              document.head.removeChild(this._placeholderStyleSheet);
            }
          }

          this._edTxt = null;
          this._placeholderStyleSheet = null;
        };

        _proto._showDom = function _showDom() {
          this._updateMaxLength();

          this._updateInputType();

          this._updateStyleSheet();

          if (this._edTxt && this._delegate) {
            this._edTxt.style.display = '';

            this._delegate._hideLabels();
          }

          if (sys.isMobile) {
            this._showDomOnMobile();
          }
        };

        _proto._hideDom = function _hideDom() {
          var elem = this._edTxt;

          if (elem && this._delegate) {
            elem.style.display = 'none';

            this._delegate._showLabels();
          }

          if (sys.isMobile) {
            this._hideDomOnMobile();
          }
        };

        _proto._showDomOnMobile = function _showDomOnMobile() {
          if (sys.os !== OS.ANDROID && sys.os !== OS.OHOS) {
            return;
          }

          screenAdapter.handleResizeEvent = false;

          this._adjustWindowScroll();
        };

        _proto._hideDomOnMobile = function _hideDomOnMobile() {
          if (sys.os === OS.ANDROID || sys.os === OS.OHOS) {
            screenAdapter.handleResizeEvent = true;
          }

          this._scrollBackWindow();
        };

        _proto._adjustWindowScroll = function _adjustWindowScroll() {
          var _this2 = this;

          setTimeout(function () {
            if (window.scrollY < SCROLLY) {
              _this2._edTxt.scrollIntoView({
                block: 'start',
                inline: 'nearest',
                behavior: 'smooth'
              });
            }
          }, DELAY_TIME);
        };

        _proto._scrollBackWindow = function _scrollBackWindow() {
          setTimeout(function () {
            if (sys.browserType === BrowserType.WECHAT && sys.os === OS.IOS) {
              if (window.top) {
                window.top.scrollTo(0, 0);
              }

              return;
            }

            window.scrollTo(0, 0);
          }, DELAY_TIME);
        };

        _proto._updateMatrix = function _updateMatrix() {
          if (!this._edTxt) {
            return;
          }

          var node = this._delegate.node;
          var scaleX = view.getScaleX();
          var scaleY = view.getScaleY();
          var widthRatio = 1;
          var heightRatio = 1;

          if (legacyCC.GAME_VIEW) {
            widthRatio = legacyCC.gameView.canvas.width / legacyCC.game.canvas.width;
            heightRatio = legacyCC.gameView.canvas.height / legacyCC.game.canvas.height;
          }

          scaleX *= widthRatio;
          scaleY *= heightRatio;
          var viewport = view.getViewportRect();
          var dpr = screenAdapter.devicePixelRatio;
          node.getWorldMatrix(_matrix$1);
          var transform = node._uiProps.uiTransformComp;

          if (transform) {
            Vec3.set(_vec3$1, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3$1.z);
          }

          Mat4.transform(_matrix$1, _matrix$1, _vec3$1);

          if (!node._uiProps.uiTransformComp) {
            return;
          }

          var camera = director.root.batcher2D.getFirstRenderCamera(node);
          if (!camera) return;
          camera.node.getWorldRT(_matrix_temp);
          var m12 = _matrix_temp.m12;
          var m13 = _matrix_temp.m13;
          var center = visibleRect.center;
          _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13);
          _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13);
          Mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1);
          scaleX /= dpr;
          scaleY /= dpr;
          var container = legacyCC.GAME_VIEW ? legacyCC.gameView.container : game.container;
          var a = _matrix_temp.m00 * scaleX;
          var b = _matrix$1.m01;
          var c = _matrix$1.m04;
          var d = _matrix_temp.m05 * scaleY;
          var offsetX = parseInt(container && container.style.paddingLeft || '0');
          offsetX += viewport.x * widthRatio / dpr;
          var offsetY = parseInt(container && container.style.paddingBottom || '0');
          offsetY += viewport.y / dpr;
          var tx = _matrix_temp.m12 * scaleX + offsetX;
          var ty = _matrix_temp.m13 * scaleY + offsetY;
          var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
          this._edTxt.style.transform = matrix;
          this._edTxt.style['-webkit-transform'] = matrix;
          this._edTxt.style['transform-origin'] = '0px 100% 0px';
          this._edTxt.style['-webkit-transform-origin'] = '0px 100% 0px';
        };

        _proto._updateInputType = function _updateInputType() {
          var delegate = this._delegate;
          var inputMode = delegate.inputMode;
          var inputFlag = delegate.inputFlag;
          var returnType = delegate.returnType;
          var elem = this._edTxt;

          if (this._inputMode === inputMode && this._inputFlag === inputFlag && this._returnType === returnType) {
            return;
          }

          this._inputMode = inputMode;
          this._inputFlag = inputFlag;
          this._returnType = returnType;

          if (this._isTextArea) {
            var transform = 'none';

            if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
              transform = 'uppercase';
            } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
              transform = 'capitalize';
            }

            elem.style.textTransform = transform;
            return;
          }

          elem = elem;

          if (inputFlag === InputFlag.PASSWORD) {
            elem.type = 'password';
            elem.style.textTransform = 'none';
            return;
          }

          var type = elem.type;

          if (inputMode === InputMode.EMAIL_ADDR) {
            type = 'email';
          } else if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) {
            type = 'number';
          } else if (inputMode === InputMode.PHONE_NUMBER) {
            type = 'number';
            elem.pattern = '[0-9]*';
            elem.addEventListener('wheel', function () {
              return false;
            });
          } else if (inputMode === InputMode.URL) {
            type = 'url';
          } else {
            type = 'text';

            if (returnType === KeyboardReturnType.SEARCH) {
              type = 'search';
            }
          }

          elem.type = type;
          var textTransform = 'none';

          if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
            textTransform = 'uppercase';
          } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
            textTransform = 'capitalize';
          }

          elem.style.textTransform = textTransform;
        };

        _proto._updateMaxLength = function _updateMaxLength() {
          var maxLength = this._delegate.maxLength;

          if (maxLength < 0) {
            maxLength = 65535;
          }

          this._edTxt.maxLength = maxLength;
        };

        _proto._initStyleSheet = function _initStyleSheet() {
          if (!this._edTxt) {
            return;
          }

          var elem = this._edTxt;
          elem.style.color = '#000000';
          elem.style.border = '0px';
          elem.style.background = 'transparent';
          elem.style.width = '100%';
          elem.style.height = '100%';
          elem.style.outline = 'medium';
          elem.style.padding = '0';
          elem.style.textTransform = 'none';
          elem.style.display = 'none';
          elem.style.position = 'absolute';
          elem.style.bottom = '0px';
          elem.style.left = LEFT_PADDING + "px";
          elem.className = 'cocosEditBox';
          elem.style.fontFamily = 'Arial';
          elem.id = this._domId;

          if (!this._isTextArea) {
            elem = elem;
            elem.type = 'text';
            elem.style['-moz-appearance'] = 'textfield';
          } else {
            elem.style.resize = 'none';
            elem.style.overflowY = 'scroll';
          }

          this._placeholderStyleSheet = document.createElement('style');
        };

        _proto._updateStyleSheet = function _updateStyleSheet() {
          var delegate = this._delegate;
          var elem = this._edTxt;

          if (elem && delegate) {
            elem.value = delegate.string;

            this._updateTextLabel(delegate.textLabel);
          }
        };

        _proto._updateTextLabel = function _updateTextLabel(textLabel) {
          if (!textLabel) {
            return;
          }

          var font = textLabel.font;

          if (font && !(font instanceof BitmapFont)) {
            font = font._fontFamily;
          } else {
            font = textLabel.fontFamily;
          }

          var fontSize = textLabel.fontSize * textLabel.node.scale.y;

          if (this._textLabelFont === font && this._textLabelFontSize === fontSize && this._textLabelFontColor === textLabel.fontColor && this._textLabelAlign === textLabel.horizontalAlign) {
            return;
          }

          this._textLabelFont = font;
          this._textLabelFontSize = fontSize;
          this._textLabelFontColor = textLabel.fontColor;
          this._textLabelAlign = textLabel.horizontalAlign;

          if (!this._edTxt) {
            return;
          }

          var elem = this._edTxt;
          elem.style.fontSize = fontSize + "px";
          elem.style.color = textLabel.color.toCSS();
          elem.style.fontFamily = font;

          switch (textLabel.horizontalAlign) {
            case Label.HorizontalAlign.LEFT:
              elem.style.textAlign = 'left';
              break;

            case Label.HorizontalAlign.CENTER:
              elem.style.textAlign = 'center';
              break;

            case Label.HorizontalAlign.RIGHT:
              elem.style.textAlign = 'right';
              break;
          }
        };

        _proto._updatePlaceholderLabel = function _updatePlaceholderLabel(placeholderLabel) {
          if (!placeholderLabel) {
            return;
          }

          var font = placeholderLabel.font;

          if (font && !(font instanceof BitmapFont)) {
            font = placeholderLabel.font._fontFamily;
          } else {
            font = placeholderLabel.fontFamily;
          }

          var fontSize = placeholderLabel.fontSize * placeholderLabel.node.scale.y;

          if (this._placeholderLabelFont === font && this._placeholderLabelFontSize === fontSize && this._placeholderLabelFontColor === placeholderLabel.fontColor && this._placeholderLabelAlign === placeholderLabel.horizontalAlign && this._placeholderLineHeight === placeholderLabel.fontSize) {
            return;
          }

          this._placeholderLabelFont = font;
          this._placeholderLabelFontSize = fontSize;
          this._placeholderLabelFontColor = placeholderLabel.fontColor;
          this._placeholderLabelAlign = placeholderLabel.horizontalAlign;
          this._placeholderLineHeight = placeholderLabel.fontSize;
          var styleEl = this._placeholderStyleSheet;
          var fontColor = placeholderLabel.color.toCSS();
          var lineHeight = placeholderLabel.fontSize;
          var horizontalAlign = '';

          switch (placeholderLabel.horizontalAlign) {
            case Label.HorizontalAlign.LEFT:
              horizontalAlign = 'left';
              break;

            case Label.HorizontalAlign.CENTER:
              horizontalAlign = 'center';
              break;

            case Label.HorizontalAlign.RIGHT:
              horizontalAlign = 'right';
              break;
          }

          styleEl.innerHTML = "#" + this._domId + "::-webkit-input-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}" + ("#" + this._domId + "::-moz-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}") + ("#" + this._domId + "::-ms-input-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}");

          if (sys.browserType === BrowserType.EDGE) {
            styleEl.innerHTML += "#" + this._domId + "::-ms-clear{display: none;}";
          }
        };

        _proto._registerEventListeners = function _registerEventListeners() {
          var _this3 = this;

          if (!this._edTxt) {
            return;
          }

          var elem = this._edTxt;
          var inputLock = false;
          var cbs = this.__eventListeners;

          cbs.compositionStart = function () {
            inputLock = true;
          };

          cbs.compositionEnd = function () {
            inputLock = false;

            _this3._delegate._editBoxTextChanged(elem.value);
          };

          cbs.onInput = function () {
            if (inputLock) {
              return;
            }

            var delegate = _this3._delegate;
            var maxLength = delegate.maxLength;

            if (maxLength >= 0) {
              elem.value = elem.value.slice(0, maxLength);
            }

            delegate._editBoxTextChanged(elem.value);
          };

          cbs.onClick = function () {
            if (_this3._editing) {
              if (sys.isMobile) {
                _this3._adjustWindowScroll();
              }
            }
          };

          cbs.onKeydown = function (e) {
            if (e.keyCode === KeyCode.ENTER) {
              e.propagationStopped = true;

              _this3._delegate._editBoxEditingReturn();

              if (!_this3._isTextArea) {
                elem.blur();
              }
            } else if (e.keyCode === KeyCode.TAB) {
              e.propagationStopped = true;
              e.preventDefault();
              tabIndexUtil.next(_this3);
            }
          };

          cbs.onBlur = function () {
            if (sys.isMobile && inputLock) {
              cbs.compositionEnd();
            }

            _this3._editing = false;
            _currentEditBoxImpl = null;

            _this3._hideDom();

            _this3._delegate._editBoxEditingDidEnded();
          };

          elem.addEventListener('compositionstart', cbs.compositionStart);
          elem.addEventListener('compositionend', cbs.compositionEnd);
          elem.addEventListener('input', cbs.onInput);
          elem.addEventListener('keydown', cbs.onKeydown);
          elem.addEventListener('blur', cbs.onBlur);
          elem.addEventListener('touchstart', cbs.onClick);
        };

        _proto._removeEventListeners = function _removeEventListeners() {
          if (!this._edTxt) {
            return;
          }

          var elem = this._edTxt;
          var cbs = this.__eventListeners;
          elem.removeEventListener('compositionstart', cbs.compositionStart);
          elem.removeEventListener('compositionend', cbs.compositionEnd);
          elem.removeEventListener('input', cbs.onInput);
          elem.removeEventListener('keydown', cbs.onKeydown);
          elem.removeEventListener('blur', cbs.onBlur);
          elem.removeEventListener('touchstart', cbs.onClick);
          cbs.compositionStart = null;
          cbs.compositionEnd = null;
          cbs.onInput = null;
          cbs.onKeydown = null;
          cbs.onBlur = null;
          cbs.onClick = null;
        };

        return EditBoxImpl;
      }(EditBoxImplBase);

      var _dec$Z, _dec2$y, _dec3$s, _dec4$k, _dec5$g, _dec6$d, _dec7$b, _dec8$b, _dec9$9, _dec10$9, _dec11$7, _dec12$7, _dec13$7, _dec14$7, _dec15$7, _dec16$7, _dec17$7, _dec18$7, _dec19$7, _dec20$7, _dec21$7, _dec22$7, _dec23$7, _dec24$7, _dec25$7, _dec26$6, _dec27$6, _dec28$6, _dec29$6, _dec30$6, _dec31$6, _dec32$5, _dec33$4, _dec34$4, _dec35$4, _dec36$4, _dec37$4, _dec38$4, _dec39$4, _dec40$4, _dec41$4, _dec42$4, _dec43$3, _class$$, _class2$R, _descriptor$J, _descriptor2$u, _descriptor3$m, _descriptor4$j, _descriptor5$e, _descriptor6$8, _descriptor7$8, _descriptor8$8, _descriptor9$7, _descriptor10$7, _descriptor11$6, _descriptor12$6, _descriptor13$6, _class3$n, _temp$W;
      var LEFT_PADDING$1 = 2;

      function capitalize(str) {
        return str.replace(/(?:^|\s)\S/g, function (a) {
          return a.toUpperCase();
        });
      }

      function capitalizeFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }

      var EventType$2;

      (function (EventType) {
        EventType["EDITING_DID_BEGAN"] = "editing-did-began";
        EventType["EDITING_DID_ENDED"] = "editing-did-ended";
        EventType["TEXT_CHANGED"] = "text-changed";
        EventType["EDITING_RETURN"] = "editing-return";
      })(EventType$2 || (EventType$2 = {}));

      var EditBox = function (v) { return exports({ EditBox: v, EditBoxComponent: v }), v; }((_dec$Z = ccclass('cc.EditBox'), _dec2$y = help(), _dec3$s = executionOrder(110), _dec4$k = menu(), _dec5$g = requireComponent(UITransform), _dec6$d = displayOrder(), _dec7$b = tooltip(), _dec8$b = displayOrder(), _dec9$9 = tooltip(), _dec10$9 = type(Label), _dec11$7 = displayOrder(), _dec12$7 = tooltip(), _dec13$7 = type(Label), _dec14$7 = displayOrder(), _dec15$7 = tooltip(), _dec16$7 = type(SpriteFrame), _dec17$7 = displayOrder(), _dec18$7 = tooltip(), _dec19$7 = type(InputFlag), _dec20$7 = displayOrder(), _dec21$7 = tooltip(), _dec22$7 = type(InputMode), _dec23$7 = displayOrder(), _dec24$7 = tooltip(), _dec25$7 = type(KeyboardReturnType), _dec26$6 = displayOrder(), _dec27$6 = tooltip(), _dec28$6 = displayOrder(), _dec29$6 = tooltip(), _dec30$6 = displayOrder(), _dec31$6 = tooltip(), _dec32$5 = type([EventHandler]), _dec33$4 = displayOrder(), _dec34$4 = tooltip(), _dec35$4 = type([EventHandler]), _dec36$4 = displayOrder(), _dec37$4 = tooltip(), _dec38$4 = type([EventHandler]), _dec39$4 = displayOrder(), _dec40$4 = tooltip(), _dec41$4 = type([EventHandler]), _dec42$4 = displayOrder(), _dec43$3 = tooltip(), _dec$Z(_class$$ = _dec2$y(_class$$ = _dec3$s(_class$$ = _dec4$k(_class$$ = _dec5$g(_class$$ = executeInEditMode(_class$$ = (_class2$R = (_temp$W = _class3$n = function (_Component) {
        _inheritsLoose(EditBox, _Component);

        function EditBox() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "editingDidBegan", _descriptor$J, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "textChanged", _descriptor2$u, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "editingDidEnded", _descriptor3$m, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "editingReturn", _descriptor4$j, _assertThisInitialized(_this));

          _this._impl = null;
          _this._background = null;

          _initializerDefineProperty(_this, "_textLabel", _descriptor5$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_placeholderLabel", _descriptor6$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_returnType", _descriptor7$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_string", _descriptor8$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_tabIndex", _descriptor9$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_backgroundImage", _descriptor10$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_inputFlag", _descriptor11$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_inputMode", _descriptor12$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_maxLength", _descriptor13$6, _assertThisInitialized(_this));

          _this._isLabelVisible = false;
          return _this;
        }

        var _proto = EditBox.prototype;

        _proto.__preload = function __preload() {
          this._init();
        };

        _proto.onEnable = function onEnable() {
          {
            this._registerEvent();
          }

          this._ensureBackgroundSprite();

          if (this._impl) {
            this._impl.onEnable();
          }
        };

        _proto.update = function update() {
          if (this._impl) {
            this._impl.update();
          }
        };

        _proto.onDisable = function onDisable() {
          {
            this._unregisterEvent();
          }

          this._unregisterBackgroundEvent();

          if (this._impl) {
            this._impl.onDisable();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this._impl) {
            this._impl.clear();
          }
        };

        _proto.setFocus = function setFocus() {
          if (this._impl) {
            this._impl.setFocus(true);
          }
        };

        _proto.focus = function focus() {
          if (this._impl) {
            this._impl.setFocus(true);
          }
        };

        _proto.blur = function blur() {
          if (this._impl) {
            this._impl.setFocus(false);
          }
        };

        _proto.isFocused = function isFocused() {
          if (this._impl) {
            return this._impl.isFocused();
          }

          return false;
        };

        _proto._editBoxEditingDidBegan = function _editBoxEditingDidBegan() {
          EventHandler.emitEvents(this.editingDidBegan, this);
          this.node.emit(EventType$2.EDITING_DID_BEGAN, this);
        };

        _proto._editBoxEditingDidEnded = function _editBoxEditingDidEnded() {
          EventHandler.emitEvents(this.editingDidEnded, this);
          this.node.emit(EventType$2.EDITING_DID_ENDED, this);
        };

        _proto._editBoxTextChanged = function _editBoxTextChanged(text) {
          text = this._updateLabelStringStyle(text, true);
          this.string = text;
          EventHandler.emitEvents(this.textChanged, text, this);
          this.node.emit(EventType$2.TEXT_CHANGED, this);
        };

        _proto._editBoxEditingReturn = function _editBoxEditingReturn() {
          EventHandler.emitEvents(this.editingReturn, this);
          this.node.emit(EventType$2.EDITING_RETURN, this);
        };

        _proto._showLabels = function _showLabels() {
          this._isLabelVisible = true;

          this._updateLabels();
        };

        _proto._hideLabels = function _hideLabels() {
          this._isLabelVisible = false;

          if (this._textLabel) {
            this._textLabel.node.active = false;
          }

          if (this._placeholderLabel) {
            this._placeholderLabel.node.active = false;
          }
        };

        _proto._onTouchBegan = function _onTouchBegan(event) {
          event.propagationStopped = true;
        };

        _proto._onTouchCancel = function _onTouchCancel(event) {
          event.propagationStopped = true;
        };

        _proto._onTouchEnded = function _onTouchEnded(event) {
          if (this._impl) {
            this._impl.beginEditing();
          }

          event.propagationStopped = true;
        };

        _proto._init = function _init() {
          this._updatePlaceholderLabel();

          this._updateTextLabel();

          this._isLabelVisible = true;
          this.node.on(NodeEventType.SIZE_CHANGED, this._resizeChildNodes, this);
          var impl = this._impl = new EditBox._EditBoxImpl();
          impl.init(this);

          this._updateString(this._string);

          this._syncSize();
        };

        _proto._ensureBackgroundSprite = function _ensureBackgroundSprite() {
          if (!this._background) {
            var background = this.node.getComponent(Sprite);

            if (!background) {
              background = this.node.addComponent(Sprite);
            }

            if (background !== this._background) {
              background.type = Sprite.Type.SLICED;
              background.spriteFrame = this._backgroundImage;
              this._background = background;

              this._registerBackgroundEvent();
            }
          }
        };

        _proto._updateTextLabel = function _updateTextLabel() {
          var textLabel = this._textLabel;

          if (!textLabel) {
            var node = this.node.getChildByName('TEXT_LABEL');

            if (!node) {
              node = new Node$1('TEXT_LABEL');
              node.layer = this.node.layer;
            }

            textLabel = node.getComponent(Label);

            if (!textLabel) {
              textLabel = node.addComponent(Label);
            }

            node.parent = this.node;
            this._textLabel = textLabel;
          }

          var transformComp = this._textLabel.node._uiProps.uiTransformComp;
          transformComp.setAnchorPoint(0, 1);
          textLabel.overflow = Label.Overflow.CLAMP;

          if (this._inputMode === InputMode.ANY) {
            textLabel.verticalAlign = VerticalTextAlignment.TOP;
            textLabel.enableWrapText = true;
          } else {
            textLabel.enableWrapText = false;
          }

          textLabel.string = this._updateLabelStringStyle(this._string);
        };

        _proto._updatePlaceholderLabel = function _updatePlaceholderLabel() {
          var placeholderLabel = this._placeholderLabel;

          if (!placeholderLabel) {
            var node = this.node.getChildByName('PLACEHOLDER_LABEL');

            if (!node) {
              node = new Node$1('PLACEHOLDER_LABEL');
              node.layer = this.node.layer;
            }

            placeholderLabel = node.getComponent(Label);

            if (!placeholderLabel) {
              placeholderLabel = node.addComponent(Label);
            }

            node.parent = this.node;
            this._placeholderLabel = placeholderLabel;
          }

          var transform = this._placeholderLabel.node._uiProps.uiTransformComp;
          transform.setAnchorPoint(0, 1);

          if (this._inputMode === InputMode.ANY) {
            placeholderLabel.enableWrapText = true;
          } else {
            placeholderLabel.enableWrapText = false;
          }

          placeholderLabel.string = this.placeholder;
        };

        _proto._syncSize = function _syncSize() {
          var trans = this.node._uiProps.uiTransformComp;
          var size = trans.contentSize;

          if (this._background) {
            var bgTrans = this._background.node._uiProps.uiTransformComp;
            bgTrans.anchorPoint = trans.anchorPoint;
            bgTrans.setContentSize(size);
          }

          this._updateLabelPosition(size);

          if (this._impl) {
            this._impl.setSize(size.width, size.height);
          }
        };

        _proto._updateLabels = function _updateLabels() {
          if (this._isLabelVisible) {
            var content = this._string;

            if (this._textLabel) {
              this._textLabel.node.active = content !== '';
            }

            if (this._placeholderLabel) {
              this._placeholderLabel.node.active = content === '';
            }
          }
        };

        _proto._updateString = function _updateString(text) {
          var textLabel = this._textLabel;

          if (!textLabel) {
            return;
          }

          var displayText = text;

          if (displayText) {
            displayText = this._updateLabelStringStyle(displayText);
          }

          textLabel.string = displayText;

          this._updateLabels();
        };

        _proto._updateLabelStringStyle = function _updateLabelStringStyle(text, ignorePassword) {
          if (ignorePassword === void 0) {
            ignorePassword = false;
          }

          var inputFlag = this._inputFlag;

          if (!ignorePassword && inputFlag === InputFlag.PASSWORD) {
            var passwordString = '';
            var len = text.length;

            for (var i = 0; i < len; ++i) {
              passwordString += "\u25CF";
            }

            text = passwordString;
          } else if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
            text = text.toUpperCase();
          } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
            text = capitalize(text);
          } else if (inputFlag === InputFlag.INITIAL_CAPS_SENTENCE) {
            text = capitalizeFirstLetter(text);
          }

          return text;
        };

        _proto._registerEvent = function _registerEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        };

        _proto._unregisterEvent = function _unregisterEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        };

        _proto._onBackgroundSpriteFrameChanged = function _onBackgroundSpriteFrameChanged() {
          if (!this._background) {
            return;
          }

          this.backgroundImage = this._background.spriteFrame;
        };

        _proto._registerBackgroundEvent = function _registerBackgroundEvent() {
          var node = this._background && this._background.node;
          node === null || node === void 0 ? void 0 : node.on(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        };

        _proto._unregisterBackgroundEvent = function _unregisterBackgroundEvent() {
          var node = this._background && this._background.node;
          node === null || node === void 0 ? void 0 : node.off(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        };

        _proto._updateLabelPosition = function _updateLabelPosition(size) {
          var trans = this.node._uiProps.uiTransformComp;
          var offX = -trans.anchorX * trans.width;
          var offY = -trans.anchorY * trans.height;
          var placeholderLabel = this._placeholderLabel;
          var textLabel = this._textLabel;

          if (textLabel) {
            textLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

            textLabel.node.setPosition(offX + LEFT_PADDING$1, offY + size.height, textLabel.node.position.z);

            if (this._inputMode === InputMode.ANY) {
              textLabel.verticalAlign = VerticalTextAlignment.TOP;
            }

            textLabel.enableWrapText = this._inputMode === InputMode.ANY;
          }

          if (placeholderLabel) {
            placeholderLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

            placeholderLabel.lineHeight = size.height;
            placeholderLabel.node.setPosition(offX + LEFT_PADDING$1, offY + size.height, placeholderLabel.node.position.z);
            placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY;
          }
        };

        _proto._resizeChildNodes = function _resizeChildNodes() {
          var trans = this.node._uiProps.uiTransformComp;
          var textLabelNode = this._textLabel && this._textLabel.node;

          if (textLabelNode) {
            textLabelNode.setPosition(-trans.width / 2, trans.height / 2, textLabelNode.position.z);

            textLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }

          var placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;

          if (placeholderLabelNode) {
            placeholderLabelNode.setPosition(-trans.width / 2, trans.height / 2, placeholderLabelNode.position.z);

            placeholderLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }

          var backgroundNode = this._background && this._background.node;

          if (backgroundNode) {
            backgroundNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
          }

          this._syncSize();
        };

        _createClass(EditBox, [{
          key: "string",
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            if (this._maxLength >= 0 && value.length >= this._maxLength) {
              value = value.slice(0, this._maxLength);
            }

            if (this._string === value) {
              return;
            }

            this._string = value;

            this._updateString(value);
          }
        }, {
          key: "placeholder",
          get: function get() {
            if (!this._placeholderLabel) {
              return '';
            }

            return this._placeholderLabel.string;
          },
          set: function set(value) {
            if (this._placeholderLabel) {
              this._placeholderLabel.string = value;
            }
          }
        }, {
          key: "textLabel",
          get: function get() {
            return this._textLabel;
          },
          set: function set(oldValue) {
            if (this._textLabel !== oldValue) {
              this._textLabel = oldValue;

              if (this._textLabel) {
                this._updateTextLabel();

                this._updateLabels();
              }
            }
          }
        }, {
          key: "placeholderLabel",
          get: function get() {
            return this._placeholderLabel;
          },
          set: function set(oldValue) {
            if (this._placeholderLabel !== oldValue) {
              this._placeholderLabel = oldValue;

              if (this._placeholderLabel) {
                this._updatePlaceholderLabel();

                this._updateLabels();
              }
            }
          }
        }, {
          key: "backgroundImage",
          get: function get() {
            return this._backgroundImage;
          },
          set: function set(value) {
            if (this._backgroundImage === value) {
              return;
            }

            this._backgroundImage = value;

            this._ensureBackgroundSprite();

            this._background.spriteFrame = value;
          }
        }, {
          key: "inputFlag",
          get: function get() {
            return this._inputFlag;
          },
          set: function set(value) {
            if (this._inputFlag === value) {
              return;
            }

            this._inputFlag = value;

            this._updateString(this._string);
          }
        }, {
          key: "inputMode",
          get: function get() {
            return this._inputMode;
          },
          set: function set(oldValue) {
            if (this._inputMode !== oldValue) {
              this._inputMode = oldValue;

              this._updateTextLabel();

              this._updatePlaceholderLabel();
            }
          }
        }, {
          key: "returnType",
          get: function get() {
            return this._returnType;
          },
          set: function set(value) {
            this._returnType = value;
          }
        }, {
          key: "maxLength",
          get: function get() {
            return this._maxLength;
          },
          set: function set(value) {
            this._maxLength = value;
          }
        }, {
          key: "tabIndex",
          get: function get() {
            return this._tabIndex;
          },
          set: function set(value) {
            if (this._tabIndex !== value) {
              this._tabIndex = value;

              if (this._impl) {
                this._impl.setTabIndex(value);
              }
            }
          }
        }]);

        return EditBox;
      }(Component), _class3$n._EditBoxImpl = EditBoxImplBase, _class3$n.KeyboardReturnType = KeyboardReturnType, _class3$n.InputFlag = InputFlag, _class3$n.InputMode = InputMode, _class3$n.EventType = EventType$2, _temp$W), (_applyDecoratedDescriptor(_class2$R.prototype, "string", [_dec6$d, _dec7$b], Object.getOwnPropertyDescriptor(_class2$R.prototype, "string"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "placeholder", [_dec8$b, _dec9$9], Object.getOwnPropertyDescriptor(_class2$R.prototype, "placeholder"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "textLabel", [_dec10$9, _dec11$7, _dec12$7], Object.getOwnPropertyDescriptor(_class2$R.prototype, "textLabel"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "placeholderLabel", [_dec13$7, _dec14$7, _dec15$7], Object.getOwnPropertyDescriptor(_class2$R.prototype, "placeholderLabel"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "backgroundImage", [_dec16$7, _dec17$7, _dec18$7], Object.getOwnPropertyDescriptor(_class2$R.prototype, "backgroundImage"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "inputFlag", [_dec19$7, _dec20$7, _dec21$7], Object.getOwnPropertyDescriptor(_class2$R.prototype, "inputFlag"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "inputMode", [_dec22$7, _dec23$7, _dec24$7], Object.getOwnPropertyDescriptor(_class2$R.prototype, "inputMode"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "returnType", [_dec25$7, _dec26$6, _dec27$6], Object.getOwnPropertyDescriptor(_class2$R.prototype, "returnType"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "maxLength", [_dec28$6, _dec29$6], Object.getOwnPropertyDescriptor(_class2$R.prototype, "maxLength"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "tabIndex", [_dec30$6, _dec31$6], Object.getOwnPropertyDescriptor(_class2$R.prototype, "tabIndex"), _class2$R.prototype), _descriptor$J = _applyDecoratedDescriptor(_class2$R.prototype, "editingDidBegan", [_dec32$5, serializable, _dec33$4, _dec34$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$u = _applyDecoratedDescriptor(_class2$R.prototype, "textChanged", [_dec35$4, serializable, _dec36$4, _dec37$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3$m = _applyDecoratedDescriptor(_class2$R.prototype, "editingDidEnded", [_dec38$4, serializable, _dec39$4, _dec40$4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor4$j = _applyDecoratedDescriptor(_class2$R.prototype, "editingReturn", [_dec41$4, serializable, _dec42$4, _dec43$3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor5$e = _applyDecoratedDescriptor(_class2$R.prototype, "_textLabel", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6$8 = _applyDecoratedDescriptor(_class2$R.prototype, "_placeholderLabel", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7$8 = _applyDecoratedDescriptor(_class2$R.prototype, "_returnType", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return KeyboardReturnType.DEFAULT;
        }
      }), _descriptor8$8 = _applyDecoratedDescriptor(_class2$R.prototype, "_string", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor9$7 = _applyDecoratedDescriptor(_class2$R.prototype, "_tabIndex", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor10$7 = _applyDecoratedDescriptor(_class2$R.prototype, "_backgroundImage", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$6 = _applyDecoratedDescriptor(_class2$R.prototype, "_inputFlag", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return InputFlag.DEFAULT;
        }
      }), _descriptor12$6 = _applyDecoratedDescriptor(_class2$R.prototype, "_inputMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return InputMode.ANY;
        }
      }), _descriptor13$6 = _applyDecoratedDescriptor(_class2$R.prototype, "_maxLength", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 20;
        }
      })), _class2$R)) || _class$$) || _class$$) || _class$$) || _class$$) || _class$$) || _class$$));

      if (typeof window === 'object' && typeof document === 'object' && !MINIGAME && !JSB && !RUNTIME_BASED) {
        EditBox._EditBoxImpl = EditBoxImpl;
      }

      legacyCC.internal.EditBox = EditBox;

      var _dec$_, _dec2$z, _dec3$t, _dec4$l, _dec5$h, _dec6$e, _dec7$c, _dec8$c, _dec9$a, _dec10$a, _dec11$8, _dec12$8, _dec13$8, _dec14$8, _dec15$8, _dec16$8, _dec17$8, _dec18$8, _dec19$8, _dec20$8, _dec21$8, _dec22$8, _dec23$8, _dec24$8, _dec25$8, _dec26$7, _dec27$7, _dec28$7, _dec29$7, _dec30$7, _dec31$7, _dec32$6, _dec33$5, _dec34$5, _dec35$5, _class$10, _class2$S, _descriptor$K, _descriptor2$v, _descriptor3$n, _descriptor4$k, _descriptor5$f, _descriptor6$9, _descriptor7$9, _descriptor8$9, _descriptor9$8, _descriptor10$8, _descriptor11$7, _descriptor12$7, _descriptor13$7, _descriptor14$6, _descriptor15$5, _descriptor16$5, _class3$o, _temp$X;
      var Type$1;

      (function (Type) {
        Type[Type["NONE"] = 0] = "NONE";
        Type[Type["HORIZONTAL"] = 1] = "HORIZONTAL";
        Type[Type["VERTICAL"] = 2] = "VERTICAL";
        Type[Type["GRID"] = 3] = "GRID";
      })(Type$1 || (Type$1 = {}));

      ccenum(Type$1);
      var ResizeMode;

      (function (ResizeMode) {
        ResizeMode[ResizeMode["NONE"] = 0] = "NONE";
        ResizeMode[ResizeMode["CONTAINER"] = 1] = "CONTAINER";
        ResizeMode[ResizeMode["CHILDREN"] = 2] = "CHILDREN";
      })(ResizeMode || (ResizeMode = {}));

      ccenum(ResizeMode);
      var AxisDirection;

      (function (AxisDirection) {
        AxisDirection[AxisDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
        AxisDirection[AxisDirection["VERTICAL"] = 1] = "VERTICAL";
      })(AxisDirection || (AxisDirection = {}));

      ccenum(AxisDirection);
      var VerticalDirection;

      (function (VerticalDirection) {
        VerticalDirection[VerticalDirection["BOTTOM_TO_TOP"] = 0] = "BOTTOM_TO_TOP";
        VerticalDirection[VerticalDirection["TOP_TO_BOTTOM"] = 1] = "TOP_TO_BOTTOM";
      })(VerticalDirection || (VerticalDirection = {}));

      ccenum(VerticalDirection);
      var HorizontalDirection;

      (function (HorizontalDirection) {
        HorizontalDirection[HorizontalDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
        HorizontalDirection[HorizontalDirection["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
      })(HorizontalDirection || (HorizontalDirection = {}));

      ccenum(HorizontalDirection);
      var Constraint;

      (function (Constraint) {
        Constraint[Constraint["NONE"] = 0] = "NONE";
        Constraint[Constraint["FIXED_ROW"] = 1] = "FIXED_ROW";
        Constraint[Constraint["FIXED_COL"] = 2] = "FIXED_COL";
      })(Constraint || (Constraint = {}));

      ccenum(Constraint);

      var _tempVec3$1 = new Vec3();

      var Layout = function (v) { return exports({ Layout: v, LayoutComponent: v }), v; }((_dec$_ = ccclass('cc.Layout'), _dec2$z = help(), _dec3$t = executionOrder(110), _dec4$l = menu(), _dec5$h = requireComponent(UITransform), _dec6$e = visible(), _dec7$c = tooltip(), _dec8$c = visible(), _dec9$a = tooltip(), _dec10$a = type(Type$1), _dec11$8 = displayOrder(), _dec12$8 = tooltip(), _dec13$8 = type(ResizeMode), _dec14$8 = visible(), _dec15$8 = tooltip(), _dec16$8 = visible(), _dec17$8 = tooltip(), _dec18$8 = type(AxisDirection), _dec19$8 = tooltip(), _dec20$8 = tooltip(), _dec21$8 = tooltip(), _dec22$8 = tooltip(), _dec23$8 = tooltip(), _dec24$8 = tooltip(), _dec25$8 = tooltip(), _dec26$7 = type(VerticalDirection), _dec27$7 = tooltip(), _dec28$7 = type(HorizontalDirection), _dec29$7 = tooltip(), _dec30$7 = type(Constraint), _dec31$7 = visible(), _dec32$6 = tooltip(), _dec33$5 = visible(), _dec34$5 = tooltip(), _dec35$5 = tooltip(), _dec$_(_class$10 = _dec2$z(_class$10 = _dec3$t(_class$10 = _dec4$l(_class$10 = _dec5$h(_class$10 = executeInEditMode(_class$10 = (_class2$S = (_temp$X = _class3$o = function (_Component) {
        _inheritsLoose(Layout, _Component);

        function Layout() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_resizeMode", _descriptor$K, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_layoutType", _descriptor2$v, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cellSize", _descriptor3$n, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_startAxis", _descriptor4$k, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_paddingLeft", _descriptor5$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_paddingRight", _descriptor6$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_paddingTop", _descriptor7$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_paddingBottom", _descriptor8$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spacingX", _descriptor9$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spacingY", _descriptor10$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalDirection", _descriptor11$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalDirection", _descriptor12$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_constraint", _descriptor13$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_constraintNum", _descriptor14$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_affectedByScale", _descriptor15$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAlign", _descriptor16$5, _assertThisInitialized(_this));

          _this._layoutSize = new Size(300, 200);
          _this._layoutDirty = true;
          _this._childrenDirty = false;
          _this._usefulLayoutObj = [];
          _this._init = false;
          return _this;
        }

        var _proto = Layout.prototype;

        _proto.updateLayout = function updateLayout(force) {
          if (force === void 0) {
            force = false;
          }

          if ((this._layoutDirty || force) && this.node.children.length > 0) {
            this._doLayout();

            this._layoutDirty = false;
          }
        };

        _proto.onEnable = function onEnable() {
          this._addEventListeners();

          var trans = this.node._uiProps.uiTransformComp;

          if (trans.contentSize.equals(Size.ZERO)) {
            trans.setContentSize(this._layoutSize);
          }

          this._childrenChanged();
        };

        _proto.onDisable = function onDisable() {
          this._usefulLayoutObj.length = 0;

          this._removeEventListeners();
        };

        _proto._checkUsefulObj = function _checkUsefulObj() {
          this._usefulLayoutObj.length = 0;
          var children = this.node.children;

          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            var uiTrans = child._uiProps.uiTransformComp;

            if (child.activeInHierarchy && uiTrans) {
              this._usefulLayoutObj.push(uiTrans);
            }
          }
        };

        _proto._addEventListeners = function _addEventListeners() {
          director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._resized, this);
          this.node.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          this.node.on(NodeEventType.CHILD_ADDED, this._childAdded, this);
          this.node.on(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
          this.node.on(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
          this.node.on('childrenSiblingOrderChanged', this.updateLayout, this);

          this._addChildrenEventListeners();
        };

        _proto._removeEventListeners = function _removeEventListeners() {
          director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._resized, this);
          this.node.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          this.node.off(NodeEventType.CHILD_ADDED, this._childAdded, this);
          this.node.off(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
          this.node.off(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
          this.node.off('childrenSiblingOrderChanged', this.updateLayout, this);

          this._removeChildrenEventListeners();
        };

        _proto._addChildrenEventListeners = function _addChildrenEventListeners() {
          var children = this.node.children;

          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
            child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
            child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
            child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        };

        _proto._removeChildrenEventListeners = function _removeChildrenEventListeners() {
          var children = this.node.children;

          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
            child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
            child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
            child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        };

        _proto._childAdded = function _childAdded(child) {
          child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
          child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);

          this._childrenChanged();
        };

        _proto._childRemoved = function _childRemoved(child) {
          child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
          child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);

          this._childrenChanged();
        };

        _proto._resized = function _resized() {
          this._layoutSize.set(this.node._uiProps.uiTransformComp.contentSize);

          this._doLayoutDirty();
        };

        _proto._doLayoutHorizontally = function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
          var trans = this.node._uiProps.uiTransformComp;
          var layoutAnchor = trans.anchorPoint;

          var limit = this._getFixedBreakingNum();

          var sign = 1;
          var paddingX = this._paddingLeft;

          if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            paddingX = this._paddingRight;
          }

          var startPos = (this._horizontalDirection - layoutAnchor.x) * baseWidth + sign * paddingX;
          var nextX = startPos - sign * this._spacingX;
          var totalHeight = 0;
          var rowMaxHeight = 0;
          var tempMaxHeight = 0;
          var maxHeight = 0;
          var isBreak = false;
          var activeChildCount = this._usefulLayoutObj.length;
          var newChildWidth = this._cellSize.width;

          var paddingH = this._getPaddingH();

          if (this._layoutType !== Type$1.GRID && this._resizeMode === ResizeMode.CHILDREN) {
            newChildWidth = (baseWidth - paddingH - (activeChildCount - 1) * this._spacingX) / activeChildCount;
          }

          var children = this._usefulLayoutObj;

          for (var i = 0; i < children.length; ++i) {
            var childTrans = children[i];
            var child = childTrans.node;
            var scale = child.scale;

            var childScaleX = this._getUsedScaleValue(scale.x);

            var childScaleY = this._getUsedScaleValue(scale.y);

            if (this._resizeMode === ResizeMode.CHILDREN) {
              childTrans.width = newChildWidth / childScaleX;

              if (this._layoutType === Type$1.GRID) {
                childTrans.height = this._cellSize.height / childScaleY;
              }
            }

            var anchorX = Math.abs(this._horizontalDirection - childTrans.anchorX);
            var childBoundingBoxWidth = childTrans.width * childScaleX;
            var childBoundingBoxHeight = childTrans.height * childScaleY;

            if (childBoundingBoxHeight > tempMaxHeight) {
              maxHeight = Math.max(tempMaxHeight, maxHeight);
              rowMaxHeight = tempMaxHeight || childBoundingBoxHeight;
              tempMaxHeight = childBoundingBoxHeight;
            }

            nextX += sign * (anchorX * childBoundingBoxWidth + this._spacingX);
            var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;

            if (rowBreak) {
              if (limit > 0) {
                isBreak = i / limit > 0 && i % limit === 0;

                if (isBreak) {
                  rowMaxHeight = tempMaxHeight > childBoundingBoxHeight ? tempMaxHeight : rowMaxHeight;
                }
              } else if (childBoundingBoxWidth > baseWidth - paddingH) {
                if (nextX > startPos + sign * (anchorX * childBoundingBoxWidth)) {
                  isBreak = true;
                }
              } else {
                var boundary = (1 - this._horizontalDirection - layoutAnchor.x) * baseWidth;
                var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft);
                isBreak = Math.abs(rowBreakBoundary) > Math.abs(boundary);
              }

              if (isBreak) {
                nextX = startPos + sign * (anchorX * childBoundingBoxWidth);

                if (childBoundingBoxHeight !== tempMaxHeight) {
                  rowMaxHeight = tempMaxHeight;
                }

                totalHeight += rowMaxHeight + this._spacingY;
                rowMaxHeight = tempMaxHeight = childBoundingBoxHeight;
              }
            }

            var finalPositionY = fnPositionY(child, childTrans, totalHeight);

            if (applyChildren) {
              child.setPosition(nextX, finalPositionY);
            }

            nextX += rightBoundaryOfChild;
          }

          rowMaxHeight = Math.max(rowMaxHeight, tempMaxHeight);

          var containerResizeBoundary = Math.max(maxHeight, totalHeight + rowMaxHeight) + this._getPaddingV();

          return containerResizeBoundary;
        };

        _proto._doLayoutVertically = function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
          var trans = this.node._uiProps.uiTransformComp;
          var layoutAnchor = trans.anchorPoint;

          var limit = this._getFixedBreakingNum();

          var sign = 1;
          var paddingY = this._paddingBottom;

          if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            paddingY = this._paddingTop;
          }

          var startPos = (this._verticalDirection - layoutAnchor.y) * baseHeight + sign * paddingY;
          var nextY = startPos - sign * this._spacingY;
          var tempMaxWidth = 0;
          var maxWidth = 0;
          var colMaxWidth = 0;
          var totalWidth = 0;
          var isBreak = false;
          var activeChildCount = this._usefulLayoutObj.length;
          var newChildHeight = this._cellSize.height;

          var paddingV = this._getPaddingV();

          if (this._layoutType !== Type$1.GRID && this._resizeMode === ResizeMode.CHILDREN) {
            newChildHeight = (baseHeight - paddingV - (activeChildCount - 1) * this._spacingY) / activeChildCount;
          }

          var children = this._usefulLayoutObj;

          for (var i = 0; i < children.length; ++i) {
            var childTrans = children[i];
            var child = childTrans.node;
            var scale = child.scale;

            var childScaleX = this._getUsedScaleValue(scale.x);

            var childScaleY = this._getUsedScaleValue(scale.y);

            if (this._resizeMode === ResizeMode.CHILDREN) {
              childTrans.height = newChildHeight / childScaleY;

              if (this._layoutType === Type$1.GRID) {
                childTrans.width = this._cellSize.width / childScaleX;
              }
            }

            var anchorY = Math.abs(this._verticalDirection - childTrans.anchorY);
            var childBoundingBoxWidth = childTrans.width * childScaleX;
            var childBoundingBoxHeight = childTrans.height * childScaleY;

            if (childBoundingBoxWidth > tempMaxWidth) {
              maxWidth = Math.max(tempMaxWidth, maxWidth);
              colMaxWidth = tempMaxWidth || childBoundingBoxWidth;
              tempMaxWidth = childBoundingBoxWidth;
            }

            nextY += sign * (anchorY * childBoundingBoxHeight + this._spacingY);
            var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;

            if (columnBreak) {
              if (limit > 0) {
                isBreak = i / limit > 0 && i % limit === 0;

                if (isBreak) {
                  colMaxWidth = tempMaxWidth > childBoundingBoxHeight ? tempMaxWidth : colMaxWidth;
                }
              } else if (childBoundingBoxHeight > baseHeight - paddingV) {
                if (nextY > startPos + sign * (anchorY * childBoundingBoxHeight)) {
                  isBreak = true;
                }
              } else {
                var boundary = (1 - this._verticalDirection - layoutAnchor.y) * baseHeight;
                var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom);
                isBreak = Math.abs(columnBreakBoundary) > Math.abs(boundary);
              }

              if (isBreak) {
                nextY = startPos + sign * (anchorY * childBoundingBoxHeight);

                if (childBoundingBoxWidth !== tempMaxWidth) {
                  colMaxWidth = tempMaxWidth;
                }

                totalWidth += colMaxWidth + this._spacingX;
                colMaxWidth = tempMaxWidth = childBoundingBoxWidth;
              }
            }

            var finalPositionX = fnPositionX(child, childTrans, totalWidth);

            if (applyChildren) {
              child.getPosition(_tempVec3$1);
              child.setPosition(finalPositionX, nextY, _tempVec3$1.z);
            }

            nextY += topBoundaryOfChild;
          }

          colMaxWidth = Math.max(colMaxWidth, tempMaxWidth);

          var containerResizeBoundary = Math.max(maxWidth, totalWidth + colMaxWidth) + this._getPaddingH();

          return containerResizeBoundary;
        };

        _proto._doLayoutGridAxisHorizontal = function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
          var _this2 = this;

          var baseWidth = layoutSize.width;
          var sign = 1;
          var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
          var paddingY = this._paddingBottom;

          if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
            paddingY = this._paddingTop;
          }

          var fnPositionY = function fnPositionY(child, childTrans, topOffset) {
            return bottomBoundaryOfLayout + sign * (topOffset + (1 - childTrans.anchorY) * childTrans.height * _this2._getUsedScaleValue(child.scale.y) + paddingY);
          };

          var newHeight = 0;

          if (this._resizeMode === ResizeMode.CONTAINER) {
            newHeight = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
            bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;

            if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
              sign = -1;
              bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
            }
          }

          this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);

          if (this._resizeMode === ResizeMode.CONTAINER) {
            this.node._uiProps.uiTransformComp.setContentSize(baseWidth, newHeight);
          }
        };

        _proto._doLayoutGridAxisVertical = function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
          var _this3 = this;

          var baseHeight = layoutSize.height;
          var sign = 1;
          var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
          var paddingX = this._paddingLeft;

          if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
            paddingX = this._paddingRight;
          }

          var fnPositionX = function fnPositionX(child, childTrans, leftOffset) {
            return leftBoundaryOfLayout + sign * (leftOffset + (1 - childTrans.anchorX) * childTrans.width * _this3._getUsedScaleValue(child.scale.x) + paddingX);
          };

          var newWidth = 0;

          if (this._resizeMode === ResizeMode.CONTAINER) {
            newWidth = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
            leftBoundaryOfLayout = -layoutAnchor.x * newWidth;

            if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
              sign = -1;
              leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
            }
          }

          this._doLayoutVertically(baseHeight, true, fnPositionX, true);

          if (this._resizeMode === ResizeMode.CONTAINER) {
            this.node._uiProps.uiTransformComp.setContentSize(newWidth, baseHeight);
          }
        };

        _proto._doLayoutGrid = function _doLayoutGrid() {
          var trans = this.node._uiProps.uiTransformComp;
          var layoutAnchor = trans.anchorPoint;
          var layoutSize = trans.contentSize;

          if (this.startAxis === AxisDirection.HORIZONTAL) {
            this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize);
          } else if (this.startAxis === AxisDirection.VERTICAL) {
            this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
          }
        };

        _proto._getHorizontalBaseWidth = function _getHorizontalBaseWidth(horizontal) {

          var children = this._usefulLayoutObj;
          var baseSize = 0;
          var activeChildCount = children.length;

          if (this._resizeMode === ResizeMode.CONTAINER) {
            for (var i = 0; i < children.length; ++i) {
              var childTrans = children[i];
              var child = childTrans.node;
              var scale = child.scale;
              baseSize += childTrans.width * this._getUsedScaleValue(scale.x);
            }

            baseSize += (activeChildCount - 1) * this._spacingX + this._getPaddingH();
          } else {
            baseSize = this.node._uiProps.uiTransformComp.width;
          }

          return baseSize;
        };

        _proto._getVerticalBaseHeight = function _getVerticalBaseHeight() {
          var children = this._usefulLayoutObj;
          var baseSize = 0;
          var activeChildCount = children.length;

          if (this._resizeMode === ResizeMode.CONTAINER) {
            for (var i = 0; i < children.length; ++i) {
              var childTrans = children[i];
              var child = childTrans.node;
              var scale = child.scale;
              baseSize += childTrans.height * this._getUsedScaleValue(scale.y);
            }

            baseSize += (activeChildCount - 1) * this._spacingY + this._getPaddingV();
          } else {
            baseSize = this.node._uiProps.uiTransformComp.height;
          }

          return baseSize;
        };

        _proto._doLayout = function _doLayout() {
          var _this4 = this;

          if (!this._init || this._childrenDirty) {
            this._checkUsefulObj();

            this._init = true;
            this._childrenDirty = false;
          }

          if (this._layoutType === Type$1.HORIZONTAL) {
            var newWidth = this._getHorizontalBaseWidth();

            var fnPositionY = function fnPositionY(child) {
              var pos = _this4._isAlign ? Vec3.ZERO : child.position;
              return pos.y;
            };

            this._doLayoutHorizontally(newWidth, false, fnPositionY, true);

            this.node._uiProps.uiTransformComp.width = newWidth;
          } else if (this._layoutType === Type$1.VERTICAL) {
            var newHeight = this._getVerticalBaseHeight();

            var fnPositionX = function fnPositionX(child) {
              var pos = _this4._isAlign ? Vec3.ZERO : child.position;
              return pos.x;
            };

            this._doLayoutVertically(newHeight, false, fnPositionX, true);

            this.node._uiProps.uiTransformComp.height = newHeight;
          } else if (this._layoutType === Type$1.GRID) {
            this._doLayoutGrid();
          }
        };

        _proto._getUsedScaleValue = function _getUsedScaleValue(value) {
          return this._affectedByScale ? Math.abs(value) : 1;
        };

        _proto._transformDirty = function _transformDirty(type) {
          if (!(type & TransformBit.SCALE) || !(type & TransformBit.POSITION) || !this._affectedByScale) {
            return;
          }

          this._doLayoutDirty();
        };

        _proto._doLayoutDirty = function _doLayoutDirty() {
          this._layoutDirty = true;
        };

        _proto._childrenChanged = function _childrenChanged() {
          this._childrenDirty = true;

          this._doLayoutDirty();
        };

        _proto._getPaddingH = function _getPaddingH() {
          return this._paddingLeft + this._paddingRight;
        };

        _proto._getPaddingV = function _getPaddingV() {
          return this._paddingTop + this._paddingBottom;
        };

        _proto._getFixedBreakingNum = function _getFixedBreakingNum() {
          if (this._layoutType !== Type$1.GRID || this._constraint === Constraint.NONE || this._constraintNum <= 0) {
            return 0;
          }

          var num = this._constraint === Constraint.FIXED_ROW ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;

          if (this._startAxis === AxisDirection.VERTICAL) {
            num = this._constraint === Constraint.FIXED_COL ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
          }

          return num;
        };

        _createClass(Layout, [{
          key: "alignHorizontal",
          get: function get() {
            return this._isAlign;
          },
          set: function set(value) {
            if (this._layoutType !== Type$1.HORIZONTAL) {
              return;
            }

            this._isAlign = value;

            this._doLayoutDirty();
          }
        }, {
          key: "alignVertical",
          get: function get() {
            return this._isAlign;
          },
          set: function set(value) {
            if (this._layoutType !== Type$1.VERTICAL) {
              return;
            }

            this._isAlign = value;

            this._doLayoutDirty();
          }
        }, {
          key: "type",
          get: function get() {
            return this._layoutType;
          },
          set: function set(value) {
            this._layoutType = value;

            this._doLayoutDirty();
          }
        }, {
          key: "resizeMode",
          get: function get() {
            return this._resizeMode;
          },
          set: function set(value) {
            if (this._layoutType === Type$1.NONE) {
              return;
            }

            this._resizeMode = value;

            this._doLayoutDirty();
          }
        }, {
          key: "cellSize",
          get: function get() {
            return this._cellSize;
          },
          set: function set(value) {
            if (this._cellSize === value) {
              return;
            }

            this._cellSize.set(value);

            this._doLayoutDirty();
          }
        }, {
          key: "startAxis",
          get: function get() {
            return this._startAxis;
          },
          set: function set(value) {
            if (this._startAxis === value) {
              return;
            }

            this._startAxis = value;

            this._doLayoutDirty();
          }
        }, {
          key: "paddingLeft",
          get: function get() {
            return this._paddingLeft;
          },
          set: function set(value) {
            if (this._paddingLeft === value) {
              return;
            }

            this._paddingLeft = value;

            this._doLayoutDirty();
          }
        }, {
          key: "paddingRight",
          get: function get() {
            return this._paddingRight;
          },
          set: function set(value) {
            if (this._paddingRight === value) {
              return;
            }

            this._paddingRight = value;

            this._doLayoutDirty();
          }
        }, {
          key: "paddingTop",
          get: function get() {
            return this._paddingTop;
          },
          set: function set(value) {
            if (this._paddingTop === value) {
              return;
            }

            this._paddingTop = value;

            this._doLayoutDirty();
          }
        }, {
          key: "paddingBottom",
          get: function get() {
            return this._paddingBottom;
          },
          set: function set(value) {
            if (this._paddingBottom === value) {
              return;
            }

            this._paddingBottom = value;

            this._doLayoutDirty();
          }
        }, {
          key: "spacingX",
          get: function get() {
            return this._spacingX;
          },
          set: function set(value) {
            if (this._spacingX === value) {
              return;
            }

            this._spacingX = value;

            this._doLayoutDirty();
          }
        }, {
          key: "spacingY",
          get: function get() {
            return this._spacingY;
          },
          set: function set(value) {
            if (this._spacingY === value) {
              return;
            }

            this._spacingY = value;

            this._doLayoutDirty();
          }
        }, {
          key: "verticalDirection",
          get: function get() {
            return this._verticalDirection;
          },
          set: function set(value) {
            if (this._verticalDirection === value) {
              return;
            }

            this._verticalDirection = value;

            this._doLayoutDirty();
          }
        }, {
          key: "horizontalDirection",
          get: function get() {
            return this._horizontalDirection;
          },
          set: function set(value) {
            if (this._horizontalDirection === value) {
              return;
            }

            this._horizontalDirection = value;

            this._doLayoutDirty();
          }
        }, {
          key: "padding",
          get: function get() {
            return this._paddingLeft;
          },
          set: function set(value) {
            if (this.paddingLeft !== value || this._paddingRight !== value || this._paddingTop !== value || this._paddingBottom !== value) {
              this._paddingLeft = this._paddingRight = this._paddingTop = this._paddingBottom = value;

              this._doLayoutDirty();
            }
          }
        }, {
          key: "constraint",
          get: function get() {
            return this._constraint;
          },
          set: function set(value) {
            if (this._layoutType === Type$1.NONE || this._constraint === value) {
              return;
            }

            this._constraint = value;

            this._doLayoutDirty();
          }
        }, {
          key: "constraintNum",
          get: function get() {
            return this._constraintNum;
          },
          set: function set(value) {
            if (this._constraint === Constraint.NONE || this._constraintNum === value) {
              return;
            }

            if (value <= 0) {
              warn('Limit values to be greater than 0');
            }

            this._constraintNum = value;

            this._doLayoutDirty();
          }
        }, {
          key: "affectedByScale",
          get: function get() {
            return this._affectedByScale;
          },
          set: function set(value) {
            this._affectedByScale = value;

            this._doLayoutDirty();
          }
        }]);

        return Layout;
      }(Component), _class3$o.Type = Type$1, _class3$o.VerticalDirection = VerticalDirection, _class3$o.HorizontalDirection = HorizontalDirection, _class3$o.ResizeMode = ResizeMode, _class3$o.AxisDirection = AxisDirection, _class3$o.Constraint = Constraint, _temp$X), (_applyDecoratedDescriptor(_class2$S.prototype, "alignHorizontal", [_dec6$e, _dec7$c], Object.getOwnPropertyDescriptor(_class2$S.prototype, "alignHorizontal"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "alignVertical", [_dec8$c, _dec9$a], Object.getOwnPropertyDescriptor(_class2$S.prototype, "alignVertical"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "type", [_dec10$a, _dec11$8, _dec12$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "type"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "resizeMode", [_dec13$8, _dec14$8, _dec15$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "resizeMode"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "cellSize", [_dec16$8, _dec17$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "cellSize"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "startAxis", [_dec18$8, _dec19$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "startAxis"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "paddingLeft", [_dec20$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "paddingLeft"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "paddingRight", [_dec21$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "paddingRight"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "paddingTop", [_dec22$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "paddingTop"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "paddingBottom", [_dec23$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "paddingBottom"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "spacingX", [_dec24$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "spacingX"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "spacingY", [_dec25$8], Object.getOwnPropertyDescriptor(_class2$S.prototype, "spacingY"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "verticalDirection", [_dec26$7, _dec27$7], Object.getOwnPropertyDescriptor(_class2$S.prototype, "verticalDirection"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "horizontalDirection", [_dec28$7, _dec29$7], Object.getOwnPropertyDescriptor(_class2$S.prototype, "horizontalDirection"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "constraint", [_dec30$7, _dec31$7, _dec32$6], Object.getOwnPropertyDescriptor(_class2$S.prototype, "constraint"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "constraintNum", [_dec33$5, _dec34$5], Object.getOwnPropertyDescriptor(_class2$S.prototype, "constraintNum"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "affectedByScale", [_dec35$5], Object.getOwnPropertyDescriptor(_class2$S.prototype, "affectedByScale"), _class2$S.prototype), _descriptor$K = _applyDecoratedDescriptor(_class2$S.prototype, "_resizeMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ResizeMode.NONE;
        }
      }), _descriptor2$v = _applyDecoratedDescriptor(_class2$S.prototype, "_layoutType", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Type$1.NONE;
        }
      }), _descriptor3$n = _applyDecoratedDescriptor(_class2$S.prototype, "_cellSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Size(40, 40);
        }
      }), _descriptor4$k = _applyDecoratedDescriptor(_class2$S.prototype, "_startAxis", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return AxisDirection.HORIZONTAL;
        }
      }), _descriptor5$f = _applyDecoratedDescriptor(_class2$S.prototype, "_paddingLeft", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor6$9 = _applyDecoratedDescriptor(_class2$S.prototype, "_paddingRight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$9 = _applyDecoratedDescriptor(_class2$S.prototype, "_paddingTop", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor8$9 = _applyDecoratedDescriptor(_class2$S.prototype, "_paddingBottom", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor9$8 = _applyDecoratedDescriptor(_class2$S.prototype, "_spacingX", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor10$8 = _applyDecoratedDescriptor(_class2$S.prototype, "_spacingY", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor11$7 = _applyDecoratedDescriptor(_class2$S.prototype, "_verticalDirection", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return VerticalDirection.TOP_TO_BOTTOM;
        }
      }), _descriptor12$7 = _applyDecoratedDescriptor(_class2$S.prototype, "_horizontalDirection", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return HorizontalDirection.LEFT_TO_RIGHT;
        }
      }), _descriptor13$7 = _applyDecoratedDescriptor(_class2$S.prototype, "_constraint", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Constraint.NONE;
        }
      }), _descriptor14$6 = _applyDecoratedDescriptor(_class2$S.prototype, "_constraintNum", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      }), _descriptor15$5 = _applyDecoratedDescriptor(_class2$S.prototype, "_affectedByScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor16$5 = _applyDecoratedDescriptor(_class2$S.prototype, "_isAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2$S)) || _class$10) || _class$10) || _class$10) || _class$10) || _class$10) || _class$10));
      legacyCC.Layout = Layout;

      var _dec$$, _dec2$A, _dec3$u, _dec4$m, _dec5$i, _dec6$f, _dec7$d, _dec8$d, _dec9$b, _dec10$b, _dec11$9, _dec12$9, _dec13$9, _class$11, _class2$T, _descriptor$L, _descriptor2$w, _descriptor3$o, _descriptor4$l, _descriptor5$g, _class3$p, _temp$Y;
      var Mode;

      (function (Mode) {
        Mode[Mode["HORIZONTAL"] = 0] = "HORIZONTAL";
        Mode[Mode["VERTICAL"] = 1] = "VERTICAL";
        Mode[Mode["FILLED"] = 2] = "FILLED";
      })(Mode || (Mode = {}));

      Enum(Mode);
      var ProgressBar = function (v) { return exports({ ProgressBar: v, ProgressBarComponent: v }), v; }((_dec$$ = ccclass('cc.ProgressBar'), _dec2$A = help(), _dec3$u = executionOrder(110), _dec4$m = menu(), _dec5$i = requireComponent(UITransform), _dec6$f = type(Sprite), _dec7$d = tooltip(), _dec8$d = type(Mode), _dec9$b = tooltip(), _dec10$b = tooltip(), _dec11$9 = range(), _dec12$9 = tooltip(), _dec13$9 = tooltip(), _dec$$(_class$11 = _dec2$A(_class$11 = _dec3$u(_class$11 = _dec4$m(_class$11 = _dec5$i(_class$11 = (_class2$T = (_temp$Y = _class3$p = function (_Component) {
        _inheritsLoose(ProgressBar, _Component);

        function ProgressBar() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_barSprite", _descriptor$L, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_mode", _descriptor2$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_totalLength", _descriptor3$o, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_progress", _descriptor4$l, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_reverse", _descriptor5$g, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = ProgressBar.prototype;

        _proto._initBarSprite = function _initBarSprite() {
          if (this._barSprite) {
            var entity = this._barSprite.node;

            if (!entity) {
              return;
            }

            var trans = this.node._uiProps.uiTransformComp;
            var nodeSize = trans.contentSize;
            var nodeAnchor = trans.anchorPoint;
            var barSpriteSize = entity._uiProps.uiTransformComp.contentSize;

            if (this._barSprite.fillType === Sprite.FillType.RADIAL) {
              this._mode = Mode.FILLED;
            }

            if (this._mode === Mode.HORIZONTAL) {
              this.totalLength = barSpriteSize.width;
            } else if (this._mode === Mode.VERTICAL) {
              this.totalLength = barSpriteSize.height;
            } else {
              this.totalLength = this._barSprite.fillRange;
            }

            if (entity.parent === this.node) {
              var x = -nodeSize.width * nodeAnchor.x;
              entity.setPosition(x, 0, 0);
            }
          }
        };

        _proto._updateBarStatus = function _updateBarStatus() {
          if (this._barSprite) {
            var entity = this._barSprite.node;

            if (!entity) {
              return;
            }

            var entTrans = entity._uiProps.uiTransformComp;
            var entityAnchorPoint = entTrans.anchorPoint;
            var entitySize = entTrans.contentSize;
            var entityPosition = entity.getPosition();
            var anchorPoint = new Vec2(0, 0.5);
            var progress = clamp01(this._progress);
            var actualLenth = this._totalLength * progress;
            var finalContentSize = entitySize;
            var totalWidth = 0;
            var totalHeight = 0;

            switch (this._mode) {
              case Mode.HORIZONTAL:
                if (this._reverse) {
                  anchorPoint = new Vec2(1, 0.5);
                }

                finalContentSize = new Size(actualLenth, entitySize.height);
                totalWidth = this._totalLength;
                totalHeight = entitySize.height;
                break;

              case Mode.VERTICAL:
                if (this._reverse) {
                  anchorPoint = new Vec2(0.5, 1);
                } else {
                  anchorPoint = new Vec2(0.5, 0);
                }

                finalContentSize = new Size(entitySize.width, actualLenth);
                totalWidth = entitySize.width;
                totalHeight = this._totalLength;
                break;
            }

            if (this._mode === Mode.FILLED) {
              if (this._barSprite.type !== Sprite.Type.FILLED) {
                warn('ProgressBar FILLED mode only works when barSprite\'s Type is FILLED!');
              } else {
                if (this._reverse) {
                  actualLenth *= -1;
                }

                this._barSprite.fillRange = actualLenth;
              }
            } else if (this._barSprite.type !== Sprite.Type.FILLED) {
              var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
              var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
              var finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
              entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z);
              entTrans.setAnchorPoint(anchorPoint);
              entTrans.setContentSize(finalContentSize);
            } else {
              warn('ProgressBar non-FILLED mode only works when barSprite\'s Type is non-FILLED!');
            }
          }
        };

        _createClass(ProgressBar, [{
          key: "barSprite",
          get: function get() {
            return this._barSprite;
          },
          set: function set(value) {
            if (this._barSprite === value) {
              return;
            }

            this._barSprite = value;

            this._initBarSprite();
          }
        }, {
          key: "mode",
          get: function get() {
            return this._mode;
          },
          set: function set(value) {
            if (this._mode === value) {
              return;
            }

            this._mode = value;

            if (this._barSprite) {
              var entity = this._barSprite.node;

              if (!entity) {
                return;
              }

              var entitySize = entity._uiProps.uiTransformComp.contentSize;

              if (this._mode === Mode.HORIZONTAL) {
                this.totalLength = entitySize.width;
              } else if (this._mode === Mode.VERTICAL) {
                this.totalLength = entitySize.height;
              } else if (this._mode === Mode.FILLED) {
                this.totalLength = this._barSprite.fillRange;
              }
            }
          }
        }, {
          key: "totalLength",
          get: function get() {
            return this._totalLength;
          },
          set: function set(value) {
            if (this._mode === Mode.FILLED) {
              value = clamp01(value);
            }

            if (this._totalLength === value) {
              return;
            }

            this._totalLength = value;

            this._updateBarStatus();
          }
        }, {
          key: "progress",
          get: function get() {
            return this._progress;
          },
          set: function set(value) {
            if (this._progress === value) {
              return;
            }

            this._progress = value;

            this._updateBarStatus();
          }
        }, {
          key: "reverse",
          get: function get() {
            return this._reverse;
          },
          set: function set(value) {
            if (this._reverse === value) {
              return;
            }

            this._reverse = value;

            if (this._barSprite) {
              this._barSprite.fillStart = 1 - this._barSprite.fillStart;
            }

            this._updateBarStatus();
          }
        }]);

        return ProgressBar;
      }(Component), _class3$p.Mode = Mode, _temp$Y), (_applyDecoratedDescriptor(_class2$T.prototype, "barSprite", [_dec6$f, _dec7$d], Object.getOwnPropertyDescriptor(_class2$T.prototype, "barSprite"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "mode", [_dec8$d, _dec9$b], Object.getOwnPropertyDescriptor(_class2$T.prototype, "mode"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "totalLength", [_dec10$b], Object.getOwnPropertyDescriptor(_class2$T.prototype, "totalLength"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "progress", [_dec11$9, slide, _dec12$9], Object.getOwnPropertyDescriptor(_class2$T.prototype, "progress"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "reverse", [_dec13$9], Object.getOwnPropertyDescriptor(_class2$T.prototype, "reverse"), _class2$T.prototype), _descriptor$L = _applyDecoratedDescriptor(_class2$T.prototype, "_barSprite", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$w = _applyDecoratedDescriptor(_class2$T.prototype, "_mode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Mode.HORIZONTAL;
        }
      }), _descriptor3$o = _applyDecoratedDescriptor(_class2$T.prototype, "_totalLength", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor4$l = _applyDecoratedDescriptor(_class2$T.prototype, "_progress", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor5$g = _applyDecoratedDescriptor(_class2$T.prototype, "_reverse", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2$T)) || _class$11) || _class$11) || _class$11) || _class$11) || _class$11));
      legacyCC.ProgressBar = ProgressBar;

      var _dec$10, _dec2$B, _dec3$v, _dec4$n, _dec5$j, _dec6$g, _dec7$e, _dec8$e, _dec9$c, _dec10$c, _dec11$a, _dec12$a, _dec13$a, _dec14$9, _dec15$9, _class$12, _class2$U, _descriptor$M, _descriptor2$x, _descriptor3$p, _descriptor4$m, _descriptor5$h, _class3$q, _temp$Z;
      var GETTING_SHORTER_FACTOR = 20;

      var _tempPos_1 = new Vec3();

      var _tempPos_2 = new Vec3();

      var _tempVec3$2 = new Vec3();

      var defaultAnchor = new Vec2();

      var _tempColor$1 = new Color();

      var _tempVec2 = new Vec2();

      var Direction;

      (function (Direction) {
        Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
        Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
      })(Direction || (Direction = {}));

      ccenum(Direction);
      var ScrollBar = function (v) { return exports({ ScrollBar: v, ScrollBarComponent: v }), v; }((_dec$10 = ccclass('cc.ScrollBar'), _dec2$B = help(), _dec3$v = executionOrder(110), _dec4$n = menu(), _dec5$j = requireComponent(UITransform), _dec6$g = type(Sprite), _dec7$e = displayOrder(), _dec8$e = tooltip(), _dec9$c = type(Direction), _dec10$c = displayOrder(), _dec11$a = tooltip(), _dec12$a = displayOrder(), _dec13$a = tooltip(), _dec14$9 = displayOrder(), _dec15$9 = tooltip(), _dec$10(_class$12 = _dec2$B(_class$12 = _dec3$v(_class$12 = _dec4$n(_class$12 = _dec5$j(_class$12 = (_class2$U = (_temp$Z = _class3$q = function (_Component) {
        _inheritsLoose(ScrollBar, _Component);

        function ScrollBar() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_scrollView", _descriptor$M, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_handle", _descriptor2$x, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor3$p, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_enableAutoHide", _descriptor4$m, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_autoHideTime", _descriptor5$h, _assertThisInitialized(_this));

          _this._touching = false;
          _this._opacity = 255;
          _this._autoHideRemainingTime = 0;
          return _this;
        }

        var _proto = ScrollBar.prototype;

        _proto.hide = function hide() {
          this._autoHideRemainingTime = 0;

          this._setOpacity(0);
        };

        _proto.show = function show() {
          this._autoHideRemainingTime = this._autoHideTime;

          this._setOpacity(this._opacity);
        };

        _proto.onScroll = function onScroll(outOfBoundary) {
          if (!this._scrollView) {
            return;
          }

          var content = this._scrollView.content;

          if (!content) {
            return;
          }

          var contentSize = content._uiProps.uiTransformComp.contentSize;
          var scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;
          var barSize = this.node._uiProps.uiTransformComp.contentSize;

          if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
            return;
          }

          if (this._enableAutoHide) {
            this._autoHideRemainingTime = this._autoHideTime;

            this._setOpacity(this._opacity);
          }

          var contentMeasure = 0;
          var scrollViewMeasure = 0;
          var outOfBoundaryValue = 0;
          var contentPosition = 0;
          var handleNodeMeasure = 0;
          var outOfContentPosition = _tempVec2;
          outOfContentPosition.set(0, 0);

          if (this._direction === Direction.HORIZONTAL) {
            contentMeasure = contentSize.width;
            scrollViewMeasure = scrollViewSize.width;
            handleNodeMeasure = barSize.width;
            outOfBoundaryValue = outOfBoundary.x;

            this._convertToScrollViewSpace(outOfContentPosition, content);

            contentPosition = -outOfContentPosition.x;
          } else if (this._direction === Direction.VERTICAL) {
            contentMeasure = contentSize.height;
            scrollViewMeasure = scrollViewSize.height;
            handleNodeMeasure = barSize.height;
            outOfBoundaryValue = outOfBoundary.y;

            this._convertToScrollViewSpace(outOfContentPosition, content);

            contentPosition = -outOfContentPosition.y;
          }

          var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);

          var position = _tempVec2;

          this._calculatePosition(position, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);

          this._updateLength(length);

          this._updateHandlerPosition(position);
        };

        _proto.setScrollView = function setScrollView(scrollView) {
          this._scrollView = scrollView;
        };

        _proto.onTouchBegan = function onTouchBegan() {
          if (!this._enableAutoHide) {
            return;
          }

          this._touching = true;
        };

        _proto.onTouchEnded = function onTouchEnded() {
          if (!this._enableAutoHide) {
            return;
          }

          this._touching = false;

          if (this._autoHideTime <= 0) {
            return;
          }

          if (this._scrollView) {
            var content = this._scrollView.content;

            if (content) {
              var contentSize = content._uiProps.uiTransformComp.contentSize;
              var scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;

              if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                return;
              }
            }
          }

          this._autoHideRemainingTime = this._autoHideTime;
        };

        _proto.onEnable = function onEnable() {
          var renderComp = this.node.getComponent(Sprite);

          if (renderComp) {
            this._opacity = renderComp.color.a;
          }
        };

        _proto.start = function start() {
          if (this._enableAutoHide) {
            this._setOpacity(0);
          }
        };

        _proto.update = function update(dt) {
          this._processAutoHide(dt);
        };

        _proto._convertToScrollViewSpace = function _convertToScrollViewSpace(out, content) {
          var scrollTrans = this._scrollView && this._scrollView.node._uiProps.uiTransformComp;
          var contentTrans = content._uiProps.uiTransformComp;

          if (!scrollTrans || !contentTrans) {
            out.set(Vec2.ZERO);
          } else {
            _tempPos_1.set(-contentTrans.anchorX * contentTrans.width, -contentTrans.anchorY * contentTrans.height, 0);

            contentTrans.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
            var scrollViewSpacePos = scrollTrans.convertToNodeSpaceAR(_tempPos_2);
            scrollViewSpacePos.x += scrollTrans.anchorX * scrollTrans.width;
            scrollViewSpacePos.y += scrollTrans.anchorY * scrollTrans.height;
            out.set(scrollViewSpacePos.x, scrollViewSpacePos.y);
          }
        };

        _proto._setOpacity = function _setOpacity(opacity) {
          if (this._handle) {
            var renderComp = this.node.getComponent(Sprite);

            if (renderComp) {
              _tempColor$1.set(renderComp.color);

              _tempColor$1.a = opacity;
              renderComp.color = _tempColor$1;
            }

            renderComp = this._handle.getComponent(Sprite);

            if (renderComp) {
              _tempColor$1.set(renderComp.color);

              _tempColor$1.a = opacity;
              renderComp.color = _tempColor$1;
            }
          }
        };

        _proto._updateHandlerPosition = function _updateHandlerPosition(position) {
          if (this._handle) {
            var oldPosition = _tempVec3$2;

            this._fixupHandlerPosition(oldPosition);

            this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
          }
        };

        _proto._fixupHandlerPosition = function _fixupHandlerPosition(out) {
          var uiTrans = this.node._uiProps.uiTransformComp;
          var barSize = uiTrans.contentSize;
          var barAnchor = uiTrans.anchorPoint;
          var handleSize = this.handle.node._uiProps.uiTransformComp.contentSize;
          var handleParent = this.handle.node.parent;
          Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);

          var leftBottomWorldPosition = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);

          var fixupPosition = out;
          fixupPosition.set(0, 0, 0);

          handleParent._uiProps.uiTransformComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition);

          if (this.direction === Direction.HORIZONTAL) {
            fixupPosition.set(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, fixupPosition.z);
          } else if (this.direction === Direction.VERTICAL) {
            fixupPosition.set(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, fixupPosition.z);
          }

          this.handle.node.setPosition(fixupPosition);
        };

        _proto._conditionalDisableScrollBar = function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
          if (contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL) {
            return true;
          }

          if (contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL) {
            return true;
          }

          return false;
        };

        _proto._calculateLength = function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
          var denominatorValue = contentMeasure;

          if (outOfBoundary) {
            denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTING_SHORTER_FACTOR;
          }

          var lengthRation = scrollViewMeasure / denominatorValue;
          return handleNodeMeasure * lengthRation;
        };

        _proto._calculatePosition = function _calculatePosition(out, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
          var denominatorValue = contentMeasure - scrollViewMeasure;

          if (outOfBoundary) {
            denominatorValue += Math.abs(outOfBoundary);
          }

          var positionRatio = 0;

          if (denominatorValue) {
            positionRatio = contentPosition / denominatorValue;
            positionRatio = clamp01(positionRatio);
          }

          var position = (handleNodeMeasure - actualLenth) * positionRatio;

          if (this._direction === Direction.VERTICAL) {
            out.set(0, position);
          } else {
            out.set(position, 0);
          }
        };

        _proto._updateLength = function _updateLength(length) {
          if (this._handle) {
            var handleNode = this._handle.node;
            var handleTrans = handleNode._uiProps.uiTransformComp;
            var handleNodeSize = handleTrans.contentSize;
            var anchor = handleTrans.anchorPoint;

            if (anchor.x !== defaultAnchor.x || anchor.y !== defaultAnchor.y) {
              handleTrans.setAnchorPoint(defaultAnchor);
            }

            if (this._direction === Direction.HORIZONTAL) {
              handleTrans.setContentSize(length, handleNodeSize.height);
            } else {
              handleTrans.setContentSize(handleNodeSize.width, length);
            }
          }
        };

        _proto._processAutoHide = function _processAutoHide(deltaTime) {
          if (!this._enableAutoHide || this._autoHideRemainingTime <= 0) {
            return;
          } else if (this._touching) {
            return;
          }

          this._autoHideRemainingTime -= deltaTime;

          if (this._autoHideRemainingTime <= this._autoHideTime) {
            this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
            var opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);

            this._setOpacity(opacity);
          }
        };

        _createClass(ScrollBar, [{
          key: "handle",
          get: function get() {
            return this._handle;
          },
          set: function set(value) {
            if (this._handle === value) {
              return;
            }

            this._handle = value;
            this.onScroll(Vec2.ZERO);
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) {
              return;
            }

            this._direction = value;
            this.onScroll(Vec2.ZERO);
          }
        }, {
          key: "enableAutoHide",
          get: function get() {
            return this._enableAutoHide;
          },
          set: function set(value) {
            if (this._enableAutoHide === value) {
              return;
            }

            this._enableAutoHide = value;

            if (this._enableAutoHide) {
              this._setOpacity(0);
            }
          }
        }, {
          key: "autoHideTime",
          get: function get() {
            return this._autoHideTime;
          },
          set: function set(value) {
            if (this._autoHideTime === value) {
              return;
            }

            this._autoHideTime = value;
          }
        }]);

        return ScrollBar;
      }(Component), _class3$q.Direction = Direction, _temp$Z), (_applyDecoratedDescriptor(_class2$U.prototype, "handle", [_dec6$g, _dec7$e, _dec8$e], Object.getOwnPropertyDescriptor(_class2$U.prototype, "handle"), _class2$U.prototype), _applyDecoratedDescriptor(_class2$U.prototype, "direction", [_dec9$c, _dec10$c, _dec11$a], Object.getOwnPropertyDescriptor(_class2$U.prototype, "direction"), _class2$U.prototype), _applyDecoratedDescriptor(_class2$U.prototype, "enableAutoHide", [_dec12$a, _dec13$a], Object.getOwnPropertyDescriptor(_class2$U.prototype, "enableAutoHide"), _class2$U.prototype), _applyDecoratedDescriptor(_class2$U.prototype, "autoHideTime", [_dec14$9, _dec15$9], Object.getOwnPropertyDescriptor(_class2$U.prototype, "autoHideTime"), _class2$U.prototype), _descriptor$M = _applyDecoratedDescriptor(_class2$U.prototype, "_scrollView", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2$x = _applyDecoratedDescriptor(_class2$U.prototype, "_handle", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$p = _applyDecoratedDescriptor(_class2$U.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Direction.HORIZONTAL;
        }
      }), _descriptor4$m = _applyDecoratedDescriptor(_class2$U.prototype, "_enableAutoHide", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor5$h = _applyDecoratedDescriptor(_class2$U.prototype, "_autoHideTime", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.0;
        }
      })), _class2$U)) || _class$12) || _class$12) || _class$12) || _class$12) || _class$12));
      legacyCC.ScrollBar = ScrollBar;

      var _dec$11, _dec2$C, _class$13;
      var ViewGroup = exports('ViewGroup', (_dec$11 = ccclass('cc.ViewGroup'), _dec2$C = executionOrder(110), _dec$11(_class$13 = _dec2$C(_class$13 = function (_Component) {
        _inheritsLoose(ViewGroup, _Component);

        function ViewGroup() {
          return _Component.apply(this, arguments) || this;
        }

        return ViewGroup;
      }(Component)) || _class$13) || _class$13));
      legacyCC.ViewGroup = ViewGroup;

      var _dec$12, _dec2$D, _dec3$w, _dec4$o, _dec5$k, _dec6$h, _dec7$f, _dec8$f, _dec9$d, _dec10$d, _dec11$b, _dec12$b, _dec13$b, _dec14$a, _dec15$a, _dec16$9, _dec17$9, _dec18$9, _dec19$9, _dec20$9, _dec21$9, _dec22$9, _dec23$9, _dec24$9, _dec25$9, _dec26$8, _dec27$8, _dec28$8, _dec29$8, _dec30$8, _dec31$8, _dec32$7, _dec33$6, _class$14, _class2$V, _descriptor$N, _descriptor2$y, _descriptor3$q, _descriptor4$n, _descriptor5$i, _descriptor6$a, _descriptor7$a, _descriptor8$a, _descriptor9$9, _descriptor10$9, _descriptor11$8, _class3$r, _temp$_;
      var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
      var OUT_OF_BOUNDARY_BREAKING_FACTOR = 0.05;
      var EPSILON$1 = 1e-4;
      var TOLERANCE = 1e4;
      var MOVEMENT_FACTOR = 0.7;

      var _tempVec3$3 = new Vec3();

      var _tempVec3_1 = new Vec3();

      var _tempVec2$1 = new Vec2();

      var _tempVec2_1 = new Vec2();

      var quintEaseOut = function quintEaseOut(time) {
        time -= 1;
        return time * time * time * time * time + 1;
      };

      var getTimeInMilliseconds = function getTimeInMilliseconds() {
        var currentTime = new Date();
        return currentTime.getMilliseconds();
      };

      var eventMap = {
        'scroll-to-top': 0,
        'scroll-to-bottom': 1,
        'scroll-to-left': 2,
        'scroll-to-right': 3,
        scrolling: 4,
        'bounce-bottom': 6,
        'bounce-left': 7,
        'bounce-right': 8,
        'bounce-top': 5,
        'scroll-ended': 9,
        'touch-up': 10,
        'scroll-ended-with-threshold': 11,
        'scroll-began': 12
      };
      var EventType$3;

      (function (EventType) {
        EventType["SCROLL_TO_TOP"] = "scroll-to-top";
        EventType["SCROLL_TO_BOTTOM"] = "scroll-to-bottom";
        EventType["SCROLL_TO_LEFT"] = "scroll-to-left";
        EventType["SCROLL_TO_RIGHT"] = "scroll-to-right";
        EventType["SCROLL_BEGAN"] = "scroll-began";
        EventType["SCROLL_ENDED"] = "scroll-ended";
        EventType["BOUNCE_TOP"] = "bounce-top";
        EventType["BOUNCE_BOTTOM"] = "bounce-bottom";
        EventType["BOUNCE_LEFT"] = "bounce-left";
        EventType["BOUNCE_RIGHT"] = "bounce-right";
        EventType["SCROLLING"] = "scrolling";
        EventType["SCROLL_ENG_WITH_THRESHOLD"] = "scroll-ended-with-threshold";
        EventType["TOUCH_UP"] = "touch-up";
      })(EventType$3 || (EventType$3 = {}));

      var ScrollView = function (v) { return exports({ ScrollView: v, ScrollViewComponent: v }), v; }((_dec$12 = ccclass('cc.ScrollView'), _dec2$D = help(), _dec3$w = executionOrder(110), _dec4$o = menu(), _dec5$k = requireComponent(UITransform), _dec6$h = range(), _dec7$f = displayOrder(), _dec8$f = tooltip(), _dec9$d = range(), _dec10$d = displayOrder(), _dec11$b = tooltip(), _dec12$b = displayOrder(), _dec13$b = tooltip(), _dec14$a = displayOrder(), _dec15$a = tooltip(), _dec16$9 = type(Node$1), _dec17$9 = displayOrder(), _dec18$9 = tooltip(), _dec19$9 = displayOrder(), _dec20$9 = tooltip(), _dec21$9 = type(ScrollBar), _dec22$9 = displayOrder(), _dec23$9 = tooltip(), _dec24$9 = displayOrder(), _dec25$9 = tooltip(), _dec26$8 = type(ScrollBar), _dec27$8 = displayOrder(), _dec28$8 = tooltip(), _dec29$8 = displayOrder(), _dec30$8 = tooltip(), _dec31$8 = type([EventHandler]), _dec32$7 = displayOrder(), _dec33$6 = tooltip(), _dec$12(_class$14 = _dec2$D(_class$14 = _dec3$w(_class$14 = _dec4$o(_class$14 = _dec5$k(_class$14 = (_class2$V = (_temp$_ = _class3$r = function (_ViewGroup) {
        _inheritsLoose(ScrollView, _ViewGroup);

        function ScrollView() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ViewGroup.call.apply(_ViewGroup, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "bounceDuration", _descriptor$N, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "brake", _descriptor2$y, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "elastic", _descriptor3$q, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "inertia", _descriptor4$n, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "horizontal", _descriptor5$i, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "vertical", _descriptor6$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor7$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "scrollEvents", _descriptor8$a, _assertThisInitialized(_this));

          _this._autoScrolling = false;
          _this._scrolling = false;

          _initializerDefineProperty(_this, "_content", _descriptor9$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalScrollBar", _descriptor10$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalScrollBar", _descriptor11$8, _assertThisInitialized(_this));

          _this._topBoundary = 0;
          _this._bottomBoundary = 0;
          _this._leftBoundary = 0;
          _this._rightBoundary = 0;
          _this._touchMoveDisplacements = [];
          _this._touchMoveTimeDeltas = [];
          _this._touchMovePreviousTimestamp = 0;
          _this._touchMoved = false;
          _this._autoScrollAttenuate = false;
          _this._autoScrollStartPosition = new Vec3();
          _this._autoScrollTargetDelta = new Vec3();
          _this._autoScrollTotalTime = 0;
          _this._autoScrollAccumulatedTime = 0;
          _this._autoScrollCurrentlyOutOfBoundary = false;
          _this._autoScrollBraking = false;
          _this._autoScrollBrakingStartPosition = new Vec3();
          _this._outOfBoundaryAmount = new Vec3();
          _this._outOfBoundaryAmountDirty = true;
          _this._stopMouseWheel = false;
          _this._mouseWheelEventElapsedTime = 0.0;
          _this._isScrollEndedWithThresholdEventFired = false;
          _this._scrollEventEmitMask = 0;
          _this._isBouncing = false;
          _this._contentPos = new Vec3();
          _this._deltaPos = new Vec3();
          return _this;
        }

        var _proto = ScrollView.prototype;

        _proto.scrollToBottom = function scrollToBottom(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: false,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta, true);
          }
        };

        _proto.scrollToTop = function scrollToTop(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 1),
            applyToHorizontal: false,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToLeft = function scrollToLeft(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToRight = function scrollToRight(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToTopLeft = function scrollToTopLeft(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 1),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToTopRight = function scrollToTopRight(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 1),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToBottomLeft = function scrollToBottomLeft(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, 0),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToBottomRight = function scrollToBottomRight(timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(1, 0),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToOffset = function scrollToOffset(offset, timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = true;
          }

          var maxScrollOffset = this.getMaxScrollOffset();
          var anchor = new Vec2(0, 0);

          if (maxScrollOffset.x === 0) {
            anchor.x = 0;
          } else {
            anchor.x = offset.x / maxScrollOffset.x;
          }

          if (maxScrollOffset.y === 0) {
            anchor.y = 1;
          } else {
            anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
          }

          this.scrollTo(anchor, timeInSecond, attenuated);
        };

        _proto.getScrollOffset = function getScrollOffset() {
          var topDelta = this._getContentTopBoundary() - this._topBoundary;

          var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

          return new Vec2(leftDelta, topDelta);
        };

        _proto.getMaxScrollOffset = function getMaxScrollOffset() {
          if (!this._content || !this.view) {
            return Vec2.ZERO;
          }

          var contentSize = this._content._uiProps.uiTransformComp.contentSize;
          var horizontalMaximizeOffset = contentSize.width - this.view.width;
          var verticalMaximizeOffset = contentSize.height - this.view.height;
          horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
          verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
          return new Vec2(horizontalMaximizeOffset, verticalMaximizeOffset);
        };

        _proto.scrollToPercentHorizontal = function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(percent, 0),
            applyToHorizontal: true,
            applyToVertical: false
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollTo = function scrollTo(anchor, timeInSecond, attenuated) {
          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(anchor),
            applyToHorizontal: true,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.scrollToPercentVertical = function scrollToPercentVertical(percent, timeInSecond, attenuated) {
          var moveDelta = this._calculateMovePercentDelta({
            anchor: new Vec2(0, percent),
            applyToHorizontal: false,
            applyToVertical: true
          });

          if (timeInSecond) {
            this._startAutoScroll(moveDelta, timeInSecond, attenuated);
          } else {
            this._moveContent(moveDelta);
          }
        };

        _proto.stopAutoScroll = function stopAutoScroll() {
          this._autoScrolling = false;
          this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
        };

        _proto.setContentPosition = function setContentPosition(position) {
          this._setContentPosition(position);
        };

        _proto._setContentPosition = function _setContentPosition(position) {
          if (!this._content) {
            return;
          }

          var contentPos = this._getContentPosition();

          if (Math.abs(position.x - contentPos.x) < EPSILON$1 && Math.abs(position.y - contentPos.y) < EPSILON$1) {
            return;
          }

          this._content.setPosition(position);

          this._outOfBoundaryAmountDirty = true;
        };

        _proto.getContentPosition = function getContentPosition() {
          return this._getContentPosition();
        };

        _proto._getContentPosition = function _getContentPosition() {
          if (!this._content) {
            return Vec3.ZERO.clone();
          }

          this._contentPos.set(this._content.position);

          return this._contentPos;
        };

        _proto.isScrolling = function isScrolling() {
          return this._scrolling;
        };

        _proto.isAutoScrolling = function isAutoScrolling() {
          return this._autoScrolling;
        };

        _proto.getScrollEndedEventTiming = function getScrollEndedEventTiming() {
          return EPSILON$1;
        };

        _proto.start = function start() {
          this._calculateBoundary();

          if (this._content) {
            director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
          }
        };

        _proto.onEnable = function onEnable() {
          {
            this._registerEvent();

            if (this._content) {
              this._content.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);

              this._content.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);

              if (this.view) {
                this.view.node.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                this.view.node.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              }
            }

            this._calculateBoundary();
          }

          this._updateScrollBarState();
        };

        _proto.update = function update(dt) {
          if (this._autoScrolling) {
            this._processAutoScrolling(dt);
          }
        };

        _proto.onDisable = function onDisable() {
          {
            this._unregisterEvent();

            if (this._content) {
              this._content.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);

              this._content.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);

              if (this.view) {
                this.view.node.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                this.view.node.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
              }
            }
          }

          this._hideScrollBar();

          this.stopAutoScroll();
        };

        _proto._registerEvent = function _registerEvent() {
          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
          this.node.on(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
        };

        _proto._unregisterEvent = function _unregisterEvent() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
          this.node.off(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
        };

        _proto._onMouseWheel = function _onMouseWheel(event, captureListeners) {
          if (!this.enabledInHierarchy) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          var deltaMove = new Vec3();
          var wheelPrecision = -0.1;
          var scrollY = event.getScrollY();

          if (this.vertical) {
            deltaMove.set(0, scrollY * wheelPrecision, 0);
          } else if (this.horizontal) {
            deltaMove.set(scrollY * wheelPrecision, 0, 0);
          }

          this._mouseWheelEventElapsedTime = 0;

          this._processDeltaMove(deltaMove);

          if (!this._stopMouseWheel) {
            this._handlePressLogic();

            this.schedule(this._checkMouseWheel, 1.0 / 60, NaN, 0);
            this._stopMouseWheel = true;
          }

          this._stopPropagationIfTargetIsMe(event);
        };

        _proto._onTouchBegan = function _onTouchBegan(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          this._handlePressLogic();

          this._touchMoved = false;

          this._stopPropagationIfTargetIsMe(event);
        };

        _proto._onTouchMoved = function _onTouchMoved(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          var touch = event.touch;

          this._handleMoveLogic(touch);

          if (!this.cancelInnerEvents) {
            return;
          }

          var deltaMove = touch.getUILocation(_tempVec2$1);
          deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1));

          if (deltaMove.length() > 7) {
            if (!this._touchMoved && event.target !== this.node) {
              var cancelEvent = new EventTouch(event.getTouches(), event.bubbles, SystemEventType.TOUCH_CANCEL);
              cancelEvent.touch = event.touch;
              cancelEvent.simulate = true;
              event.target.dispatchEvent(cancelEvent);
              this._touchMoved = true;
            }
          }

          this._stopPropagationIfTargetIsMe(event);
        };

        _proto._onTouchEnded = function _onTouchEnded(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content || !event) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          this._dispatchEvent(EventType$3.TOUCH_UP);

          var touch = event.touch;

          this._handleReleaseLogic(touch);

          if (this._touchMoved) {
            event.propagationStopped = true;
          } else {
            this._stopPropagationIfTargetIsMe(event);
          }
        };

        _proto._onTouchCancelled = function _onTouchCancelled(event, captureListeners) {
          if (!this.enabledInHierarchy || !this._content) {
            return;
          }

          if (this._hasNestedViewGroup(event, captureListeners)) {
            return;
          }

          if (event && !event.simulate) {
            var touch = event.touch;

            this._handleReleaseLogic(touch);
          }

          this._stopPropagationIfTargetIsMe(event);
        };

        _proto._calculateBoundary = function _calculateBoundary() {
          if (this._content && this.view) {
            var layout = this._content.getComponent(Layout);

            if (layout && layout.enabledInHierarchy) {
              layout.updateLayout();
            }

            var viewTrans = this.view;
            var anchorX = viewTrans.width * viewTrans.anchorX;
            var anchorY = viewTrans.height * viewTrans.anchorY;
            this._leftBoundary = -anchorX;
            this._bottomBoundary = -anchorY;
            this._rightBoundary = this._leftBoundary + viewTrans.width;
            this._topBoundary = this._bottomBoundary + viewTrans.height;

            this._moveContentToTopLeft(viewTrans.contentSize);
          }
        };

        _proto._hasNestedViewGroup = function _hasNestedViewGroup(event, captureListeners) {
          if (!event || event.eventPhase !== Event.CAPTURING_PHASE) {
            return false;
          }

          if (captureListeners) {
            for (var _iterator = _createForOfIteratorHelperLoose(captureListeners), _step; !(_step = _iterator()).done;) {
              var listener = _step.value;
              var item = listener;

              if (this.node === item) {
                if (event.target && event.target.getComponent(ViewGroup)) {
                  return true;
                }

                return false;
              }

              if (item.getComponent(ViewGroup)) {
                return true;
              }
            }
          }

          return false;
        };

        _proto._startInertiaScroll = function _startInertiaScroll(touchMoveVelocity) {
          var inertiaTotalMovement = new Vec3(touchMoveVelocity);
          inertiaTotalMovement.multiplyScalar(MOVEMENT_FACTOR);

          this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
        };

        _proto._calculateAttenuatedFactor = function _calculateAttenuatedFactor(distance) {
          if (this.brake <= 0) {
            return 1 - this.brake;
          }

          return (1 - this.brake) * (1 / (1 + distance * 0.000014 + distance * distance * 0.000000008));
        };

        _proto._startAttenuatingAutoScroll = function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
          var targetDelta = deltaMove.clone();
          targetDelta.normalize();

          if (this._content && this.view) {
            var contentSize = this._content._uiProps.uiTransformComp.contentSize;
            var scrollViewSize = this.view.contentSize;
            var totalMoveWidth = contentSize.width - scrollViewSize.width;
            var totalMoveHeight = contentSize.height - scrollViewSize.height;

            var attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);

            var attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);

            targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX;
            targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake);
            targetDelta.z = 0;
          }

          var originalMoveLength = deltaMove.length();
          var factor = targetDelta.length() / originalMoveLength;
          targetDelta.add(deltaMove);

          if (this.brake > 0 && factor > 7) {
            factor = Math.sqrt(factor);
            var clonedDeltaMove = deltaMove.clone();
            clonedDeltaMove.multiplyScalar(factor);
            targetDelta.set(clonedDeltaMove);
            targetDelta.add(deltaMove);
          }

          var time = this._calculateAutoScrollTimeByInitialSpeed(initialVelocity.length());

          if (this.brake > 0 && factor > 3) {
            factor = 3;
            time *= factor;
          }

          if (this.brake === 0 && factor > 1) {
            time *= factor;
          }

          this._startAutoScroll(targetDelta, time, true);
        };

        _proto._calculateAutoScrollTimeByInitialSpeed = function _calculateAutoScrollTimeByInitialSpeed(initialSpeed) {
          return Math.sqrt(Math.sqrt(initialSpeed / 5));
        };

        _proto._startAutoScroll = function _startAutoScroll(deltaMove, timeInSecond, attenuated) {
          if (attenuated === void 0) {
            attenuated = false;
          }

          var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);

          this._autoScrolling = true;
          this._autoScrollTargetDelta = adjustedDeltaMove;
          this._autoScrollAttenuate = attenuated;
          Vec3.copy(this._autoScrollStartPosition, this._getContentPosition());
          this._autoScrollTotalTime = timeInSecond;
          this._autoScrollAccumulatedTime = 0;
          this._autoScrollBraking = false;
          this._isScrollEndedWithThresholdEventFired = false;

          this._autoScrollBrakingStartPosition.set(0, 0, 0);

          var currentOutOfBoundary = this._getHowMuchOutOfBoundary();

          if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
            this._autoScrollCurrentlyOutOfBoundary = true;
          }
        };

        _proto._calculateTouchMoveVelocity = function _calculateTouchMoveVelocity() {
          var out = new Vec3();
          var totalTime = 0;
          totalTime = this._touchMoveTimeDeltas.reduce(function (a, b) {
            return a + b;
          }, totalTime);

          if (totalTime <= 0 || totalTime >= 0.5) {
            out.set(Vec3.ZERO);
          } else {
            var totalMovement = new Vec3();
            totalMovement = this._touchMoveDisplacements.reduce(function (a, b) {
              a.add(b);
              return a;
            }, totalMovement);
            out.set(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, totalMovement.z);
          }

          return out;
        };

        _proto._flattenVectorByDirection = function _flattenVectorByDirection(vector) {
          var result = vector;
          result.x = this.horizontal ? result.x : 0;
          result.y = this.vertical ? result.y : 0;
          return result;
        };

        _proto._moveContent = function _moveContent(deltaMove, canStartBounceBack) {
          var adjustedMove = this._flattenVectorByDirection(deltaMove);

          _tempVec3$3.set(this._getContentPosition());

          _tempVec3$3.add(adjustedMove);

          _tempVec3$3.set(Math.round(_tempVec3$3.x * TOLERANCE) * EPSILON$1, Math.round(_tempVec3$3.y * TOLERANCE) * EPSILON$1, _tempVec3$3.z);

          this._setContentPosition(_tempVec3$3);

          var outOfBoundary = this._getHowMuchOutOfBoundary();

          _tempVec2$1.set(outOfBoundary.x, outOfBoundary.y);

          this._updateScrollBar(_tempVec2$1);

          if (this.elastic && canStartBounceBack) {
            this._startBounceBackIfNeeded();
          }
        };

        _proto._getContentLeftBoundary = function _getContentLeftBoundary() {
          if (!this._content) {
            return -1;
          }

          var contentPos = this._getContentPosition();

          var uiTrans = this._content._uiProps.uiTransformComp;
          return contentPos.x - uiTrans.anchorX * uiTrans.width;
        };

        _proto._getContentRightBoundary = function _getContentRightBoundary() {
          if (!this._content) {
            return -1;
          }

          var uiTrans = this._content._uiProps.uiTransformComp;
          return this._getContentLeftBoundary() + uiTrans.width;
        };

        _proto._getContentTopBoundary = function _getContentTopBoundary() {
          if (!this._content) {
            return -1;
          }

          var uiTrans = this._content._uiProps.uiTransformComp;
          return this._getContentBottomBoundary() + uiTrans.height;
        };

        _proto._getContentBottomBoundary = function _getContentBottomBoundary() {
          if (!this._content) {
            return -1;
          }

          var contentPos = this._getContentPosition();

          var uiTrans = this._content._uiProps.uiTransformComp;
          return contentPos.y - uiTrans.anchorY * uiTrans.height;
        };

        _proto._getHowMuchOutOfBoundary = function _getHowMuchOutOfBoundary(addition) {
          addition = addition || new Vec3();

          if (addition.equals(Vec3.ZERO, EPSILON$1) && !this._outOfBoundaryAmountDirty) {
            return this._outOfBoundaryAmount;
          }

          var outOfBoundaryAmount = new Vec3();

          var tempLeftBoundary = this._getContentLeftBoundary();

          var tempRightBoundary = this._getContentRightBoundary();

          if (tempLeftBoundary + addition.x > this._leftBoundary) {
            outOfBoundaryAmount.x = this._leftBoundary - (tempLeftBoundary + addition.x);
          } else if (tempRightBoundary + addition.x < this._rightBoundary) {
            outOfBoundaryAmount.x = this._rightBoundary - (tempRightBoundary + addition.x);
          }

          var tempTopBoundary = this._getContentTopBoundary();

          var tempBottomBoundary = this._getContentBottomBoundary();

          if (tempTopBoundary + addition.y < this._topBoundary) {
            outOfBoundaryAmount.y = this._topBoundary - (tempTopBoundary + addition.y);
          } else if (tempBottomBoundary + addition.y > this._bottomBoundary) {
            outOfBoundaryAmount.y = this._bottomBoundary - (tempBottomBoundary + addition.y);
          }

          if (addition.equals(Vec3.ZERO, EPSILON$1)) {
            this._outOfBoundaryAmount = outOfBoundaryAmount;
            this._outOfBoundaryAmountDirty = false;
          }

          this._clampDelta(outOfBoundaryAmount);

          return outOfBoundaryAmount;
        };

        _proto._updateScrollBar = function _updateScrollBar(outOfBoundary) {
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.onScroll(outOfBoundary);
          }

          if (this.verticalScrollBar) {
            this.verticalScrollBar.onScroll(outOfBoundary);
          }
        };

        _proto._onScrollBarTouchBegan = function _onScrollBarTouchBegan() {
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.onTouchBegan();
          }

          if (this.verticalScrollBar) {
            this.verticalScrollBar.onTouchBegan();
          }
        };

        _proto._onScrollBarTouchEnded = function _onScrollBarTouchEnded() {
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.onTouchEnded();
          }

          if (this.verticalScrollBar) {
            this.verticalScrollBar.onTouchEnded();
          }
        };

        _proto._dispatchEvent = function _dispatchEvent(event) {
          if (event === EventType$3.SCROLL_ENDED) {
            this._scrollEventEmitMask = 0;
          } else if (event === EventType$3.SCROLL_TO_TOP || event === EventType$3.SCROLL_TO_BOTTOM || event === EventType$3.SCROLL_TO_LEFT || event === EventType$3.SCROLL_TO_RIGHT) {
            var flag = 1 << eventMap[event];

            if (this._scrollEventEmitMask & flag) {
              return;
            } else {
              this._scrollEventEmitMask |= flag;
            }
          }

          EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
          this.node.emit(event, this);
        };

        _proto._adjustContentOutOfBoundary = function _adjustContentOutOfBoundary() {
          if (!this._content) {
            return;
          }

          this._outOfBoundaryAmountDirty = true;

          if (this._isOutOfBoundary()) {
            var outOfBoundary = this._getHowMuchOutOfBoundary();

            _tempVec3$3.set(this._getContentPosition());

            _tempVec3$3.add(outOfBoundary);

            this._content.setPosition(_tempVec3$3);

            this._updateScrollBar(Vec2.ZERO);
          }
        };

        _proto._hideScrollBar = function _hideScrollBar() {
          if (this._horizontalScrollBar) {
            this._horizontalScrollBar.hide();
          }

          if (this._verticalScrollBar) {
            this._verticalScrollBar.hide();
          }
        };

        _proto._updateScrollBarState = function _updateScrollBarState() {
          if (!this._content || !this.view) {
            return;
          }

          var viewTrans = this.view;
          var uiTrans = this._content._uiProps.uiTransformComp;

          if (this.verticalScrollBar) {
            if (uiTrans.height < viewTrans.height) {
              this.verticalScrollBar.hide();
            } else {
              this.verticalScrollBar.show();
            }
          }

          if (this.horizontalScrollBar) {
            if (uiTrans.width < viewTrans.width) {
              this.horizontalScrollBar.hide();
            } else {
              this.horizontalScrollBar.show();
            }
          }
        };

        _proto._stopPropagationIfTargetIsMe = function _stopPropagationIfTargetIsMe(event) {
          if (event.eventPhase === Event.AT_TARGET && event.target === this.node) {
            event.propagationStopped = true;
          }
        };

        _proto._processDeltaMove = function _processDeltaMove(deltaMove) {
          this._scrollChildren(deltaMove);

          this._gatherTouchMove(deltaMove);
        };

        _proto._handleMoveLogic = function _handleMoveLogic(touch) {
          this._getLocalAxisAlignDelta(this._deltaPos, touch);

          this._processDeltaMove(this._deltaPos);
        };

        _proto._handleReleaseLogic = function _handleReleaseLogic(touch) {
          this._getLocalAxisAlignDelta(this._deltaPos, touch);

          this._gatherTouchMove(this._deltaPos);

          this._processInertiaScroll();

          if (this._scrolling) {
            this._scrolling = false;

            if (!this._autoScrolling) {
              this._dispatchEvent(EventType$3.SCROLL_ENDED);
            }
          }
        };

        _proto._getLocalAxisAlignDelta = function _getLocalAxisAlignDelta(out, touch) {
          var uiTransformComp = this.node._uiProps.uiTransformComp;
          var vec = new Vec3();

          if (uiTransformComp) {
            touch.getUILocation(_tempVec2$1);
            touch.getUIPreviousLocation(_tempVec2_1);

            _tempVec3$3.set(_tempVec2$1.x, _tempVec2$1.y, 0);

            _tempVec3_1.set(_tempVec2_1.x, _tempVec2_1.y, 0);

            uiTransformComp.convertToNodeSpaceAR(_tempVec3$3, _tempVec3$3);
            uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1);
            Vec3.subtract(vec, _tempVec3$3, _tempVec3_1);
          }

          out.set(vec);
        };

        _proto._scrollChildren = function _scrollChildren(deltaMove) {
          this._clampDelta(deltaMove);

          var realMove = deltaMove;
          var outOfBoundary;

          if (this.elastic) {
            outOfBoundary = this._getHowMuchOutOfBoundary();
            realMove.x *= outOfBoundary.x === 0 ? 1 : 0.5;
            realMove.y *= outOfBoundary.y === 0 ? 1 : 0.5;
          }

          if (!this.elastic) {
            outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
            realMove.add(outOfBoundary);
          }

          var verticalScrollEventType = '';
          var horizontalScrollEventType = '';

          if (this._content) {
            var _ref = this._content._uiProps.uiTransformComp,
                anchorX = _ref.anchorX,
                anchorY = _ref.anchorY,
                width = _ref.width,
                height = _ref.height;
            var pos = this._content.position || Vec3.ZERO;

            if (this.vertical) {
              if (realMove.y > 0) {
                var icBottomPos = pos.y - anchorY * height;

                if (icBottomPos + realMove.y >= this._bottomBoundary) {
                  verticalScrollEventType = EventType$3.SCROLL_TO_BOTTOM;
                }
              } else if (realMove.y < 0) {
                var icTopPos = pos.y - anchorY * height + height;

                if (icTopPos + realMove.y <= this._topBoundary) {
                  verticalScrollEventType = EventType$3.SCROLL_TO_TOP;
                }
              }
            }

            if (this.horizontal) {
              if (realMove.x < 0) {
                var icRightPos = pos.x - anchorX * width + width;

                if (icRightPos + realMove.x <= this._rightBoundary) {
                  horizontalScrollEventType = EventType$3.SCROLL_TO_RIGHT;
                }
              } else if (realMove.x > 0) {
                var icLeftPos = pos.x - anchorX * width;

                if (icLeftPos + realMove.x >= this._leftBoundary) {
                  horizontalScrollEventType = EventType$3.SCROLL_TO_LEFT;
                }
              }
            }
          }

          this._moveContent(realMove, false);

          if (this.horizontal && realMove.x !== 0 || this.vertical && realMove.y !== 0) {
            if (!this._scrolling) {
              this._scrolling = true;

              this._dispatchEvent(EventType$3.SCROLL_BEGAN);
            }

            this._dispatchEvent(EventType$3.SCROLLING);
          }

          if (verticalScrollEventType !== '') {
            this._dispatchEvent(verticalScrollEventType);
          }

          if (horizontalScrollEventType !== '') {
            this._dispatchEvent(horizontalScrollEventType);
          }
        };

        _proto._handlePressLogic = function _handlePressLogic() {
          if (this._autoScrolling) {
            this._dispatchEvent(EventType$3.SCROLL_ENDED);
          }

          this._autoScrolling = false;
          this._isBouncing = false;
          this._touchMovePreviousTimestamp = getTimeInMilliseconds();
          this._touchMoveDisplacements.length = 0;
          this._touchMoveTimeDeltas.length = 0;

          this._onScrollBarTouchBegan();
        };

        _proto._clampDelta = function _clampDelta(out) {
          if (this._content && this.view) {
            var scrollViewSize = this.view.contentSize;
            var uiTrans = this._content._uiProps.uiTransformComp;

            if (uiTrans.width < scrollViewSize.width) {
              out.x = 0;
            }

            if (uiTrans.height < scrollViewSize.height) {
              out.y = 0;
            }
          }
        };

        _proto._gatherTouchMove = function _gatherTouchMove(delta) {
          var clampDt = delta.clone();

          this._clampDelta(clampDt);

          while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
            this._touchMoveDisplacements.shift();

            this._touchMoveTimeDeltas.shift();
          }

          this._touchMoveDisplacements.push(clampDt);

          var timeStamp = getTimeInMilliseconds();

          this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1000);

          this._touchMovePreviousTimestamp = timeStamp;
        };

        _proto._startBounceBackIfNeeded = function _startBounceBackIfNeeded() {
          if (!this.elastic) {
            return false;
          }

          var bounceBackAmount = this._getHowMuchOutOfBoundary();

          this._clampDelta(bounceBackAmount);

          if (bounceBackAmount.equals(Vec3.ZERO, EPSILON$1)) {
            return false;
          }

          var bounceBackTime = Math.max(this.bounceDuration, 0);

          this._startAutoScroll(bounceBackAmount, bounceBackTime, true);

          if (!this._isBouncing) {
            if (bounceBackAmount.y > 0) {
              this._dispatchEvent(EventType$3.BOUNCE_TOP);
            }

            if (bounceBackAmount.y < 0) {
              this._dispatchEvent(EventType$3.BOUNCE_BOTTOM);
            }

            if (bounceBackAmount.x > 0) {
              this._dispatchEvent(EventType$3.BOUNCE_RIGHT);
            }

            if (bounceBackAmount.x < 0) {
              this._dispatchEvent(EventType$3.BOUNCE_LEFT);
            }

            this._isBouncing = true;
          }

          return true;
        };

        _proto._processInertiaScroll = function _processInertiaScroll() {
          var bounceBackStarted = this._startBounceBackIfNeeded();

          if (!bounceBackStarted && this.inertia) {
            var touchMoveVelocity = this._calculateTouchMoveVelocity();

            if (!touchMoveVelocity.equals(_tempVec3$3, EPSILON$1) && this.brake < 1) {
              this._startInertiaScroll(touchMoveVelocity);
            }
          }

          this._onScrollBarTouchEnded();
        };

        _proto._isOutOfBoundary = function _isOutOfBoundary() {
          var outOfBoundary = this._getHowMuchOutOfBoundary();

          return !outOfBoundary.equals(Vec3.ZERO, EPSILON$1);
        };

        _proto._isNecessaryAutoScrollBrake = function _isNecessaryAutoScrollBrake() {
          if (this._autoScrollBraking) {
            return true;
          }

          if (this._isOutOfBoundary()) {
            if (!this._autoScrollCurrentlyOutOfBoundary) {
              this._autoScrollCurrentlyOutOfBoundary = true;
              this._autoScrollBraking = true;
              Vec3.copy(this._autoScrollBrakingStartPosition, this._getContentPosition());
              return true;
            }
          } else {
            this._autoScrollCurrentlyOutOfBoundary = false;
          }

          return false;
        };

        _proto._processAutoScrolling = function _processAutoScrolling(dt) {
          var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();

          var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
          this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
          var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);

          if (this._autoScrollAttenuate) {
            percentage = quintEaseOut(percentage);
          }

          var clonedAutoScrollTargetDelta = this._autoScrollTargetDelta.clone();

          clonedAutoScrollTargetDelta.multiplyScalar(percentage);

          var clonedAutoScrollStartPosition = this._autoScrollStartPosition.clone();

          clonedAutoScrollStartPosition.add(clonedAutoScrollTargetDelta);
          var reachedEnd = Math.abs(percentage - 1) <= EPSILON$1;
          var fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();

          if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
            this._dispatchEvent(EventType$3.SCROLL_ENG_WITH_THRESHOLD);

            this._isScrollEndedWithThresholdEventFired = true;
          }

          if (this.elastic) {
            var brakeOffsetPosition = clonedAutoScrollStartPosition.clone();
            brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition);

            if (isAutoScrollBrake) {
              brakeOffsetPosition.multiplyScalar(brakingFactor);
            }

            clonedAutoScrollStartPosition.set(this._autoScrollBrakingStartPosition);
            clonedAutoScrollStartPosition.add(brakeOffsetPosition);
          } else {
            var moveDelta = clonedAutoScrollStartPosition.clone();
            moveDelta.subtract(this.getContentPosition());

            var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);

            if (!outOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
              clonedAutoScrollStartPosition.add(outOfBoundary);
              reachedEnd = true;
            }
          }

          if (reachedEnd) {
            this._autoScrolling = false;
          }

          var deltaMove = clonedAutoScrollStartPosition.clone();
          deltaMove.subtract(this._getContentPosition());

          this._clampDelta(deltaMove);

          this._moveContent(deltaMove, reachedEnd);

          this._dispatchEvent(EventType$3.SCROLLING);

          if (!this._autoScrolling) {
            this._isBouncing = false;
            this._scrolling = false;

            this._dispatchEvent(EventType$3.SCROLL_ENDED);
          }
        };

        _proto._checkMouseWheel = function _checkMouseWheel(dt) {
          var currentOutOfBoundary = this._getHowMuchOutOfBoundary();

          var maxElapsedTime = 0.1;

          if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
            this._processInertiaScroll();

            this.unschedule(this._checkMouseWheel);

            this._dispatchEvent(EventType$3.SCROLL_ENDED);

            this._stopMouseWheel = false;
            return;
          }

          this._mouseWheelEventElapsedTime += dt;

          if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
            this._onScrollBarTouchEnded();

            this.unschedule(this._checkMouseWheel);

            this._dispatchEvent(EventType$3.SCROLL_ENDED);

            this._stopMouseWheel = false;
          }
        };

        _proto._calculateMovePercentDelta = function _calculateMovePercentDelta(options) {
          var anchor = options.anchor;
          var applyToHorizontal = options.applyToHorizontal;
          var applyToVertical = options.applyToVertical;

          this._calculateBoundary();

          anchor.clampf(Vec2.ZERO, Vec2.ONE);

          var bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

          bottomDelta = -bottomDelta;

          var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

          leftDelta = -leftDelta;
          var moveDelta = new Vec3();

          if (this._content && this.view) {
            var totalScrollDelta = 0;
            var uiTrans = this._content._uiProps.uiTransformComp;
            var contentSize = uiTrans.contentSize;
            var scrollSize = this.view.contentSize;

            if (applyToHorizontal) {
              totalScrollDelta = contentSize.width - scrollSize.width;
              moveDelta.x = leftDelta - totalScrollDelta * anchor.x;
            }

            if (applyToVertical) {
              totalScrollDelta = contentSize.height - scrollSize.height;
              moveDelta.y = bottomDelta - totalScrollDelta * anchor.y;
            }
          }

          return moveDelta;
        };

        _proto._moveContentToTopLeft = function _moveContentToTopLeft(scrollViewSize) {
          var bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

          bottomDelta = -bottomDelta;
          var moveDelta = new Vec3();
          var totalScrollDelta = 0;

          var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

          leftDelta = -leftDelta;

          if (this._content) {
            var uiTrans = this._content._uiProps.uiTransformComp;
            var contentSize = uiTrans.contentSize;

            if (contentSize.height < scrollViewSize.height) {
              totalScrollDelta = contentSize.height - scrollViewSize.height;
              moveDelta.y = bottomDelta - totalScrollDelta;
            }

            if (contentSize.width < scrollViewSize.width) {
              totalScrollDelta = contentSize.width - scrollViewSize.width;
              moveDelta.x = leftDelta;
            }
          }

          this._updateScrollBarState();

          this._moveContent(moveDelta);

          this._adjustContentOutOfBoundary();
        };

        _proto._scaleChanged = function _scaleChanged(value) {
          if (value === TransformBit.SCALE) {
            this._calculateBoundary();
          }
        };

        _createClass(ScrollView, [{
          key: "content",
          get: function get() {
            return this._content;
          },
          set: function set(value) {
            if (this._content === value) {
              return;
            }

            var viewTrans = value && value.parent && value.parent._uiProps.uiTransformComp;

            if (value && (!value || !viewTrans)) {
              logID(4302);
              return;
            }

            this._content = value;

            this._calculateBoundary();
          }
        }, {
          key: "horizontalScrollBar",
          get: function get() {
            return this._horizontalScrollBar;
          },
          set: function set(value) {
            if (this._horizontalScrollBar === value) {
              return;
            }

            this._horizontalScrollBar = value;

            if (this._horizontalScrollBar) {
              this._horizontalScrollBar.setScrollView(this);

              this._updateScrollBar(Vec2.ZERO);
            }
          }
        }, {
          key: "verticalScrollBar",
          get: function get() {
            return this._verticalScrollBar;
          },
          set: function set(value) {
            if (this._verticalScrollBar === value) {
              return;
            }

            this._verticalScrollBar = value;

            if (this._verticalScrollBar) {
              this._verticalScrollBar.setScrollView(this);

              this._updateScrollBar(Vec2.ZERO);
            }
          }
        }, {
          key: "view",
          get: function get() {
            var parent = this._content && this._content.parent;

            if (!parent) {
              return null;
            }

            return parent._uiProps.uiTransformComp;
          }
        }]);

        return ScrollView;
      }(ViewGroup), _class3$r.EventType = EventType$3, _temp$_), (_descriptor$N = _applyDecoratedDescriptor(_class2$V.prototype, "bounceDuration", [serializable, _dec6$h, _dec7$f, _dec8$f], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor2$y = _applyDecoratedDescriptor(_class2$V.prototype, "brake", [serializable, _dec9$d, _dec10$d, _dec11$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor3$q = _applyDecoratedDescriptor(_class2$V.prototype, "elastic", [serializable, _dec12$b, _dec13$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor4$n = _applyDecoratedDescriptor(_class2$V.prototype, "inertia", [serializable, _dec14$a, _dec15$a], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "content", [_dec16$9, _dec17$9, _dec18$9], Object.getOwnPropertyDescriptor(_class2$V.prototype, "content"), _class2$V.prototype), _descriptor5$i = _applyDecoratedDescriptor(_class2$V.prototype, "horizontal", [serializable, _dec19$9, _dec20$9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "horizontalScrollBar", [_dec21$9, _dec22$9, _dec23$9], Object.getOwnPropertyDescriptor(_class2$V.prototype, "horizontalScrollBar"), _class2$V.prototype), _descriptor6$a = _applyDecoratedDescriptor(_class2$V.prototype, "vertical", [serializable, _dec24$9, _dec25$9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2$V.prototype, "verticalScrollBar", [_dec26$8, _dec27$8, _dec28$8], Object.getOwnPropertyDescriptor(_class2$V.prototype, "verticalScrollBar"), _class2$V.prototype), _descriptor7$a = _applyDecoratedDescriptor(_class2$V.prototype, "cancelInnerEvents", [serializable, _dec29$8, _dec30$8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor8$a = _applyDecoratedDescriptor(_class2$V.prototype, "scrollEvents", [_dec31$8, serializable, _dec32$7, _dec33$6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor9$9 = _applyDecoratedDescriptor(_class2$V.prototype, "_content", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10$9 = _applyDecoratedDescriptor(_class2$V.prototype, "_horizontalScrollBar", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$8 = _applyDecoratedDescriptor(_class2$V.prototype, "_verticalScrollBar", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$V)) || _class$14) || _class$14) || _class$14) || _class$14) || _class$14));
      legacyCC.ScrollView = ScrollView;

      var _dec$13, _dec2$E, _dec3$x, _dec4$p, _dec5$l, _dec6$i, _dec7$g, _dec8$g, _dec9$e, _dec10$e, _dec11$c, _dec12$c, _dec13$c, _class$15, _class2$W, _descriptor$O, _descriptor2$z, _descriptor3$r, _descriptor4$o, _class3$s, _temp$$;

      var _tempPos = new Vec3();

      var Direction$1;

      (function (Direction) {
        Direction[Direction["Horizontal"] = 0] = "Horizontal";
        Direction[Direction["Vertical"] = 1] = "Vertical";
      })(Direction$1 || (Direction$1 = {}));

      ccenum(Direction$1);
      var Slider = function (v) { return exports({ Slider: v, SliderComponent: v }), v; }((_dec$13 = ccclass('cc.Slider'), _dec2$E = help(), _dec3$x = executionOrder(110), _dec4$p = menu(), _dec5$l = requireComponent(UITransform), _dec6$i = type(Sprite), _dec7$g = tooltip(), _dec8$g = type(Direction$1), _dec9$e = tooltip(), _dec10$e = range(), _dec11$c = tooltip(), _dec12$c = type([EventHandler]), _dec13$c = tooltip(), _dec$13(_class$15 = _dec2$E(_class$15 = _dec3$x(_class$15 = _dec4$p(_class$15 = _dec5$l(_class$15 = (_class2$W = (_temp$$ = _class3$s = function (_Component) {
        _inheritsLoose(Slider, _Component);

        function Slider() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "slideEvents", _descriptor$O, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_handle", _descriptor2$z, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor3$r, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_progress", _descriptor4$o, _assertThisInitialized(_this));

          _this._offset = new Vec3();
          _this._dragging = false;
          _this._touchHandle = false;
          _this._handleLocalPos = new Vec3();
          _this._touchPos = new Vec3();
          return _this;
        }

        var _proto = Slider.prototype;

        _proto.__preload = function __preload() {
          this._updateHandlePosition();
        };

        _proto.onEnable = function onEnable() {
          this._updateHandlePosition();

          this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);

          if (this._handle && this._handle.isValid) {
            this._handle.node.on(NodeEventType.TOUCH_START, this._onHandleDragStart, this);

            this._handle.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);

            this._handle.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          }
        };

        _proto.onDisable = function onDisable() {
          this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
          this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);

          if (this._handle && this._handle.isValid) {
            this._handle.node.off(NodeEventType.TOUCH_START, this._onHandleDragStart, this);

            this._handle.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);

            this._handle.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
          }
        };

        _proto._onHandleDragStart = function _onHandleDragStart(event) {
          if (!event || !this._handle || !this._handle.node._uiProps.uiTransformComp) {
            return;
          }

          this._dragging = true;
          this._touchHandle = true;
          var touhPos = event.touch.getUILocation();
          Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0);

          this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset);

          event.propagationStopped = true;
        };

        _proto._onTouchBegan = function _onTouchBegan(event) {
          if (!this._handle || !event) {
            return;
          }

          this._dragging = true;

          if (!this._touchHandle) {
            this._handleSliderLogic(event.touch);
          }

          event.propagationStopped = true;
        };

        _proto._onTouchMoved = function _onTouchMoved(event) {
          if (!this._dragging || !event) {
            return;
          }

          this._handleSliderLogic(event.touch);

          event.propagationStopped = true;
        };

        _proto._onTouchEnded = function _onTouchEnded(event) {
          this._dragging = false;
          this._touchHandle = false;
          this._offset = new Vec3();

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._onTouchCancelled = function _onTouchCancelled(event) {
          this._dragging = false;

          if (event) {
            event.propagationStopped = true;
          }
        };

        _proto._handleSliderLogic = function _handleSliderLogic(touch) {
          this._updateProgress(touch);

          this._emitSlideEvent();
        };

        _proto._emitSlideEvent = function _emitSlideEvent() {
          EventHandler.emitEvents(this.slideEvents, this);
          this.node.emit('slide', this);
        };

        _proto._updateProgress = function _updateProgress(touch) {
          if (!this._handle || !touch) {
            return;
          }

          var touchPos = touch.getUILocation();
          Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
          var uiTrans = this.node._uiProps.uiTransformComp;
          var localTouchPos = uiTrans.convertToNodeSpaceAR(this._touchPos, _tempPos);

          if (this.direction === Direction$1.Horizontal) {
            this.progress = clamp01(0.5 + (localTouchPos.x - this._offset.x) / uiTrans.width);
          } else {
            this.progress = clamp01(0.5 + (localTouchPos.y - this._offset.y) / uiTrans.height);
          }
        };

        _proto._updateHandlePosition = function _updateHandlePosition() {
          if (!this._handle) {
            return;
          }

          this._handleLocalPos.set(this._handle.node.getPosition());

          var uiTrans = this.node._uiProps.uiTransformComp;

          if (this._direction === Direction$1.Horizontal) {
            this._handleLocalPos.x = -uiTrans.width * uiTrans.anchorX + this.progress * uiTrans.width;
          } else {
            this._handleLocalPos.y = -uiTrans.height * uiTrans.anchorY + this.progress * uiTrans.height;
          }

          this._handle.node.setPosition(this._handleLocalPos);
        };

        _proto._changeLayout = function _changeLayout() {
          var uiTrans = this.node._uiProps.uiTransformComp;
          var contentSize = uiTrans.contentSize;
          uiTrans.setContentSize(contentSize.height, contentSize.width);

          if (this._handle) {
            var pos = this._handle.node.position;

            if (this._direction === Direction$1.Horizontal) {
              this._handle.node.setPosition(pos.x, 0, pos.z);
            } else {
              this._handle.node.setPosition(0, pos.y, pos.z);
            }

            this._updateHandlePosition();
          }
        };

        _createClass(Slider, [{
          key: "handle",
          get: function get() {
            return this._handle;
          },
          set: function set(value) {
            if (this._handle === value) {
              return;
            }

            this._handle = value;
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) {
              return;
            }

            this._direction = value;

            this._changeLayout();
          }
        }, {
          key: "progress",
          get: function get() {
            return this._progress;
          },
          set: function set(value) {
            if (this._progress === value) {
              return;
            }

            this._progress = value;

            this._updateHandlePosition();
          }
        }]);

        return Slider;
      }(Component), _class3$s.Direction = Direction$1, _temp$$), (_applyDecoratedDescriptor(_class2$W.prototype, "handle", [_dec6$i, _dec7$g], Object.getOwnPropertyDescriptor(_class2$W.prototype, "handle"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "direction", [_dec8$g, _dec9$e], Object.getOwnPropertyDescriptor(_class2$W.prototype, "direction"), _class2$W.prototype), _applyDecoratedDescriptor(_class2$W.prototype, "progress", [slide, _dec10$e, _dec11$c], Object.getOwnPropertyDescriptor(_class2$W.prototype, "progress"), _class2$W.prototype), _descriptor$O = _applyDecoratedDescriptor(_class2$W.prototype, "slideEvents", [_dec12$c, serializable, _dec13$c], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$z = _applyDecoratedDescriptor(_class2$W.prototype, "_handle", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$r = _applyDecoratedDescriptor(_class2$W.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Direction$1.Horizontal;
        }
      }), _descriptor4$o = _applyDecoratedDescriptor(_class2$W.prototype, "_progress", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      })), _class2$W)) || _class$15) || _class$15) || _class$15) || _class$15) || _class$15));
      legacyCC.Slider = Slider;

      function extendsEnum() {
        for (var _len = arguments.length, enums = new Array(_len), _key = 0; _key < _len; _key++) {
          enums[_key] = arguments[_key];
        }

        return Object.assign.apply(Object, [{}].concat(enums));
      }

      var _dec$14, _dec2$F, _dec3$y, _dec4$q, _dec5$m, _dec6$j, _dec7$h, _dec8$h, _dec9$f, _dec10$f, _dec11$d, _dec12$d, _class$16, _class2$X, _descriptor$P, _descriptor2$A, _descriptor3$s, _class3$t, _temp$10;
      var EventType$4;

      (function (EventType) {
        EventType["TOGGLE"] = "toggle";
      })(EventType$4 || (EventType$4 = {}));

      var Toggle = function (v) { return exports({ Toggle: v, ToggleComponent: v }), v; }((_dec$14 = ccclass('cc.Toggle'), _dec2$F = help(), _dec3$y = executionOrder(110), _dec4$q = menu(), _dec5$m = requireComponent(UITransform), _dec6$j = displayOrder(), _dec7$h = tooltip(), _dec8$h = type(Sprite), _dec9$f = displayOrder(), _dec10$f = tooltip(), _dec11$d = type([EventHandler]), _dec12$d = tooltip(), _dec$14(_class$16 = _dec2$F(_class$16 = _dec3$y(_class$16 = _dec4$q(_class$16 = _dec5$m(_class$16 = (_class2$X = (_temp$10 = _class3$t = function (_Button) {
        _inheritsLoose(Toggle, _Button);

        function Toggle() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Button.call.apply(_Button, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "checkEvents", _descriptor$P, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isChecked", _descriptor2$A, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_checkMark", _descriptor3$s, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = Toggle.prototype;

        _proto._internalToggle = function _internalToggle() {
          this.isChecked = !this.isChecked;
        };

        _proto._set = function _set(value, emitEvent) {
          if (emitEvent === void 0) {
            emitEvent = true;
          }

          if (this._isChecked == value) return;
          this._isChecked = value;
          var group = this._toggleContainer;

          if (group && group.enabled && this.enabled) {
            if (value || !group.anyTogglesChecked() && !group.allowSwitchOff) {
              this._isChecked = true;
              group.notifyToggleCheck(this, emitEvent);
            }
          }

          this.playEffect();

          if (emitEvent) {
            this._emitToggleEvents();
          }
        };

        _proto.playEffect = function playEffect() {
          if (this._checkMark) {
            this._checkMark.node.active = this._isChecked;
          }
        };

        _proto.setIsCheckedWithoutNotify = function setIsCheckedWithoutNotify(value) {
          this._set(value, false);
        };

        _proto.onEnable = function onEnable() {
          _Button.prototype.onEnable.call(this);

          this.playEffect();

          {
            this.node.on(Toggle.EventType.CLICK, this._internalToggle, this);
          }
        };

        _proto.onDisable = function onDisable() {
          _Button.prototype.onDisable.call(this);

          {
            this.node.off(Toggle.EventType.CLICK, this._internalToggle, this);
          }
        };

        _proto.OnDestroy = function OnDestroy() {
          var group = this._toggleContainer;

          if (group) {
            group.ensureValidState();
          }
        };

        _proto._emitToggleEvents = function _emitToggleEvents() {
          this.node.emit(Toggle.EventType.TOGGLE, this);

          if (this.checkEvents) {
            EventHandler.emitEvents(this.checkEvents, this);
          }
        };

        _createClass(Toggle, [{
          key: "isChecked",
          get: function get() {
            return this._isChecked;
          },
          set: function set(value) {
            this._set(value);
          }
        }, {
          key: "checkMark",
          get: function get() {
            return this._checkMark;
          },
          set: function set(value) {
            if (this._checkMark === value) {
              return;
            }

            this._checkMark = value;
          }
        }, {
          key: "_resizeToTarget",
          set: function set(value) {
            if (value) {
              this._resizeNodeToTargetNode();
            }
          }
        }, {
          key: "_toggleContainer",
          get: function get() {
            var parent = this.node.parent;

            if (legacyCC.Node.isNode(parent)) {
              return parent.getComponent('cc.ToggleContainer');
            }

            return null;
          }
        }]);

        return Toggle;
      }(Button), _class3$t.EventType = extendsEnum(EventType$4, EventType$1), _temp$10), (_applyDecoratedDescriptor(_class2$X.prototype, "isChecked", [_dec6$j, _dec7$h], Object.getOwnPropertyDescriptor(_class2$X.prototype, "isChecked"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "checkMark", [_dec8$h, _dec9$f, _dec10$f], Object.getOwnPropertyDescriptor(_class2$X.prototype, "checkMark"), _class2$X.prototype), _descriptor$P = _applyDecoratedDescriptor(_class2$X.prototype, "checkEvents", [_dec11$d, serializable, _dec12$d], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$A = _applyDecoratedDescriptor(_class2$X.prototype, "_isChecked", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor3$s = _applyDecoratedDescriptor(_class2$X.prototype, "_checkMark", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$X)) || _class$16) || _class$16) || _class$16) || _class$16) || _class$16));
      legacyCC.Toggle = Toggle;

      var _dec$15, _dec2$G, _dec3$z, _dec4$r, _dec5$n, _dec6$k, _dec7$i, _class$17, _class2$Y, _descriptor$Q, _descriptor2$B, _temp$11;
      var ToggleContainer = function (v) { return exports({ ToggleContainer: v, ToggleContainerComponent: v }), v; }((_dec$15 = ccclass('cc.ToggleContainer'), _dec2$G = help(), _dec3$z = executionOrder(110), _dec4$r = menu(), _dec5$n = tooltip(), _dec6$k = type([EventHandler]), _dec7$i = tooltip(), _dec$15(_class$17 = _dec2$G(_class$17 = _dec3$z(_class$17 = _dec4$r(_class$17 = executeInEditMode(_class$17 = (_class2$Y = (_temp$11 = function (_Component) {
        _inheritsLoose(ToggleContainer, _Component);

        function ToggleContainer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_allowSwitchOff", _descriptor$Q, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "checkEvents", _descriptor2$B, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = ToggleContainer.prototype;

        _proto.onEnable = function onEnable() {
          this.ensureValidState();
          this.node.on(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
          this.node.on(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
        };

        _proto.onDisable = function onDisable() {
          this.node.off(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
          this.node.off(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
        };

        _proto.activeToggles = function activeToggles() {
          return this.toggleItems.filter(function (x) {
            return x.isChecked;
          });
        };

        _proto.anyTogglesChecked = function anyTogglesChecked() {
          return !!this.toggleItems.find(function (x) {
            return x.isChecked;
          });
        };

        _proto.notifyToggleCheck = function notifyToggleCheck(toggle, emitEvent) {
          if (emitEvent === void 0) {
            emitEvent = true;
          }

          if (!this.enabledInHierarchy) {
            return;
          }

          for (var i = 0; i < this.toggleItems.length; i++) {
            var item = this.toggleItems[i];

            if (item === toggle) {
              continue;
            }

            if (emitEvent) {
              item.isChecked = false;
            } else {
              item.setIsCheckedWithoutNotify(false);
            }
          }

          if (this.checkEvents) {
            legacyCC.Component.EventHandler.emitEvents(this.checkEvents, toggle);
          }
        };

        _proto.ensureValidState = function ensureValidState() {
          var toggles = this.toggleItems;

          if (!this._allowSwitchOff && !this.anyTogglesChecked() && toggles.length !== 0) {
            var toggle = toggles[0];
            toggle.isChecked = true;
            this.notifyToggleCheck(toggle);
          }

          var activeToggles = this.activeToggles();

          if (activeToggles.length > 1) {
            var firstToggle = activeToggles[0];

            for (var i = 0; i < activeToggles.length; ++i) {
              var _toggle = activeToggles[i];

              if (_toggle === firstToggle) {
                continue;
              }

              _toggle.isChecked = false;
            }
          }
        };

        _createClass(ToggleContainer, [{
          key: "allowSwitchOff",
          get: function get() {
            return this._allowSwitchOff;
          },
          set: function set(value) {
            this._allowSwitchOff = value;
          }
        }, {
          key: "toggleItems",
          get: function get() {
            return this.node.children.map(function (item) {
              var toggle = item.getComponent('cc.Toggle');

              if (toggle && toggle.enabled) {
                return toggle;
              }

              return null;
            }).filter(Boolean);
          }
        }]);

        return ToggleContainer;
      }(Component), _temp$11), (_descriptor$Q = _applyDecoratedDescriptor(_class2$Y.prototype, "_allowSwitchOff", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2$Y.prototype, "allowSwitchOff", [_dec5$n], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "allowSwitchOff"), _class2$Y.prototype), _descriptor2$B = _applyDecoratedDescriptor(_class2$Y.prototype, "checkEvents", [_dec6$k, serializable, _dec7$i], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$Y)) || _class$17) || _class$17) || _class$17) || _class$17) || _class$17));
      legacyCC.ToggleContainer = ToggleContainer;

      var _dec$16, _dec2$H, _dec3$A, _dec4$s, _dec5$o, _dec6$l, _dec7$j, _dec8$i, _dec9$g, _dec10$g, _dec11$e, _dec12$e, _dec13$d, _dec14$b, _dec15$b, _dec16$a, _dec17$a, _dec18$a, _dec19$a, _dec20$a, _dec21$a, _dec22$a, _dec23$a, _class$18, _class2$Z, _descriptor$R, _descriptor2$C, _descriptor3$t, _descriptor4$p, _descriptor5$j, _descriptor6$b, _descriptor7$b, _descriptor8$b, _descriptor9$a, _descriptor10$a, _descriptor11$9, _descriptor12$8, _descriptor13$8, _descriptor14$7, _descriptor15$6, _descriptor16$6, _descriptor17$5, _descriptor18$4, _class3$u, _temp$12;

      var _tempScale = new Vec2();

      function getReadonlyNodeSize(parent) {
        if (parent instanceof Scene) {

          return visibleRect;
        } else if (parent._uiProps.uiTransformComp) {
          return parent._uiProps.uiTransformComp.contentSize;
        } else {
          return Size.ZERO;
        }
      }
      function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
        if (widgetNode.parent) {
          _tempScale.set(widgetNode.parent.getScale().x, widgetNode.parent.getScale().y);
        } else {
          _tempScale.set(0, 0);
        }

        var scaleX = _tempScale.x;
        var scaleY = _tempScale.y;
        var translateX = 0;
        var translateY = 0;

        for (var node = widgetNode.parent;;) {
          if (!node) {
            out_inverseTranslate.x = out_inverseTranslate.y = 0;
            out_inverseScale.x = out_inverseScale.y = 1;
            return;
          }

          var pos = node.getPosition();
          translateX += pos.x;
          translateY += pos.y;
          node = node.parent;

          if (node !== target) {
            if (node) {
              _tempScale.set(node.getScale().x, node.getScale().y);
            } else {
              _tempScale.set(0, 0);
            }

            var sx = _tempScale.x;
            var sy = _tempScale.y;
            translateX *= sx;
            translateY *= sy;
            scaleX *= sx;
            scaleY *= sy;
          } else {
            break;
          }
        }

        out_inverseScale.x = scaleX !== 0 ? 1 / scaleX : 1;
        out_inverseScale.y = scaleY !== 0 ? 1 / scaleY : 1;
        out_inverseTranslate.x = -translateX;
        out_inverseTranslate.y = -translateY;
      }
      var AlignMode;

      (function (AlignMode) {
        AlignMode[AlignMode["ONCE"] = 0] = "ONCE";
        AlignMode[AlignMode["ALWAYS"] = 1] = "ALWAYS";
        AlignMode[AlignMode["ON_WINDOW_RESIZE"] = 2] = "ON_WINDOW_RESIZE";
      })(AlignMode || (AlignMode = {}));

      ccenum(AlignMode);
      var AlignFlags;

      (function (AlignFlags) {
        AlignFlags[AlignFlags["TOP"] = 1] = "TOP";
        AlignFlags[AlignFlags["MID"] = 2] = "MID";
        AlignFlags[AlignFlags["BOT"] = 4] = "BOT";
        AlignFlags[AlignFlags["LEFT"] = 8] = "LEFT";
        AlignFlags[AlignFlags["CENTER"] = 16] = "CENTER";
        AlignFlags[AlignFlags["RIGHT"] = 32] = "RIGHT";
        AlignFlags[AlignFlags["HORIZONTAL"] = 56] = "HORIZONTAL";
        AlignFlags[AlignFlags["VERTICAL"] = 7] = "VERTICAL";
      })(AlignFlags || (AlignFlags = {}));

      var TOP_BOT = AlignFlags.TOP | AlignFlags.BOT;
      var LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT;
      var Widget = function (v) { return exports({ Widget: v, WidgetComponent: v }), v; }((_dec$16 = ccclass('cc.Widget'), _dec2$H = help(), _dec3$A = executionOrder(110), _dec4$s = menu(), _dec5$o = requireComponent(UITransform), _dec6$l = type(Node$1), _dec7$j = tooltip(), _dec8$i = tooltip(), _dec9$g = tooltip(), _dec10$g = tooltip(), _dec11$e = tooltip(), _dec12$e = tooltip(), _dec13$d = tooltip(), _dec14$b = visible(), _dec15$b = visible(), _dec16$a = tooltip(), _dec17$a = tooltip(), _dec18$a = tooltip(), _dec19$a = tooltip(), _dec20$a = tooltip(), _dec21$a = tooltip(), _dec22$a = type(AlignMode), _dec23$a = tooltip(), _dec$16(_class$18 = _dec2$H(_class$18 = _dec3$A(_class$18 = _dec4$s(_class$18 = _dec5$o(_class$18 = executeInEditMode(_class$18 = (_class2$Z = (_temp$12 = _class3$u = function (_Component) {
        _inheritsLoose(Widget, _Component);

        function Widget() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._lastPos = new Vec3();
          _this._lastSize = new Size();
          _this._dirty = true;
          _this._hadAlignOnce = false;

          _initializerDefineProperty(_this, "_alignFlags", _descriptor$R, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_target", _descriptor2$C, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_left", _descriptor3$t, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_right", _descriptor4$p, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_top", _descriptor5$j, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_bottom", _descriptor6$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalCenter", _descriptor7$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalCenter", _descriptor8$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsLeft", _descriptor9$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsRight", _descriptor10$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsTop", _descriptor11$9, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsBottom", _descriptor12$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsHorizontalCenter", _descriptor13$8, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isAbsVerticalCenter", _descriptor14$7, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_originalWidth", _descriptor15$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_originalHeight", _descriptor16$6, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_alignMode", _descriptor17$5, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lockFlags", _descriptor18$4, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = Widget.prototype;

        _proto.updateAlignment = function updateAlignment() {
          legacyCC._widgetManager.updateAlignment(this.node);
        };

        _proto._validateTargetInDEV = function _validateTargetInDEV() {
          {
            return;
          }
        };

        _proto.setDirty = function setDirty() {
          this._recursiveDirty();
        };

        _proto.onEnable = function onEnable() {
          this.node.getPosition(this._lastPos);

          this._lastSize.set(this.node._uiProps.uiTransformComp.contentSize);

          legacyCC._widgetManager.add(this);

          this._hadAlignOnce = false;

          this._registerEvent();

          this._registerTargetEvents();
        };

        _proto.onDisable = function onDisable() {
          legacyCC._widgetManager.remove(this);

          this._unregisterEvent();

          this._unregisterTargetEvents();
        };

        _proto.onDestroy = function onDestroy() {
          this._removeParentEvent();
        };

        _proto._adjustWidgetToAllowMovingInEditor = function _adjustWidgetToAllowMovingInEditor(eventType) {};

        _proto._adjustWidgetToAllowResizingInEditor = function _adjustWidgetToAllowResizingInEditor() {};

        _proto._adjustWidgetToAnchorChanged = function _adjustWidgetToAnchorChanged() {
          this.setDirty();
        };

        _proto._adjustTargetToParentChanged = function _adjustTargetToParentChanged(oldParent) {
          if (oldParent) {
            this._unregisterOldParentEvents(oldParent);
          }

          if (this.node.getParent()) {
            this._registerTargetEvents();
          }

          this._setDirtyByMode();
        };

        _proto._registerEvent = function _registerEvent() {
          {
            this.node.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            this.node.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }

          this.node.on(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
          this.node.on(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        };

        _proto._unregisterEvent = function _unregisterEvent() {
          {
            this.node.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            this.node.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }

          this.node.off(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
        };

        _proto._removeParentEvent = function _removeParentEvent() {
          this.node.off(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        };

        _proto._autoChangedValue = function _autoChangedValue(flag, isAbs) {
          var current = (this._alignFlags & flag) > 0;

          if (!current) {
            return;
          }

          var parentUiProps = this.node.parent && this.node.parent._uiProps;
          var parentTrans = parentUiProps && parentUiProps.uiTransformComp;
          var size = parentTrans ? parentTrans.contentSize : visibleRect;

          if (this.isAlignLeft && flag === AlignFlags.LEFT) {
            this._left = isAbs ? this._left * size.width : this._left / size.width;
          } else if (this.isAlignRight && flag === AlignFlags.RIGHT) {
            this._right = isAbs ? this._right * size.width : this._right / size.width;
          } else if (this.isAlignHorizontalCenter && flag === AlignFlags.CENTER) {
            this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width;
          } else if (this.isAlignTop && flag === AlignFlags.TOP) {
            this._top = isAbs ? this._top * size.height : this._top / size.height;
          } else if (this.isAlignBottom && flag === AlignFlags.BOT) {
            this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height;
          } else if (this.isAbsoluteVerticalCenter && flag === AlignFlags.MID) {
            this._verticalCenter = isAbs ? this._verticalCenter / size.height : this._verticalCenter / size.height;
          }

          this._recursiveDirty();
        };

        _proto._registerTargetEvents = function _registerTargetEvents() {
          var target = this._target || this.node.parent;

          if (target) {
            if (target.getComponent(UITransform)) {
              target.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
              target.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
              target.on(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
            }
          }
        };

        _proto._unregisterTargetEvents = function _unregisterTargetEvents() {
          var target = this._target || this.node.parent;

          if (target) {
            target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
          }
        };

        _proto._unregisterOldParentEvents = function _unregisterOldParentEvents(oldParent) {
          var target = this._target || oldParent;

          if (target) {
            target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
            target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
          }
        };

        _proto._setDirtyByMode = function _setDirtyByMode() {
          if (this.alignMode === AlignMode.ALWAYS || EDITOR) {
            this._recursiveDirty();
          }
        };

        _proto._setAlign = function _setAlign(flag, isAlign) {
          var current = (this._alignFlags & flag) > 0;

          if (isAlign === current) {
            return;
          }

          var isHorizontal = (flag & LEFT_RIGHT) > 0;
          var trans = this.node._uiProps.uiTransformComp;

          if (isAlign) {
            this._alignFlags |= flag;

            if (isHorizontal) {
              this.isAlignHorizontalCenter = false;

              if (this.isStretchWidth) {
                this._originalWidth = trans.width;
              }
            } else {
              this.isAlignVerticalCenter = false;

              if (this.isStretchHeight) {
                this._originalHeight = trans.height;
              }
            }
          } else {
            if (isHorizontal) {
              if (this.isStretchWidth) {
                trans.width = this._originalWidth;
              }
            } else if (this.isStretchHeight) {
              trans.height = this._originalHeight;
            }

            this._alignFlags &= ~flag;
          }
        };

        _proto._recursiveDirty = function _recursiveDirty() {
          if (this._dirty) {
            return;
          }

          this._dirty = true;
        };

        _createClass(Widget, [{
          key: "target",
          get: function get() {
            return this._target;
          },
          set: function set(value) {
            if (this._target === value) {
              return;
            }

            this._unregisterTargetEvents();

            this._target = value;

            this._registerTargetEvents();

            this._validateTargetInDEV();

            this._recursiveDirty();
          }
        }, {
          key: "isAlignTop",
          get: function get() {
            return (this._alignFlags & AlignFlags.TOP) > 0;
          },
          set: function set(value) {
            this._setAlign(AlignFlags.TOP, value);

            this._recursiveDirty();
          }
        }, {
          key: "isAlignBottom",
          get: function get() {
            return (this._alignFlags & AlignFlags.BOT) > 0;
          },
          set: function set(value) {
            this._setAlign(AlignFlags.BOT, value);

            this._recursiveDirty();
          }
        }, {
          key: "isAlignLeft",
          get: function get() {
            return (this._alignFlags & AlignFlags.LEFT) > 0;
          },
          set: function set(value) {
            this._setAlign(AlignFlags.LEFT, value);

            this._recursiveDirty();
          }
        }, {
          key: "isAlignRight",
          get: function get() {
            return (this._alignFlags & AlignFlags.RIGHT) > 0;
          },
          set: function set(value) {
            this._setAlign(AlignFlags.RIGHT, value);

            this._recursiveDirty();
          }
        }, {
          key: "isAlignVerticalCenter",
          get: function get() {
            return (this._alignFlags & AlignFlags.MID) > 0;
          },
          set: function set(value) {
            if (value) {
              this.isAlignTop = false;
              this.isAlignBottom = false;
              this._alignFlags |= AlignFlags.MID;
            } else {
              this._alignFlags &= ~AlignFlags.MID;
            }

            this._recursiveDirty();
          }
        }, {
          key: "isAlignHorizontalCenter",
          get: function get() {
            return (this._alignFlags & AlignFlags.CENTER) > 0;
          },
          set: function set(value) {
            if (value) {
              this.isAlignLeft = false;
              this.isAlignRight = false;
              this._alignFlags |= AlignFlags.CENTER;
            } else {
              this._alignFlags &= ~AlignFlags.CENTER;
            }

            this._recursiveDirty();
          }
        }, {
          key: "isStretchWidth",
          get: function get() {
            return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
          }
        }, {
          key: "isStretchHeight",
          get: function get() {
            return (this._alignFlags & TOP_BOT) === TOP_BOT;
          }
        }, {
          key: "top",
          get: function get() {
            return this._top;
          },
          set: function set(value) {
            this._top = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorTop",
          get: function get() {
            return this._isAbsTop ? this._top : this._top * 100;
          },
          set: function set(value) {
            this._top = this._isAbsTop ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "bottom",
          get: function get() {
            return this._bottom;
          },
          set: function set(value) {
            this._bottom = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorBottom",
          get: function get() {
            return this._isAbsBottom ? this._bottom : this._bottom * 100;
          },
          set: function set(value) {
            this._bottom = this._isAbsBottom ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "left",
          get: function get() {
            return this._left;
          },
          set: function set(value) {
            this._left = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorLeft",
          get: function get() {
            return this._isAbsLeft ? this._left : this._left * 100;
          },
          set: function set(value) {
            this._left = this._isAbsLeft ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "right",
          get: function get() {
            return this._right;
          },
          set: function set(value) {
            this._right = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorRight",
          get: function get() {
            return this._isAbsRight ? this._right : this._right * 100;
          },
          set: function set(value) {
            this._right = this._isAbsRight ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "horizontalCenter",
          get: function get() {
            return this._horizontalCenter;
          },
          set: function set(value) {
            this._horizontalCenter = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorHorizontalCenter",
          get: function get() {
            return this._isAbsHorizontalCenter ? this._horizontalCenter : this._horizontalCenter * 100;
          },
          set: function set(value) {
            this._horizontalCenter = this._isAbsHorizontalCenter ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "verticalCenter",
          get: function get() {
            return this._verticalCenter;
          },
          set: function set(value) {
            this._verticalCenter = value;

            this._recursiveDirty();
          }
        }, {
          key: "editorVerticalCenter",
          get: function get() {
            return this._isAbsVerticalCenter ? this._verticalCenter : this._verticalCenter * 100;
          },
          set: function set(value) {
            this._verticalCenter = this._isAbsVerticalCenter ? value : value / 100;

            this._recursiveDirty();
          }
        }, {
          key: "isAbsoluteTop",
          get: function get() {
            return this._isAbsTop;
          },
          set: function set(value) {
            if (this._isAbsTop === value) {
              return;
            }

            this._isAbsTop = value;

            this._autoChangedValue(AlignFlags.TOP, this._isAbsTop);
          }
        }, {
          key: "isAbsoluteBottom",
          get: function get() {
            return this._isAbsBottom;
          },
          set: function set(value) {
            if (this._isAbsBottom === value) {
              return;
            }

            this._isAbsBottom = value;

            this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom);
          }
        }, {
          key: "isAbsoluteLeft",
          get: function get() {
            return this._isAbsLeft;
          },
          set: function set(value) {
            if (this._isAbsLeft === value) {
              return;
            }

            this._isAbsLeft = value;

            this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft);
          }
        }, {
          key: "isAbsoluteRight",
          get: function get() {
            return this._isAbsRight;
          },
          set: function set(value) {
            if (this._isAbsRight === value) {
              return;
            }

            this._isAbsRight = value;

            this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight);
          }
        }, {
          key: "isAbsoluteHorizontalCenter",
          get: function get() {
            return this._isAbsHorizontalCenter;
          },
          set: function set(value) {
            if (this._isAbsHorizontalCenter === value) {
              return;
            }

            this._isAbsHorizontalCenter = value;

            this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter);
          }
        }, {
          key: "isAbsoluteVerticalCenter",
          get: function get() {
            return this._isAbsVerticalCenter;
          },
          set: function set(value) {
            if (this._isAbsVerticalCenter === value) {
              return;
            }

            this._isAbsVerticalCenter = value;

            this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter);
          }
        }, {
          key: "alignMode",
          get: function get() {
            return this._alignMode;
          },
          set: function set(value) {
            this._alignMode = value;

            this._recursiveDirty();
          }
        }, {
          key: "alignFlags",
          get: function get() {
            return this._alignFlags;
          },
          set: function set(value) {
            if (this._alignFlags === value) {
              return;
            }

            this._alignFlags = value;

            this._recursiveDirty();
          }
        }]);

        return Widget;
      }(Component), _class3$u.AlignMode = AlignMode, _temp$12), (_applyDecoratedDescriptor(_class2$Z.prototype, "target", [_dec6$l, _dec7$j], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "target"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAlignTop", [_dec8$i], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAlignTop"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAlignBottom", [_dec9$g], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAlignBottom"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAlignLeft", [_dec10$g], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAlignLeft"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAlignRight", [_dec11$e], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAlignRight"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAlignVerticalCenter", [_dec12$e], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAlignVerticalCenter"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAlignHorizontalCenter", [_dec13$d], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAlignHorizontalCenter"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isStretchWidth", [_dec14$b], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isStretchWidth"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isStretchHeight", [_dec15$b], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isStretchHeight"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "top", [_dec16$a], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "top"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "editorTop", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "editorTop"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "bottom", [_dec17$a], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "bottom"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "editorBottom", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "editorBottom"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "left", [_dec18$a], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "left"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "editorLeft", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "editorLeft"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "right", [_dec19$a], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "right"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "editorRight", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "editorRight"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "horizontalCenter", [_dec20$a], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "horizontalCenter"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "editorHorizontalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "editorHorizontalCenter"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "verticalCenter", [_dec21$a], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "verticalCenter"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "editorVerticalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "editorVerticalCenter"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAbsoluteTop", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAbsoluteTop"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAbsoluteBottom", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAbsoluteBottom"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAbsoluteLeft", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAbsoluteLeft"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAbsoluteRight", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAbsoluteRight"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAbsoluteHorizontalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAbsoluteHorizontalCenter"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "isAbsoluteVerticalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "isAbsoluteVerticalCenter"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "alignMode", [_dec22$a, _dec23$a], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "alignMode"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "alignFlags", [editable], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "alignFlags"), _class2$Z.prototype), _descriptor$R = _applyDecoratedDescriptor(_class2$Z.prototype, "_alignFlags", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2$C = _applyDecoratedDescriptor(_class2$Z.prototype, "_target", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$t = _applyDecoratedDescriptor(_class2$Z.prototype, "_left", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor4$p = _applyDecoratedDescriptor(_class2$Z.prototype, "_right", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor5$j = _applyDecoratedDescriptor(_class2$Z.prototype, "_top", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor6$b = _applyDecoratedDescriptor(_class2$Z.prototype, "_bottom", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$b = _applyDecoratedDescriptor(_class2$Z.prototype, "_horizontalCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor8$b = _applyDecoratedDescriptor(_class2$Z.prototype, "_verticalCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor9$a = _applyDecoratedDescriptor(_class2$Z.prototype, "_isAbsLeft", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor10$a = _applyDecoratedDescriptor(_class2$Z.prototype, "_isAbsRight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor11$9 = _applyDecoratedDescriptor(_class2$Z.prototype, "_isAbsTop", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor12$8 = _applyDecoratedDescriptor(_class2$Z.prototype, "_isAbsBottom", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor13$8 = _applyDecoratedDescriptor(_class2$Z.prototype, "_isAbsHorizontalCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor14$7 = _applyDecoratedDescriptor(_class2$Z.prototype, "_isAbsVerticalCenter", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor15$6 = _applyDecoratedDescriptor(_class2$Z.prototype, "_originalWidth", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor16$6 = _applyDecoratedDescriptor(_class2$Z.prototype, "_originalHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor17$5 = _applyDecoratedDescriptor(_class2$Z.prototype, "_alignMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return AlignMode.ON_WINDOW_RESIZE;
        }
      }), _descriptor18$4 = _applyDecoratedDescriptor(_class2$Z.prototype, "_lockFlags", [serializable, editorOnly], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$Z)) || _class$18) || _class$18) || _class$18) || _class$18) || _class$18) || _class$18));
      legacyCC.internal.computeInverseTransForTarget = computeInverseTransForTarget;
      legacyCC.internal.getReadonlyNodeSize = getReadonlyNodeSize;
      legacyCC.Widget = Widget;

      var _dec$17, _dec2$I, _dec3$B, _dec4$t, _dec5$p, _dec6$m, _dec7$k, _dec8$j, _dec9$h, _dec10$h, _dec11$f, _class$19, _class2$_, _descriptor$S, _descriptor2$D, _descriptor3$u, _descriptor4$q, _class3$v, _temp$13;

      var _color = new Color();

      var Direction$2;

      (function (Direction) {
        Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
        Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
      })(Direction$2 || (Direction$2 = {}));

      ccenum(Direction$2);
      var PageViewIndicator = function (v) { return exports({ PageViewIndicator: v, PageViewIndicatorComponent: v }), v; }((_dec$17 = ccclass('cc.PageViewIndicator'), _dec2$I = help(), _dec3$B = executionOrder(110), _dec4$t = menu(), _dec5$p = type(SpriteFrame), _dec6$m = tooltip(), _dec7$k = type(Direction$2), _dec8$j = tooltip(), _dec9$h = type(Size), _dec10$h = tooltip(), _dec11$f = tooltip(), _dec$17(_class$19 = _dec2$I(_class$19 = _dec3$B(_class$19 = _dec4$t(_class$19 = (_class2$_ = (_temp$13 = _class3$v = function (_Component) {
        _inheritsLoose(PageViewIndicator, _Component);

        function PageViewIndicator() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "spacing", _descriptor$S, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spriteFrame", _descriptor2$D, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor3$u, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cellSize", _descriptor4$q, _assertThisInitialized(_this));

          _this._layout = null;
          _this._pageView = null;
          _this._indicators = [];
          return _this;
        }

        var _proto = PageViewIndicator.prototype;

        _proto.onLoad = function onLoad() {
          this._updateLayout();
        };

        _proto.setPageView = function setPageView(target) {
          this._pageView = target;

          this._refresh();
        };

        _proto._updateLayout = function _updateLayout() {
          this._layout = this.getComponent(Layout);

          if (!this._layout) {
            this._layout = this.addComponent(Layout);
          }

          var layout = this._layout;

          if (this.direction === Direction$2.HORIZONTAL) {
            layout.type = Layout.Type.HORIZONTAL;
            layout.spacingX = this.spacing;
          } else if (this.direction === Direction$2.VERTICAL) {
            layout.type = Layout.Type.VERTICAL;
            layout.spacingY = this.spacing;
          }

          layout.resizeMode = Layout.ResizeMode.CONTAINER;
        };

        _proto._createIndicator = function _createIndicator() {
          var node = new Node$1();
          node.layer = this.node.layer;
          var sprite = node.addComponent(Sprite);
          sprite.spriteFrame = this.spriteFrame;
          sprite.sizeMode = Sprite.SizeMode.CUSTOM;
          node.parent = this.node;

          node._uiProps.uiTransformComp.setContentSize(this._cellSize);

          return node;
        };

        _proto._changedState = function _changedState() {
          var indicators = this._indicators;

          if (indicators.length === 0 || !this._pageView) {
            return;
          }

          var idx = this._pageView.curPageIdx;

          if (idx >= indicators.length) {
            return;
          }

          for (var i = 0; i < indicators.length; ++i) {
            var node = indicators[i];

            if (!node._uiProps.uiComp) {
              continue;
            }

            var uiComp = node._uiProps.uiComp;

            _color.set(uiComp.color);

            _color.a = 255 / 2;
            uiComp.color = _color;
          }

          if (indicators[idx]._uiProps.uiComp) {
            var comp = indicators[idx]._uiProps.uiComp;

            _color.set(comp.color);

            _color.a = 255;
            comp.color = _color;
          }
        };

        _proto._refresh = function _refresh() {
          if (!this._pageView) {
            return;
          }

          var indicators = this._indicators;

          var pages = this._pageView.getPages();

          if (pages.length === indicators.length) {
            return;
          }

          var i = 0;

          if (pages.length > indicators.length) {
            for (i = 0; i < pages.length; ++i) {
              if (!indicators[i]) {
                indicators[i] = this._createIndicator();
              }
            }
          } else {
            var count = indicators.length - pages.length;

            for (i = count; i > 0; --i) {
              var node = indicators[i - 1];
              this.node.removeChild(node);
              indicators.splice(i - 1, 1);
            }
          }

          if (this._layout && this._layout.enabledInHierarchy) {
            this._layout.updateLayout();
          }

          this._changedState();
        };

        _createClass(PageViewIndicator, [{
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value) {
            if (this._spriteFrame === value) {
              return;
            }

            this._spriteFrame = value;
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) {
              return;
            }

            this._direction = value;
          }
        }, {
          key: "cellSize",
          get: function get() {
            return this._cellSize;
          },
          set: function set(value) {
            if (this._cellSize === value) {
              return;
            }

            this._cellSize = value;
          }
        }]);

        return PageViewIndicator;
      }(Component), _class3$v.Direction = Direction$2, _temp$13), (_applyDecoratedDescriptor(_class2$_.prototype, "spriteFrame", [_dec5$p, _dec6$m], Object.getOwnPropertyDescriptor(_class2$_.prototype, "spriteFrame"), _class2$_.prototype), _applyDecoratedDescriptor(_class2$_.prototype, "direction", [_dec7$k, _dec8$j], Object.getOwnPropertyDescriptor(_class2$_.prototype, "direction"), _class2$_.prototype), _applyDecoratedDescriptor(_class2$_.prototype, "cellSize", [_dec9$h, _dec10$h], Object.getOwnPropertyDescriptor(_class2$_.prototype, "cellSize"), _class2$_.prototype), _descriptor$S = _applyDecoratedDescriptor(_class2$_.prototype, "spacing", [serializable, _dec11$f], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2$D = _applyDecoratedDescriptor(_class2$_.prototype, "_spriteFrame", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$u = _applyDecoratedDescriptor(_class2$_.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Direction$2.HORIZONTAL;
        }
      }), _descriptor4$q = _applyDecoratedDescriptor(_class2$_.prototype, "_cellSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Size(20, 20);
        }
      })), _class2$_)) || _class$19) || _class$19) || _class$19) || _class$19));
      legacyCC.PageViewIndicator = PageViewIndicator;

      var _dec$18, _dec2$J, _dec3$C, _dec4$u, _dec5$q, _dec6$n, _dec7$l, _dec8$k, _dec9$i, _dec10$i, _dec11$g, _dec12$f, _dec13$e, _dec14$c, _dec15$c, _dec16$b, _dec17$b, _dec18$b, _dec19$b, _dec20$b, _dec21$b, _dec22$b, _dec23$b, _dec24$a, _dec25$a, _dec26$9, _dec27$9, _class$1a, _class2$$, _descriptor$T, _descriptor2$E, _descriptor3$v, _descriptor4$r, _descriptor5$k, _descriptor6$c, _descriptor7$c, _descriptor8$c, _descriptor9$b, _descriptor10$b, _descriptor11$a, _descriptor12$9, _class3$w, _temp$14;

      var _tempVec2$2 = new Vec2();

      var SizeMode$1;

      (function (SizeMode) {
        SizeMode[SizeMode["Unified"] = 0] = "Unified";
        SizeMode[SizeMode["Free"] = 1] = "Free";
      })(SizeMode$1 || (SizeMode$1 = {}));

      ccenum(SizeMode$1);
      var Direction$3;

      (function (Direction) {
        Direction[Direction["Horizontal"] = 0] = "Horizontal";
        Direction[Direction["Vertical"] = 1] = "Vertical";
      })(Direction$3 || (Direction$3 = {}));

      ccenum(Direction$3);
      var EventType$5;

      (function (EventType) {
        EventType["PAGE_TURNING"] = "page-turning";
      })(EventType$5 || (EventType$5 = {}));

      var PageView = function (v) { return exports({ PageView: v, PageViewComponent: v }), v; }((_dec$18 = ccclass('cc.PageView'), _dec2$J = help(), _dec3$C = executionOrder(110), _dec4$u = menu(), _dec5$q = type(SizeMode$1), _dec6$n = tooltip(), _dec7$l = type(Direction$3), _dec8$k = tooltip(), _dec9$i = range(), _dec10$i = tooltip(), _dec11$g = range(), _dec12$f = tooltip(), _dec13$e = type(PageViewIndicator), _dec14$c = tooltip(), _dec15$c = tooltip(), _dec16$b = type(ScrollBar), _dec17$b = visible(), _dec18$b = type(ScrollBar), _dec19$b = visible(), _dec20$b = visible(), _dec21$b = visible(), _dec22$b = visible(), _dec23$b = type([EventHandler]), _dec24$a = visible(), _dec25$a = tooltip(), _dec26$9 = type([EventHandler]), _dec27$9 = tooltip(), _dec$18(_class$1a = _dec2$J(_class$1a = _dec3$C(_class$1a = _dec4$u(_class$1a = (_class2$$ = (_temp$14 = _class3$w = function (_ScrollView) {
        _inheritsLoose(PageView, _ScrollView);

        function PageView() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _ScrollView.call.apply(_ScrollView, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "autoPageTurningThreshold", _descriptor$T, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "horizontal", _descriptor2$E, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "vertical", _descriptor3$v, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor4$r, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "scrollEvents", _descriptor5$k, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "pageTurningSpeed", _descriptor6$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "pageEvents", _descriptor7$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_sizeMode", _descriptor8$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_direction", _descriptor9$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_scrollThreshold", _descriptor10$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_pageTurningEventTiming", _descriptor11$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_indicator", _descriptor12$9, _assertThisInitialized(_this));

          _this._curPageIdx = 0;
          _this._lastPageIdx = 0;
          _this._pages = [];
          _this._initContentPos = new Vec3();
          _this._scrollCenterOffsetX = [];
          _this._scrollCenterOffsetY = [];
          _this._touchBeganPosition = new Vec2();
          _this._touchEndPosition = new Vec2();
          return _this;
        }

        var _proto = PageView.prototype;

        _proto.onEnable = function onEnable() {
          _ScrollView.prototype.onEnable.call(this);

          this.node.on(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

          {
            this.node.on(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
          }
        };

        _proto.onDisable = function onDisable() {
          _ScrollView.prototype.onDisable.call(this);

          this.node.off(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

          {
            this.node.off(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
          }
        };

        _proto.onLoad = function onLoad() {
          this._initPages();

          if (this.indicator) {
            this.indicator.setPageView(this);
          }
        };

        _proto.getCurrentPageIndex = function getCurrentPageIndex() {
          return this._curPageIdx;
        };

        _proto.setCurrentPageIndex = function setCurrentPageIndex(index) {
          this.scrollToPage(index, 1);
        };

        _proto.getPages = function getPages() {
          return this._pages;
        };

        _proto.addPage = function addPage(page) {
          if (!page || this._pages.indexOf(page) !== -1 || !this.content) {
            return;
          }

          if (!page._uiProps.uiTransformComp) {
            logID(4301);
            return;
          }

          this.content.addChild(page);

          this._pages.push(page);

          this._updatePageView();
        };

        _proto.insertPage = function insertPage(page, index) {
          if (index < 0 || !page || this._pages.indexOf(page) !== -1 || !this.content) {
            return;
          }

          var pageCount = this._pages.length;

          if (index >= pageCount) {
            this.addPage(page);
          } else {
            if (!page._uiProps.uiTransformComp) {
              logID(4301);
              return;
            }

            this._pages.splice(index, 0, page);

            this.content.insertChild(page, index);

            this._updatePageView();
          }
        };

        _proto.removePage = function removePage(page) {
          if (!page || !this.content) {
            return;
          }

          var index = this._pages.indexOf(page);

          if (index === -1) {
            warnID(4300, page.name);
            return;
          }

          this.removePageAtIndex(index);
        };

        _proto.removePageAtIndex = function removePageAtIndex(index) {
          var pageList = this._pages;

          if (index < 0 || index >= pageList.length) {
            return;
          }

          var page = pageList[index];

          if (!page || !this.content) {
            return;
          }

          this.content.removeChild(page);
          pageList.splice(index, 1);

          this._updatePageView();
        };

        _proto.removeAllPages = function removeAllPages() {
          if (!this.content) {
            return;
          }

          var locPages = this._pages;

          for (var i = 0, len = locPages.length; i < len; i++) {
            this.content.removeChild(locPages[i]);
          }

          this._pages.length = 0;

          this._updatePageView();
        };

        _proto.scrollToPage = function scrollToPage(idx, timeInSecond) {
          if (timeInSecond === void 0) {
            timeInSecond = 0.3;
          }

          if (idx < 0 || idx >= this._pages.length) {
            return;
          }

          this._curPageIdx = idx;
          this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);

          if (this.indicator) {
            this.indicator._changedState();
          }
        };

        _proto.getScrollEndedEventTiming = function getScrollEndedEventTiming() {
          return this.pageTurningEventTiming;
        };

        _proto._updatePageView = function _updatePageView() {
          if (!this.content) {
            return;
          }

          var layout = this.content.getComponent(Layout);

          if (layout && layout.enabled) {
            layout.updateLayout();
          }

          var pageCount = this._pages.length;

          if (this._curPageIdx >= pageCount) {
            this._curPageIdx = pageCount === 0 ? 0 : pageCount - 1;
            this._lastPageIdx = this._curPageIdx;
          }

          var contentPos = this._initContentPos;

          for (var i = 0; i < pageCount; ++i) {
            var page = this._pages[i];
            var pos = page.position;

            if (this.direction === Direction$3.Horizontal) {
              this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x);
            } else {
              this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
            }
          }

          if (this.indicator) {
            this.indicator._refresh();
          }
        };

        _proto._updateAllPagesSize = function _updateAllPagesSize() {
          var viewTrans = this.view;

          if (!this.content || !viewTrans) {
            return;
          }

          if (this._sizeMode !== SizeMode$1.Unified) {
            return;
          }

          var locPages =  this._pages;
          var selfSize = viewTrans.contentSize;

          for (var i = 0, len = locPages.length; i < len; i++) {
            locPages[i]._uiProps.uiTransformComp.setContentSize(selfSize);
          }
        };

        _proto._handleReleaseLogic = function _handleReleaseLogic() {
          this._autoScrollToPage();

          if (this._scrolling) {
            this._scrolling = false;

            if (!this._autoScrolling) {
              this._dispatchEvent(PageView.EventType.SCROLL_ENDED);
            }
          }
        };

        _proto._onTouchBegan = function _onTouchBegan(event, captureListeners) {
          event.touch.getUILocation(_tempVec2$2);
          Vec2.set(this._touchBeganPosition, _tempVec2$2.x, _tempVec2$2.y);

          _ScrollView.prototype._onTouchBegan.call(this, event, captureListeners);
        };

        _proto._onTouchMoved = function _onTouchMoved(event, captureListeners) {
          _ScrollView.prototype._onTouchMoved.call(this, event, captureListeners);
        };

        _proto._onTouchEnded = function _onTouchEnded(event, captureListeners) {
          event.touch.getUILocation(_tempVec2$2);
          Vec2.set(this._touchEndPosition, _tempVec2$2.x, _tempVec2$2.y);

          _ScrollView.prototype._onTouchEnded.call(this, event, captureListeners);
        };

        _proto._onTouchCancelled = function _onTouchCancelled(event, captureListeners) {
          event.touch.getUILocation(_tempVec2$2);
          Vec2.set(this._touchEndPosition, _tempVec2$2.x, _tempVec2$2.y);

          _ScrollView.prototype._onTouchCancelled.call(this, event, captureListeners);
        };

        _proto._onMouseWheel = function _onMouseWheel() {};

        _proto._syncScrollDirection = function _syncScrollDirection() {
          this.horizontal = this.direction === Direction$3.Horizontal;
          this.vertical = this.direction === Direction$3.Vertical;
        };

        _proto._syncSizeMode = function _syncSizeMode() {
          var viewTrans = this.view;

          if (!this.content || !viewTrans) {
            return;
          }

          var layout = this.content.getComponent(Layout);

          if (layout) {
            if (this._sizeMode === SizeMode$1.Free && this._pages.length > 0) {
              var firstPageTrans = this._pages[0]._uiProps.uiTransformComp;
              var lastPageTrans = this._pages[this._pages.length - 1]._uiProps.uiTransformComp;

              if (this.direction === Direction$3.Horizontal) {
                layout.paddingLeft = (viewTrans.width - firstPageTrans.width) / 2;
                layout.paddingRight = (viewTrans.width - lastPageTrans.width) / 2;
              } else if (this.direction === Direction$3.Vertical) {
                layout.paddingTop = (viewTrans.height - firstPageTrans.height) / 2;
                layout.paddingBottom = (viewTrans.height - lastPageTrans.height) / 2;
              }
            }

            layout.updateLayout();
          }
        };

        _proto._initPages = function _initPages() {
          if (!this.content) {
            return;
          }

          this._initContentPos = this.content.position;
          var children = this.content.children;

          for (var i = 0; i < children.length; ++i) {
            var page = children[i];

            if (this._pages.indexOf(page) >= 0) {
              continue;
            }

            this._pages.push(page);
          }

          this._syncScrollDirection();

          this._syncSizeMode();

          this._updatePageView();
        };

        _proto._dispatchPageTurningEvent = function _dispatchPageTurningEvent() {
          if (this._lastPageIdx === this._curPageIdx) {
            return;
          }

          this._lastPageIdx = this._curPageIdx;
          EventHandler.emitEvents(this.pageEvents, this, EventType$5.PAGE_TURNING);
          this.node.emit(EventType$5.PAGE_TURNING, this);
        };

        _proto._isQuicklyScrollable = function _isQuicklyScrollable(touchMoveVelocity) {
          if (this.direction === Direction$3.Horizontal) {
            if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) {
              return true;
            }
          } else if (this.direction === Direction$3.Vertical) {
            if (Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) {
              return true;
            }
          }

          return false;
        };

        _proto._moveOffsetValue = function _moveOffsetValue(idx) {
          var offset = new Vec2();

          if (this._sizeMode === SizeMode$1.Free) {
            if (this.direction === Direction$3.Horizontal) {
              offset.x = this._scrollCenterOffsetX[idx];
            } else if (this.direction === Direction$3.Vertical) {
              offset.y = this._scrollCenterOffsetY[idx];
            }
          } else {
            var viewTrans = this.view;

            if (!viewTrans) {
              return offset;
            }

            if (this.direction === Direction$3.Horizontal) {
              offset.x = idx * viewTrans.width;
            } else if (this.direction === Direction$3.Vertical) {
              offset.y = idx * viewTrans.height;
            }
          }

          return offset;
        };

        _proto._getDragDirection = function _getDragDirection(moveOffset) {
          if (this._direction === Direction$3.Horizontal) {
            if (moveOffset.x === 0) {
              return 0;
            }

            return moveOffset.x > 0 ? 1 : -1;
          } else {
            if (moveOffset.y === 0) {
              return 0;
            }

            return moveOffset.y < 0 ? 1 : -1;
          }
        };

        _proto._isScrollable = function _isScrollable(offset, index, nextIndex) {
          if (this._sizeMode === SizeMode$1.Free) {
            var curPageCenter = 0;
            var nextPageCenter = 0;

            if (this.direction === Direction$3.Horizontal) {
              curPageCenter = this._scrollCenterOffsetX[index];
              nextPageCenter = this._scrollCenterOffsetX[nextIndex];
              return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            } else if (this.direction === Direction$3.Vertical) {
              curPageCenter = this._scrollCenterOffsetY[index];
              nextPageCenter = this._scrollCenterOffsetY[nextIndex];
              return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            }
          } else {
            var viewTrans = this.view;

            if (!viewTrans) {
              return false;
            }

            if (this.direction === Direction$3.Horizontal) {
              return Math.abs(offset.x) >= viewTrans.width * this.scrollThreshold;
            } else if (this.direction === Direction$3.Vertical) {
              return Math.abs(offset.y) >= viewTrans.height * this.scrollThreshold;
            }
          }

          return false;
        };

        _proto._autoScrollToPage = function _autoScrollToPage() {
          var bounceBackStarted = this._startBounceBackIfNeeded();

          if (bounceBackStarted) {
            var bounceBackAmount = this._getHowMuchOutOfBoundary();

            this._clampDelta(bounceBackAmount);

            if (bounceBackAmount.x > 0 || bounceBackAmount.y < 0) {
              this._curPageIdx = this._pages.length === 0 ? 0 : this._pages.length - 1;
            }

            if (bounceBackAmount.x < 0 || bounceBackAmount.y > 0) {
              this._curPageIdx = 0;
            }

            if (this.indicator) {
              this.indicator._changedState();
            }
          } else {
            var moveOffset = new Vec2();
            Vec2.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition);
            var index = this._curPageIdx;

            var nextIndex = index + this._getDragDirection(moveOffset);

            var timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);

            if (nextIndex < this._pages.length) {
              if (this._isScrollable(moveOffset, index, nextIndex)) {
                this.scrollToPage(nextIndex, timeInSecond);
                return;
              } else {
                var touchMoveVelocity = this._calculateTouchMoveVelocity();

                if (this._isQuicklyScrollable(touchMoveVelocity)) {
                  this.scrollToPage(nextIndex, timeInSecond);
                  return;
                }
              }
            }

            this.scrollToPage(index, timeInSecond);
          }
        };

        _createClass(PageView, [{
          key: "sizeMode",
          get: function get() {
            return this._sizeMode;
          },
          set: function set(value) {
            if (this._sizeMode === value) {
              return;
            }

            this._sizeMode = value;

            this._syncSizeMode();
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(value) {
            if (this._direction === value) {
              return;
            }

            this._direction = value;

            this._syncScrollDirection();
          }
        }, {
          key: "scrollThreshold",
          get: function get() {
            return this._scrollThreshold;
          },
          set: function set(value) {
            if (this._scrollThreshold === value) {
              return;
            }

            this._scrollThreshold = value;
          }
        }, {
          key: "pageTurningEventTiming",
          get: function get() {
            return this._pageTurningEventTiming;
          },
          set: function set(value) {
            if (this._pageTurningEventTiming === value) {
              return;
            }

            this._pageTurningEventTiming = value;
          }
        }, {
          key: "indicator",
          get: function get() {
            return this._indicator;
          },
          set: function set(value) {
            if (this._indicator === value) {
              return;
            }

            this._indicator = value;

            if (this.indicator) {
              this.indicator.setPageView(this);
            }
          }
        }, {
          key: "curPageIdx",
          get: function get() {
            return this._curPageIdx;
          }
        }, {
          key: "verticalScrollBar",
          get: function get() {
            return _ScrollView.prototype.verticalScrollBar;
          },
          set: function set(value) {
            this.verticalScrollBar = value;
          }
        }, {
          key: "horizontalScrollBar",
          get: function get() {
            return _ScrollView.prototype.horizontalScrollBar;
          },
          set: function set(value) {
            this.horizontalScrollBar = value;
          }
        }]);

        return PageView;
      }(ScrollView), _class3$w.SizeMode = SizeMode$1, _class3$w.Direction = Direction$3, _class3$w.EventType = extendsEnum(EventType$5, EventType$3), _temp$14), (_applyDecoratedDescriptor(_class2$$.prototype, "sizeMode", [_dec5$q, _dec6$n], Object.getOwnPropertyDescriptor(_class2$$.prototype, "sizeMode"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "direction", [_dec7$l, _dec8$k], Object.getOwnPropertyDescriptor(_class2$$.prototype, "direction"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "scrollThreshold", [slide, _dec9$i, _dec10$i], Object.getOwnPropertyDescriptor(_class2$$.prototype, "scrollThreshold"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "pageTurningEventTiming", [slide, _dec11$g, _dec12$f], Object.getOwnPropertyDescriptor(_class2$$.prototype, "pageTurningEventTiming"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "indicator", [_dec13$e, _dec14$c], Object.getOwnPropertyDescriptor(_class2$$.prototype, "indicator"), _class2$$.prototype), _descriptor$T = _applyDecoratedDescriptor(_class2$$.prototype, "autoPageTurningThreshold", [serializable, _dec15$c], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      }), _applyDecoratedDescriptor(_class2$$.prototype, "verticalScrollBar", [_dec16$b, override, _dec17$b], Object.getOwnPropertyDescriptor(_class2$$.prototype, "verticalScrollBar"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "horizontalScrollBar", [_dec18$b, override, _dec19$b], Object.getOwnPropertyDescriptor(_class2$$.prototype, "horizontalScrollBar"), _class2$$.prototype), _descriptor2$E = _applyDecoratedDescriptor(_class2$$.prototype, "horizontal", [override, serializable, _dec20$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor3$v = _applyDecoratedDescriptor(_class2$$.prototype, "vertical", [override, serializable, _dec21$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor4$r = _applyDecoratedDescriptor(_class2$$.prototype, "cancelInnerEvents", [override, serializable, _dec22$b], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor5$k = _applyDecoratedDescriptor(_class2$$.prototype, "scrollEvents", [_dec23$b, serializable, override, _dec24$a], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor6$c = _applyDecoratedDescriptor(_class2$$.prototype, "pageTurningSpeed", [serializable, editable, _dec25$a], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.3;
        }
      }), _descriptor7$c = _applyDecoratedDescriptor(_class2$$.prototype, "pageEvents", [_dec26$9, serializable, _dec27$9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor8$c = _applyDecoratedDescriptor(_class2$$.prototype, "_sizeMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return SizeMode$1.Unified;
        }
      }), _descriptor9$b = _applyDecoratedDescriptor(_class2$$.prototype, "_direction", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Direction$3.Horizontal;
        }
      }), _descriptor10$b = _applyDecoratedDescriptor(_class2$$.prototype, "_scrollThreshold", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor11$a = _applyDecoratedDescriptor(_class2$$.prototype, "_pageTurningEventTiming", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor12$9 = _applyDecoratedDescriptor(_class2$$.prototype, "_indicator", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2$$)) || _class$1a) || _class$1a) || _class$1a) || _class$1a));
      legacyCC.PageView = PageView;

      var _tempPos$1 = new Vec3();

      var _defaultAnchor = new Vec2();

      var tInverseTranslate = new Vec2();
      var tInverseScale = new Vec2(1, 1);

      var _tempVec2_1$1 = new Vec2();

      var _tempVec2_2 = new Vec2();

      function align(node, widget) {
        if (widget._hadAlignOnce) return;

        if ( widget.alignMode === AlignMode.ONCE) {
          widget._hadAlignOnce = true;
        }

        var hasTarget = widget.target;
        var target;
        var inverseTranslate = tInverseTranslate;
        var inverseScale = tInverseScale;

        if (hasTarget) {
          target = hasTarget;
          computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
        } else {
          target = node.parent;
        }

        var targetSize = getReadonlyNodeSize(target);
        var useGlobal = target instanceof Scene || !target.getComponent(UITransform);
        var targetAnchor = useGlobal ? _defaultAnchor : target.getComponent(UITransform).anchorPoint;
        var isRoot = useGlobal;
        node.getPosition(_tempPos$1);
        var uiTrans = node._uiProps.uiTransformComp;
        var x = _tempPos$1.x;
        var y = _tempPos$1.y;
        var anchor = uiTrans.anchorPoint;
        var scale = node.getScale();

        if (widget.alignFlags & AlignFlags.HORIZONTAL) {
          var localLeft = 0;
          var localRight = 0;
          var targetWidth = targetSize.width;

          if (isRoot) {
            localLeft = visibleRect.left.x;
            localRight = visibleRect.right.x;
          } else {
            localLeft = -targetAnchor.x * targetWidth;
            localRight = localLeft + targetWidth;
          }

          localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth;
          localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth;

          if (hasTarget) {
            localLeft += inverseTranslate.x;
            localLeft *= inverseScale.x;
            localRight += inverseTranslate.x;
            localRight *= inverseScale.x;
          }

          var width = 0;
          var anchorX = anchor.x;
          var scaleX = scale.x;

          if (scaleX < 0) {
            anchorX = 1.0 - anchorX;
            scaleX = -scaleX;
          }

          if (widget.isStretchWidth) {
            width = localRight - localLeft;

            if (scaleX !== 0) {
              uiTrans.width = width / scaleX;
            }

            x = localLeft + anchorX * width;
          } else {
            width = uiTrans.width * scaleX;

            if (widget.isAlignHorizontalCenter) {
              var localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth;
              var targetCenter = (0.5 - targetAnchor.x) * targetSize.width;

              if (hasTarget) {
                localHorizontalCenter *= inverseScale.x;
                targetCenter += inverseTranslate.x;
                targetCenter *= inverseScale.x;
              }

              x = targetCenter + (anchorX - 0.5) * width + localHorizontalCenter;
            } else if (widget.isAlignLeft) {
              x = localLeft + anchorX * width;
            } else {
              x = localRight + (anchorX - 1) * width;
            }
          }

          widget._lastSize.width = width;
        }

        if (widget.alignFlags & AlignFlags.VERTICAL) {
          var localTop = 0;
          var localBottom = 0;
          var targetHeight = targetSize.height;

          if (isRoot) {
            localBottom = visibleRect.bottom.y;
            localTop = visibleRect.top.y;
          } else {
            localBottom = -targetAnchor.y * targetHeight;
            localTop = localBottom + targetHeight;
          }

          localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight;
          localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight;

          if (hasTarget) {
            localBottom += inverseTranslate.y;
            localBottom *= inverseScale.y;
            localTop += inverseTranslate.y;
            localTop *= inverseScale.y;
          }

          var height = 0;
          var anchorY = anchor.y;
          var scaleY = scale.y;

          if (scaleY < 0) {
            anchorY = 1.0 - anchorY;
            scaleY = -scaleY;
          }

          if (widget.isStretchHeight) {
            height = localTop - localBottom;

            if (scaleY !== 0) {
              uiTrans.height = height / scaleY;
            }

            y = localBottom + anchorY * height;
          } else {
            height = uiTrans.height * scaleY;

            if (widget.isAlignVerticalCenter) {
              var localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight;
              var targetMiddle = (0.5 - targetAnchor.y) * targetSize.height;

              if (hasTarget) {
                localVerticalCenter *= inverseScale.y;
                targetMiddle += inverseTranslate.y;
                targetMiddle *= inverseScale.y;
              }

              y = targetMiddle + (anchorY - 0.5) * height + localVerticalCenter;
            } else if (widget.isAlignBottom) {
              y = localBottom + anchorY * height;
            } else {
              y = localTop + (anchorY - 1) * height;
            }
          }

          widget._lastSize.height = height;
        }

        node.setPosition(x, y, _tempPos$1.z);
        Vec3.set(widget._lastPos, x, y, _tempPos$1.z);
      }

      function visitNode$1(node) {
        var widget = node.getComponent(Widget);

        if (widget && widget.enabled) {

          if (!legacyCC.isValid(node, true)) {
            return;
          }

          activeWidgets.push(widget);
        }

        var children = node.children;

        for (var _iterator = _createForOfIteratorHelperLoose(children), _step; !(_step = _iterator()).done;) {
          var child = _step.value;

          if (child.active) {
            visitNode$1(child);
          }
        }
      }

      function refreshScene() {
        var scene = director.getScene();

        if (scene) {
          widgetManager.isAligning = true;

          if (widgetManager._nodesOrderDirty) {
            activeWidgets.length = 0;
            visitNode$1(scene);
            widgetManager._nodesOrderDirty = false;
          }
          var widget = null;
          var iterator = widgetManager._activeWidgetsIterator;

          for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
            widget = activeWidgets[iterator.i];

            if (widget._dirty) {
              align(widget.node, widget);
              widget._dirty = false;
            }
          }

          widgetManager.isAligning = false;
        }
      }

      var activeWidgets = [];

      function updateAlignment(node) {
        var parent = node.parent;

        if (parent && Node$1.isNode(parent)) {
          updateAlignment(parent);
        }

        var widget = node.getComponent(Widget);

        if (widget && parent) {
          align(node, widget);
        }
      }

      var widgetManager = exports('widgetManager', legacyCC._widgetManager = {
        isAligning: false,
        _nodesOrderDirty: false,
        _activeWidgetsIterator: new array.MutableForwardIterator(activeWidgets),
        animationState:  null,
        init: function init() {
          director.on(Director.EVENT_AFTER_SCENE_LAUNCH, refreshScene);
          director.on(Director.EVENT_AFTER_UPDATE, refreshScene);
          View.instance.on('design-resolution-changed', this.onResized, this);

          {
            var thisOnResized = this.onResized.bind(this);
            View.instance.on('canvas-resize', thisOnResized);
            screenAdapter.on('orientation-change', thisOnResized);
          }
        },
        add: function add(widget) {
          this._nodesOrderDirty = true;
        },
        remove: function remove(widget) {
          this._activeWidgetsIterator.remove(widget);
        },
        onResized: function onResized() {
          var scene = director.getScene();

          if (scene) {
            this.refreshWidgetOnResized(scene);
          }
        },
        refreshWidgetOnResized: function refreshWidgetOnResized(node) {
          var widget = Node$1.isNode(node) && node.getComponent(Widget);

          if (widget && widget.enabled && (widget.alignMode === AlignMode.ON_WINDOW_RESIZE || widget.alignMode === AlignMode.ALWAYS)) {
            widget.setDirty();
          }

          var children = node.children;

          for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {
            var child = _step2.value;
            this.refreshWidgetOnResized(child);
          }
        },
        updateOffsetsToStayPut: function updateOffsetsToStayPut(widget, e) {
          function i(t, c) {
            return Math.abs(t - c) > 1e-10 ? c : t;
          }

          var widgetNode = widget.node;
          var widgetParent = widgetNode.parent;

          if (widgetParent) {
            var zero = _tempVec2_1$1;
            zero.set(0, 0);
            var one = _tempVec2_2;
            one.set(1, 1);

            if (widget.target) {
              widgetParent = widget.target;
              computeInverseTransForTarget(widgetNode, widgetParent, zero, one);
            }

            if (!e) {
              return;
            }

            var parentTrans = widgetParent._uiProps && widgetParent._uiProps.uiTransformComp;
            var parentAP = parentTrans ? parentTrans.anchorPoint : _defaultAnchor;
            var trans = widgetNode._uiProps.uiTransformComp;
            var matchSize = getReadonlyNodeSize(widgetParent);
            var myAP = trans.anchorPoint;
            var pos = widgetNode.getPosition();
            var alignFlags = AlignFlags;
            var widgetNodeScale = widgetNode.getScale();
            var temp = 0;

            if (e & alignFlags.LEFT) {
              var l = -parentAP.x * matchSize.width;
              l += zero.x;
              l *= one.x;
              temp = pos.x - myAP.x * trans.width * Math.abs(widgetNodeScale.x) - l;

              if (!widget.isAbsoluteLeft) {
                temp /= matchSize.width;
              }

              temp /= one.x;
              widget.left = i(widget.left, temp);
            }

            if (e & alignFlags.RIGHT) {
              var r = (1 - parentAP.x) * matchSize.width;
              r += zero.x;
              temp = (r *= one.x) - (pos.x + (1 - myAP.x) * trans.width * Math.abs(widgetNodeScale.x));

              if (!widget.isAbsoluteRight) {
                temp /= matchSize.width;
              }

              temp /= one.x;
              widget.right = i(widget.right, temp);
            }

            if (e & alignFlags.TOP) {
              var t = (1 - parentAP.y) * matchSize.height;
              t += zero.y;
              temp = (t *= one.y) - (pos.y + (1 - myAP.y) * trans.height * Math.abs(widgetNodeScale.y));

              if (!widget.isAbsoluteTop) {
                temp /= matchSize.height;
              }

              temp /= one.y;
              widget.top = i(widget.top, temp);
            }

            if (e & alignFlags.BOT) {
              var b = -parentAP.y * matchSize.height;
              b += zero.y;
              b *= one.y;
              temp = pos.y - myAP.y * trans.height * Math.abs(widgetNodeScale.y) - b;

              if (!widget.isAbsoluteBottom) {
                temp /= matchSize.height;
              }

              temp /= one.y;
              widget.bottom = i(widget.bottom, temp);
            }
          }
        },
        updateAlignment: updateAlignment,
        AlignMode: AlignMode,
        AlignFlags: AlignFlags
      });
      director.on(Director.EVENT_INIT, function () {
        widgetManager.init();
      });

      var _dec$19, _dec2$K, _dec3$D, _dec4$v, _dec5$r, _class$1b;
      var SafeArea = function (v) { return exports({ SafeArea: v, SafeAreaComponent: v }), v; }((_dec$19 = ccclass('cc.SafeArea'), _dec2$K = help(), _dec3$D = executionOrder(110), _dec4$v = menu(), _dec5$r = requireComponent(Widget), _dec$19(_class$1b = _dec2$K(_class$1b = _dec3$D(_class$1b = executeInEditMode(_class$1b = _dec4$v(_class$1b = _dec5$r(_class$1b = function (_Component) {
        _inheritsLoose(SafeArea, _Component);

        function SafeArea() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = SafeArea.prototype;

        _proto.onEnable = function onEnable() {
          this.updateArea();
          screenAdapter.on('window-resize', this.updateArea, this);
          screenAdapter.on('orientation-change', this.updateArea, this);
        };

        _proto.onDisable = function onDisable() {
          screenAdapter.off('window-resize', this.updateArea, this);
          screenAdapter.off('orientation-change', this.updateArea, this);
        };

        _proto.updateArea = function updateArea() {
          var widget = this.node.getComponent(Widget);
          var uiTransComp = this.node.getComponent(UITransform);

          if (!widget || !uiTransComp) {
            return;
          }

          widget.updateAlignment();
          var lastPos = this.node.position.clone();
          var lastAnchorPoint = uiTransComp.anchorPoint.clone();
          widget.isAlignTop = widget.isAlignBottom = widget.isAlignLeft = widget.isAlignRight = true;
          var visibleSize = view.getVisibleSize();
          var screenWidth = visibleSize.width;
          var screenHeight = visibleSize.height;
          var safeArea = sys.getSafeAreaRect();
          widget.top = screenHeight - safeArea.y - safeArea.height;
          widget.bottom = safeArea.y;
          widget.left = safeArea.x;
          widget.right = screenWidth - safeArea.x - safeArea.width;
          widget.updateAlignment();
          var curPos = this.node.position.clone();
          var anchorX = lastAnchorPoint.x - (curPos.x - lastPos.x) / uiTransComp.width;
          var anchorY = lastAnchorPoint.y - (curPos.y - lastPos.y) / uiTransComp.height;
          uiTransComp.setAnchorPoint(anchorX, anchorY);
          widgetManager.add(widget);
        };

        return SafeArea;
      }(Component)) || _class$1b) || _class$1b) || _class$1b) || _class$1b) || _class$1b) || _class$1b));
      legacyCC.SafeArea = SafeArea;

      var _dec$1a, _dec2$L, _dec3$E, _dec4$w, _dec5$s, _dec6$o, _dec7$m, _dec8$l, _dec9$j, _dec10$j, _dec11$h, _dec12$g, _class$1c, _class2$10, _descriptor$U, _descriptor2$F, _descriptor3$w, _descriptor4$s, _descriptor5$l, _temp$15;
      var UICoordinateTracker = function (v) { return exports({ UICoordinateTracker: v, UICoordinateTrackerComponent: v }), v; }((_dec$1a = ccclass('cc.UICoordinateTracker'), _dec2$L = help(), _dec3$E = menu(), _dec4$w = executionOrder(110), _dec5$s = type(Node$1), _dec6$o = tooltip(), _dec7$m = type(Camera$1), _dec8$l = tooltip(), _dec9$j = tooltip(), _dec10$j = tooltip(), _dec11$h = type([EventHandler]), _dec12$g = tooltip(), _dec$1a(_class$1c = _dec2$L(_class$1c = _dec3$E(_class$1c = _dec4$w(_class$1c = (_class2$10 = (_temp$15 = function (_Component) {
        _inheritsLoose(UICoordinateTracker, _Component);

        function UICoordinateTracker() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "syncEvents", _descriptor$U, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_target", _descriptor2$F, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_camera", _descriptor3$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_useScale", _descriptor4$s, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_distance", _descriptor5$l, _assertThisInitialized(_this));

          _this._transformPos = new Vec3();
          _this._viewPos = new Vec3();
          _this._canMove = true;
          _this._lastWPos = new Vec3();
          _this._lastCameraPos = new Vec3();
          return _this;
        }

        var _proto = UICoordinateTracker.prototype;

        _proto.onEnable = function onEnable() {
          this._checkCanMove();
        };

        _proto.update = function update() {
          var wPos = this.node.worldPosition;
          var camera = this._camera;

          if (!this._canMove || !camera || !camera.camera || this._lastWPos.equals(wPos) && this._lastCameraPos.equals(camera.node.worldPosition)) {
            return;
          }

          this._lastWPos.set(wPos);

          this._lastCameraPos.set(camera.node.worldPosition);

          camera.camera.update();
          camera.convertToUINode(wPos, this._target, this._transformPos);

          if (this._useScale) {
            Vec3.transformMat4(this._viewPos, this.node.worldPosition, camera.camera.matView);
          }

          if (this.syncEvents.length > 0) {
            var data = this._distance / Math.abs(this._viewPos.z);
            EventHandler.emitEvents(this.syncEvents, this._transformPos, data);
          }
        };

        _proto._checkCanMove = function _checkCanMove() {
          this._canMove = !!(this._camera && this._target);
        };

        _createClass(UICoordinateTracker, [{
          key: "target",
          get: function get() {
            return this._target;
          },
          set: function set(value) {
            if (this._target === value) {
              return;
            }

            this._target = value;

            this._checkCanMove();
          }
        }, {
          key: "camera",
          get: function get() {
            return this._camera;
          },
          set: function set(value) {
            if (this._camera === value) {
              return;
            }

            this._camera = value;

            this._checkCanMove();
          }
        }, {
          key: "useScale",
          get: function get() {
            return this._useScale;
          },
          set: function set(value) {
            if (this._useScale === value) {
              return;
            }

            this._useScale = value;
          }
        }, {
          key: "distance",
          get: function get() {
            return this._distance;
          },
          set: function set(value) {
            if (this._distance === value) {
              return;
            }

            this._distance = value;
          }
        }]);

        return UICoordinateTracker;
      }(Component), _temp$15), (_applyDecoratedDescriptor(_class2$10.prototype, "target", [_dec5$s, _dec6$o], Object.getOwnPropertyDescriptor(_class2$10.prototype, "target"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "camera", [_dec7$m, _dec8$l], Object.getOwnPropertyDescriptor(_class2$10.prototype, "camera"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "useScale", [_dec9$j], Object.getOwnPropertyDescriptor(_class2$10.prototype, "useScale"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "distance", [_dec10$j], Object.getOwnPropertyDescriptor(_class2$10.prototype, "distance"), _class2$10.prototype), _descriptor$U = _applyDecoratedDescriptor(_class2$10.prototype, "syncEvents", [_dec11$h, serializable, _dec12$g], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2$F = _applyDecoratedDescriptor(_class2$10.prototype, "_target", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3$w = _applyDecoratedDescriptor(_class2$10.prototype, "_camera", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4$s = _applyDecoratedDescriptor(_class2$10.prototype, "_useScale", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor5$l = _applyDecoratedDescriptor(_class2$10.prototype, "_distance", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      })), _class2$10)) || _class$1c) || _class$1c) || _class$1c) || _class$1c));

      var _dec$1b, _dec2$M, _dec3$F, _class$1d;
      var BlockEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_END, NodeEventType.TOUCH_MOVE, NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_WHEEL];

      function stopPropagation(event) {
        event.propagationStopped = true;
      }

      var BlockInputEvents = function (v) { return exports({ BlockInputEvents: v, BlockInputEventsComponent: v }), v; }((_dec$1b = ccclass('cc.BlockInputEvents'), _dec2$M = help(), _dec3$F = menu(), _dec$1b(_class$1d = _dec2$M(_class$1d = _dec3$F(_class$1d = function (_Component) {
        _inheritsLoose(BlockInputEvents, _Component);

        function BlockInputEvents() {
          return _Component.apply(this, arguments) || this;
        }

        var _proto = BlockInputEvents.prototype;

        _proto.onEnable = function onEnable() {
          for (var i = 0; i < BlockEvents.length; i++) {
            this.node.on(BlockEvents[i], stopPropagation, this);
          }
        };

        _proto.onDisable = function onDisable() {
          for (var i = 0; i < BlockEvents.length; i++) {
            this.node.off(BlockEvents[i], stopPropagation, this);
          }
        };

        return BlockInputEvents;
      }(Component)) || _class$1d) || _class$1d) || _class$1d));

      var _dec$1c, _dec2$N, _dec3$G, _dec4$x, _dec5$t, _dec6$p, _dec7$n, _class$1e, _class2$11, _descriptor$V, _descriptor2$G, _temp$16;
      var SubContextView = exports('SubContextView', (_dec$1c = ccclass('cc.SubContextView'), _dec2$N = help(), _dec3$G = executionOrder(110), _dec4$x = requireComponent(UITransform), _dec5$t = menu(), _dec6$p = tooltip(), _dec7$n = tooltip(), _dec$1c(_class$1e = _dec2$N(_class$1e = _dec3$G(_class$1e = _dec4$x(_class$1e = _dec5$t(_class$1e = (_class2$11 = (_temp$16 = function (_Component) {
        _inheritsLoose(SubContextView, _Component);

        function SubContextView() {
          var _this;

          _this = _Component.call(this) || this;

          _initializerDefineProperty(_this, "_fps", _descriptor$V, _assertThisInitialized(_this));

          _this._sprite = void 0;
          _this._imageAsset = void 0;
          _this._texture = void 0;
          _this._updatedTime = 0;
          _this._updateInterval = 0;
          _this._openDataContext = void 0;
          _this._content = void 0;

          _initializerDefineProperty(_this, "_designResolutionSize", _descriptor2$G, _assertThisInitialized(_this));

          _this._content = new Node$1('content');
          _this._content.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
          _this._sprite = null;
          _this._imageAsset = new ImageAsset();
          _this._openDataContext = null;
          _this._updatedTime = performance.now();
          _this._texture = new Texture2D();
          return _this;
        }

        var _proto = SubContextView.prototype;

        _proto.onLoad = function onLoad() {
          if (minigame.getOpenDataContext) {
            this._updateInterval = 1000 / this._fps;
            this._openDataContext = minigame.getOpenDataContext();

            this._initSharedCanvas();

            this._initContentNode();

            this._updateSubContextView();

            this._updateContentLayer();
          } else {
            this.enabled = false;
          }
        };

        _proto.onEnable = function onEnable() {
          this._registerNodeEvent();
        };

        _proto.onDisable = function onDisable() {
          this._unregisterNodeEvent();
        };

        _proto._initSharedCanvas = function _initSharedCanvas() {
          if (this._openDataContext) {
            var sharedCanvas = this._openDataContext.canvas;
            var designWidth = this._designResolutionSize.width;
            var designHeight = this._designResolutionSize.height;

            sharedCanvas.width = designWidth;
            sharedCanvas.height = designHeight;
          }
        };

        _proto._initContentNode = function _initContentNode() {
          if (this._openDataContext) {
            var sharedCanvas = this._openDataContext.canvas;
            var image = this._imageAsset;
            image.reset(sharedCanvas);
            this._texture.image = image;

            this._texture.create(sharedCanvas.width, sharedCanvas.height);

            this._sprite = this._content.getComponent(Sprite);

            if (!this._sprite) {
              this._sprite = this._content.addComponent(Sprite);
            }

            if (this._sprite.spriteFrame) {
              this._sprite.spriteFrame.texture = this._texture;
            } else {
              var sp = new SpriteFrame();
              sp.texture = this._texture;
              this._sprite.spriteFrame = sp;
            }

            this._content.parent = this.node;
          }
        };

        _proto._updateSubContextView = function _updateSubContextView() {
          if (!this._openDataContext) {
            return;
          }

          var nodeTrans = this.node.getComponent(UITransform);

          var contentTrans = this._content.getComponent(UITransform);

          var scaleX = nodeTrans.width / contentTrans.width;
          var scaleY = nodeTrans.height / contentTrans.height;
          var scale = scaleX > scaleY ? scaleY : scaleX;
          contentTrans.width *= scale;
          contentTrans.height *= scale;
          var viewportRect = view.getViewportRect();
          var box = contentTrans.getBoundingBoxToWorld();
          var visibleSize = view.getVisibleSize();
          var dpr = screenAdapter.devicePixelRatio;
          var x = (viewportRect.width * (box.x / visibleSize.width) + viewportRect.x) / dpr;
          var y = (viewportRect.height * (box.y / visibleSize.height) + viewportRect.y) / dpr;
          var width = viewportRect.width * (box.width / visibleSize.width) / dpr;
          var height = viewportRect.height * (box.height / visibleSize.height) / dpr;

          this._openDataContext.postMessage({
            fromEngine: true,
            type: 'engine',
            event: 'viewport',
            x: x,
            y: y,
            width: width,
            height: height
          });
        };

        _proto._updateSubContextTexture = function _updateSubContextTexture() {
          var img = this._imageAsset;

          if (!img || !this._openDataContext) {
            return;
          }

          if (img.width <= 0 || img.height <= 0) {
            return;
          }

          var sharedCanvas = this._openDataContext.canvas;
          img.reset(sharedCanvas);

          if (sharedCanvas.width > img.width || sharedCanvas.height > img.height) {
            this._texture.create(sharedCanvas.width, sharedCanvas.height);
          }

          this._texture.uploadData(sharedCanvas);
        };

        _proto._registerNodeEvent = function _registerNodeEvent() {
          this.node.on(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
          this.node.on(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
          this.node.on(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
        };

        _proto._unregisterNodeEvent = function _unregisterNodeEvent() {
          this.node.off(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
          this.node.off(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
          this.node.off(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
        };

        _proto._updateContentLayer = function _updateContentLayer() {
          this._content.layer = this.node.layer;
        };

        _proto.update = function update(dt) {
          var calledUpdateManually = dt === undefined;

          if (calledUpdateManually) {
            this._updateSubContextTexture();

            return;
          }

          var now = performance.now();
          var deltaTime = now - this._updatedTime;

          if (deltaTime >= this._updateInterval) {
            this._updatedTime += this._updateInterval;

            this._updateSubContextTexture();
          }
        };

        _proto.onDestroy = function onDestroy() {
          this._content.destroy();

          this._texture.destroy();

          if (this._sprite) {
            this._sprite.destroy();
          }

          this._imageAsset.destroy();

          this._openDataContext = null;
        };

        _createClass(SubContextView, [{
          key: "designResolutionSize",
          get: function get() {
            return this._designResolutionSize;
          },
          set: function set(value) {
            {
              return;
            }
          }
        }, {
          key: "fps",
          get: function get() {
            return this._fps;
          },
          set: function set(value) {
            if (this._fps === value) {
              return;
            }

            this._fps = value;
            this._updateInterval = 1000 / value;
          }
        }]);

        return SubContextView;
      }(Component), _temp$16), (_applyDecoratedDescriptor(_class2$11.prototype, "designResolutionSize", [_dec6$p], Object.getOwnPropertyDescriptor(_class2$11.prototype, "designResolutionSize"), _class2$11.prototype), _applyDecoratedDescriptor(_class2$11.prototype, "fps", [_dec7$n], Object.getOwnPropertyDescriptor(_class2$11.prototype, "fps"), _class2$11.prototype), _descriptor$V = _applyDecoratedDescriptor(_class2$11.prototype, "_fps", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 60;
        }
      }), _descriptor2$G = _applyDecoratedDescriptor(_class2$11.prototype, "_designResolutionSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Size(640, 960);
        }
      })), _class2$11)) || _class$1e) || _class$1e) || _class$1e) || _class$1e) || _class$1e));
      legacyCC.SubContextView = SubContextView;

      var _dec$1d, _class$1f;
      var UIReorderComponent = exports('UIReorderComponent', (_dec$1d = ccclass('cc.UIReorderComponent'), _dec$1d(_class$1f = function UIReorderComponent() {
        warnID(1408, 'UIReorderComponent');
      }) || _class$1f));
      legacyCC.UIReorderComponent = UIReorderComponent;
      legacyCC.ButtonComponent = Button;
      js.setClassAlias(Button, 'cc.ButtonComponent');
      legacyCC.EditBoxComponent = EditBox;
      js.setClassAlias(EditBox, 'cc.EditBoxComponent');
      legacyCC.LayoutComponent = Layout;
      js.setClassAlias(Layout, 'cc.LayoutComponent');
      legacyCC.ProgressBarComponent = ProgressBar;
      js.setClassAlias(ProgressBar, 'cc.ProgressBarComponent');
      legacyCC.ScrollViewComponent = ScrollView;
      js.setClassAlias(ScrollView, 'cc.ScrollViewComponent');
      legacyCC.ScrollBarComponent = ScrollBar;
      js.setClassAlias(ScrollBar, 'cc.ScrollBarComponent');
      legacyCC.SliderComponent = Slider;
      js.setClassAlias(Slider, 'cc.SliderComponent');
      legacyCC.ToggleComponent = Toggle;
      js.setClassAlias(Toggle, 'cc.ToggleComponent');
      legacyCC.ToggleContainerComponent = ToggleContainer;
      js.setClassAlias(ToggleContainer, 'cc.ToggleContainerComponent');
      legacyCC.WidgetComponent = Widget;
      js.setClassAlias(Widget, 'cc.WidgetComponent');
      legacyCC.PageViewComponent = PageView;
      js.setClassAlias(PageView, 'cc.PageViewComponent');
      legacyCC.PageViewIndicatorComponent = PageViewIndicator;
      js.setClassAlias(PageViewIndicator, 'cc.PageViewIndicatorComponent');
      legacyCC.SafeAreaComponent = SafeArea;
      js.setClassAlias(SafeArea, 'cc.SafeAreaComponent');
      js.setClassAlias(UICoordinateTracker, 'cc.UICoordinateTrackerComponent');
      legacyCC.BlockInputEventsComponent = BlockInputEvents;
      js.setClassAlias(BlockInputEvents, 'cc.BlockInputEventsComponent');

      var vec3_temp = new Vec3();

      var _worldMatrix$1 = new Mat4();

      function fillMeshVertices3D(node, renderer, renderData, color) {
        var chunk = renderData.chunk;
        var dataList = renderData.data;
        var vData = chunk.vb;
        var vertexCount = renderData.vertexCount;
        node.getWorldMatrix(_worldMatrix$1);
        var vertexOffset = 0;

        for (var i = 0; i < vertexCount; i++) {
          var vert = dataList[i];
          Vec3.set(vec3_temp, vert.x, vert.y, 0);
          Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$1);
          vData[vertexOffset++] = vec3_temp.x;
          vData[vertexOffset++] = vec3_temp.y;
          vData[vertexOffset++] = vec3_temp.z;
          Color.toArray(vData, color, vertexOffset + 2);
          vertexOffset += 6;
        }

        var bid = chunk.bufferId;
        var vid = chunk.vertexOffset;
        var meshBuffer = chunk.vertexAccessor.getMeshBuffer(chunk.bufferId);
        var ib = chunk.vertexAccessor.getIndexBuffer(bid);
        var indexOffset = meshBuffer.indexOffset;

        for (var _i = 0, count = vertexCount / 4; _i < count; _i++) {
          var start = vid + _i * 4;
          ib[indexOffset++] = start;
          ib[indexOffset++] = start + 1;
          ib[indexOffset++] = start + 2;
          ib[indexOffset++] = start + 1;
          ib[indexOffset++] = start + 3;
          ib[indexOffset++] = start + 2;
        }

        meshBuffer.indexOffset += renderData.indexCount;
        meshBuffer.setDirty();
      }
      function updateOpacity(renderData, opacity) {
        var vfmt = renderData.vertexFormat;
        var vb = renderData.chunk.vb;
        var attr;
        var format;
        var stride;
        var offset = 0;

        for (var i = 0; i < vfmt.length; ++i) {
          attr = vfmt[i];
          format = FormatInfos[attr.format];

          if (format.hasAlpha) {
            stride = renderData.floatStride;

            if (format.size / format.count === 1) {
              var alpha = ~~clamp(Math.round(opacity * 255), 0, 255);

              for (var color = offset; color < vb.length; color += stride) {
                vb[color] = (vb[color] & 0xffffff00 | alpha) >>> 0;
              }
            } else if (format.size / format.count === 4) {
              for (var _alpha = offset + 3; _alpha < vb.length; _alpha += stride) {
                vb[_alpha] = opacity;
              }
            }
          }

          offset += format.size >> 2;
        }
      }

      var LineCap;

      (function (LineCap) {
        LineCap[LineCap["BUTT"] = 0] = "BUTT";
        LineCap[LineCap["ROUND"] = 1] = "ROUND";
        LineCap[LineCap["SQUARE"] = 2] = "SQUARE";
      })(LineCap || (LineCap = {}));

      ccenum(LineCap);
      var LineJoin;

      (function (LineJoin) {
        LineJoin[LineJoin["BEVEL"] = 0] = "BEVEL";
        LineJoin[LineJoin["ROUND"] = 1] = "ROUND";
        LineJoin[LineJoin["MITER"] = 2] = "MITER";
      })(LineJoin || (LineJoin = {}));

      ccenum(LineJoin);
      var PointFlags;

      (function (PointFlags) {
        PointFlags[PointFlags["PT_CORNER"] = 1] = "PT_CORNER";
        PointFlags[PointFlags["PT_LEFT"] = 2] = "PT_LEFT";
        PointFlags[PointFlags["PT_BEVEL"] = 4] = "PT_BEVEL";
        PointFlags[PointFlags["PT_INNERBEVEL"] = 8] = "PT_INNERBEVEL";
      })(PointFlags || (PointFlags = {}));

      ccenum(PointFlags);

      var PI = Math.PI;
      var min$2 = Math.min;
      var max$3 = Math.max;
      var cos$1 = Math.cos;
      var sin = Math.sin;
      var abs$1 = Math.abs;
      var sign$1 = Math.sign;
      var KAPPA90 = 0.5522847493;
      function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
        counterclockwise = counterclockwise || false;
        var a = 0;
        var da = 0;
        var hda = 0;
        var kappa = 0;
        var dx = 0;
        var dy = 0;
        var x = 0;
        var y = 0;
        var tanx = 0;
        var tany = 0;
        var px = 0;
        var py = 0;
        var ptanx = 0;
        var ptany = 0;
        var i = 0;
        var ndivs = 0;
        da = endAngle - startAngle;

        if (counterclockwise) {
          if (abs$1(da) >= PI * 2) {
            da = PI * 2;
          } else {
            while (da < 0) {
              da += PI * 2;
            }
          }
        } else if (abs$1(da) >= PI * 2) {
          da = -PI * 2;
        } else {
          while (da > 0) {
            da -= PI * 2;
          }
        }

        ndivs = max$3(1, min$2(abs$1(da) / (PI * 0.5) + 0.5, 5)) | 0;
        hda = da / ndivs / 2.0;
        kappa = abs$1(4.0 / 3.0 * (1 - cos$1(hda)) / sin(hda));

        if (!counterclockwise) {
          kappa = -kappa;
        }

        for (i = 0; i <= ndivs; i++) {
          a = startAngle + da * (i / ndivs);
          dx = cos$1(a);
          dy = sin(a);
          x = cx + dx * r;
          y = cy + dy * r;
          tanx = -dy * r * kappa;
          tany = dx * r * kappa;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
          }

          px = x;
          py = y;
          ptanx = tanx;
          ptany = tany;
        }
      }
      function ellipse(ctx, cx, cy, rx, ry) {
        ctx.moveTo(cx - rx, cy);
        ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
        ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
        ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
        ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
        ctx.close();
      }
      function roundRect(ctx, x, y, w, h, r) {
        if (r < 0.1) {
          ctx.rect(x, y, w, h);
        } else {
          var rx = min$2(r, abs$1(w) * 0.5) * sign$1(w);
          var ry = min$2(r, abs$1(h) * 0.5) * sign$1(h);
          ctx.moveTo(x, y + ry);
          ctx.lineTo(x, y + h - ry);
          ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
          ctx.lineTo(x + w - rx, y + h);
          ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
          ctx.lineTo(x + w, y + ry);
          ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
          ctx.lineTo(x + rx, y);
          ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
          ctx.close();
        }
      }
      function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
        var x12 = 0;
        var y12 = 0;
        var x23 = 0;
        var y23 = 0;
        var x34 = 0;
        var y34 = 0;
        var x123 = 0;
        var y123 = 0;
        var x234 = 0;
        var y234 = 0;
        var x1234 = 0;
        var y1234 = 0;
        var dx = 0;
        var dy = 0;
        var d2 = 0;
        var d3 = 0;

        if (level > 10) {
          return;
        }

        x12 = (x1 + x2) * 0.5;
        y12 = (y1 + y2) * 0.5;
        x23 = (x2 + x3) * 0.5;
        y23 = (y2 + y3) * 0.5;
        x34 = (x3 + x4) * 0.5;
        y34 = (y3 + y4) * 0.5;
        x123 = (x12 + x23) * 0.5;
        y123 = (y12 + y23) * 0.5;
        dx = x4 - x1;
        dy = y4 - y1;
        d2 = abs$1((x2 - x4) * dy - (y2 - y4) * dx);
        d3 = abs$1((x3 - x4) * dy - (y3 - y4) * dx);

        if ((d2 + d3) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy)) {
          ctx.addPoint(x4, y4, type === 0 ? type | PointFlags.PT_BEVEL : type);
          return;
        }

        x234 = (x23 + x34) * 0.5;
        y234 = (y23 + y34) * 0.5;
        x1234 = (x123 + x234) * 0.5;
        y1234 = (y123 + y234) * 0.5;
        tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
        tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
      }

      var Point = function (_Vec) {
        _inheritsLoose(Point, _Vec);

        function Point(x, y) {
          var _this;

          _this = _Vec.call(this, x, y) || this;
          _this.dx = 0;
          _this.dy = 0;
          _this.dmx = 0;
          _this.dmy = 0;
          _this.flags = 0;
          _this.len = 0;

          _this.reset();

          return _this;
        }

        var _proto = Point.prototype;

        _proto.reset = function reset() {
          this.dx = 0;
          this.dy = 0;
          this.dmx = 0;
          this.dmy = 0;
          this.flags = 0;
          this.len = 0;
        };

        return Point;
      }(Vec2);
      var Path = function () {
        function Path() {
          this.closed = false;
          this.bevel = 0;
          this.complex = true;
          this.points = [];
          this.reset();
        }

        var _proto2 = Path.prototype;

        _proto2.reset = function reset() {
          this.closed = false;
          this.bevel = 0;
          this.complex = true;

          if (this.points) {
            this.points.length = 0;
          } else {
            this.points = [];
          }
        };

        return Path;
      }();
      var Impl = function () {
        function Impl() {
          this.dataOffset = 0;
          this.updatePathOffset = false;
          this.pathLength = 0;
          this.pathOffset = 0;
          this.paths = [];
          this.tessTol = 0.25;
          this.distTol = 0.01;
          this.fillColor = Color.WHITE.clone();
          this.lineCap = LineCap.BUTT;
          this.strokeColor = Color.BLACK.clone();
          this.lineJoin = LineJoin.MITER;
          this.lineWidth = 0;
          this.pointsOffset = 0;
          this._commandX = 0;
          this._commandY = 0;
          this._points = [];
          this._renderDataList = [];
          this._curPath = null;
        }

        var _proto3 = Impl.prototype;

        _proto3.moveTo = function moveTo(x, y) {
          if (this.updatePathOffset) {
            this.pathOffset = this.pathLength;
            this.updatePathOffset = false;
          }

          this._addPath();

          this.addPoint(x, y, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        };

        _proto3.lineTo = function lineTo(x, y) {
          this.addPoint(x, y, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        };

        _proto3.bezierCurveTo = function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
          var path = this._curPath;
          var last = path.points[path.points.length - 1];

          if (!last) {
            return;
          }

          if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
            this.lineTo(x, y);
            return;
          }

          tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
          this._commandX = x;
          this._commandY = y;
        };

        _proto3.quadraticCurveTo = function quadraticCurveTo(cx, cy, x, y) {
          var x0 = this._commandX;
          var y0 = this._commandY;
          this.bezierCurveTo(x0 + 2.0 / 3.0 * (cx - x0), y0 + 2.0 / 3.0 * (cy - y0), x + 2.0 / 3.0 * (cx - x), y + 2.0 / 3.0 * (cy - y), x, y);
        };

        _proto3.arc = function arc$1(cx, cy, r, startAngle, endAngle, counterclockwise) {
          arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
        };

        _proto3.ellipse = function ellipse$1(cx, cy, rx, ry) {
          ellipse(this, cx, cy, rx, ry);

          this._curPath.complex = false;
        };

        _proto3.circle = function circle(cx, cy, r) {
          ellipse(this, cx, cy, r, r);

          this._curPath.complex = false;
        };

        _proto3.rect = function rect(x, y, w, h) {
          this.moveTo(x, y);
          this.lineTo(x + w, y);
          this.lineTo(x + w, y + h);
          this.lineTo(x, y + h);
          this.close();
          this._curPath.complex = false;
        };

        _proto3.roundRect = function roundRect$1(x, y, w, h, r) {
          roundRect(this, x, y, w, h, r);

          this._curPath.complex = false;
        };

        _proto3.clear = function clear() {
          this.pathLength = 0;
          this.pathOffset = 0;
          this.pointsOffset = 0;
          this.dataOffset = 0;
          this._curPath = null;
          this.paths.length = 0;
          this._points.length = 0;
          var dataList = this._renderDataList;

          for (var i = 0, l = dataList.length; i < l; i++) {
            var data = dataList[i];

            if (!data) {
              continue;
            }

            MeshRenderData.remove(data);
          }

          this._renderDataList.length = 0;
        };

        _proto3.close = function close() {
          this._curPath.closed = true;
        };

        _proto3.requestRenderData = function requestRenderData() {
          var renderData = MeshRenderData.add();

          this._renderDataList.push(renderData);

          return renderData;
        };

        _proto3.getRenderDataList = function getRenderDataList() {
          if (this._renderDataList.length === 0) {
            this.requestRenderData();
          }

          return this._renderDataList;
        };

        _proto3.addPoint = function addPoint(x, y, flags) {
          var path = this._curPath;

          if (!path) {
            return;
          }

          var points = this._points;
          var pathPoints = path.points;
          var offset = this.pointsOffset++;
          var pt = points[offset];

          if (!pt) {
            pt = new Point(x, y);
            points.push(pt);
          } else {
            pt.x = x;
            pt.y = y;
          }

          pt.flags = flags;
          pathPoints.push(pt);
        };

        _proto3._addPath = function _addPath() {
          var offset = this.pathLength;
          var path = this.paths[offset];

          if (!path) {
            path = new Path();
            this.paths.push(path);
          } else {
            path.reset();
          }

          this.pathLength++;
          this._curPath = path;
          return path;
        };

        return Impl;
      }();

      var _dec$1e, _dec2$O, _dec3$H, _dec4$y, _dec5$u, _dec6$q, _dec7$o, _dec8$m, _dec9$k, _dec10$k, _dec11$i, _dec12$h, _dec13$f, _class$1g, _class2$12, _descriptor$W, _descriptor2$H, _descriptor3$x, _descriptor4$t, _descriptor5$m, _descriptor6$d, _class3$x, _temp$17;
      var attributes = vfmtPosColor.concat([new Attribute('a_dist', Format.R32F)]);
      var componentPerVertex = getComponentPerVertex(attributes);
      var stride = getAttributeStride(attributes);
      var Graphics = function (v) { return exports({ Graphics: v, GraphicsComponent: v }), v; }((_dec$1e = ccclass('cc.Graphics'), _dec2$O = help(), _dec3$H = executionOrder(110), _dec4$y = menu(), _dec5$u = tooltip(), _dec6$q = type(LineJoin), _dec7$o = tooltip(), _dec8$m = type(LineCap), _dec9$k = tooltip(), _dec10$k = tooltip(), _dec11$i = tooltip(), _dec12$h = tooltip(), _dec13$f = visible(), _dec$1e(_class$1g = _dec2$O(_class$1g = _dec3$H(_class$1g = _dec4$y(_class$1g = (_class2$12 = (_temp$17 = _class3$x = function (_Renderable2D) {
        _inheritsLoose(Graphics, _Renderable2D);

        function Graphics() {
          var _this;

          _this = _Renderable2D.call(this) || this;
          _this.impl = null;
          _this.model = null;

          _initializerDefineProperty(_this, "_lineWidth", _descriptor$W, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_strokeColor", _descriptor2$H, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lineJoin", _descriptor3$x, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_lineCap", _descriptor4$t, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fillColor", _descriptor5$m, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_miterLimit", _descriptor6$d, _assertThisInitialized(_this));

          _this._isDrawing = false;
          _this._isNeedUploadData = true;
          _this._graphicsUseSubMeshes = [];
          _this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
          _this.impl = new Impl();
          return _this;
        }

        var _proto = Graphics.prototype;

        _proto.onRestore = function onRestore() {
          if (!this.impl) {
            this._flushAssembler();
          }
        };

        _proto.onLoad = function onLoad() {
          this.model = director.root.createModel(Model);
          this.model.node = this.model.transform = this.node;

          this._flushAssembler();
        };

        _proto.onEnable = function onEnable() {
          _Renderable2D.prototype.onEnable.call(this);

          this._updateMtlForGraphics();
        };

        _proto.onDisable = function onDisable() {
          _Renderable2D.prototype.onDisable.call(this);
        };

        _proto.onDestroy = function onDestroy() {
          this._sceneGetter = null;

          if (this.model) {
            director.root.destroyModel(this.model);
            this.model = null;
          }

          var subMeshLength = this._graphicsUseSubMeshes.length;

          if (subMeshLength > 0) {
            for (var i = 0; i < subMeshLength; ++i) {
              this._graphicsUseSubMeshes[i].destroy();
            }

            this._graphicsUseSubMeshes.length = 0;
          }

          if (this.impl) {
            this._isDrawing = false;
            this.impl.clear();
            this.impl = null;
          }

          _Renderable2D.prototype.onDestroy.call(this);
        };

        _proto.moveTo = function moveTo(x, y) {
          if (!this.impl) {
            return;
          }

          this.impl.moveTo(x, y);
        };

        _proto.lineTo = function lineTo(x, y) {
          if (!this.impl) {
            return;
          }

          this.impl.lineTo(x, y);
        };

        _proto.bezierCurveTo = function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
          if (!this.impl) {
            return;
          }

          this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
        };

        _proto.quadraticCurveTo = function quadraticCurveTo(cx, cy, x, y) {
          if (!this.impl) {
            return;
          }

          this.impl.quadraticCurveTo(cx, cy, x, y);
        };

        _proto.arc = function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
          if (!this.impl) {
            return;
          }

          this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
        };

        _proto.ellipse = function ellipse(cx, cy, rx, ry) {
          if (!this.impl) {
            return;
          }

          this.impl.ellipse(cx, cy, rx, ry);
        };

        _proto.circle = function circle(cx, cy, r) {
          if (!this.impl) {
            return;
          }

          this.impl.circle(cx, cy, r);
        };

        _proto.rect = function rect(x, y, w, h) {
          if (!this.impl) {
            return;
          }

          this.impl.rect(x, y, w, h);
        };

        _proto.roundRect = function roundRect(x, y, w, h, r) {
          if (!this.impl) {
            return;
          }

          this.impl.roundRect(x, y, w, h, r);
        };

        _proto.fillRect = function fillRect(x, y, w, h) {
          this.rect(x, y, w, h);
          this.fill();
        };

        _proto.clear = function clear() {
          if (!this.impl) {
            return;
          }

          this.impl.clear();
          this._isDrawing = false;

          if (this.model) {
            for (var i = 0; i < this.model.subModels.length; i++) {
              var subModel = this.model.subModels[i];
              subModel.inputAssembler.indexCount = 0;
            }
          }

          this.markForUpdateRenderData();
        };

        _proto.close = function close() {
          if (!this.impl) {
            return;
          }

          this.impl.close();
        };

        _proto.stroke = function stroke() {
          if (!this._assembler) {
            this._flushAssembler();
          }

          this._isDrawing = true;
          this._isNeedUploadData = true;

          this._assembler.stroke(this);
        };

        _proto.fill = function fill() {
          if (!this._assembler) {
            this._flushAssembler();
          }

          this._isDrawing = true;
          this._isNeedUploadData = true;

          this._assembler.fill(this);
        };

        _proto._updateMtlForGraphics = function _updateMtlForGraphics() {
          var mat;

          if (this._customMaterial) {
            mat = this.getMaterialInstance(0);
          } else {
            mat = builtinResMgr.get('ui-graphics-material');
            this.setMaterial(mat, 0);
            mat = this.getMaterialInstance(0);
            mat.recompileShaders({
              USE_LOCAL: true
            });
          }
        };

        _proto.activeSubModel = function activeSubModel(idx) {
          if (!this.model) {
            warnID(4500, this.node.name);
            return;
          }

          if (this.model.subModels.length <= idx) {
            var gfxDevice = legacyCC.director.root.device;
            var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * stride, stride));
            var indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * Uint16Array.BYTES_PER_ELEMENT * 2, Uint16Array.BYTES_PER_ELEMENT));
            var renderMesh = new RenderingSubMesh([vertexBuffer], attributes, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
            renderMesh.subMeshIdx = 0;
            this.model.initSubModel(idx, renderMesh, this.getMaterialInstance(0));

            this._graphicsUseSubMeshes.push(renderMesh);
          }
        };

        _proto._uploadData = function _uploadData() {
          var impl = this.impl;

          if (!impl) {
            return;
          }

          var renderDataList = impl && impl.getRenderDataList();

          if (renderDataList.length <= 0 || !this.model) {
            return;
          }

          var subModelList = this.model.subModels;

          for (var i = 0; i < renderDataList.length; i++) {
            var renderData = renderDataList[i];
            var ia = subModelList[i].inputAssembler;

            if (renderData.lastFilledVertex === renderData.vertexStart) {
              continue;
            }

            var vb = new Float32Array(renderData.vData.buffer, 0, renderData.vertexStart * componentPerVertex);
            ia.vertexBuffers[0].update(vb);
            ia.vertexCount = renderData.vertexStart;
            var ib = new Uint16Array(renderData.iData.buffer, 0, renderData.indexStart);
            ia.indexBuffer.update(ib);
            ia.indexCount = renderData.indexStart;
            renderData.lastFilledVertex = renderData.vertexStart;
            renderData.lastFilledIndex = renderData.indexStart;
          }

          this._isNeedUploadData = false;
        };

        _proto._render = function _render(render) {
          if (this._isNeedUploadData) {
            if (this.impl) {
              var renderDataList = this.impl.getRenderDataList();
              var len = this.model.subModels.length;

              if (renderDataList.length > len) {
                for (var i = len; i < renderDataList.length; i++) {
                  this.activeSubModel(i);
                }
              }
            }

            this._uploadData();
          }

          render.commitModel(this, this.model, this.getMaterialInstance(0));
        };

        _proto._flushAssembler = function _flushAssembler() {
          var assembler = Graphics.Assembler.getAssembler(this);

          if (this._assembler !== assembler) {
            this._assembler = assembler;
          }
        };

        _proto._canRender = function _canRender() {
          if (!_Renderable2D.prototype._canRender.call(this)) {
            return false;
          }

          return !!this.model && this._isDrawing;
        };

        _createClass(Graphics, [{
          key: "lineWidth",
          get: function get() {
            return this._lineWidth;
          },
          set: function set(value) {
            this._lineWidth = value;

            if (!this.impl) {
              return;
            }

            this.impl.lineWidth = value;
          }
        }, {
          key: "lineJoin",
          get: function get() {
            return this._lineJoin;
          },
          set: function set(value) {
            this._lineJoin = value;

            if (!this.impl) {
              return;
            }

            this.impl.lineJoin = value;
          }
        }, {
          key: "lineCap",
          get: function get() {
            return this._lineCap;
          },
          set: function set(value) {
            this._lineCap = value;

            if (!this.impl) {
              return;
            }

            this.impl.lineCap = value;
          }
        }, {
          key: "strokeColor",
          get: function get() {
            return this._strokeColor;
          },
          set: function set(value) {
            if (!this.impl) {
              return;
            }

            this._strokeColor.set(value);

            this.impl.strokeColor = this._strokeColor;
          }
        }, {
          key: "fillColor",
          get: function get() {
            return this._fillColor;
          },
          set: function set(value) {
            if (!this.impl) {
              return;
            }

            this._fillColor.set(value);

            this.impl.fillColor = this._fillColor;
          }
        }, {
          key: "miterLimit",
          get: function get() {
            return this._miterLimit;
          },
          set: function set(value) {
            this._miterLimit = value;
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color === value) {
              return;
            }

            this._color.set(value);
          }
        }, {
          key: "srcBlendFactor",
          get: function get() {
            return this._srcBlendFactor;
          },
          set: function set(value) {}
        }, {
          key: "dstBlendFactor",
          get: function get() {
            return this._dstBlendFactor;
          },
          set: function set(value) {}
        }]);

        return Graphics;
      }(Renderable2D), _class3$x.LineJoin = LineJoin, _class3$x.LineCap = LineCap, _temp$17), (_applyDecoratedDescriptor(_class2$12.prototype, "lineWidth", [editable, _dec5$u], Object.getOwnPropertyDescriptor(_class2$12.prototype, "lineWidth"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "lineJoin", [_dec6$q, _dec7$o], Object.getOwnPropertyDescriptor(_class2$12.prototype, "lineJoin"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "lineCap", [_dec8$m, _dec9$k], Object.getOwnPropertyDescriptor(_class2$12.prototype, "lineCap"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "strokeColor", [_dec10$k], Object.getOwnPropertyDescriptor(_class2$12.prototype, "strokeColor"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "fillColor", [_dec11$i], Object.getOwnPropertyDescriptor(_class2$12.prototype, "fillColor"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "miterLimit", [_dec12$h], Object.getOwnPropertyDescriptor(_class2$12.prototype, "miterLimit"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "color", [override, _dec13$f], Object.getOwnPropertyDescriptor(_class2$12.prototype, "color"), _class2$12.prototype), _descriptor$W = _applyDecoratedDescriptor(_class2$12.prototype, "_lineWidth", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor2$H = _applyDecoratedDescriptor(_class2$12.prototype, "_strokeColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.BLACK.clone();
        }
      }), _descriptor3$x = _applyDecoratedDescriptor(_class2$12.prototype, "_lineJoin", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return LineJoin.MITER;
        }
      }), _descriptor4$t = _applyDecoratedDescriptor(_class2$12.prototype, "_lineCap", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return LineCap.BUTT;
        }
      }), _descriptor5$m = _applyDecoratedDescriptor(_class2$12.prototype, "_fillColor", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor6$d = _applyDecoratedDescriptor(_class2$12.prototype, "_miterLimit", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      })), _class2$12)) || _class$1g) || _class$1g) || _class$1g) || _class$1g));
      legacyCC.Graphics = Graphics;

      var _dec$1f, _dec2$P, _dec3$I, _dec4$z, _dec5$v, _dec6$r, _dec7$p, _dec8$n, _dec9$l, _dec10$l, _dec11$j, _dec12$i, _dec13$g, _dec14$d, _dec15$d, _class$1h, _class2$13, _descriptor$X, _descriptor2$I, _descriptor3$y, _descriptor4$u, _descriptor5$n, _class3$y, _temp$18;

      var _worldMatrix$2 = new Mat4();

      var _vec2_temp = new Vec2();

      var _mat4_temp$1 = new Mat4();

      var _circlePoints = [];

      function _calculateCircle(center, radius, segments) {
        _circlePoints.length = 0;
        var anglePerStep = Math.PI * 2 / segments;

        for (var step = 0; step < segments; ++step) {
          _circlePoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
        }

        return _circlePoints;
      }

      var MaskType;

      (function (MaskType) {
        MaskType[MaskType["RECT"] = 0] = "RECT";
        MaskType[MaskType["ELLIPSE"] = 1] = "ELLIPSE";
        MaskType[MaskType["GRAPHICS_STENCIL"] = 2] = "GRAPHICS_STENCIL";
        MaskType[MaskType["IMAGE_STENCIL"] = 3] = "IMAGE_STENCIL";
      })(MaskType || (MaskType = {}));

      ccenum(MaskType);
      var SEGMENTS_MIN = 3;
      var SEGMENTS_MAX = 10000;
      var Mask = function (v) { return exports({ Mask: v, MaskComponent: v }), v; }((_dec$1f = ccclass('cc.Mask'), _dec2$P = help(), _dec3$I = executionOrder(110), _dec4$z = menu(), _dec5$v = type(MaskType), _dec6$r = tooltip(), _dec7$p = displayOrder(), _dec8$n = tooltip(), _dec9$l = visible(), _dec10$l = type(SpriteFrame), _dec11$j = visible(), _dec12$i = visible(), _dec13$g = range(), _dec14$d = visible(), _dec15$d = visible(), _dec$1f(_class$1h = _dec2$P(_class$1h = _dec3$I(_class$1h = _dec4$z(_class$1h = (_class2$13 = (_temp$18 = _class3$y = function (_Renderable2D) {
        _inheritsLoose(Mask, _Renderable2D);

        function Mask() {
          var _this;

          _this = _Renderable2D.call(this) || this;
          _this._clearStencilMtl = null;
          _this._clearModel = null;

          _initializerDefineProperty(_this, "_type", _descriptor$X, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_inverted", _descriptor2$I, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_segments", _descriptor3$y, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_spriteFrame", _descriptor4$u, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_alphaThreshold", _descriptor5$n, _assertThisInitialized(_this));

          _this._graphics = null;
          _this._clearModelMesh = null;
          _this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
          return _this;
        }

        var _proto = Mask.prototype;

        _proto.onLoad = function onLoad() {
          this._createClearModel();

          this._createGraphics();

          if (this._graphics) {
            this._graphics.onLoad();
          }
        };

        _proto.onEnable = function onEnable() {
          _Renderable2D.prototype.onEnable.call(this);

          this._updateGraphics();

          this._enableGraphics();
        };

        _proto.onRestore = function onRestore() {
          this._createGraphics();

          _Renderable2D.prototype.updateMaterial.call(this);

          this._updateGraphics();

          this._renderFlag = this._canRender();
        };

        _proto.onDisable = function onDisable() {
          _Renderable2D.prototype.onDisable.call(this);

          this._disableGraphics();
        };

        _proto.onDestroy = function onDestroy() {
          if (this._clearModel && this._clearModelMesh) {
            director.root.destroyModel(this._clearModel);

            this._clearModelMesh.destroy();
          }

          if (this._clearStencilMtl) {
            this._clearStencilMtl.destroy();
          }

          this._removeGraphics();

          _Renderable2D.prototype.onDestroy.call(this);
        };

        _proto.isHit = function isHit(worldPt) {
          var uiTrans = this.node._uiProps.uiTransformComp;
          var size = uiTrans.contentSize;
          var w = size.width;
          var h = size.height;
          var testPt = _vec2_temp;
          this.node.getWorldMatrix(_worldMatrix$2);
          Mat4.invert(_mat4_temp$1, _worldMatrix$2);
          Vec2.transformMat4(testPt, worldPt, _mat4_temp$1);
          var ap = uiTrans.anchorPoint;
          testPt.x += ap.x * w;
          testPt.y += ap.y * h;
          var result = false;

          if (this.type === MaskType.RECT || this.type === MaskType.GRAPHICS_STENCIL || this.type === MaskType.IMAGE_STENCIL) {
            result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h;
          } else if (this.type === MaskType.ELLIPSE) {
            var rx = w / 2;
            var ry = h / 2;
            var px = testPt.x - 0.5 * w;
            var py = testPt.y - 0.5 * h;
            result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
          }

          if (this._inverted) {
            result = !result;
          }

          return result;
        };

        _proto._render = function _render(render) {
          render.commitComp(this, this.renderData, null, this._assembler, null);
        };

        _proto._postRender = function _postRender(render) {
          if (!this._postAssembler) {
            return;
          }

          render.commitComp(this, null, null, this._postAssembler, null);
        };

        _proto._nodeStateChange = function _nodeStateChange(type) {
          _Renderable2D.prototype._nodeStateChange.call(this, type);

          this._updateGraphics();
        };

        _proto._canRender = function _canRender() {
          if (!_Renderable2D.prototype._canRender.call(this)) {
            return false;
          }

          return this._graphics !== null && (this._type !== MaskType.IMAGE_STENCIL || this._spriteFrame !== null);
        };

        _proto._flushAssembler = function _flushAssembler() {
          var assembler = Mask.Assembler.getAssembler(this);
          var posAssembler = Mask.PostAssembler.getAssembler(this);

          if (this._assembler !== assembler) {
            this.destroyRenderData();
            this._assembler = assembler;
          }

          if (this._postAssembler !== posAssembler) {
            this._postAssembler = posAssembler;
          }

          this._useRenderData();
        };

        _proto._createGraphics = function _createGraphics() {
          if (!this._graphics) {
            var graphics = this._graphics = new Graphics();
            graphics._objFlags |= CCObject.Flags.IsOnLoadCalled;
            graphics.node = this.node;
            graphics.node.getWorldMatrix();
            graphics.lineWidth = 0;
            var color = Color.WHITE.clone();
            color.a = 0;
            graphics.fillColor = color;
          }

          this._updateMaterial();
        };

        _proto._updateGraphics = function _updateGraphics() {
          if (!this._graphics || this._type !== MaskType.RECT && this._type !== MaskType.ELLIPSE) {
            return;
          }

          var uiTrans = this.node._uiProps.uiTransformComp;
          var graphics = this._graphics;
          graphics.clear();
          var size = uiTrans.contentSize;
          var width = size.width;
          var height = size.height;
          var ap = uiTrans.anchorPoint;
          var x = -width * ap.x;
          var y = -height * ap.y;

          if (this._type === MaskType.RECT) {
            graphics.rect(x, y, width, height);
          } else if (this._type === MaskType.ELLIPSE) {
            var center = new Vec3(x + width / 2, y + height / 2, 0);
            var radius = new Vec3(width / 2, height / 2, 0);

            var points = _calculateCircle(center, radius, this._segments);

            for (var i = 0; i < points.length; ++i) {
              var point = points[i];

              if (i === 0) {
                graphics.moveTo(point.x, point.y);
              } else {
                graphics.lineTo(point.x, point.y);
              }
            }

            graphics.close();
          }

          graphics.fill();
        };

        _proto._createClearModel = function _createClearModel() {
          if (!this._clearModel) {
            var mtl = builtinResMgr.get('default-clear-stencil');
            this._clearStencilMtl = new MaterialInstance({
              parent: mtl,
              owner: this,
              subModelIdx: 0
            });
            this._clearModel = director.root.createModel(Model);
            this._clearModel.node = this._clearModel.transform = this.node;
            var stride = getAttributeStride(vfmt);
            var gfxDevice = legacyCC.director.root.device;
            var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 4 * stride, stride));
            var vb = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
            vertexBuffer.update(vb);
            var indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
            var ib = new Uint16Array([0, 1, 2, 2, 1, 3]);
            indexBuffer.update(ib);
            this._clearModelMesh = new RenderingSubMesh([vertexBuffer], vfmt, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
            this._clearModelMesh.subMeshIdx = 0;

            this._clearModel.initSubModel(0, this._clearModelMesh, this._clearStencilMtl);
          }
        };

        _proto._updateMaterial = function _updateMaterial() {
          if (this._graphics) {
            var target = this._graphics;
            target.stencilStage = Stage.DISABLED;
            var mat;

            if (this._type === MaskType.IMAGE_STENCIL) {
              mat = builtinResMgr.get('ui-alpha-test-material');
              target.setMaterial(mat, 0);
              mat = target.getMaterialInstance(0);
              mat.setProperty('alphaThreshold', this._alphaThreshold);
            } else {
              mat = builtinResMgr.get('ui-graphics-material');
              target.setMaterial(mat, 0);
              target.getMaterialInstance(0);
            }
          }
        };

        _proto._enableGraphics = function _enableGraphics() {
          if (this._graphics) {
            this._graphics._renderFlag = this._graphics._canRender();
          }
        };

        _proto._disableGraphics = function _disableGraphics() {
          if (this._graphics) {
            this._graphics.onDisable();
          }
        };

        _proto._removeGraphics = function _removeGraphics() {
          if (this._graphics) {
            this._graphics.destroy();

            this._graphics._destroyImmediate();

            this._graphics = null;
          }
        };

        _proto._useRenderData = function _useRenderData() {
          if (this._type === MaskType.IMAGE_STENCIL && !this._renderData) {
            if (this._assembler && this._assembler.createData) {
              this._renderData = this._assembler.createData(this);
              this.markForUpdateRenderData();
            }
          }
        };

        _createClass(Mask, [{
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(value) {
            if (this._type === value) {
              return;
            }

            this._type = value;
            this.markForUpdateRenderData(false);

            this._updateMaterial();

            if (this._type !== MaskType.IMAGE_STENCIL) {
              this._spriteFrame = null;

              this._updateGraphics();

              if (this._renderData) {
                this.destroyRenderData();
                this._renderData = null;
              }
            } else {
              this._useRenderData();

              if (this._graphics) {
                this._graphics.clear();
              }
            }
          }
        }, {
          key: "inverted",
          get: function get() {
            return this._inverted;
          },
          set: function set(value) {
            this._inverted = value;
            this.stencilStage = Stage.DISABLED;

            if (this._graphics) {
              this._graphics.stencilStage = Stage.DISABLED;
            }
          }
        }, {
          key: "segments",
          get: function get() {
            return this._segments;
          },
          set: function set(value) {
            if (this._segments === value) {
              return;
            }

            this._segments = clamp(value, SEGMENTS_MIN, SEGMENTS_MAX);

            this._updateGraphics();
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value) {
            if (this._spriteFrame === value) {
              return;
            }

            var lastSp = this._spriteFrame;
            this._spriteFrame = value;

            if (this._type === MaskType.IMAGE_STENCIL) {
              if (!lastSp && value) {
                this.markForUpdateRenderData();
              }
            }
          }
        }, {
          key: "alphaThreshold",
          get: function get() {
            return this._alphaThreshold;
          },
          set: function set(value) {
            if (this._alphaThreshold === value) {
              return;
            }

            this._alphaThreshold = value;

            if (this.type === MaskType.IMAGE_STENCIL && this._graphics) {
              var mat = this._graphics.getMaterialInstance(0);

              mat.setProperty('alphaThreshold', this._alphaThreshold);
            }
          }
        }, {
          key: "graphics",
          get: function get() {
            return this._graphics;
          }
        }, {
          key: "dstBlendFactor",
          get: function get() {
            return this._dstBlendFactor;
          },
          set: function set(value) {
            if (this._dstBlendFactor === value) {
              return;
            }

            this._dstBlendFactor = value;

            this._updateBlendFunc();
          }
        }, {
          key: "srcBlendFactor",
          get: function get() {
            return this._srcBlendFactor;
          },
          set: function set(value) {
            if (this._srcBlendFactor === value) {
              return;
            }

            this._srcBlendFactor = value;

            this._updateBlendFunc();
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color === value) {
              return;
            }

            this._color.set(value);

            this.markForUpdateRenderData();
          }
        }, {
          key: "customMaterial",
          get: function get() {
            return this._customMaterial;
          },
          set: function set(val) {}
        }]);

        return Mask;
      }(Renderable2D), _class3$y.Type = MaskType, _temp$18), (_applyDecoratedDescriptor(_class2$13.prototype, "type", [_dec5$v, _dec6$r], Object.getOwnPropertyDescriptor(_class2$13.prototype, "type"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "inverted", [_dec7$p, _dec8$n], Object.getOwnPropertyDescriptor(_class2$13.prototype, "inverted"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "segments", [_dec9$l], Object.getOwnPropertyDescriptor(_class2$13.prototype, "segments"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "spriteFrame", [_dec10$l, _dec11$j], Object.getOwnPropertyDescriptor(_class2$13.prototype, "spriteFrame"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "alphaThreshold", [_dec12$i, _dec13$g, slide], Object.getOwnPropertyDescriptor(_class2$13.prototype, "alphaThreshold"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "color", [override, _dec14$d], Object.getOwnPropertyDescriptor(_class2$13.prototype, "color"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "customMaterial", [override, _dec15$d], Object.getOwnPropertyDescriptor(_class2$13.prototype, "customMaterial"), _class2$13.prototype), _descriptor$X = _applyDecoratedDescriptor(_class2$13.prototype, "_type", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return MaskType.RECT;
        }
      }), _descriptor2$I = _applyDecoratedDescriptor(_class2$13.prototype, "_inverted", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor3$y = _applyDecoratedDescriptor(_class2$13.prototype, "_segments", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 64;
        }
      }), _descriptor4$u = _applyDecoratedDescriptor(_class2$13.prototype, "_spriteFrame", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5$n = _applyDecoratedDescriptor(_class2$13.prototype, "_alphaThreshold", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      })), _class2$13)) || _class$1h) || _class$1h) || _class$1h) || _class$1h));
      NodeEventProcessor._maskComp = Mask;
      legacyCC.Mask = Mask;

      var eventRegx = /^(click)(\s)*=|(param)(\s)*=/;
      var imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
      var HtmlTextParser = exports('HtmlTextParser', function () {
        function HtmlTextParser() {
          this._specialSymbolArray = [];
          this._stack = [];
          this._resultObjectArray = [];

          this._specialSymbolArray.push([/&lt;/g, '<']);

          this._specialSymbolArray.push([/&gt;/g, '>']);

          this._specialSymbolArray.push([/&amp;/g, '&']);

          this._specialSymbolArray.push([/&quot;/g, '"']);

          this._specialSymbolArray.push([/&apos;/g, '\'']);
        }

        var _proto = HtmlTextParser.prototype;

        _proto.parse = function parse(htmlString) {
          this._resultObjectArray.length = 0;
          this._stack.length = 0;
          var startIndex = 0;
          var length = htmlString.length;

          while (startIndex < length) {
            var tagEndIndex = htmlString.indexOf('>', startIndex);
            var tagBeginIndex = -1;

            if (tagEndIndex >= 0) {
              tagBeginIndex = htmlString.lastIndexOf('<', tagEndIndex);
              var noTagBegin = tagBeginIndex < startIndex - 1;

              if (noTagBegin) {
                tagBeginIndex = htmlString.indexOf('<', tagEndIndex + 1);
                tagEndIndex = htmlString.indexOf('>', tagBeginIndex + 1);
              }
            }

            if (tagBeginIndex < 0) {
              this._stack.pop();

              this._processResult(htmlString.substring(startIndex));

              startIndex = length;
            } else {
              var newStr = htmlString.substring(startIndex, tagBeginIndex);
              var tagStr = htmlString.substring(tagBeginIndex + 1, tagEndIndex);
              if (tagStr === '') newStr = htmlString.substring(startIndex, tagEndIndex + 1);

              this._processResult(newStr);

              if (tagEndIndex === -1) {
                tagEndIndex = tagBeginIndex;
              } else if (htmlString.charAt(tagBeginIndex + 1) === '/') {
                this._stack.pop();
              } else {
                this._addToStack(tagStr);
              }

              startIndex = tagEndIndex + 1;
            }
          }

          return this._resultObjectArray;
        };

        _proto._attributeToObject = function _attributeToObject(attribute) {
          attribute = attribute.trim();
          var obj = {};
          var header = /^(color|size)(\s)*=/.exec(attribute);
          var tagName = '';
          var nextSpace = 0;
          var eventHanlderString = '';

          if (header) {
            tagName = header[0];
            attribute = attribute.substring(tagName.length).trim();

            if (attribute === '') {
              return obj;
            }

            nextSpace = attribute.indexOf(' ');

            switch (tagName[0]) {
              case 'c':
                if (nextSpace > -1) {
                  obj.color = attribute.substring(0, nextSpace).trim();
                } else {
                  obj.color = attribute;
                }

                break;

              case 's':
                obj.size = parseInt(attribute);
                break;
            }

            if (nextSpace > -1) {
              eventHanlderString = attribute.substring(nextSpace + 1).trim();
              obj.event = this._processEventHandler(eventHanlderString);
            }

            return obj;
          }

          header = /^(br(\s)*\/)/.exec(attribute);

          if (header && header[0].length > 0) {
            tagName = header[0].trim();

            if (tagName.startsWith('br') && tagName[tagName.length - 1] === '/') {
              obj.isNewLine = true;

              this._resultObjectArray.push({
                text: '',
                style: {
                  isNewLine: true
                }
              });

              return obj;
            }
          }

          header = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(attribute);
          var remainingArgument = '';
          var rightQuot = -1;

          if (header && header[0].length > 0) {
            tagName = header[0].trim();

            if (tagName.startsWith('img') && tagName[tagName.length - 1] === '/') {
              header = imageAttrReg.exec(attribute);
              var tagValue;
              var isValidImageTag = false;

              while (header) {
                attribute = attribute.substring(attribute.indexOf(header[0]));
                tagName = attribute.substr(0, header[0].length);
                var originTagNameLength = tagName.length;
                tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                tagName = tagName.toLowerCase();
                remainingArgument = attribute.substring(originTagNameLength).trim();

                if (tagName === 'src') {
                  rightQuot = this.getRightQuotationIndex(remainingArgument);
                } else {
                  rightQuot = -1;
                }

                nextSpace = remainingArgument.indexOf(' ', rightQuot + 1 >= remainingArgument.length ? -1 : rightQuot + 1);
                tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
                attribute = remainingArgument.substring(nextSpace).trim();

                if (tagValue.endsWith('/')) {
                  tagValue = tagValue.slice(0, -1);
                }

                if (tagName === 'src') {
                  switch (tagValue.charCodeAt(0)) {
                    case 34:
                    case 39:
                      isValidImageTag = true;
                      tagValue = tagValue.slice(1, -1);
                      break;
                  }

                  obj.isImage = true;
                  obj.src = tagValue;
                } else if (tagName === 'height') {
                  obj.imageHeight = parseInt(tagValue);
                } else if (tagName === 'width') {
                  obj.imageWidth = parseInt(tagValue);
                } else if (tagName === 'align') {
                  switch (tagValue.charCodeAt(0)) {
                    case 34:
                    case 39:
                      tagValue = tagValue.slice(1, -1);
                      break;
                  }

                  obj.imageAlign = tagValue.toLowerCase();
                } else if (tagName === 'offset') {
                  obj.imageOffset = tagValue;
                } else if (tagName === 'click') {
                  obj.event = this._processEventHandler(tagName + "=" + tagValue);
                }

                if (obj.event && tagName === 'param') {
                  obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                }

                header = imageAttrReg.exec(attribute);
              }

              if (isValidImageTag && obj.isImage) {
                this._resultObjectArray.push({
                  text: '',
                  style: obj
                });
              }

              return {};
            }
          }

          header = /^(outline(\s)*[^>]*)/.exec(attribute);

          if (header) {
            attribute = header[0].substring('outline'.length).trim();
            var defaultOutlineObject = {
              color: '#ffffff',
              width: 1
            };

            if (attribute) {
              var outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
              header = outlineAttrReg.exec(attribute);

              var _tagValue;

              while (header) {
                attribute = attribute.substring(attribute.indexOf(header[0]));
                tagName = attribute.substr(0, header[0].length);
                remainingArgument = attribute.substring(tagName.length).trim();
                nextSpace = remainingArgument.indexOf(' ');

                if (nextSpace > -1) {
                  _tagValue = remainingArgument.substr(0, nextSpace);
                } else {
                  _tagValue = remainingArgument;
                }

                tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                tagName = tagName.toLowerCase();
                attribute = remainingArgument.substring(nextSpace).trim();

                if (tagName === 'click') {
                  obj.event = this._processEventHandler(tagName + "=" + _tagValue);
                } else if (tagName === 'color') {
                  defaultOutlineObject.color = _tagValue;
                } else if (tagName === 'width') {
                  defaultOutlineObject.width = parseInt(_tagValue);
                }

                if (obj.event && tagName === 'param') {
                  obj.event[tagName] = _tagValue.replace(/^"|"$/g, '');
                }

                header = outlineAttrReg.exec(attribute);
              }
            }

            obj.outline = defaultOutlineObject;
          }

          header = /^(on|u|b|i)(\s)*/.exec(attribute);

          if (header && header[0].length > 0) {
            tagName = header[0];
            attribute = attribute.substring(tagName.length).trim();

            switch (tagName[0]) {
              case 'u':
                obj.underline = true;
                break;

              case 'i':
                obj.italic = true;
                break;

              case 'b':
                obj.bold = true;
                break;
            }

            if (attribute === '') {
              return obj;
            }

            obj.event = this._processEventHandler(attribute);
          }

          return obj;
        };

        _proto.getRightQuotationIndex = function getRightQuotationIndex(remainingArgument) {
          var leftQuot = -1;
          var rightQuot = -1;
          var leftSingleQuot = remainingArgument.indexOf('\'');
          var leftDoubleQuot = remainingArgument.indexOf('"');
          var useSingleQuot = leftSingleQuot > -1 && (leftSingleQuot < leftDoubleQuot || leftDoubleQuot === -1);
          var useDoubleQuot = leftDoubleQuot > -1 && (leftDoubleQuot < leftSingleQuot || leftSingleQuot === -1);

          if (useSingleQuot) {
            leftQuot = leftSingleQuot;
            rightQuot = remainingArgument.indexOf('\'', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
          } else if (useDoubleQuot) {
            leftQuot = leftDoubleQuot;
            rightQuot = remainingArgument.indexOf('"', leftQuot + 1 >= remainingArgument.length ? -1 : leftQuot + 1);
          }

          return rightQuot;
        };

        _proto._processEventHandler = function _processEventHandler(eventString) {
          var obj = {};
          var index = 0;
          var isValidTag = false;
          var eventNames = eventRegx.exec(eventString);

          while (eventNames) {
            var eventName = eventNames[0];
            var eventValue = '';
            isValidTag = false;
            eventString = eventString.substring(eventName.length).trim();

            if (eventString.charAt(0) === '"') {
              index = eventString.indexOf('"', 1);

              if (index > -1) {
                eventValue = eventString.substring(1, index).trim();
                isValidTag = true;
              }

              index++;
            } else if (eventString.charAt(0) === '\'') {
              index = eventString.indexOf('\'', 1);

              if (index > -1) {
                eventValue = eventString.substring(1, index).trim();
                isValidTag = true;
              }

              index++;
            } else {
              var match = /(\S)+/.exec(eventString);

              if (match) {
                eventValue = match[0];
              } else {
                eventValue = '';
              }

              index = eventValue.length;
            }

            if (isValidTag) {
              eventName = eventName.substring(0, eventName.length - 1).trim();
              obj[eventName] = eventValue;
            }

            eventString = eventString.substring(index).trim();
            eventNames = eventRegx.exec(eventString);
          }

          return obj;
        };

        _proto._addToStack = function _addToStack(attribute) {
          var obj = this._attributeToObject(attribute);

          if (this._stack.length === 0) {
            this._stack.push(obj);
          } else {
            if (obj.isNewLine || obj.isImage) {
              return;
            }

            var previousTagObj = this._stack[this._stack.length - 1];

            for (var key in previousTagObj) {
              if (!obj[key]) {
                obj[key] = previousTagObj[key];
              }
            }

            this._stack.push(obj);
          }
        };

        _proto._processResult = function _processResult(value) {
          if (value.length === 0) {
            return;
          }

          value = this._escapeSpecialSymbol(value);

          if (this._stack.length > 0) {
            this._resultObjectArray.push({
              text: value,
              style: this._stack[this._stack.length - 1]
            });
          } else {
            this._resultObjectArray.push({
              text: value
            });
          }
        };

        _proto._escapeSpecialSymbol = function _escapeSpecialSymbol(str) {
          for (var _iterator = _createForOfIteratorHelperLoose(this._specialSymbolArray), _step; !(_step = _iterator()).done;) {
            var symbolArr = _step.value;
            var key = symbolArr[0];
            var value = symbolArr[1];
            str = str.replace(key, value);
          }

          return str;
        };

        return HtmlTextParser;
      }());

      var _dec$1g, _dec2$Q, _dec3$J, _dec4$A, _dec5$w, _dec6$s, _dec7$q, _class$1i, _class2$14, _descriptor$Y, _descriptor2$J, _temp$19;
      var LabelOutline = function (v) { return exports({ LabelOutline: v, LabelOutlineComponent: v }), v; }((_dec$1g = ccclass('cc.LabelOutline'), _dec2$Q = help(), _dec3$J = executionOrder(110), _dec4$A = menu(), _dec5$w = requireComponent(Label), _dec6$s = tooltip(), _dec7$q = tooltip(), _dec$1g(_class$1i = _dec2$Q(_class$1i = _dec3$J(_class$1i = _dec4$A(_class$1i = _dec5$w(_class$1i = executeInEditMode(_class$1i = (_class2$14 = (_temp$19 = function (_Component) {
        _inheritsLoose(LabelOutline, _Component);

        function LabelOutline() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_color", _descriptor$Y, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_width", _descriptor2$J, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = LabelOutline.prototype;

        _proto.onEnable = function onEnable() {
          this._updateRenderData();
        };

        _proto.onDisable = function onDisable() {
          this._updateRenderData();
        };

        _proto._updateRenderData = function _updateRenderData() {
          var label = this.node.getComponent(Label);

          if (label) {
            label.updateRenderData(true);
          }
        };

        _createClass(LabelOutline, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color === value) {
              return;
            }

            this._color.set(value);

            this._updateRenderData();
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          },
          set: function set(value) {
            if (this._width === value) {
              return;
            }

            this._width = value;

            this._updateRenderData();
          }
        }]);

        return LabelOutline;
      }(Component), _temp$19), (_descriptor$Y = _applyDecoratedDescriptor(_class2$14.prototype, "_color", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(0, 0, 0, 255);
        }
      }), _descriptor2$J = _applyDecoratedDescriptor(_class2$14.prototype, "_width", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      }), _applyDecoratedDescriptor(_class2$14.prototype, "color", [_dec6$s], Object.getOwnPropertyDescriptor(_class2$14.prototype, "color"), _class2$14.prototype), _applyDecoratedDescriptor(_class2$14.prototype, "width", [_dec7$q], Object.getOwnPropertyDescriptor(_class2$14.prototype, "width"), _class2$14.prototype)), _class2$14)) || _class$1i) || _class$1i) || _class$1i) || _class$1i) || _class$1i) || _class$1i));
      legacyCC.LabelOutline = LabelOutline;

      var _dec$1h, _dec2$R, _dec3$K, _dec4$B, _dec5$x, _dec6$t, _dec7$r, _dec8$o, _dec9$m, _dec10$m, _dec11$k, _dec12$j, _dec13$h, _dec14$e, _dec15$e, _dec16$c, _dec17$c, _dec18$c, _dec19$c, _dec20$c, _dec21$c, _dec22$c, _class$1j, _class2$15, _descriptor$Z, _descriptor2$K, _descriptor3$z, _descriptor4$v, _descriptor5$o, _descriptor6$e, _descriptor7$d, _descriptor8$d, _descriptor9$c, _descriptor10$c, _descriptor11$b, _descriptor12$a, _descriptor13$9, _class3$z, _temp$1a;

      var _htmlTextParser = new HtmlTextParser();

      var RichTextChildName = 'RICHTEXT_CHILD';
      var RichTextChildImageName = 'RICHTEXT_Image_CHILD';
      var labelPool = new Pool(function (seg) {

        if (!legacyCC.isValid(seg.node)) {
          return false;
        } else {
          var outline = seg.node.getComponent(LabelOutline);

          if (outline) {
            outline.width = 0;
          }
        }

        return true;
      }, 20);
      var imagePool = new Pool(function (seg) {

        return legacyCC.isValid(seg.node);
      }, 10);

      function createSegment(type) {
        return {
          node: new Node$1(type),
          comp: null,
          lineCount: 0,
          styleIndex: 0,
          imageOffset: '',
          clickParam: '',
          clickHandler: '',
          type: type
        };
      }

      function getSegmentByPool(type, content) {
        var seg;

        if (type === RichTextChildName) {
          seg = labelPool._get();
        } else if (type === RichTextChildImageName) {
          seg = imagePool._get();
        }

        seg = seg || createSegment(type);
        var node = seg.node;

        if (!node) {
          node = new Node$1(type);
        }

        node.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;

        if (type === RichTextChildImageName) {
          seg.comp = node.getComponent(Sprite) || node.addComponent(Sprite);
          seg.comp.spriteFrame = content;
          seg.comp.type = Sprite.Type.SLICED;
          seg.comp.sizeMode = Sprite.SizeMode.CUSTOM;
        } else {
          seg.comp = node.getComponent(Label) || node.addComponent(Label);
          seg.comp.string = content;
          seg.comp.horizontalAlign = HorizontalTextAlignment.LEFT;
          seg.comp.verticalAlign = VerticalTextAlignment.TOP;
          seg.comp.underlineHeight = 2;
        }

        node.setPosition(0, 0, 0);
        var trans = node._uiProps.uiTransformComp;
        trans.setAnchorPoint(0.5, 0.5);
        seg.node = node;
        seg.lineCount = 0;
        seg.styleIndex = 0;
        seg.imageOffset = '';
        seg.clickParam = '';
        seg.clickHandler = '';
        return seg;
      }

      var RichText = function (v) { return exports({ RichText: v, RichTextComponent: v }), v; }((_dec$1h = ccclass('cc.RichText'), _dec2$R = help(), _dec3$K = executionOrder(110), _dec4$B = menu(), _dec5$x = tooltip(), _dec6$t = type(HorizontalTextAlignment), _dec7$r = tooltip(), _dec8$o = type(VerticalTextAlignment), _dec9$m = tooltip(), _dec10$m = tooltip(), _dec11$k = tooltip(), _dec12$j = type(Font), _dec13$h = tooltip(), _dec14$e = tooltip(), _dec15$e = displayOrder(), _dec16$c = type(CacheMode), _dec17$c = tooltip(), _dec18$c = tooltip(), _dec19$c = tooltip(), _dec20$c = type(SpriteAtlas), _dec21$c = tooltip(), _dec22$c = tooltip(), _dec$1h(_class$1j = _dec2$R(_class$1j = _dec3$K(_class$1j = _dec4$B(_class$1j = executeInEditMode(_class$1j = (_class2$15 = (_temp$1a = _class3$z = function (_Component) {
        _inheritsLoose(RichText, _Component);

        function RichText() {
          var _this;

          _this = _Component.call(this) || this;

          _initializerDefineProperty(_this, "_lineHeight", _descriptor$Z, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_string", _descriptor2$K, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$z, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_verticalAlign", _descriptor4$v, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fontSize", _descriptor5$o, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_maxWidth", _descriptor6$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fontFamily", _descriptor7$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_font", _descriptor8$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor9$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_userDefinedFont", _descriptor10$c, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_cacheMode", _descriptor11$b, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_imageAtlas", _descriptor12$a, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_handleTouchEvent", _descriptor13$9, _assertThisInitialized(_this));

          _this._textArray = [];
          _this._segments = [];
          _this._labelSegmentsCache = [];
          _this._linesWidth = [];
          _this._lineCount = 1;
          _this._labelWidth = 0;
          _this._labelHeight = 0;
          _this._layoutDirty = true;
          _this._lineOffsetX = 0;
          _this._updateRichTextStatus = void 0;
          _this._labelChildrenNum = 0;

          _this._updateRichTextStatus = _this._updateRichText;
          return _this;
        }

        var _proto = RichText.prototype;

        _proto.onLoad = function onLoad() {
          this.node.on(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
        };

        _proto.onEnable = function onEnable() {
          if (this.handleTouchEvent) {
            this._addEventListeners();
          }

          this._updateRichText();

          this._activateChildren(true);
        };

        _proto.onDisable = function onDisable() {
          if (this.handleTouchEvent) {
            this._removeEventListeners();
          }

          this._activateChildren(false);
        };

        _proto.start = function start() {
          this._onTTFLoaded();

          this.node.on(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
        };

        _proto.onRestore = function onRestore() {
          {
            return;
          }
        };

        _proto.onDestroy = function onDestroy() {
          for (var _iterator = _createForOfIteratorHelperLoose(this._segments), _step; !(_step = _iterator()).done;) {
            var seg = _step.value;
            seg.node.removeFromParent();

            if (seg.type === RichTextChildName) {
              labelPool.put(seg);
            } else if (seg.type === RichTextChildImageName) {
              imagePool.put(seg);
            }
          }

          this.node.off(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
          this.node.off(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
        };

        _proto._addEventListeners = function _addEventListeners() {
          this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        };

        _proto._removeEventListeners = function _removeEventListeners() {
          this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
        };

        _proto._updateLabelSegmentTextAttributes = function _updateLabelSegmentTextAttributes() {
          var _this2 = this;

          this._segments.forEach(function (item) {
            _this2._applyTextAttribute(item);
          });
        };

        _proto._createFontLabel = function _createFontLabel(str) {
          return getSegmentByPool(RichTextChildName, str);
        };

        _proto._createImage = function _createImage(spriteFrame) {
          return getSegmentByPool(RichTextChildImageName, spriteFrame);
        };

        _proto._onTTFLoaded = function _onTTFLoaded() {
          if (this._font instanceof TTFFont) {
            this._layoutDirty = true;

            this._updateRichText();
          } else {
            this._layoutDirty = true;

            this._updateRichText();
          }
        };

        _proto.SplitLongStringApproximatelyIn2048 = function SplitLongStringApproximatelyIn2048(text, styleIndex) {
          var labelSize = this._calculateSize(styleIndex, text);

          var partStringArr = [];

          if (labelSize.x < 2048) {
            partStringArr.push(text);
          } else {
            var multilineTexts = text.split('\n');

            for (var i = 0; i < multilineTexts.length; i++) {
              var thisPartSize = this._calculateSize(styleIndex, multilineTexts[i]);

              if (thisPartSize.x < 2048) {
                partStringArr.push(multilineTexts[i]);
              } else {
                var thisPartSplitResultArr = this.splitLongStringOver2048(multilineTexts[i], styleIndex);
                partStringArr.push.apply(partStringArr, thisPartSplitResultArr);
              }
            }
          }

          return partStringArr;
        };

        _proto.splitLongStringOver2048 = function splitLongStringOver2048(text, styleIndex) {
          var partStringArr = [];
          var longStr = text;
          var curStart = 0;
          var curEnd = longStr.length / 2;
          var curString = longStr.substring(curStart, curEnd);
          var leftString = longStr.substring(curEnd);

          var curStringSize = this._calculateSize(styleIndex, curString);

          var leftStringSize = this._calculateSize(styleIndex, leftString);

          var lineCountForOnePart = 1;
          var sizeForOnePart = lineCountForOnePart * this.maxWidth;

          while (curStringSize.x > sizeForOnePart) {
            curEnd /= 2;

            if (curEnd < 1) {
              curEnd *= 2;
              break;
            }

            curString = curString.substring(curStart, curEnd);
            leftString = longStr.substring(curEnd);
            curStringSize = this._calculateSize(styleIndex, curString);
          }

          var leftTryTimes = 1000;
          var curWordStep = 1;

          while (leftTryTimes && curStart < text.length) {
            while (leftTryTimes && curStringSize.x < sizeForOnePart) {
              var nextPartExec = getEnglishWordPartAtFirst(leftString);

              if (nextPartExec && nextPartExec.length > 0) {
                curWordStep = nextPartExec[0].length;
              }

              curEnd += curWordStep;
              curString = longStr.substring(curStart, curEnd);
              leftString = longStr.substring(curEnd);
              curStringSize = this._calculateSize(styleIndex, curString);
              leftTryTimes--;
            }

            while (leftTryTimes && curString.length >= 2 && curStringSize.x > sizeForOnePart) {
              curEnd -= curWordStep;
              curString = longStr.substring(curStart, curEnd);
              curStringSize = this._calculateSize(styleIndex, curString);
              curWordStep = 1;
              leftTryTimes--;
            }

            if (curString.length >= 2) {
              var lastWordExec = getEnglishWordPartAtLast(curString);

              if (lastWordExec && lastWordExec.length > 0 && curString !== lastWordExec[0]) {
                curEnd -= lastWordExec[0].length;
                curString = longStr.substring(curStart, curEnd);
              }
            }

            partStringArr.push(curString);
            var partStep = curString.length;
            curStart = curEnd;
            curEnd += partStep;
            curString = longStr.substring(curStart, curEnd);
            leftString = longStr.substring(curEnd);
            leftStringSize = this._calculateSize(styleIndex, leftString);
            leftTryTimes--;

            if (leftStringSize.x < 2048) {
              curStart = text.length;
              curEnd = text.length;
              curString = leftString;
              partStringArr.push(curString);
              break;
            } else {
              curStringSize = this._calculateSize(styleIndex, curString);
            }
          }

          return partStringArr;
        };

        _proto._measureText = function _measureText(styleIndex, string) {
          var _this3 = this;

          var func = function func(s) {
            var labelSize = _this3._calculateSize(styleIndex, s);

            return labelSize.width;
          };

          if (string) {
            return func(string);
          } else {
            return func;
          }
        };

        _proto._calculateSize = function _calculateSize(styleIndex, s) {
          var label;

          if (this._labelSegmentsCache.length === 0) {
            label = this._createFontLabel(s);

            this._labelSegmentsCache.push(label);
          } else {
            label = this._labelSegmentsCache[0];
            label.node.getComponent(Label).string = s;
          }

          label.styleIndex = styleIndex;

          this._applyTextAttribute(label);

          var labelSize = label.node._uiProps.uiTransformComp.contentSize;
          return labelSize;
        };

        _proto._onTouchEnded = function _onTouchEnded(event) {
          var _this4 = this;

          var components = this.node.getComponents(Component);

          var _loop = function _loop() {
            var seg = _step2.value;
            var clickHandler = seg.clickHandler;
            var clickParam = seg.clickParam;

            if (clickHandler && _this4._containsTouchLocation(seg, event.touch.getUILocation())) {
              components.forEach(function (component) {
                var func = component[clickHandler];

                if (component.enabledInHierarchy && func) {
                  func.call(component, event, clickParam);
                }
              });
              event.propagationStopped = true;
            }
          };

          for (var _iterator2 = _createForOfIteratorHelperLoose(this._segments), _step2; !(_step2 = _iterator2()).done;) {
            _loop();
          }
        };

        _proto._containsTouchLocation = function _containsTouchLocation(label, point) {
          var comp = label.node.getComponent(UITransform);

          if (!comp) {
            return false;
          }

          var myRect = comp.getBoundingBoxToWorld();
          return myRect.contains(point);
        };

        _proto._resetState = function _resetState() {
          var children = this.node.children;

          for (var i = children.length - 1; i >= 0; i--) {
            var child = children[i];

            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
              if (child.parent === this.node) {
                child.parent = null;
              } else {
                children.splice(i, 1);
              }

              var segment = createSegment(child.name);
              segment.node = child;

              if (child.name === RichTextChildName) {
                segment.comp = child.getComponent(Label);
                labelPool.put(segment);
              } else {
                segment.comp = child.getComponent(Sprite);
                imagePool.put(segment);
              }

              this._labelChildrenNum--;
            }
          }

          this._segments.length = 0;
          this._labelSegmentsCache.length = 0;
          this._linesWidth.length = 0;
          this._lineOffsetX = 0;
          this._lineCount = 1;
          this._labelWidth = 0;
          this._labelHeight = 0;
          this._layoutDirty = true;
        };

        _proto._activateChildren = function _activateChildren(active) {
          for (var i = this.node.children.length - 1; i >= 0; i--) {
            var child = this.node.children[i];

            if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
              child.active = active;
            }
          }
        };

        _proto._addLabelSegment = function _addLabelSegment(stringToken, styleIndex) {
          var labelSegment;

          if (this._labelSegmentsCache.length === 0) {
            labelSegment = this._createFontLabel(stringToken);
          } else {
            labelSegment = this._labelSegmentsCache.pop();
            var label = labelSegment.node.getComponent(Label);

            if (label) {
              label.string = stringToken;
            }
          }

          var labelComp = labelSegment.comp;

          if (labelComp.verticalAlign !== this._verticalAlign) {
            labelComp.verticalAlign = this._verticalAlign;
          }

          labelSegment.styleIndex = styleIndex;
          labelSegment.lineCount = this._lineCount;

          labelSegment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

          labelSegment.node.layer = this.node.layer;
          this.node.insertChild(labelSegment.node, this._labelChildrenNum++);

          this._applyTextAttribute(labelSegment);

          this._segments.push(labelSegment);

          return labelSegment;
        };

        _proto._updateRichTextWithMaxWidth = function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
          var fragmentWidth = labelWidth;
          var labelSegment;

          if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this._maxWidth) {
            var checkStartIndex = 0;

            while (this._lineOffsetX <= this._maxWidth) {
              var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);

              var checkString = labelString.substr(checkStartIndex, checkEndIndex);

              var checkStringWidth = this._measureText(styleIndex, checkString);

              if (this._lineOffsetX + checkStringWidth <= this._maxWidth) {
                this._lineOffsetX += checkStringWidth;
                checkStartIndex += checkEndIndex;
              } else {
                if (checkStartIndex > 0) {
                  var remainingString = labelString.substr(0, checkStartIndex);

                  this._addLabelSegment(remainingString, styleIndex);

                  labelString = labelString.substr(checkStartIndex, labelString.length);
                  fragmentWidth = this._measureText(styleIndex, labelString);
                }

                this._updateLineInfo();

                break;
              }
            }
          }

          if (fragmentWidth > this._maxWidth) {
            var fragments = fragmentText(labelString, fragmentWidth, this._maxWidth, this._measureText(styleIndex));

            for (var k = 0; k < fragments.length; ++k) {
              var splitString = fragments[k];
              labelSegment = this._addLabelSegment(splitString, styleIndex);
              var labelSize = labelSegment.node._uiProps.uiTransformComp.contentSize;
              this._lineOffsetX += labelSize.width;

              if (fragments.length > 1 && k < fragments.length - 1) {
                this._updateLineInfo();
              }
            }
          } else {
            this._lineOffsetX += fragmentWidth;

            this._addLabelSegment(labelString, styleIndex);
          }
        };

        _proto._isLastComponentCR = function _isLastComponentCR(stringToken) {
          return stringToken.length - 1 === stringToken.lastIndexOf('\n');
        };

        _proto._updateLineInfo = function _updateLineInfo() {
          this._linesWidth.push(this._lineOffsetX);

          this._lineOffsetX = 0;
          this._lineCount++;
        };

        _proto._needsUpdateTextLayout = function _needsUpdateTextLayout(newTextArray) {
          if (this._layoutDirty || !this._textArray || !newTextArray) {
            return true;
          }

          if (this._textArray.length !== newTextArray.length) {
            return true;
          }

          for (var i = 0; i < this._textArray.length; i++) {
            var oldItem = this._textArray[i];
            var newItem = newTextArray[i];

            if (oldItem.text !== newItem.text) {
              return true;
            } else {
              var oldStyle = oldItem.style;
              var newStyle = newItem.style;

              if (oldStyle) {
                if (newStyle) {
                  if (!!newStyle.outline !== !!oldStyle.outline) {
                    return true;
                  }

                  if (oldStyle.size !== newStyle.size || oldStyle.italic !== newStyle.italic || oldStyle.isImage !== newStyle.isImage) {
                    return true;
                  }

                  if (oldStyle.src !== newStyle.src || oldStyle.imageAlign !== newStyle.imageAlign || oldStyle.imageHeight !== newStyle.imageHeight || oldStyle.imageWidth !== newStyle.imageWidth || oldStyle.imageOffset !== newStyle.imageOffset) {
                    return true;
                  }
                } else if (oldStyle.size || oldStyle.italic || oldStyle.isImage || oldStyle.outline) {
                  return true;
                }
              } else if (newStyle) {
                if (newStyle.size || newStyle.italic || newStyle.isImage || newStyle.outline) {
                  return true;
                }
              }
            }
          }

          return false;
        };

        _proto._addRichTextImageElement = function _addRichTextImageElement(richTextElement) {
          if (!richTextElement.style) {
            return;
          }

          var style = richTextElement.style;
          var spriteFrameName = style.src;

          var spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);

          if (!spriteFrame) {
            warnID(4400);
          } else {
            var segment = this._createImage(spriteFrame);

            var sprite = segment.comp;

            switch (style.imageAlign) {
              case 'top':
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);

                break;

              case 'center':
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0.5);

                break;

              default:
                segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

                break;
            }

            if (style.imageOffset) {
              segment.imageOffset = style.imageOffset;
            }

            segment.node.layer = this.node.layer;
            this.node.insertChild(segment.node, this._labelChildrenNum++);

            this._segments.push(segment);

            var spriteRect = spriteFrame.rect.clone();
            var scaleFactor = 1;
            var spriteWidth = spriteRect.width;
            var spriteHeight = spriteRect.height;
            var expectWidth = style.imageWidth || 0;
            var expectHeight = style.imageHeight || 0;

            if (expectHeight > 0) {
              scaleFactor = expectHeight / spriteHeight;
              spriteWidth *= scaleFactor;
              spriteHeight *= scaleFactor;
            } else {
              scaleFactor = this._lineHeight / spriteHeight;
              spriteWidth *= scaleFactor;
              spriteHeight *= scaleFactor;
            }

            if (expectWidth > 0) {
              spriteWidth = expectWidth;
            }

            if (this._maxWidth > 0) {
              if (this._lineOffsetX + spriteWidth > this._maxWidth) {
                this._updateLineInfo();
              }

              this._lineOffsetX += spriteWidth;
            } else {
              this._lineOffsetX += spriteWidth;

              if (this._lineOffsetX > this._labelWidth) {
                this._labelWidth = this._lineOffsetX;
              }
            }

            segment.node._uiProps.uiTransformComp.setContentSize(spriteWidth, spriteHeight);

            segment.lineCount = this._lineCount;
            segment.clickHandler = '';
            segment.clickParam = '';
            var event = style.event;

            if (event) {
              segment.clickHandler = event.click;
              segment.clickParam = event.param;
            }
          }
        };

        _proto._updateRichText = function _updateRichText() {
          if (!this.enabledInHierarchy) {
            return;
          }

          var newTextArray = _htmlTextParser.parse(this._string);

          if (!this._needsUpdateTextLayout(newTextArray)) {
            this._textArray = newTextArray.slice();

            this._updateLabelSegmentTextAttributes();

            return;
          }

          this._textArray = newTextArray.slice();

          this._resetState();

          var lastEmptyLine = false;
          var label;

          for (var i = 0; i < this._textArray.length; ++i) {
            var richTextElement = this._textArray[i];
            var text = richTextElement.text;

            if (text === undefined) {
              continue;
            }

            if (text === '') {
              if (richTextElement.style && richTextElement.style.isNewLine) {
                this._updateLineInfo();

                continue;
              }

              if (richTextElement.style && richTextElement.style.isImage && this._imageAtlas) {
                this._addRichTextImageElement(richTextElement);

                continue;
              }
            }

            var splitArr = this.SplitLongStringApproximatelyIn2048(text, i);
            text = splitArr.join('\n');
            var multilineTexts = text.split('\n');

            for (var j = 0; j < multilineTexts.length; ++j) {
              var labelString = multilineTexts[j];

              if (labelString === '') {
                if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) {
                  continue;
                }

                this._updateLineInfo();

                lastEmptyLine = true;
                continue;
              }

              lastEmptyLine = false;

              if (this._maxWidth > 0) {
                var labelWidth = this._measureText(i, labelString);

                this._updateRichTextWithMaxWidth(labelString, labelWidth, i);

                if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                  this._updateLineInfo();
                }
              } else {
                label = this._addLabelSegment(labelString, i);
                this._lineOffsetX += label.node._uiProps.uiTransformComp.width;

                if (this._lineOffsetX > this._labelWidth) {
                  this._labelWidth = this._lineOffsetX;
                }

                if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                  this._updateLineInfo();
                }
              }
            }
          }

          if (!lastEmptyLine) {
            this._linesWidth.push(this._lineOffsetX);
          }

          if (this._maxWidth > 0) {
            this._labelWidth = this._maxWidth;
          }

          this._labelHeight = (this._lineCount + BASELINE_RATIO) * this._lineHeight;

          this.node._uiProps.uiTransformComp.setContentSize(this._labelWidth, this._labelHeight);

          this._updateRichTextPosition();

          this._layoutDirty = false;
        };

        _proto._getFirstWordLen = function _getFirstWordLen(text, startIndex, textLen) {
          var character = text.charAt(startIndex);

          if (isUnicodeCJK(character) || isUnicodeSpace(character)) {
            return 1;
          }

          var len = 1;

          for (var index = startIndex + 1; index < textLen; ++index) {
            character = text.charAt(index);

            if (isUnicodeSpace(character) || isUnicodeCJK(character)) {
              break;
            }

            len++;
          }

          return len;
        };

        _proto._updateRichTextPosition = function _updateRichTextPosition() {
          var nextTokenX = 0;
          var nextLineIndex = 1;
          var totalLineCount = this._lineCount;
          var trans = this.node._uiProps.uiTransformComp;
          var anchorX = trans.anchorX;
          var anchorY = trans.anchorY;

          for (var i = 0; i < this._segments.length; ++i) {
            var segment = this._segments[i];
            var lineCount = segment.lineCount;

            if (lineCount > nextLineIndex) {
              nextTokenX = 0;
              nextLineIndex = lineCount;
            }

            var lineOffsetX = this._labelWidth * (this._horizontalAlign * 0.5 - anchorX);

            switch (this._horizontalAlign) {
              case HorizontalTextAlignment.LEFT:
                break;

              case HorizontalTextAlignment.CENTER:
                lineOffsetX -= this._linesWidth[lineCount - 1] / 2;
                break;

              case HorizontalTextAlignment.RIGHT:
                lineOffsetX -= this._linesWidth[lineCount - 1];
                break;
            }

            var pos = segment.node.position;
            segment.node.setPosition(nextTokenX + lineOffsetX, this._lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z);

            if (lineCount === nextLineIndex) {
              nextTokenX += segment.node._uiProps.uiTransformComp.width;
            }

            var sprite = segment.node.getComponent(Sprite);

            if (sprite) {
              var position = segment.node.position.clone();
              var lineHeightSet = this._lineHeight;
              var lineHeightReal = this._lineHeight * (1 + BASELINE_RATIO);

              switch (segment.node._uiProps.uiTransformComp.anchorY) {
                case 1:
                  position.y += lineHeightSet + (lineHeightReal - lineHeightSet) / 2;
                  break;

                case 0.5:
                  position.y += lineHeightReal / 2;
                  break;

                default:
                  position.y += (lineHeightReal - lineHeightSet) / 2;
                  break;
              }

              if (segment.imageOffset) {
                var offsets = segment.imageOffset.split(',');

                if (offsets.length === 1 && offsets[0]) {
                  var offsetY = parseFloat(offsets[0]);
                  if (Number.isInteger(offsetY)) position.y += offsetY;
                } else if (offsets.length === 2) {
                  var offsetX = parseFloat(offsets[0]);

                  var _offsetY = parseFloat(offsets[1]);

                  if (Number.isInteger(offsetX)) position.x += offsetX;
                  if (Number.isInteger(_offsetY)) position.y += _offsetY;
                }
              }

              segment.node.position = position;
            }

            var outline = segment.node.getComponent(LabelOutline);

            if (outline) {
              var _position = segment.node.position.clone();

              _position.y -= outline.width;
              segment.node.position = _position;
            }
          }
        };

        _proto._convertLiteralColorValue = function _convertLiteralColorValue(color) {
          var colorValue = color.toUpperCase();

          if (Color[colorValue]) {
            var colorUse = Color[colorValue];
            return colorUse;
          } else {
            var out = new Color();
            return out.fromHEX(color);
          }
        };

        _proto._applyTextAttribute = function _applyTextAttribute(labelSeg) {
          var label = labelSeg.node.getComponent(Label);

          if (!label) {
            return;
          }

          this._resetLabelState(label);

          var index = labelSeg.styleIndex;
          var textStyle;

          if (this._textArray[index]) {
            textStyle = this._textArray[index].style;
          }

          if (textStyle) {
            label.color = this._convertLiteralColorValue(textStyle.color || 'white');
            label.isBold = !!textStyle.bold;
            label.isItalic = !!textStyle.italic;
            label.isUnderline = !!textStyle.underline;

            if (textStyle.outline) {
              var labelOutline = labelSeg.node.getComponent(LabelOutline);

              if (!labelOutline) {
                labelOutline = labelSeg.node.addComponent(LabelOutline);
              }

              labelOutline.color = this._convertLiteralColorValue(textStyle.outline.color);
              labelOutline.width = textStyle.outline.width;
            }

            label.fontSize = textStyle.size || this._fontSize;
            labelSeg.clickHandler = '';
            labelSeg.clickParam = '';
            var event = textStyle.event;

            if (event) {
              labelSeg.clickHandler = event.click || '';
              labelSeg.clickParam = event.param || '';
            }
          }

          label.cacheMode = this._cacheMode;
          var isAsset = this._font instanceof Font;

          if (isAsset && !this._isSystemFontUsed) {
            label.font = this._font;
          } else {
            label.fontFamily = this._fontFamily;
          }

          label.useSystemFont = this._isSystemFontUsed;
          label.lineHeight = this._lineHeight;
          label.updateRenderData(true);
          var assembler = label._assembler;

          if (assembler) {
            assembler.updateRenderData(label);
          }
        };

        _proto._applyLayer = function _applyLayer() {
          for (var _iterator3 = _createForOfIteratorHelperLoose(this._segments), _step3; !(_step3 = _iterator3()).done;) {
            var seg = _step3.value;
            seg.node.layer = this.node.layer;
          }
        };

        _proto._resetLabelState = function _resetLabelState(label) {
          label.fontSize = this._fontSize;
          label.color = Color.WHITE;
          label.isBold = false;
          label.isItalic = false;
          label.isUnderline = false;
        };

        _createClass(RichText, [{
          key: "string",
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            if (this._string === value) {
              return;
            }

            this._string = value;

            this._updateRichTextStatus();
          }
        }, {
          key: "horizontalAlign",
          get: function get() {
            return this._horizontalAlign;
          },
          set: function set(value) {
            if (this.horizontalAlign === value) {
              return;
            }

            this._horizontalAlign = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "verticalAlign",
          get: function get() {
            return this._verticalAlign;
          },
          set: function set(value) {
            if (this._verticalAlign === value) {
              return;
            }

            this._verticalAlign = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "fontSize",
          get: function get() {
            return this._fontSize;
          },
          set: function set(value) {
            if (this._fontSize === value) {
              return;
            }

            this._fontSize = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "fontFamily",
          get: function get() {
            return this._fontFamily;
          },
          set: function set(value) {
            if (this._fontFamily === value) return;
            this._fontFamily = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "font",
          get: function get() {
            return this._font;
          },
          set: function set(value) {
            if (this._font === value) {
              return;
            }

            this._font = value;
            this._layoutDirty = true;

            if (this._font) {

              this.useSystemFont = false;

              this._onTTFLoaded();
            } else {
              this.useSystemFont = true;
            }

            this._updateRichTextStatus();
          }
        }, {
          key: "useSystemFont",
          get: function get() {
            return this._isSystemFontUsed;
          },
          set: function set(value) {
            if (this._isSystemFontUsed === value) {
              return;
            }

            this._isSystemFontUsed = value;

            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "cacheMode",
          get: function get() {
            return this._cacheMode;
          },
          set: function set(value) {
            if (this._cacheMode === value) {
              return;
            }

            this._cacheMode = value;

            this._updateRichTextStatus();
          }
        }, {
          key: "maxWidth",
          get: function get() {
            return this._maxWidth;
          },
          set: function set(value) {
            if (this._maxWidth === value) {
              return;
            }

            this._maxWidth = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "lineHeight",
          get: function get() {
            return this._lineHeight;
          },
          set: function set(value) {
            if (this._lineHeight === value) {
              return;
            }

            this._lineHeight = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "imageAtlas",
          get: function get() {
            return this._imageAtlas;
          },
          set: function set(value) {
            if (this._imageAtlas === value) {
              return;
            }

            this._imageAtlas = value;
            this._layoutDirty = true;

            this._updateRichTextStatus();
          }
        }, {
          key: "handleTouchEvent",
          get: function get() {
            return this._handleTouchEvent;
          },
          set: function set(value) {
            if (this._handleTouchEvent === value) {
              return;
            }

            this._handleTouchEvent = value;

            if (this.enabledInHierarchy) {
              if (this.handleTouchEvent) {
                this._addEventListeners();
              } else {
                this._removeEventListeners();
              }
            }
          }
        }]);

        return RichText;
      }(Component), _class3$z.HorizontalAlign = HorizontalTextAlignment, _class3$z.VerticalAlign = VerticalTextAlignment, _temp$1a), (_applyDecoratedDescriptor(_class2$15.prototype, "string", [multiline, _dec5$x], Object.getOwnPropertyDescriptor(_class2$15.prototype, "string"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "horizontalAlign", [_dec6$t, _dec7$r], Object.getOwnPropertyDescriptor(_class2$15.prototype, "horizontalAlign"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "verticalAlign", [_dec8$o, _dec9$m], Object.getOwnPropertyDescriptor(_class2$15.prototype, "verticalAlign"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "fontSize", [_dec10$m], Object.getOwnPropertyDescriptor(_class2$15.prototype, "fontSize"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "fontFamily", [_dec11$k], Object.getOwnPropertyDescriptor(_class2$15.prototype, "fontFamily"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "font", [_dec12$j, _dec13$h], Object.getOwnPropertyDescriptor(_class2$15.prototype, "font"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "useSystemFont", [_dec14$e, _dec15$e], Object.getOwnPropertyDescriptor(_class2$15.prototype, "useSystemFont"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "cacheMode", [_dec16$c, _dec17$c], Object.getOwnPropertyDescriptor(_class2$15.prototype, "cacheMode"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "maxWidth", [_dec18$c], Object.getOwnPropertyDescriptor(_class2$15.prototype, "maxWidth"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "lineHeight", [_dec19$c], Object.getOwnPropertyDescriptor(_class2$15.prototype, "lineHeight"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "imageAtlas", [_dec20$c, _dec21$c], Object.getOwnPropertyDescriptor(_class2$15.prototype, "imageAtlas"), _class2$15.prototype), _applyDecoratedDescriptor(_class2$15.prototype, "handleTouchEvent", [_dec22$c], Object.getOwnPropertyDescriptor(_class2$15.prototype, "handleTouchEvent"), _class2$15.prototype), _descriptor$Z = _applyDecoratedDescriptor(_class2$15.prototype, "_lineHeight", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 40;
        }
      }), _descriptor2$K = _applyDecoratedDescriptor(_class2$15.prototype, "_string", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '<color=#00ff00>Rich</color><color=#0fffff>Text</color>';
        }
      }), _descriptor3$z = _applyDecoratedDescriptor(_class2$15.prototype, "_horizontalAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return HorizontalTextAlignment.LEFT;
        }
      }), _descriptor4$v = _applyDecoratedDescriptor(_class2$15.prototype, "_verticalAlign", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return VerticalTextAlignment.TOP;
        }
      }), _descriptor5$o = _applyDecoratedDescriptor(_class2$15.prototype, "_fontSize", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 40;
        }
      }), _descriptor6$e = _applyDecoratedDescriptor(_class2$15.prototype, "_maxWidth", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7$d = _applyDecoratedDescriptor(_class2$15.prototype, "_fontFamily", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'Arial';
        }
      }), _descriptor8$d = _applyDecoratedDescriptor(_class2$15.prototype, "_font", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9$c = _applyDecoratedDescriptor(_class2$15.prototype, "_isSystemFontUsed", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor10$c = _applyDecoratedDescriptor(_class2$15.prototype, "_userDefinedFont", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11$b = _applyDecoratedDescriptor(_class2$15.prototype, "_cacheMode", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return CacheMode.NONE;
        }
      }), _descriptor12$a = _applyDecoratedDescriptor(_class2$15.prototype, "_imageAtlas", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor13$9 = _applyDecoratedDescriptor(_class2$15.prototype, "_handleTouchEvent", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      })), _class2$15)) || _class$1j) || _class$1j) || _class$1j) || _class$1j) || _class$1j));
      legacyCC.RichText = RichText;

      var _dec$1i, _dec2$S, _dec3$L, _dec4$C, _class$1k, _temp$1b;
      var UIMeshRenderer = function (v) { return exports({ UIMeshRenderer: v, UIModelComponent: v }), v; }((_dec$1i = ccclass('cc.UIMeshRenderer'), _dec2$S = help(), _dec3$L = executionOrder(110), _dec4$C = menu(), _dec$1i(_class$1k = _dec2$S(_class$1k = _dec3$L(_class$1k = _dec4$C(_class$1k = executeInEditMode(_class$1k = (_temp$1b = function (_Component) {
        _inheritsLoose(UIMeshRenderer, _Component);

        function UIMeshRenderer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._modelComponent = null;
          _this.stencilStage = Stage.DISABLED;
          return _this;
        }

        var _proto = UIMeshRenderer.prototype;

        _proto.__preload = function __preload() {
          this.node._uiProps.uiComp = this;
        };

        _proto.onLoad = function onLoad() {
          if (!this.node._uiProps.uiTransformComp) {
            this.node.addComponent('cc.UITransform');
          }

          this._modelComponent = this.getComponent('cc.RenderableComponent');

          if (!this._modelComponent) {
            console.warn("node '" + (this.node && this.node.name) + "' doesn't have any renderable component");
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this.node._uiProps.uiComp === this) {
            this.node._uiProps.uiComp = null;
          }

          this._modelComponent = this.getComponent('cc.RenderableComponent');

          if (!this._modelComponent) {
            return;
          }

          this._modelComponent._sceneGetter = null;
        };

        _proto.updateAssembler = function updateAssembler(render) {
          if (this._modelComponent) {
            var models = this._modelComponent._collectModels();

            this._modelComponent._detachFromScene();

            for (var i = 0; i < models.length; i++) {
              if (models[i].enabled) {
                render.commitModel(this, models[i], this._modelComponent.material);
              }
            }

            return true;
          }

          return false;
        };

        _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

        _proto.update = function update() {
          this._fitUIRenderQueue();
        };

        _proto._fitUIRenderQueue = function _fitUIRenderQueue() {
          if (!this._modelComponent) {
            return;
          }

          var matNum = this._modelComponent.sharedMaterials.length;

          for (var i = 0; i < matNum; i++) {
            var material = this._modelComponent.getMaterialInstance(i);

            if (material == null) {
              continue;
            }

            var passes = material.passes;
            var passNum = passes.length;

            for (var j = 0; j < passNum; j++) {
              var pass = passes[j];
              pass._priority = RenderPriority.MAX - 11;
              material.recompileShaders({
                CC_FORCE_FORWARD_SHADING: true
              }, j);
            }
          }
        };

        _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
        };

        _proto.setNodeDirty = function setNodeDirty() {};

        _proto.setTextureDirty = function setTextureDirty() {};

        _createClass(UIMeshRenderer, [{
          key: "modelComponent",
          get: function get() {
            return this._modelComponent;
          }
        }]);

        return UIMeshRenderer;
      }(Component), _temp$1b)) || _class$1k) || _class$1k) || _class$1k) || _class$1k) || _class$1k));
      legacyCC.UIMeshRenderer = UIMeshRenderer;

      var UI_VIS_FLAG = Layers.Enum.NONE | Layers.Enum.UI_3D;
      var DrawBatch2D = exports('UIDrawBatch', function () {
        function DrawBatch2D() {
          this.bufferBatch = null;
          this.camera = null;
          this.renderScene = null;
          this.model = null;
          this.texture = null;
          this.sampler = null;
          this.useLocalData = null;
          this.isStatic = false;
          this.textureHash = 0;
          this.samplerHash = 0;
          this._passes = [];
          this._shaders = [];
          this._visFlags = UI_VIS_FLAG;
          this._inputAssembler = null;
          this._descriptorSet = null;
        }

        var _proto = DrawBatch2D.prototype;

        _proto.destroy = function destroy(ui) {
          this._passes = [];
        };

        _proto.clear = function clear() {
          this.bufferBatch = null;
          this.inputAssembler = null;
          this.descriptorSet = null;
          this.camera = null;
          this.texture = null;
          this.sampler = null;
          this.textureHash = 0;
          this.samplerHash = 0;
          this.model = null;
          this.isStatic = false;
          this.useLocalData = null;
          this.visFlags = UI_VIS_FLAG;
          this.renderScene = null;
        };

        _proto.fillPasses = function fillPasses(mat, dss, dssHash, bs, bsHash, patches, batcher) {
          if (mat) {
            var passes = mat.passes;

            if (!passes) {
              return;
            }

            var hashFactor = 0;
            this._shaders.length = passes.length;

            for (var i = 0; i < passes.length; i++) {
              if (!this._passes[i]) {
                this._passes[i] = new Pass(legacyCC.director.root);
              }

              var mtlPass = passes[i];
              var passInUse = this._passes[i];
              mtlPass.update();

              if (!dss) {
                dss = mtlPass.depthStencilState;
                dssHash = 0;
              }

              if (!bs) {
                bs = mtlPass.blendState;
                bsHash = 0;
              }

              if (bsHash === -1) {
                bsHash = 0;
              }

              hashFactor = dssHash << 16 | bsHash;

              passInUse._initPassFromTarget(mtlPass, dss, bs, hashFactor);

              this._shaders[i] = passInUse.getShaderVariant(patches);
            }
          }
        };

        _createClass(DrawBatch2D, [{
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "inputAssembler",
          get: function get() {
            return this._inputAssembler;
          },
          set: function set(ia) {
            this._inputAssembler = ia;
          }
        }, {
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          },
          set: function set(ds) {
            this._descriptorSet = ds;
          }
        }, {
          key: "visFlags",
          get: function get() {
            return this._visFlags;
          },
          set: function set(vis) {
            this._visFlags = vis;
          }
        }, {
          key: "passes",
          get: function get() {
            return this._passes;
          }
        }, {
          key: "shaders",
          get: function get() {
            return this._shaders;
          }
        }]);

        return DrawBatch2D;
      }());

      var _dec$1j, _dec2$T, _dec3$M, _dec4$D, _dec5$y, _class$1l, _class2$16, _temp$1c;
      var UIStaticBatch = function (v) { return exports({ UIStaticBatch: v, UIStaticBatchComponent: v }), v; }((_dec$1j = ccclass('cc.UIStaticBatch'), _dec2$T = help(), _dec3$M = menu(), _dec4$D = executionOrder(110), _dec5$y = visible(), _dec$1j(_class$1l = _dec2$T(_class$1l = _dec3$M(_class$1l = _dec4$D(_class$1l = (_class2$16 = (_temp$1c = function (_Renderable2D) {
        _inheritsLoose(UIStaticBatch, _Renderable2D);

        function UIStaticBatch() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Renderable2D.call.apply(_Renderable2D, [this].concat(args)) || this;
          _this._init = false;
          _this._bufferAccessor = null;
          _this._dirty = true;
          _this._uiDrawBatchList = [];
          return _this;
        }

        var _proto = UIStaticBatch.prototype;

        _proto.onLoad = function onLoad() {};

        _proto.onDestroy = function onDestroy() {};

        _proto.updateAssembler = function updateAssembler(render) {};

        _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

        _proto.markAsDirty = function markAsDirty() {};

        _proto._requireDrawBatch = function _requireDrawBatch() {
          var batch = new DrawBatch2D();
          batch.isStatic = true;

          this._uiDrawBatchList.push(batch);

          return batch;
        };

        _proto._clearData = function _clearData() {
          if (this._bufferAccessor) {
            this._bufferAccessor.reset();

            var ui = this._getBatcher();

            for (var i = 0; i < this._uiDrawBatchList.length; i++) {
              var element = this._uiDrawBatchList[i];
              element.destroy(ui);
            }
          }

          this._uiDrawBatchList.length = 0;
          this._init = false;
        };

        _proto._getBatcher = function _getBatcher() {
          if (director.root && director.root.batcher2D) {
            return director.root.batcher2D;
          }

          warnID(9301);
          return null;
        };

        _createClass(UIStaticBatch, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color === value) {
              return;
            }

            this._color.set(value);
          }
        }, {
          key: "drawBatchList",
          get: function get() {
            return this._uiDrawBatchList;
          }
        }]);

        return UIStaticBatch;
      }(Renderable2D), _temp$1c), (_applyDecoratedDescriptor(_class2$16.prototype, "color", [override, _dec5$y], Object.getOwnPropertyDescriptor(_class2$16.prototype, "color"), _class2$16.prototype)), _class2$16)) || _class$1l) || _class$1l) || _class$1l) || _class$1l));

      var _dec$1k, _dec2$U, _dec3$N, _dec4$E, _dec5$z, _dec6$u, _dec7$s, _dec8$p, _class$1m, _class2$17, _descriptor$_, _descriptor2$L, _descriptor3$A, _temp$1d;
      var LabelShadow = exports('LabelShadow', (_dec$1k = ccclass('cc.LabelShadow'), _dec2$U = help(), _dec3$N = executionOrder(110), _dec4$E = menu(), _dec5$z = requireComponent(Label), _dec6$u = tooltip(), _dec7$s = tooltip(), _dec8$p = tooltip(), _dec$1k(_class$1m = _dec2$U(_class$1m = _dec3$N(_class$1m = _dec4$E(_class$1m = _dec5$z(_class$1m = executeInEditMode(_class$1m = (_class2$17 = (_temp$1d = function (_Component) {
        _inheritsLoose(LabelShadow, _Component);

        function LabelShadow() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_color", _descriptor$_, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_offset", _descriptor2$L, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_blur", _descriptor3$A, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = LabelShadow.prototype;

        _proto.onEnable = function onEnable() {
          this._updateRenderData();
        };

        _proto.onDisable = function onDisable() {
          this._updateRenderData();
        };

        _proto._updateRenderData = function _updateRenderData() {
          var label = this.node.getComponent(Label);

          if (label) {
            label.updateRenderData(true);
          }
        };

        _createClass(LabelShadow, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            if (this._color === value) {
              return;
            }

            this._color.set(value);

            this._updateRenderData();
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(value) {
            this._offset = value;

            this._updateRenderData();
          }
        }, {
          key: "blur",
          get: function get() {
            return this._blur;
          },
          set: function set(value) {
            this._blur = value;

            this._updateRenderData();
          }
        }]);

        return LabelShadow;
      }(Component), _temp$1d), (_descriptor$_ = _applyDecoratedDescriptor(_class2$17.prototype, "_color", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(0, 0, 0, 255);
        }
      }), _descriptor2$L = _applyDecoratedDescriptor(_class2$17.prototype, "_offset", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(2, 2);
        }
      }), _descriptor3$A = _applyDecoratedDescriptor(_class2$17.prototype, "_blur", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      }), _applyDecoratedDescriptor(_class2$17.prototype, "color", [_dec6$u], Object.getOwnPropertyDescriptor(_class2$17.prototype, "color"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "offset", [_dec7$s], Object.getOwnPropertyDescriptor(_class2$17.prototype, "offset"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "blur", [_dec8$p], Object.getOwnPropertyDescriptor(_class2$17.prototype, "blur"), _class2$17.prototype)), _class2$17)) || _class$1m) || _class$1m) || _class$1m) || _class$1m) || _class$1m) || _class$1m));

      var _dec$1l, _dec2$V, _dec3$O, _dec4$F, _dec5$A, _class$1n, _class2$18, _descriptor$$, _temp$1e;
      var UIOpacity = function (v) { return exports({ UIOpacity: v, UIOpacityComponent: v }), v; }((_dec$1l = ccclass('cc.UIOpacity'), _dec2$V = help(), _dec3$O = executionOrder(110), _dec4$F = menu(), _dec5$A = tooltip(), _dec$1l(_class$1n = _dec2$V(_class$1n = _dec3$O(_class$1n = _dec4$F(_class$1n = executeInEditMode(_class$1n = disallowMultiple(_class$1n = (_class2$18 = (_temp$1e = function (_Component) {
        _inheritsLoose(UIOpacity, _Component);

        function UIOpacity() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_opacity", _descriptor$$, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = UIOpacity.prototype;

        _proto.onEnable = function onEnable() {
          this.node._uiProps.localOpacity = this._opacity / 255;
        };

        _proto.onDisable = function onDisable() {
          this.node._uiProps.localOpacity = 1;
        };

        _createClass(UIOpacity, [{
          key: "opacity",
          get: function get() {
            return this._opacity;
          },
          set: function set(value) {
            if (this._opacity === value) {
              return;
            }

            value = clampf(value, 0, 255);
            this._opacity = value;
            this.node._uiProps.localOpacity = value / 255;
          }
        }]);

        return UIOpacity;
      }(Component), _temp$1e), (_applyDecoratedDescriptor(_class2$18.prototype, "opacity", [editable, _dec5$A], Object.getOwnPropertyDescriptor(_class2$18.prototype, "opacity"), _class2$18.prototype), _descriptor$$ = _applyDecoratedDescriptor(_class2$18.prototype, "_opacity", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 255;
        }
      })), _class2$18)) || _class$1n) || _class$1n) || _class$1n) || _class$1n) || _class$1n) || _class$1n));

      legacyCC.MaskComponent = Mask;
      js.setClassAlias(Mask, 'cc.MaskComponent');
      legacyCC.LabelComponent = Label;
      js.setClassAlias(Label, 'cc.LabelComponent');
      legacyCC.LabelOutlineComponent = LabelOutline;
      js.setClassAlias(LabelOutline, 'cc.LabelOutlineComponent');
      legacyCC.RichTextComponent = RichText;
      js.setClassAlias(RichText, 'cc.RichTextComponent');
      legacyCC.SpriteComponent = Sprite;
      js.setClassAlias(Sprite, 'cc.SpriteComponent');
      legacyCC.UIModelComponent = UIMeshRenderer;
      js.setClassAlias(UIMeshRenderer, 'cc.UIModelComponent');
      legacyCC.GraphicsComponent = Graphics;
      js.setClassAlias(Graphics, 'cc.GraphicsComponent');
      js.setClassAlias(UIStaticBatch, 'cc.UIStaticBatchComponent');
      js.setClassAlias(UIOpacity, 'cc.UIOpacityComponent');

      var Aim = function Aim(i, x, y) {
        this.i = void 0;
        this.x = void 0;
        this.y = void 0;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
        this.i = i;
        this.x = x;
        this.y = y;
      };

      function linkedList(datas, start, end, dim, clockwise) {
        var i = 0;
        var last = null;

        if (clockwise === signedArea(datas, start, end, dim) > 0) {
          for (i = start; i < end; i += dim) {
            last = insertNode(i, datas[i], datas[i + 1], last);
          }
        } else {
          for (i = end - dim; i >= start; i -= dim) {
            last = insertNode(i, datas[i], datas[i + 1], last);
          }
        }

        if (last && equals$1(last, last.next)) {
          removeNode(last);
          last = last.next;
        }

        return last;
      }

      function filterPoints(start, end) {
        if (end === void 0) {
          end = null;
        }

        if (!start) {
          return start;
        }

        if (!end) {
          end = start;
        }

        var p = start;
        var again = false;

        do {
          again = false;

          if (!p.steiner && (equals$1(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;

            if (p === p.next) {
              return null;
            }

            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);

        return end;
      }

      function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
        if (pass === void 0) {
          pass = 0;
        }

        if (!ear) {
          return;
        }

        if (!pass && size) {
          indexCurve(ear, minX, minY, size);
        }

        var stop = ear;
        var prev = null;
        var next = null;

        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;

          if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }

          ear = next;

          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(ear, triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, size, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
          }
        }
      }

      function isEar(ear) {
        var a = ear.prev;
        var b = ear;
        var c = ear.next;

        if (area(a, b, c) >= 0) {
          return false;
        }

        var p = ear.next.next;

        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }

          p = p.next;
        }

        return true;
      }

      function isEarHashed(ear, minX, minY, size) {
        var a = ear.prev;
        var b = ear;
        var c = ear.next;

        if (area(a, b, c) >= 0) {
          return false;
        }

        var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
        var minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
        var maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
        var maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        var minZ = zOrder(minTX, minTY, minX, minY, size);
        var maxZ = zOrder(maxTX, maxTY, minX, minY, size);
        var p = ear.nextZ;

        while (p && p.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }

          p = p.nextZ;
        }

        p = ear.prevZ;

        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
            return false;
          }

          p = p.prevZ;
        }

        return true;
      }

      function cureLocalIntersections(start, triangles, dim) {
        var p = start;

        do {
          var a = p.prev;
          var b = p.next.next;

          if (!equals$1(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }

          p = p.next;
        } while (p !== start);

        return p;
      }

      function splitEarcut(start, triangles, dim, minX, minY, size) {
        var a = start;

        do {
          var b = a.next.next;

          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, size);
              earcutLinked(c, triangles, dim, minX, minY, size);
              return;
            }

            b = b.next;
          }

          a = a.next;
        } while (a !== start);
      }

      function eliminateHoles(datas, holeIndices, outerNode, dim) {
        var queue = [];
        var i = 0;
        var len = 0;
        var start = 0;
        var end = 0;
        var list = null;

        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : datas.length;
          list = linkedList(datas, start, end, dim, false);

          if (!list) {
            continue;
          }

          if (list === list.next) {
            list.steiner = true;
          }

          queue.push(getLeftmost(list));
        }

        queue.sort(compareX);

        if (!outerNode) {
          return outerNode;
        }

        for (i = 0; i < queue.length; i++) {
          eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }

        return outerNode;
      }

      function compareX(a, b) {
        return a.x - b.x;
      }

      function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);

        if (outerNode) {
          var b = splitPolygon(outerNode, hole);
          filterPoints(b, b.next);
        }
      }

      function findHoleBridge(hole, outerNode) {
        var p = outerNode;
        var hx = hole.x;
        var hy = hole.y;
        var qx = -Infinity;
        var m = null;

        do {
          if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

            if (x <= hx && x > qx) {
              qx = x;

              if (x === hx) {
                if (hy === p.y) {
                  return p;
                }

                if (hy === p.next.y) {
                  return p.next;
                }
              }

              m = p.x < p.next.x ? p : p.next;
            }
          }

          p = p.next;
        } while (p !== outerNode);

        if (!m) {
          return null;
        }

        if (hx === qx) {
          return m.prev;
        }

        var stop = m;
        var mx = m.x;
        var my = m.y;
        var tanMin = Infinity;
        var tan;
        p = m.next;

        while (p !== stop) {
          if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);

            if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
              m = p;
              tanMin = tan;
            }
          }

          p = p.next;
        }

        return m;
      }

      function indexCurve(start, minX, minY, size) {
        var p = start;

        do {
          if (p.z === null) {
            p.z = zOrder(p.x, p.y, minX, minY, size);
          }

          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);

        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }

      function sortLinked(list) {
        var i = 0;
        var p = null;
        var q = null;
        var e = null;
        var tail = null;
        var numMerges = 0;
        var pSize = 0;
        var qSize = 0;
        var inSize = 1;

        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;

          while (p) {
            numMerges++;
            q = p;
            pSize = 0;

            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;

              if (!q) {
                break;
              }
            }

            qSize = inSize;

            while (pSize > 0 || qSize > 0 && q) {
              if (pSize === 0) {
                e = q;
                q = q.nextZ;
                qSize--;
              } else if (qSize === 0 || !q) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else if (p.z <= q.z) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }

              if (tail) {
                tail.nextZ = e;
              } else {
                list = e;
              }

              e.prevZ = tail;
              tail = e;
            }

            p = q;
          }

          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);

        return list;
      }

      function zOrder(x, y, minX, minY, size) {
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;
        x = (x | x << 8) & 0x00FF00FF;
        x = (x | x << 4) & 0x0F0F0F0F;
        x = (x | x << 2) & 0x33333333;
        x = (x | x << 1) & 0x55555555;
        y = (y | y << 8) & 0x00FF00FF;
        y = (y | y << 4) & 0x0F0F0F0F;
        y = (y | y << 2) & 0x33333333;
        y = (y | y << 1) & 0x55555555;
        return x | y << 1;
      }

      function getLeftmost(start) {
        var p = start;
        var leftmost = start;

        do {
          if (p.x < leftmost.x) {
            leftmost = p;
          }

          p = p.next;
        } while (p !== start);

        return leftmost;
      }

      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
      }

      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
      }

      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }

      function equals$1(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }

      function intersects(p1, q1, p2, q2) {
        if (equals$1(p1, q1) && equals$1(p2, q2) || equals$1(p1, q2) && equals$1(p2, q1)) {
          return true;
        }

        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
      }

      function intersectsPolygon(a, b) {
        var p = a;

        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
            return true;
          }

          p = p.next;
        } while (p !== a);

        return false;
      }

      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }

      function middleInside(a, b) {
        var p = a;
        var inside = false;
        var px = (a.x + b.x) / 2;
        var py = (a.y + b.y) / 2;

        do {
          if (p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
            inside = !inside;
          }

          p = p.next;
        } while (p !== a);

        return inside;
      }

      function splitPolygon(a, b) {
        var a2 = new Aim(a.i, a.x, a.y);
        var b2 = new Aim(b.i, b.x, b.y);
        var an = a.next;
        var bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }

      function insertNode(i, x, y, last) {
        var p = new Aim(i, x, y);

        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }

        return p;
      }

      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;

        if (p.prevZ) {
          p.prevZ.nextZ = p.nextZ;
        }

        if (p.nextZ) {
          p.nextZ.prevZ = p.prevZ;
        }
      }

      function signedArea(datas, start, end, dim) {
        var sum = 0;

        for (var i = start, j = end - dim; i < end; i += dim) {
          sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]);
          j = i;
        }

        return sum;
      }

      function earcut(datas, holeIndices, dim) {
        dim = dim || 3;
        var hasHoles = holeIndices ? holeIndices.length : 0;
        var outerLen = hasHoles ? holeIndices[0] * dim : datas.length;
        var outerNode = linkedList(datas, 0, outerLen, dim, true);
        var triangles = [];

        if (!outerNode) {
          return triangles;
        }

        var minX = 0;
        var minY = 0;
        var maxX = 0;
        var maxY = 0;
        var x = 0;
        var y = 0;
        var size = 0;

        if (hasHoles) {
          outerNode = eliminateHoles(datas, holeIndices, outerNode, dim);
        }

        if (datas.length > 80 * dim) {
          minX = maxX = datas[0];
          minY = maxY = datas[1];

          for (var i = dim; i < outerLen; i += dim) {
            x = datas[i];
            y = datas[i + 1];

            if (x < minX) {
              minX = x;
            }

            if (y < minY) {
              minY = y;
            }

            if (x > maxX) {
              maxX = x;
            }

            if (y > maxY) {
              maxY = y;
            }
          }

          size = Math.max(maxX - minX, maxY - minY);
        }

        earcutLinked(outerNode, triangles, dim, minX, minY, size);
        return triangles;
      }

      var MAX_VERTEX = 65535;
      var MAX_INDICES = MAX_VERTEX * 2;
      var PI$1 = Math.PI;
      var min$3 = Math.min;
      var max$4 = Math.max;
      var ceil = Math.ceil;
      var acos$1 = Math.acos;
      var cos$2 = Math.cos;
      var sin$1 = Math.sin;
      var atan2 = Math.atan2;
      var attrBytes = 8;
      var _renderData = null;
      var _impl = null;

      var _curColor = new Color();

      var vec3_temps = [];

      for (var i$1 = 0; i$1 < 4; i$1++) {
        vec3_temps.push(new Vec3());
      }

      function curveDivs(r, arc, tol) {
        var da = acos$1(r / (r + tol)) * 2.0;
        return max$4(2, ceil(arc / da));
      }

      function clamp$1(v, minNum, maxNum) {
        if (v < minNum) {
          return minNum;
        } else if (v > maxNum) {
          return maxNum;
        }

        return v;
      }

      var graphicsAssembler = {
        useModel: true,
        updateRenderData: function updateRenderData(graphics) {},
        fillBuffers: function fillBuffers(graphics, renderer) {},
        renderIA: function renderIA(graphics, renderer) {},
        getRenderData: function getRenderData(graphics, vertexCount) {
          if (!_impl) {
            return null;
          }

          var renderDataList = _impl.getRenderDataList();

          var renderData = renderDataList[_impl.dataOffset];

          if (!renderData) {
            return null;
          }

          var meshBuffer = renderData;
          var maxVertexCount = meshBuffer ? meshBuffer.vertexStart + vertexCount : 0;

          if (maxVertexCount > MAX_VERTEX || maxVertexCount * 3 > MAX_INDICES) {
            ++_impl.dataOffset;

            if (_impl.dataOffset < renderDataList.length) {
              renderData = renderDataList[_impl.dataOffset];
            } else {
              renderData = _impl.requestRenderData();
              renderDataList[_impl.dataOffset] = renderData;
            }

            meshBuffer = renderData;
          }

          if (meshBuffer && meshBuffer.vertexCount < maxVertexCount) {
            meshBuffer.request(vertexCount, vertexCount * 3);
          }

          return renderData;
        },
        stroke: function stroke(graphics) {
          Color.copy(_curColor, graphics.strokeColor);

          if (!graphics.impl) {
            return;
          }

          this._flattenPaths(graphics.impl);

          this._expandStroke(graphics);

          graphics.impl.updatePathOffset = true;
          this.end(graphics);
        },
        fill: function fill(graphics) {
          Color.copy(_curColor, graphics.fillColor);

          this._expandFill(graphics);

          if (graphics.impl) {
            graphics.impl.updatePathOffset = true;
          }

          this.end(graphics);
        },
        end: function end(graphics) {
          graphics.markForUpdateRenderData();
        },
        _expandStroke: function _expandStroke(graphics) {
          var w = graphics.lineWidth * 0.5;
          var lineCap = graphics.lineCap;
          var lineJoin = graphics.lineJoin;
          var miterLimit = graphics.miterLimit;
          _impl = graphics.impl;

          if (!_impl) {
            return;
          }

          var nCap = curveDivs(w, PI$1, _impl.tessTol);

          this._calculateJoins(_impl, w, lineJoin, miterLimit);

          var paths = _impl.paths;
          var vertexCount = 0;

          for (var _i = _impl.pathOffset, l = _impl.pathLength; _i < l; _i++) {
            var path = paths[_i];
            var pointsLength = path.points.length;

            if (lineJoin === LineJoin.ROUND) {
              vertexCount += (pointsLength + path.bevel * (nCap + 2) + 1) * 2;
            } else {
              vertexCount += (pointsLength + path.bevel * 5 + 1) * 2;
            }

            if (!path.closed) {
              if (lineCap === LineCap.ROUND) {
                vertexCount += (nCap * 2 + 2) * 2;
              } else {
                vertexCount += (3 + 3) * 2;
              }
            }
          }

          var meshBuffer = _renderData = this.getRenderData(graphics, vertexCount);

          if (!meshBuffer) {
            return;
          }

          var vData = meshBuffer.vData;
          var iData = meshBuffer.iData;

          for (var _i2 = _impl.pathOffset, _l = _impl.pathLength; _i2 < _l; _i2++) {
            var _path = paths[_i2];
            var pts = _path.points;
            var _pointsLength = pts.length;
            var offset = meshBuffer.vertexStart;
            var p0 = void 0;
            var p1 = void 0;
            var start = 0;
            var end = 0;
            var loop = _path.closed;

            if (loop) {
              p0 = pts[_pointsLength - 1];
              p1 = pts[0];
              start = 0;
              end = _pointsLength;
            } else {
              p0 = pts[0];
              p1 = pts[1];
              start = 1;
              end = _pointsLength - 1;
            }

            p1 = p1 || p0;

            if (!loop) {
              var dPos = new Point(p1.x, p1.y);
              dPos.subtract(p0);
              dPos.normalize();
              var dx = dPos.x;
              var dy = dPos.y;

              if (lineCap === LineCap.BUTT) {
                this._buttCapStart(p0, dx, dy, w, 0);
              } else if (lineCap === LineCap.SQUARE) {
                this._buttCapStart(p0, dx, dy, w, w);
              } else if (lineCap === LineCap.ROUND) {
                this._roundCapStart(p0, dx, dy, w, nCap);
              }
            }

            for (var j = start; j < end; ++j) {
              if (lineJoin === LineJoin.ROUND) {
                this._roundJoin(p0, p1, w, w, nCap);
              } else if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                this._bevelJoin(p0, p1, w, w);
              } else {
                this._vSet(p1.x + p1.dmx * w, p1.y + p1.dmy * w, 1);

                this._vSet(p1.x - p1.dmx * w, p1.y - p1.dmy * w, -1);
              }

              p0 = p1;
              p1 = pts[j + 1];
            }

            if (loop) {
              var vDataOffset = offset * attrBytes;

              this._vSet(vData[vDataOffset], vData[vDataOffset + 1], 1);

              this._vSet(vData[vDataOffset + attrBytes], vData[vDataOffset + attrBytes + 1], -1);
            } else {
              var _dPos = new Point(p1.x, p1.y);

              _dPos.subtract(p0);

              _dPos.normalize();

              var _dx = _dPos.x;
              var _dy = _dPos.y;

              if (lineCap === LineCap.BUTT) {
                this._buttCapEnd(p1, _dx, _dy, w, 0);
              } else if (lineCap === LineCap.SQUARE) {
                this._buttCapEnd(p1, _dx, _dy, w, w);
              } else if (lineCap === LineCap.ROUND) {
                this._roundCapEnd(p1, _dx, _dy, w, nCap);
              }
            }

            var indicesOffset = meshBuffer.indexStart;

            for (var begin = offset + 2, over = meshBuffer.vertexStart; begin < over; begin++) {
              iData[indicesOffset++] = begin - 2;
              iData[indicesOffset++] = begin - 1;
              iData[indicesOffset++] = begin;
            }

            meshBuffer.indexStart = indicesOffset;
          }

          _renderData = null;
          _impl = null;
        },
        _expandFill: function _expandFill(graphics) {
          _impl = graphics.impl;

          if (!_impl) {
            return;
          }

          var paths = _impl.paths;
          var vertexCount = 0;

          for (var _i3 = _impl.pathOffset, l = _impl.pathLength; _i3 < l; _i3++) {
            var path = paths[_i3];
            var pointsLength = path.points.length;
            vertexCount += pointsLength;
          }

          var renderData = _renderData = this.getRenderData(graphics, vertexCount);

          if (!renderData) {
            return;
          }

          var meshBuffer = renderData;
          var vData = meshBuffer.vData;
          var iData = meshBuffer.iData;

          for (var _i4 = _impl.pathOffset, _l2 = _impl.pathLength; _i4 < _l2; _i4++) {
            var _path2 = paths[_i4];
            var pts = _path2.points;
            var _pointsLength2 = pts.length;

            if (_pointsLength2 === 0) {
              continue;
            }

            var vertexOffset = renderData.vertexStart;

            for (var j = 0; j < _pointsLength2; ++j) {
              this._vSet(pts[j].x, pts[j].y);
            }

            var indicesOffset = renderData.indexStart;

            if (_path2.complex) {
              var earcutData = [];

              for (var _j = vertexOffset, end = renderData.vertexStart; _j < end; _j++) {
                var vDataOffset = _j * attrBytes;
                earcutData.push(vData[vDataOffset++]);
                earcutData.push(vData[vDataOffset++]);
                earcutData.push(vData[vDataOffset++]);
              }

              var newIndices = earcut(earcutData, null, 3);

              if (!newIndices || newIndices.length === 0) {
                continue;
              }

              for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) {
                iData[indicesOffset++] = newIndices[_j2] + vertexOffset;
              }
            } else {
              var first = vertexOffset;

              for (var start = vertexOffset + 2, _end = meshBuffer.vertexStart; start < _end; start++) {
                iData[indicesOffset++] = first;
                iData[indicesOffset++] = start - 1;
                iData[indicesOffset++] = start;
              }
            }

            meshBuffer.indexStart = indicesOffset;
          }

          _renderData = null;
          _impl = null;
        },
        _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
          var iw = 0.0;

          if (w > 0.0) {
            iw = 1 / w;
          }

          var paths = impl.paths;

          for (var _i5 = impl.pathOffset, l = impl.pathLength; _i5 < l; _i5++) {
            var path = paths[_i5];
            var pts = path.points;
            var ptsLength = pts.length;
            var p0 = pts[ptsLength - 1];
            var p1 = pts[0];
            path.bevel = 0;

            for (var j = 0; j < ptsLength; j++) {
              var dmr2 = 0;
              var cross = 0;
              var limit = 0;
              var dlx0 = p0.dy;
              var dly0 = -p0.dx;
              var dlx1 = p1.dy;
              var dly1 = -p1.dx;
              p1.dmx = (dlx0 + dlx1) * 0.5;
              p1.dmy = (dly0 + dly1) * 0.5;
              dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;

              if (dmr2 > 0.000001) {
                var scale = 1 / dmr2;

                if (scale > 600) {
                  scale = 600;
                }

                p1.dmx *= scale;
                p1.dmy *= scale;
              }

              cross = p1.dx * p0.dy - p0.dx * p1.dy;

              if (cross > 0) {
                p1.flags |= PointFlags.PT_LEFT;
              }

              limit = max$4(11, min$3(p0.len, p1.len) * iw);

              if (dmr2 * limit * limit < 1) {
                p1.flags |= PointFlags.PT_INNERBEVEL;
              }

              if (p1.flags & PointFlags.PT_CORNER) {
                if (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) {
                  p1.flags |= PointFlags.PT_BEVEL;
                }
              }

              if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                path.bevel++;
              }

              p0 = p1;
              p1 = pts[j + 1];
            }
          }
        },
        _flattenPaths: function _flattenPaths(impl) {
          var paths = impl.paths;

          for (var _i6 = impl.pathOffset, l = impl.pathLength; _i6 < l; _i6++) {
            var path = paths[_i6];
            var pts = path.points;
            var p0 = pts[pts.length - 1];
            var p1 = pts[0];

            if (pts.length > 2 && p0.equals(p1)) {
              path.closed = true;
              pts.pop();
              p0 = pts[pts.length - 1];
            }

            for (var j = 0, size = pts.length; j < size; j++) {
              var dPos = new Point(p1.x, p1.y);
              dPos.subtract(p0);
              p0.len = dPos.length();

              if (dPos.x || dPos.y) {
                dPos.normalize();
              }

              p0.dx = dPos.x;
              p0.dy = dPos.y;
              p0 = p1;
              p1 = pts[j + 1];
            }
          }
        },
        _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
          var x = p1.x;
          var y = p1.y;
          var x0 = 0;
          var y0 = 0;
          var x1 = 0;
          var y1 = 0;

          if (bevel !== 0) {
            x0 = x + p0.dy * w;
            y0 = y - p0.dx * w;
            x1 = x + p1.dy * w;
            y1 = y - p1.dx * w;
          } else {
            x0 = x1 = x + p1.dmx * w;
            y0 = y1 = y + p1.dmy * w;
          }

          return [x0, y0, x1, y1];
        },
        _buttCapStart: function _buttCapStart(p, dx, dy, w, d) {
          var px = p.x - dx * d;
          var py = p.y - dy * d;
          var dlx = dy;
          var dly = -dx;

          this._vSet(px + dlx * w, py + dly * w, 1);

          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _buttCapEnd: function _buttCapEnd(p, dx, dy, w, d) {
          var px = p.x + dx * d;
          var py = p.y + dy * d;
          var dlx = dy;
          var dly = -dx;

          this._vSet(px + dlx * w, py + dly * w, 1);

          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _roundCapStart: function _roundCapStart(p, dx, dy, w, nCap) {
          var px = p.x;
          var py = p.y;
          var dlx = dy;
          var dly = -dx;

          for (var _i7 = 0; _i7 < nCap; _i7++) {
            var a = _i7 / (nCap - 1) * PI$1;
            var ax = cos$2(a) * w;
            var ay = sin$1(a) * w;

            this._vSet(px - dlx * ax - dx * ay, py - dly * ax - dy * ay, 1);

            this._vSet(px, py, 0);
          }

          this._vSet(px + dlx * w, py + dly * w, 1);

          this._vSet(px - dlx * w, py - dly * w, -1);
        },
        _roundCapEnd: function _roundCapEnd(p, dx, dy, w, nCap) {
          var px = p.x;
          var py = p.y;
          var dlx = dy;
          var dly = -dx;

          this._vSet(px + dlx * w, py + dly * w, 1);

          this._vSet(px - dlx * w, py - dly * w, -1);

          for (var _i8 = 0; _i8 < nCap; _i8++) {
            var a = _i8 / (nCap - 1) * PI$1;
            var ax = cos$2(a) * w;
            var ay = sin$1(a) * w;

            this._vSet(px, py, 0);

            this._vSet(px - dlx * ax + dx * ay, py - dly * ax + dy * ay, 1);
          }
        },
        _roundJoin: function _roundJoin(p0, p1, lw, rw, nCap) {
          var dlx0 = p0.dy;
          var dly0 = -p0.dx;
          var dlx1 = p1.dy;
          var dly1 = -p1.dx;
          var p1x = p1.x;
          var p1y = p1.y;

          if ((p1.flags & PointFlags.PT_LEFT) !== 0) {
            var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

            var lx0 = out[0];
            var ly0 = out[1];
            var lx1 = out[2];
            var ly1 = out[3];
            var a0 = atan2(-dly0, -dlx0);
            var a1 = atan2(-dly1, -dlx1);

            if (a1 > a0) {
              a1 -= PI$1 * 2;
            }

            this._vSet(lx0, ly0, 1);

            this._vSet(p1x - dlx0 * rw, p1.y - dly0 * rw, -1);

            var n = clamp$1(ceil((a0 - a1) / PI$1) * nCap, 2, nCap);

            for (var _i9 = 0; _i9 < n; _i9++) {
              var u = _i9 / (n - 1);
              var a = a0 + u * (a1 - a0);
              var rx = p1x + cos$2(a) * rw;
              var ry = p1y + sin$1(a) * rw;

              this._vSet(p1x, p1y, 0);

              this._vSet(rx, ry, -1);
            }

            this._vSet(lx1, ly1, 1);

            this._vSet(p1x - dlx1 * rw, p1y - dly1 * rw, -1);
          } else {
            var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

            var rx0 = _out[0];
            var ry0 = _out[1];
            var rx1 = _out[2];
            var ry1 = _out[3];

            var _a = atan2(dly0, dlx0);

            var _a2 = atan2(dly1, dlx1);

            if (_a2 < _a) {
              _a2 += PI$1 * 2;
            }

            this._vSet(p1x + dlx0 * rw, p1y + dly0 * rw, 1);

            this._vSet(rx0, ry0, -1);

            var _n = clamp$1(ceil((_a2 - _a) / PI$1) * nCap, 2, nCap);

            for (var _i10 = 0; _i10 < _n; _i10++) {
              var _u = _i10 / (_n - 1);

              var _a3 = _a + _u * (_a2 - _a);

              var lx = p1x + cos$2(_a3) * lw;
              var ly = p1y + sin$1(_a3) * lw;

              this._vSet(lx, ly, 1);

              this._vSet(p1x, p1y, 0);
            }

            this._vSet(p1x + dlx1 * rw, p1y + dly1 * rw, 1);

            this._vSet(rx1, ry1, -1);
          }
        },
        _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
          var rx0 = 0;
          var ry0 = 0;
          var rx1 = 0;
          var ry1 = 0;
          var lx0 = 0;
          var ly0 = 0;
          var lx1 = 0;
          var ly1 = 0;
          var dlx0 = p0.dy;
          var dly0 = -p0.dx;
          var dlx1 = p1.dy;
          var dly1 = -p1.dx;

          if (p1.flags & PointFlags.PT_LEFT) {
            var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

            lx0 = out[0];
            ly0 = out[1];
            lx1 = out[2];
            ly1 = out[3];

            this._vSet(lx0, ly0, 1);

            this._vSet(p1.x - dlx0 * rw, p1.y - dly0 * rw, -1);

            this._vSet(lx1, ly1, 1);

            this._vSet(p1.x - dlx1 * rw, p1.y - dly1 * rw, -1);
          } else {
            var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

            rx0 = _out2[0];
            ry0 = _out2[1];
            rx1 = _out2[2];
            ry1 = _out2[3];

            this._vSet(p1.x + dlx0 * lw, p1.y + dly0 * lw, 1);

            this._vSet(rx0, ry0, -1);

            this._vSet(p1.x + dlx1 * lw, p1.y + dly1 * lw, 1);

            this._vSet(rx1, ry1, -1);
          }
        },
        _vSet: function _vSet(x, y, distance) {
          if (distance === void 0) {
            distance = 0;
          }

          if (!_renderData) {
            return;
          }

          var meshBuffer = _renderData;
          var dataOffset = meshBuffer.vertexStart * attrBytes;
          var vData = meshBuffer.vData;
          vData[dataOffset++] = x;
          vData[dataOffset++] = y;
          vData[dataOffset++] = 0;
          Color.toArray(vData, _curColor, dataOffset);
          dataOffset += 4;
          vData[dataOffset++] = distance;
          meshBuffer.vertexStart++;
        }
      };

      var graphicsAssemblerManager = exports('graphicsAssembler', {
        getAssembler: function getAssembler(sprite) {
          return graphicsAssembler;
        }
      });
      Graphics.Assembler = graphicsAssemblerManager;

      var LetterInfo = function LetterInfo() {
        this["char"] = '';
        this.valid = true;
        this.x = 0;
        this.y = 0;
        this.line = 0;
        this.hash = '';
      };

      var _tmpRect = new Rect();

      var _comp = null;
      var _uiTrans = null;
      var _horizontalKerning = [];
      var _lettersInfo = [];
      var _linesWidth = [];
      var _linesOffsetX = [];

      var _labelDimensions = new Size();

      var _contentSize = new Size();

      var letterPosition = new Vec2();
      var _lineSpacing = 0;
      var _fntConfig = null;
      var _numberOfLines = 0;
      var _textDesiredHeight = 0;
      var _letterOffsetY = 0;
      var _tailoredTopY = 0;
      var _tailoredBottomY = 0;
      var _bmfontScale = 1.0;
      var _spriteFrame = null;
      var _string = '';
      var _fontSize = 0;
      var _originFontSize = 0;
      var _hAlign = 0;
      var _vAlign = 0;
      var _spacingX = 0;
      var _lineHeight = 0;
      var _overflow = 0;
      var _isWrapText = false;
      var _labelWidth = 0;
      var _labelHeight = 0;
      var _maxLineWidth = 0;
      var bmfontUtils = {
        updateRenderData: function updateRenderData(comp) {
          if (!comp.renderData) {
            return;
          }

          if (_comp === comp) {
            return;
          }

          if (comp.renderData.vertDirty) {
            _comp = comp;
            _uiTrans = _comp.node._uiProps.uiTransformComp;

            this._updateFontFamily(comp);

            this._updateProperties(comp);

            this._updateLabelInfo(comp);

            this._updateContent();

            _comp.actualFontSize = _fontSize;

            _uiTrans.setContentSize(_contentSize);

            this.updateUVs(comp);
            _comp.renderData.vertDirty = false;

            _comp.markForUpdateRenderData(false);

            _comp = null;

            this._resetProperties();
          }

          if (comp.spriteFrame) {
            var renderData = comp.renderData;
            renderData.updateRenderData(comp, comp.spriteFrame);
          }
        },
        updateUVs: function updateUVs(label) {
          var renderData = label.renderData;
          var vData = renderData.chunk.vb;
          var vertexCount = renderData.vertexCount;
          var dataList = renderData.data;
          var vertexOffset = 3;

          for (var i = 0; i < vertexCount; i++) {
            var vert = dataList[i];
            vData[vertexOffset] = vert.u;
            vData[vertexOffset + 1] = vert.v;
            vertexOffset += 9;
          }
        },
        _updateFontScale: function _updateFontScale() {
          _bmfontScale = _fontSize / _originFontSize;
        },
        _updateFontFamily: function _updateFontFamily(comp) {
          var fontAsset = comp.font;
          _spriteFrame = fontAsset.spriteFrame;
          _fntConfig = fontAsset.fntConfig;
          shareLabelInfo.fontAtlas = fontAsset.fontDefDictionary;
          dynamicAtlasManager.packToDynamicAtlas(comp, _spriteFrame);
        },
        _updateLabelInfo: function _updateLabelInfo(comp) {
          shareLabelInfo.hash = '';
          shareLabelInfo.margin = 0;
        },
        _updateProperties: function _updateProperties(comp) {
          _string = comp.string.toString();
          _fontSize = comp.fontSize;
          _originFontSize = _fntConfig ? _fntConfig.fontSize : comp.fontSize;
          _hAlign = comp.horizontalAlign;
          _vAlign = comp.verticalAlign;
          _spacingX = comp.spacingX;
          _overflow = comp.overflow;
          _lineHeight = comp._lineHeight;
          var contentSize = _uiTrans.contentSize;
          _contentSize.width = contentSize.width;
          _contentSize.height = contentSize.height;

          if (_overflow === Overflow.NONE) {
            _isWrapText = false;
            _contentSize.width += shareLabelInfo.margin * 2;
            _contentSize.height += shareLabelInfo.margin * 2;
          } else if (_overflow === Overflow.RESIZE_HEIGHT) {
            _isWrapText = true;
            _contentSize.height += shareLabelInfo.margin * 2;
          } else {
            _isWrapText = comp.enableWrapText;
          }

          shareLabelInfo.lineHeight = _lineHeight;
          shareLabelInfo.fontSize = _fontSize;

          this._setupBMFontOverflowMetrics();
        },
        _resetProperties: function _resetProperties() {
          _fntConfig = null;
          _spriteFrame = null;
          shareLabelInfo.hash = '';
          shareLabelInfo.margin = 0;
        },
        _updateContent: function _updateContent() {
          this._updateFontScale();

          this._computeHorizontalKerningForText();

          this._alignText();
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
          var string = _string;
          var stringLen = string.length;
          var kerningDict = _fntConfig.kerningDict;
          var horizontalKerning = _horizontalKerning;
          var prev = -1;

          for (var i = 0; i < stringLen; ++i) {
            var key = string.charCodeAt(i);
            var kerningAmount = kerningDict[prev << 16 | key & 0xffff] || 0;

            if (i < stringLen - 1) {
              horizontalKerning[i] = kerningAmount;
            } else {
              horizontalKerning[i] = 0;
            }

            prev = key;
          }
        },
        _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
          var textLen = _string.length;
          var lineIndex = 0;
          var nextTokenX = 0;
          var nextTokenY = 0;
          var longestLine = 0;
          var letterRight = 0;
          var highestY = 0;
          var lowestY = 0;
          var letterDef = null;

          for (var index = 0; index < textLen;) {
            var character = _string.charAt(index);

            if (character === '\n') {
              _linesWidth.push(letterRight);

              letterRight = 0;
              lineIndex++;
              nextTokenX = 0;
              nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;

              this._recordPlaceholderInfo(index, character);

              index++;
              continue;
            }

            var tokenLen = nextTokenFunc(_string, index, textLen);
            var tokenHighestY = highestY;
            var tokenLowestY = lowestY;
            var tokenRight = letterRight;
            var nextLetterX = nextTokenX;
            var newLine = false;

            for (var tmp = 0; tmp < tokenLen; ++tmp) {
              var letterIndex = index + tmp;
              character = _string.charAt(letterIndex);

              if (character === '\r') {
                this._recordPlaceholderInfo(letterIndex, character);

                continue;
              }

              letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

              if (!letterDef) {
                this._recordPlaceholderInfo(letterIndex, character);

                console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character);
                continue;
              }

              var letterX = nextLetterX + letterDef.offsetX * _bmfontScale - shareLabelInfo.margin;

              if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                _linesWidth.push(letterRight);

                letterRight = 0;
                lineIndex++;
                nextTokenX = 0;
                nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;
                newLine = true;
                break;
              } else {
                letterPosition.x = letterX;
              }

              letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale;

              this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);

              if (letterIndex + 1 < _horizontalKerning.length && letterIndex < textLen - 1) {
                nextLetterX += _horizontalKerning[letterIndex + 1];
              }

              nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;
              tokenRight = letterPosition.x + letterDef.w * _bmfontScale;

              if (tokenHighestY < letterPosition.y) {
                tokenHighestY = letterPosition.y;
              }

              if (tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale) {
                tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale;
              }
            }

            if (newLine) {
              continue;
            }

            nextTokenX = nextLetterX;
            letterRight = tokenRight;

            if (highestY < tokenHighestY) {
              highestY = tokenHighestY;
            }

            if (lowestY > tokenLowestY) {
              lowestY = tokenLowestY;
            }

            if (longestLine < letterRight) {
              longestLine = letterRight;
            }

            index += tokenLen;
          }

          _linesWidth.push(letterRight);

          _numberOfLines = lineIndex + 1;
          _textDesiredHeight = _numberOfLines * _lineHeight * this._getFontScale();

          if (_numberOfLines > 1) {
            _textDesiredHeight += (_numberOfLines - 1) * _lineSpacing;
          }

          _contentSize.width = _labelWidth;
          _contentSize.height = _labelHeight;

          if (_labelWidth <= 0) {
            _contentSize.width = parseFloat(longestLine.toFixed(2)) + shareLabelInfo.margin * 2;
          }

          if (_labelHeight <= 0) {
            _contentSize.height = parseFloat(_textDesiredHeight.toFixed(2)) + shareLabelInfo.margin * 2;
          }

          _tailoredTopY = _contentSize.height;
          _tailoredBottomY = 0;

          if (highestY > 0) {
            _tailoredTopY = _contentSize.height + highestY;
          }

          if (lowestY < -_textDesiredHeight) {
            _tailoredBottomY = _textDesiredHeight + lowestY;
          }

          return true;
        },
        _getFirstCharLen: function _getFirstCharLen() {
          return 1;
        },
        _getFontScale: function _getFontScale() {
          return _overflow === Overflow.SHRINK ? _bmfontScale : 1;
        },
        _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
          var character = text.charAt(startIndex);

          if (isUnicodeCJK(character) || character === '\n' || isUnicodeSpace(character)) {
            return 1;
          }

          var len = 1;
          var letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

          if (!letterDef) {
            return len;
          }

          var nextLetterX = letterDef.xAdvance * _bmfontScale + _spacingX;
          var letterX = 0;

          for (var index = startIndex + 1; index < textLen; ++index) {
            character = text.charAt(index);
            letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

            if (!letterDef) {
              break;
            }

            letterX = nextLetterX + letterDef.offsetX * _bmfontScale;

            if (letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && _maxLineWidth > 0) {
              return len;
            }

            nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;

            if (character === '\n' || isUnicodeSpace(character) || isUnicodeCJK(character)) {
              break;
            }

            len++;
          }

          return len;
        },
        _multilineTextWrapByWord: function _multilineTextWrapByWord() {
          return this._multilineTextWrap(this._getFirstWordLen);
        },
        _multilineTextWrapByChar: function _multilineTextWrapByChar() {
          return this._multilineTextWrap(this._getFirstCharLen);
        },
        _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char) {
          if (letterIndex >= _lettersInfo.length) {
            var tmpInfo = new LetterInfo();

            _lettersInfo.push(tmpInfo);
          }

          _lettersInfo[letterIndex]["char"] = _char;
          _lettersInfo[letterIndex].hash = "" + _char.charCodeAt(0) + shareLabelInfo.hash;
          _lettersInfo[letterIndex].valid = false;
        },
        _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
          if (letterIndex >= _lettersInfo.length) {
            var tmpInfo = new LetterInfo();

            _lettersInfo.push(tmpInfo);
          }

          var _char2 = character.charCodeAt(0);

          var key = "" + _char2 + shareLabelInfo.hash;
          _lettersInfo[letterIndex].line = lineIndex;
          _lettersInfo[letterIndex]["char"] = character;
          _lettersInfo[letterIndex].hash = key;
          _lettersInfo[letterIndex].valid = shareLabelInfo.fontAtlas.getLetter(key).valid;
          _lettersInfo[letterIndex].x = letterPosition.x;
          _lettersInfo[letterIndex].y = letterPosition.y;
        },
        _alignText: function _alignText() {
          _textDesiredHeight = 0;
          _linesWidth.length = 0;

          {
            this._multilineTextWrapByWord();
          }

          this._computeAlignmentOffset();

          if (_overflow === Overflow.SHRINK) {
            if (_fontSize > 0 && this._isVerticalClamp()) {
              this._shrinkLabelToContentSize(this._isVerticalClamp);
            }
          }

          if (!this._updateQuads()) {
            if (_overflow === Overflow.SHRINK) {
              this._shrinkLabelToContentSize(this._isHorizontalClamp);
            }
          }
        },
        _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
          var shouldUpdateContent = true;

          if (!fontSize) {
            fontSize = 0.1;
            shouldUpdateContent = false;
          }

          _fontSize = fontSize;

          if (shouldUpdateContent) {
            this._updateContent();
          }
        },
        _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
          var fontSize = _fontSize;
          var left = 0;
          var right = fontSize | 0;
          var mid = 0;

          while (left < right) {
            mid = left + right + 1 >> 1;
            var newFontSize = mid;

            if (newFontSize <= 0) {
              break;
            }

            _bmfontScale = newFontSize / _originFontSize;

            {
              this._multilineTextWrapByWord();
            }

            this._computeAlignmentOffset();

            if (lambda()) {
              right = mid - 1;
            } else {
              left = mid;
            }
          }

          if (left >= 0) {
            this._scaleFontSizeDown(left);
          }
        },
        _isVerticalClamp: function _isVerticalClamp() {
          if (_textDesiredHeight > _contentSize.height) {
            return true;
          } else {
            return false;
          }
        },
        _isHorizontalClamp: function _isHorizontalClamp() {
          var letterClamp = false;

          for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
            var letterInfo = _lettersInfo[ctr];

            if (letterInfo.valid) {
              var letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(letterInfo["char"], shareLabelInfo);

              if (!letterDef) {
                continue;
              }

              var px = letterInfo.x + letterDef.w * _bmfontScale;
              var lineIndex = letterInfo.line;

              if (_labelWidth > 0) {
                if (!_isWrapText) {
                  if (px > _contentSize.width) {
                    letterClamp = true;
                    break;
                  }
                } else {
                  var wordWidth = _linesWidth[lineIndex];

                  if (wordWidth > _contentSize.width && (px > _contentSize.width || px < 0)) {
                    letterClamp = true;
                    break;
                  }
                }
              }
            }
          }

          return letterClamp;
        },
        _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
          var wordWidth = _linesWidth[lineIndex];
          var letterOverClamp = px > _contentSize.width || px < 0;

          if (!_isWrapText) {
            return letterOverClamp;
          } else {
            return wordWidth > _contentSize.width && letterOverClamp;
          }
        },
        _updateQuads: function _updateQuads() {
          if (!_comp) {
            return false;
          }

          var texture = _spriteFrame ? _spriteFrame.texture : shareLabelInfo.fontAtlas.getTexture();
          var renderData = _comp.renderData;
          renderData.dataLength = 0;
          renderData.resize(0, 0);
          var anchorPoint = _uiTrans.anchorPoint;
          var contentSize = _contentSize;
          var appX = anchorPoint.x * contentSize.width;
          var appY = anchorPoint.y * contentSize.height;
          var ret = true;

          for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
            var letterInfo = _lettersInfo[ctr];

            if (!letterInfo.valid) {
              continue;
            }

            var letterDef = shareLabelInfo.fontAtlas.getLetter(letterInfo.hash);

            if (!letterDef) {
              console.warn('Can\'t find letter in this bitmap-font');
              continue;
            }

            _tmpRect.height = letterDef.h;
            _tmpRect.width = letterDef.w;
            _tmpRect.x = letterDef.u;
            _tmpRect.y = letterDef.v;
            var py = letterInfo.y + _letterOffsetY;

            if (_labelHeight > 0) {
              if (py > _tailoredTopY) {
                var clipTop = py - _tailoredTopY;
                _tmpRect.y += clipTop;
                _tmpRect.height -= clipTop;
                py -= clipTop;
              }

              if (py - letterDef.h * _bmfontScale < _tailoredBottomY && _overflow === Overflow.CLAMP) {
                _tmpRect.height = py < _tailoredBottomY ? 0 : (py - _tailoredBottomY) / _bmfontScale;
              }
            }

            var lineIndex = letterInfo.line;
            var px = letterInfo.x + letterDef.w / 2 * _bmfontScale + _linesOffsetX[lineIndex];

            if (_labelWidth > 0) {
              if (this._isHorizontalClamped(px, lineIndex)) {
                if (_overflow === Overflow.CLAMP) {
                  _tmpRect.width = 0;
                } else if (_overflow === Overflow.SHRINK) {
                  if (_contentSize.width > letterDef.w) {
                    ret = false;
                    break;
                  } else {
                    _tmpRect.width = 0;
                  }
                }
              }
            }

            if (_tmpRect.height > 0 && _tmpRect.width > 0) {
              var isRotated = this._determineRect();

              var letterPositionX = letterInfo.x + _linesOffsetX[letterInfo.line];
              this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appX, py - appY, _bmfontScale);
            }
          }

          return ret;
        },
        appendQuad: function appendQuad(comp, texture, rect, rotated, x, y, scale) {},
        _determineRect: function _determineRect() {
          var isRotated = _spriteFrame.isRotated();

          var originalSize = _spriteFrame.getOriginalSize();

          var rect = _spriteFrame.getRect();

          var offset = _spriteFrame.getOffset();

          var trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
          var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;

          if (!isRotated) {
            _tmpRect.x += rect.x - trimmedLeft;
            _tmpRect.y += rect.y + trimmedTop;
          } else {
            var originalX = _tmpRect.x;
            _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop;
            _tmpRect.y = originalX + rect.y - trimmedLeft;

            if (_tmpRect.y < 0) {
              _tmpRect.height += trimmedTop;
            }
          }

          return isRotated;
        },
        _computeAlignmentOffset: function _computeAlignmentOffset() {
          _linesOffsetX.length = 0;

          switch (_hAlign) {
            case HorizontalTextAlignment.LEFT:
              for (var i = 0; i < _numberOfLines; ++i) {
                _linesOffsetX.push(0);
              }

              break;

            case HorizontalTextAlignment.CENTER:
              for (var _i = 0, l = _linesWidth.length; _i < l; _i++) {
                _linesOffsetX.push((_contentSize.width - _linesWidth[_i]) / 2);
              }

              break;

            case HorizontalTextAlignment.RIGHT:
              for (var _i2 = 0, _l = _linesWidth.length; _i2 < _l; _i2++) {
                _linesOffsetX.push(_contentSize.width - _linesWidth[_i2]);
              }

              break;
          }

          _letterOffsetY = _contentSize.height;

          if (_vAlign !== VerticalTextAlignment.TOP) {
            var blank = _contentSize.height - _textDesiredHeight + _lineHeight * this._getFontScale() - _originFontSize * _bmfontScale;

            if (_vAlign === VerticalTextAlignment.BOTTOM) {
              _letterOffsetY -= blank;
            } else {
              _letterOffsetY -= blank / 2;
            }
          }
        },
        _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
          var newWidth = _contentSize.width;
          var newHeight = _contentSize.height;

          if (_overflow === Overflow.RESIZE_HEIGHT) {
            newHeight = 0;
          }

          if (_overflow === Overflow.NONE) {
            newWidth = 0;
            newHeight = 0;
          }

          _labelWidth = newWidth;
          _labelHeight = newHeight;
          _labelDimensions.width = newWidth;
          _labelDimensions.height = newHeight;
          _maxLineWidth = newWidth;
        }
      };

      var tempColor = new Color(255, 255, 255, 255);
      var bmfont = {
        createData: function createData(comp) {
          return comp.requestRenderData();
        },
        fillBuffers: function fillBuffers(comp, renderer) {
          var node = comp.node;
          tempColor.set(comp.color);
          tempColor.a = node._uiProps.opacity * 255;
          fillMeshVertices3D(node, renderer, comp.renderData, tempColor);
        },
        appendQuad: function appendQuad(comp, spriteFrame, rect, rotated, x, y, scale) {
          var renderData = comp.renderData;

          if (!renderData) {
            return;
          }

          var dataOffset = renderData.dataLength;
          renderData.dataLength += 4;
          renderData.resize(renderData.dataLength, renderData.dataLength / 2 * 3);
          var dataList = renderData.data;
          var texW = spriteFrame.width;
          var texH = spriteFrame.height;
          var rectWidth = rect.width;
          var rectHeight = rect.height;
          var l = 0;
          var b = 0;
          var t = 0;
          var r = 0;

          if (!rotated) {
            l = rect.x / texW;
            r = (rect.x + rectWidth) / texW;
            b = (rect.y + rectHeight) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = b;
            dataList[dataOffset + 1].u = r;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = l;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = t;
          } else {
            l = rect.x / texW;
            r = (rect.x + rectHeight) / texW;
            b = (rect.y + rectWidth) / texH;
            t = rect.y / texH;
            dataList[dataOffset].u = l;
            dataList[dataOffset].v = t;
            dataList[dataOffset + 1].u = l;
            dataList[dataOffset + 1].v = b;
            dataList[dataOffset + 2].u = r;
            dataList[dataOffset + 2].v = t;
            dataList[dataOffset + 3].u = r;
            dataList[dataOffset + 3].v = b;
          }

          dataList[dataOffset].x = x;
          dataList[dataOffset].y = y - rectHeight * scale;
          dataList[dataOffset + 1].x = x + rectWidth * scale;
          dataList[dataOffset + 1].y = y - rectHeight * scale;
          dataList[dataOffset + 2].x = x;
          dataList[dataOffset + 2].y = y;
          dataList[dataOffset + 3].x = x + rectWidth * scale;
          dataList[dataOffset + 3].y = y;
        },
        updateColor: function updateColor(comp) {}
      };
      addon(bmfont, bmfontUtils);

      var _atlasWidth = 1024;
      var _atlasHeight = 1024;
      var _shareAtlas = null;
      var letterFont = mixin(bmfontUtils, {
        getAssemblerData: function getAssemblerData() {
          if (!_shareAtlas) {
            _shareAtlas = new LetterAtlas(_atlasWidth, _atlasHeight);
          }

          return _shareAtlas.getTexture();
        },
        _updateFontFamily: function _updateFontFamily(comp) {
          shareLabelInfo.fontAtlas = _shareAtlas;
          shareLabelInfo.fontFamily = this._getFontFamily(comp);
          var outline = comp.getComponent(LabelOutline);

          if (outline && outline.enabled) {
            shareLabelInfo.isOutlined = true;
            shareLabelInfo.margin = outline.width;
            shareLabelInfo.out = outline.color.clone();
            shareLabelInfo.out.a = outline.color.a * comp.color.a / 255.0;
          } else {
            shareLabelInfo.isOutlined = false;
            shareLabelInfo.margin = 0;
          }
        },
        _getFontFamily: function _getFontFamily(comp) {
          var fontFamily = 'Arial';

          if (!comp.useSystemFont) {
            if (comp.font) {
              fontFamily = comp.font._nativeAsset || 'Arial';
            }
          } else {
            fontFamily = comp.fontFamily || 'Arial';
          }

          return fontFamily;
        },
        _updateLabelInfo: function _updateLabelInfo(comp) {
          shareLabelInfo.fontDesc = this._getFontDesc();
          shareLabelInfo.color = comp.color;
          shareLabelInfo.hash = computeHash(shareLabelInfo);
        },
        _getFontDesc: function _getFontDesc() {
          var fontDesc = shareLabelInfo.fontSize.toString() + "px ";
          fontDesc += shareLabelInfo.fontFamily;

          return fontDesc;
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
        _determineRect: function _determineRect(tempRect) {
          return false;
        }
      });

      var tempColor$1 = new Color(255, 255, 255, 255);
      var letter = {
        createData: function createData(comp) {
          return comp.requestRenderData();
        },
        fillBuffers: function fillBuffers(comp, renderer) {
          if (!comp.renderData) {
            return;
          }

          var node = comp.node;
          tempColor$1.a = node._uiProps.opacity * 255;
          fillMeshVertices3D(node, renderer, comp.renderData, tempColor$1);
        },
        updateColor: function updateColor(comp) {},
        appendQuad: bmfont.appendQuad
      };
      addon(letter, letterFont);

      var Overflow$1 = Label.Overflow;
      var MAX_SIZE$1 = 2048;

      var _BASELINE_OFFSET$1 = getBaselineOffset();

      var _invisibleAlpha = (1 / 255).toFixed(3);

      var _context = null;
      var _canvas = null;
      var _texture = null;
      var _fontDesc = '';
      var _string$1 = '';
      var _fontSize$1 = 0;
      var _drawFontsize = 0;
      var _splitStrings = [];

      var _canvasSize = new Size();

      var _lineHeight$1 = 0;
      var _hAlign$1 = 0;
      var _vAlign$1 = 0;

      var _color$1 = new Color();

      var _alpha = 1;
      var _fontFamily = '';
      var _overflow$1 = Overflow$1.NONE;
      var _isWrapText$1 = false;
      var _outlineComp = null;

      var _outlineColor = Color.BLACK.clone();

      var _shadowComp = null;

      var _shadowColor = Color.BLACK.clone();

      var _canvasPadding = new Rect();

      var _contentSizeExtend = Size.ZERO.clone();

      var _nodeContentSize = Size.ZERO.clone();

      var _startPosition = Vec2.ZERO.clone();

      var _drawUnderlinePos = Vec2.ZERO.clone();

      var _drawUnderlineWidth = 0;
      var _underlineThickness = 0;
      var _isBold = false;
      var _isItalic = false;
      var _isUnderline = false;
      var Alignment = ['left', 'center', 'right'];
      var ttfUtils = {
        getAssemblerData: function getAssemblerData() {
          var sharedLabelData = Label._canvasPool.get();

          return sharedLabelData;
        },
        resetAssemblerData: function resetAssemblerData(assemblerData) {
          if (assemblerData) {
            Label._canvasPool.put(assemblerData);
          }
        },
        updateRenderData: function updateRenderData(comp) {
          if (!comp.renderData) {
            return;
          }

          if (comp.renderData.vertDirty) {
            var trans = comp.node._uiProps.uiTransformComp;

            this._updateFontFamily(comp);

            this._updateProperties(comp, trans);

            this._calculateLabelFont();

            this._updateLabelDimensions();

            this._updateTexture(comp);

            this._calDynamicAtlas(comp);

            comp.actualFontSize = _fontSize$1;
            trans.setContentSize(_canvasSize);
            this.updateVertexData(comp);
            this.updateUVs(comp);
            comp.markForUpdateRenderData(false);
            _context = null;
            _canvas = null;
            _texture = null;
          }

          if (comp.spriteFrame) {
            var renderData = comp.renderData;
            renderData.updateRenderData(comp, comp.spriteFrame);
          }
        },
        updateVertexData: function updateVertexData(comp) {},
        updateUVs: function updateUVs(comp) {},
        _updateFontFamily: function _updateFontFamily(comp) {
          if (!comp.useSystemFont) {
            if (comp.font) {
              _fontFamily = comp.font._nativeAsset || 'Arial';
            } else {
              _fontFamily = 'Arial';
            }
          } else {
            _fontFamily = comp.fontFamily || 'Arial';
          }
        },
        _updateProperties: function _updateProperties(comp, trans) {
          var assemblerData = comp.assemblerData;

          if (!assemblerData) {
            return;
          }

          _context = assemblerData.context;
          _canvas = assemblerData.canvas;
          _texture = comp.spriteFrame;
          _string$1 = comp.string.toString();
          _fontSize$1 = comp.fontSize;
          _drawFontsize = _fontSize$1;
          _overflow$1 = comp.overflow;
          _nodeContentSize.width = _canvasSize.width = trans.width;
          _nodeContentSize.height = _canvasSize.height = trans.height;
          _underlineThickness = comp.underlineHeight;
          _lineHeight$1 = comp.lineHeight;
          _hAlign$1 = comp.horizontalAlign;
          _vAlign$1 = comp.verticalAlign;
          _color$1 = comp.color;
          _alpha = comp.node._uiProps.opacity;
          _isBold = comp.isBold;
          _isItalic = comp.isItalic;
          _isUnderline = comp.isUnderline;

          if (_overflow$1 === Overflow$1.NONE) {
            _isWrapText$1 = false;
          } else if (_overflow$1 === Overflow$1.RESIZE_HEIGHT) {
            _isWrapText$1 = true;
          } else {
            _isWrapText$1 = comp.enableWrapText;
          }

          _outlineComp = LabelOutline && comp.getComponent(LabelOutline);
          _outlineComp = _outlineComp && _outlineComp.enabled && _outlineComp.width > 0 ? _outlineComp : null;

          if (_outlineComp) {
            _outlineColor.set(_outlineComp.color);
          }

          _shadowComp = LabelShadow && comp.getComponent(LabelShadow);
          _shadowComp = _shadowComp && _shadowComp.enabled ? _shadowComp : null;

          if (_shadowComp) {
            _shadowColor.set(_shadowComp.color);
          }

          this._updatePaddingRect();
        },
        _updatePaddingRect: function _updatePaddingRect() {
          var top = 0;
          var bottom = 0;
          var left = 0;
          var right = 0;
          var outlineWidth = 0;
          _contentSizeExtend.width = _contentSizeExtend.height = 0;

          if (_outlineComp) {
            outlineWidth = _outlineComp.width;
            top = bottom = left = right = outlineWidth;
            _contentSizeExtend.width = _contentSizeExtend.height = outlineWidth * 2;
          }

          if (_shadowComp) {
            var shadowWidth = _shadowComp.blur + outlineWidth;
            var offsetX = _shadowComp.offset.x;
            var offsetY = _shadowComp.offset.y;
            left = Math.max(left, -offsetX + shadowWidth);
            right = Math.max(right, offsetX + shadowWidth);
            top = Math.max(top, offsetY + shadowWidth);
            bottom = Math.max(bottom, -offsetY + shadowWidth);
          }

          if (_isItalic) {
            var offset = _drawFontsize * Math.tan(12 * 0.0174532925);

            right += offset;
            _contentSizeExtend.width += offset;
          }

          _canvasPadding.x = left;
          _canvasPadding.y = top;
          _canvasPadding.width = left + right;
          _canvasPadding.height = top + bottom;
        },
        _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
          var labelX = 0;

          if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
            labelX = _canvasSize.width - _canvasPadding.width;
          } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
            labelX = (_canvasSize.width - _canvasPadding.width) / 2;
          }

          var lineHeight = this._getLineHeight();

          var drawStartY = lineHeight * (_splitStrings.length - 1);
          var firstLinelabelY = _fontSize$1 * (1 - BASELINE_RATIO / 2);

          if (_vAlign$1 !== VerticalTextAlignment.TOP) {
            var blank = drawStartY + _canvasPadding.height + _fontSize$1 - _canvasSize.height;

            if (_vAlign$1 === VerticalTextAlignment.BOTTOM) {
              blank += BASELINE_RATIO / 2 * _fontSize$1;
              firstLinelabelY -= blank;
            } else {
              firstLinelabelY -= blank / 2;
            }
          }

          firstLinelabelY += _BASELINE_OFFSET$1 * _fontSize$1;

          _startPosition.set(labelX + _canvasPadding.x, firstLinelabelY + _canvasPadding.y);
        },
        _updateTexture: function _updateTexture(comp) {
          if (!_context || !_canvas) {
            return;
          }

          _context.clearRect(0, 0, _canvas.width, _canvas.height);

          _context.font = _fontDesc;

          this._calculateFillTextStartPosition();

          var lineHeight = this._getLineHeight();

          _context.lineJoin = 'round';

          if (_outlineComp) {
            _context.fillStyle = "rgba(" + _outlineColor.r + ", " + _outlineColor.g + ", " + _outlineColor.b + ", " + _invisibleAlpha + ")";

            _context.fillRect(0, 0, _canvas.width, _canvas.height);
          } else if (comp._srcBlendFactor === BlendFactor.SRC_ALPHA) {
            _context.fillStyle = "rgba(" + _color$1.r + ", " + _color$1.g + ", " + _color$1.b + ", " + _invisibleAlpha + ")";

            _context.fillRect(0, 0, _canvas.width, _canvas.height);
          }

          _context.fillStyle = "rgb(" + _color$1.r + ", " + _color$1.g + ", " + _color$1.b + ")";
          var drawTextPosX = _startPosition.x;
          var drawTextPosY = 0;

          this._drawTextEffect(_startPosition, lineHeight);

          for (var i = 0; i < _splitStrings.length; ++i) {
            drawTextPosY = _startPosition.y + i * lineHeight;

            if (_outlineComp) {
              _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
            }

            _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
          }

          if (_shadowComp) {
            _context.shadowColor = 'transparent';
          }

          this._uploadTexture(comp);
        },
        _uploadTexture: function _uploadTexture(comp) {
          if (comp.cacheMode === Label.CacheMode.BITMAP) {
            var frame = comp.ttfSpriteFrame;
            dynamicAtlasManager.deleteAtlasSpriteFrame(frame);

            frame._resetDynamicAtlasFrame();
          }

          if (_texture && _canvas) {
            var tex;

            if (_texture instanceof SpriteFrame) {
              tex = _texture.texture;
            } else {
              tex = _texture;
            }

            var uploadAgain = _canvas.width !== 0 && _canvas.height !== 0;

            if (uploadAgain) {
              tex.reset({
                width: _canvas.width,
                height: _canvas.height,
                mipmapLevel: 1
              });
              tex.uploadData(_canvas);
              tex.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE);

              if (_texture instanceof SpriteFrame) {
                _texture.rect = new Rect(0, 0, _canvas.width, _canvas.height);

                _texture._calculateUV();
              }

              if (comp.renderData) {
                comp.renderData.textureDirty = true;
              }

              if (legacyCC.director.root && legacyCC.director.root.batcher2D) {
                legacyCC.director.root.batcher2D._releaseDescriptorSetCache(tex.getHash());
              }
            }
          }
        },
        _calDynamicAtlas: function _calDynamicAtlas(comp) {
          if (comp.cacheMode !== Label.CacheMode.BITMAP || !_canvas || _canvas.width <= 0 || _canvas.height <= 0) return;
          var frame = comp.ttfSpriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(comp, frame);
        },
        _setupOutline: function _setupOutline() {
          _context.strokeStyle = "rgba(" + _outlineColor.r + ", " + _outlineColor.g + ", " + _outlineColor.b + ", " + _outlineColor.a / 255 + ")";
          _context.lineWidth = _outlineComp.width * 2;
        },
        _setupShadow: function _setupShadow() {
          _context.shadowColor = "rgba(" + _shadowColor.r + ", " + _shadowColor.g + ", " + _shadowColor.b + ", " + _shadowColor.a / 255 + ")";
          _context.shadowBlur = _shadowComp.blur;
          _context.shadowOffsetX = _shadowComp.offset.x;
          _context.shadowOffsetY = -_shadowComp.offset.y;
        },
        _drawTextEffect: function _drawTextEffect(startPosition, lineHeight) {
          if (!_shadowComp && !_outlineComp && !_isUnderline) return;
          var isMultiple = _splitStrings.length > 1 && _shadowComp;

          var measureText = this._measureText(_context, _fontDesc);

          var drawTextPosX = 0;
          var drawTextPosY = 0;

          if (_shadowComp) {
            this._setupShadow();
          }

          if (_outlineComp) {
            this._setupOutline();
          }

          for (var i = 0; i < _splitStrings.length; ++i) {
            drawTextPosX = startPosition.x;
            drawTextPosY = startPosition.y + i * lineHeight;

            if (isMultiple) {
              if (_outlineComp) {
                _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
              }

              _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
            }

            if (_isUnderline) {
              _drawUnderlineWidth = measureText(_splitStrings[i]);

              if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
                _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth;
              } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
                _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth / 2;
              } else {
                _drawUnderlinePos.x = startPosition.x;
              }

              _drawUnderlinePos.y = drawTextPosY + _drawFontsize / 8;

              _context.fillRect(_drawUnderlinePos.x, _drawUnderlinePos.y, _drawUnderlineWidth, _underlineThickness);
            }
          }

          if (isMultiple) {
            _context.shadowColor = 'transparent';
          }
        },
        _updateLabelDimensions: function _updateLabelDimensions() {
          _canvasSize.width = Math.min(_canvasSize.width, MAX_SIZE$1);
          _canvasSize.height = Math.min(_canvasSize.height, MAX_SIZE$1);
          var recreate = false;

          if (_canvas.width !== _canvasSize.width) {
            _canvas.width = _canvasSize.width;
            recreate = true;
          }

          if (_canvas.height !== _canvasSize.height) {
            _canvas.height = _canvasSize.height;
            recreate = true;
          }

          if (recreate) _context.font = _fontDesc;
          _context.textAlign = Alignment[_hAlign$1];
          _context.textBaseline = 'alphabetic';
        },
        _getFontDesc: function _getFontDesc() {
          var fontDesc = _fontSize$1.toString() + "px ";
          fontDesc += _fontFamily;

          if (_isBold) {
            fontDesc = "bold " + fontDesc;
          }

          if (_isItalic) {
            fontDesc = "italic " + fontDesc;
          }

          return fontDesc;
        },
        _getLineHeight: function _getLineHeight() {
          var nodeSpacingY = _lineHeight$1;

          if (nodeSpacingY === 0) {
            nodeSpacingY = _fontSize$1;
          } else {
            nodeSpacingY = nodeSpacingY * _fontSize$1 / _drawFontsize;
          }

          return nodeSpacingY | 0;
        },
        _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
          var paragraphLength = [];

          for (var _iterator = _createForOfIteratorHelperLoose(paragraphedStrings), _step; !(_step = _iterator()).done;) {
            var para = _step.value;
            var width = safeMeasureText(ctx, para, _fontDesc);
            paragraphLength.push(width);
          }

          return paragraphLength;
        },
        _measureText: function _measureText(ctx, fontDesc) {
          return function (string) {
            return safeMeasureText(ctx, string, fontDesc);
          };
        },
        _calculateShrinkFont: function _calculateShrinkFont(paragraphedStrings) {
          if (!_context) return;

          var paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);

          var i = 0;
          var totalHeight = 0;
          var maxLength = 0;

          if (_isWrapText$1) {
            var canvasWidthNoMargin = _nodeContentSize.width;
            var canvasHeightNoMargin = _nodeContentSize.height;

            if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
              return;
            }

            totalHeight = canvasHeightNoMargin + 1;
            var actualFontSize = _fontSize$1 + 1;
            var textFragment = [];
            var left = 0;
            var right = actualFontSize | 0;
            var mid = 0;

            while (left < right) {
              mid = left + right + 1 >> 1;

              if (mid <= 0) {
                logID(4003);
                break;
              }

              _fontSize$1 = mid;
              _fontDesc = this._getFontDesc();
              _context.font = _fontDesc;

              var lineHeight = this._getLineHeight();

              totalHeight = 0;

              for (i = 0; i < paragraphedStrings.length; ++i) {
                var allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
                totalHeight += textFragment.length * lineHeight;
              }

              if (totalHeight > canvasHeightNoMargin) {
                right = mid - 1;
              } else {
                left = mid;
              }
            }

            if (left === 0) {
              logID(4003);
            } else {
              _fontSize$1 = left;
              _fontDesc = this._getFontDesc();
              _context.font = _fontDesc;
            }
          } else {
            totalHeight = paragraphedStrings.length * this._getLineHeight();

            for (i = 0; i < paragraphedStrings.length; ++i) {
              if (maxLength < paragraphLength[i]) {
                maxLength = paragraphLength[i];
              }
            }

            var scaleX = (_canvasSize.width - _canvasPadding.width) / maxLength;
            var scaleY = _canvasSize.height / totalHeight;
            _fontSize$1 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0;
            _fontDesc = this._getFontDesc();
            _context.font = _fontDesc;
          }
        },
        _calculateWrapText: function _calculateWrapText(paragraphedStrings) {
          if (!_isWrapText$1 || !_context) return;
          _splitStrings = [];
          var canvasWidthNoMargin = _nodeContentSize.width;

          for (var i = 0; i < paragraphedStrings.length; ++i) {
            var allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
            var textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
            _splitStrings = _splitStrings.concat(textFragment);
          }
        },
        _calculateLabelFont: function _calculateLabelFont() {
          if (!_context) {
            return;
          }

          var paragraphedStrings = _string$1.split('\n');

          _splitStrings = paragraphedStrings;
          _fontDesc = this._getFontDesc();
          _context.font = _fontDesc;

          switch (_overflow$1) {
            case Overflow$1.NONE:
              {
                var canvasSizeX = 0;
                var canvasSizeY = 0;

                for (var i = 0; i < paragraphedStrings.length; ++i) {
                  var paraLength = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                  canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                }

                canvasSizeY = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();
                var rawWidth = parseFloat(canvasSizeX.toFixed(2));
                var rawHeight = parseFloat(canvasSizeY.toFixed(2));
                _canvasSize.width = rawWidth + _canvasPadding.width;
                _canvasSize.height = rawHeight + _canvasPadding.height;
                _nodeContentSize.width = rawWidth + _contentSizeExtend.width;
                _nodeContentSize.height = rawHeight + _contentSizeExtend.height;
                break;
              }

            case Overflow$1.SHRINK:
              {
                this._calculateShrinkFont(paragraphedStrings);

                this._calculateWrapText(paragraphedStrings);

                break;
              }

            case Overflow$1.CLAMP:
              {
                this._calculateWrapText(paragraphedStrings);

                break;
              }

            case Overflow$1.RESIZE_HEIGHT:
              {
                this._calculateWrapText(paragraphedStrings);

                var _rawHeight = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();

                _canvasSize.height = _rawHeight + _canvasPadding.height;
                _nodeContentSize.height = _rawHeight + _contentSizeExtend.height;
                break;
              }
          }
        }
      };

      var WHITE$1 = Color.WHITE.clone();
      var ttf = {
        createData: function createData(comp) {
          var renderData = comp.requestRenderData();
          renderData.dataLength = 2;
          renderData.resize(4, 6);
          var vData = renderData.chunk.vb;
          vData[3] = vData[21] = vData[22] = vData[31] = 0;
          vData[4] = vData[12] = vData[13] = vData[30] = 1;
          var offset = 5;

          for (var i = 0; i < 4; i++) {
            Color.toArray(vData, WHITE$1, offset);
            offset += 9;
          }

          return renderData;
        },
        fillBuffers: function fillBuffers(comp, renderer) {
          var chunk = comp.renderData.chunk;
          var dataList = comp.renderData.data;
          var node = comp.node;
          var vData = chunk.vb;
          var data0 = dataList[0];
          var data3 = dataList[1];
          node.updateWorldTransform();
          var pos = node._pos;
          var rot = node._rot;
          var scale = node._scale;
          var ax = data0.x * scale.x;
          var bx = data3.x * scale.x;
          var ay = data0.y * scale.y;
          var by = data3.y * scale.y;
          var qx = rot.x;
          var qy = rot.y;
          var qz = rot.z;
          var qw = rot.w;
          var qxy = qx * qy;
          var qzw = qz * qw;
          var qxy2 = qx * qx - qy * qy;
          var qzw2 = qw * qw - qz * qz;
          var cx1 = qzw2 + qxy2;
          var cx2 = (qxy - qzw) * 2;
          var cy1 = qzw2 - qxy2;
          var cy2 = (qxy + qzw) * 2;
          var x = pos.x;
          var y = pos.y;
          vData[0] = cx1 * ax + cx2 * ay + x;
          vData[1] = cy1 * ay + cy2 * ax + y;
          vData[9] = cx1 * bx + cx2 * ay + x;
          vData[10] = cy1 * ay + cy2 * bx + y;
          vData[18] = cx1 * ax + cx2 * by + x;
          vData[19] = cy1 * by + cy2 * ax + y;
          vData[27] = cx1 * bx + cx2 * by + x;
          vData[28] = cy1 * by + cy2 * bx + y;
          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.vertexAccessor.getMeshBuffer(chunk.bufferId);
          var ib = chunk.vertexAccessor.getIndexBuffer(bid);
          var indexOffset = meshBuffer.indexOffset;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          meshBuffer.indexOffset += 6;
        },
        updateVertexData: function updateVertexData(comp) {
          var renderData = comp.renderData;

          if (!renderData) {
            return;
          }

          var uiTrans = comp.node._uiProps.uiTransformComp;
          var width = uiTrans.width;
          var height = uiTrans.height;
          var appX = uiTrans.anchorX * width;
          var appY = uiTrans.anchorY * height;
          var data = renderData.data;
          data[0].x = -appX;
          data[0].y = -appY;
          data[1].x = width - appX;
          data[1].y = height - appY;
        },
        updateUVs: function updateUVs(comp) {
          var renderData = comp.renderData;

          if (!renderData || !comp.ttfSpriteFrame) {
            return;
          }

          var vData = renderData.chunk.vb;
          var uv = comp.ttfSpriteFrame.uv;
          vData[3] = uv[0];
          vData[4] = uv[1];
          vData[12] = uv[2];
          vData[13] = uv[3];
          vData[21] = uv[4];
          vData[22] = uv[5];
          vData[30] = uv[6];
          vData[31] = uv[7];
        },
        updateColor: function updateColor(comp) {}
      };
      addon(ttf, ttfUtils);

      var labelAssembler = exports('labelAssembler', {
        getAssembler: function getAssembler(comp) {
          var assembler = ttf;

          if (comp.font instanceof BitmapFont) {
            assembler = bmfont;
          } else if (comp.cacheMode === Label.CacheMode.CHAR) {
            assembler = letter;
          }

          return assembler;
        }
      });
      Label.Assembler = labelAssembler;

      var FillType$1 = Sprite.FillType;
      var matrix = new Mat4();
      var vec3_temp$1 = new Vec3();
      var barFilled = {
        updateRenderData: function updateRenderData(sprite) {
          var frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          var renderData = sprite.renderData;

          if (renderData && frame) {
            renderData.updateRenderData(sprite, frame);
            var vertDirty = renderData.vertDirty;

            if (!vertDirty) {
              return;
            }

            var fillStart = sprite.fillStart;
            var fillRange = sprite.fillRange;

            if (fillRange < 0) {
              fillStart += fillRange;
              fillRange = -fillRange;
            }

            fillRange = fillStart + fillRange;
            fillStart = fillStart > 1.0 ? 1.0 : fillStart;
            fillStart = fillStart < 0.0 ? 0.0 : fillStart;
            fillRange = fillRange > 1.0 ? 1.0 : fillRange;
            fillRange = fillRange < 0.0 ? 0.0 : fillRange;
            fillRange -= fillStart;
            fillRange = fillRange < 0 ? 0 : fillRange;
            var fillEnd = fillStart + fillRange;
            fillEnd = fillEnd > 1 ? 1 : fillEnd;
            this.updateUVs(sprite, fillStart, fillEnd);
            this.updateVertexData(sprite, fillStart, fillEnd);
          }
        },
        updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
          var spriteFrame = sprite.spriteFrame;
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var atlasWidth = spriteFrame.width;
          var atlasHeight = spriteFrame.height;
          var textureRect = spriteFrame.rect;
          var ul = 0;
          var vb = 0;
          var ur = 0;
          var vt = 0;
          var quadUV0 = 0;
          var quadUV1 = 0;
          var quadUV2 = 0;
          var quadUV3 = 0;
          var quadUV4 = 0;
          var quadUV5 = 0;
          var quadUV6 = 0;
          var quadUV7 = 0;

          if (spriteFrame.isRotated()) {
            ul = textureRect.x / atlasWidth;
            vb = (textureRect.y + textureRect.width) / atlasHeight;
            ur = (textureRect.x + textureRect.height) / atlasWidth;
            vt = textureRect.y / atlasHeight;
            quadUV0 = quadUV2 = ul;
            quadUV4 = quadUV6 = ur;
            quadUV3 = quadUV7 = vb;
            quadUV1 = quadUV5 = vt;
          } else {
            ul = textureRect.x / atlasWidth;
            vb = (textureRect.y + textureRect.height) / atlasHeight;
            ur = (textureRect.x + textureRect.width) / atlasWidth;
            vt = textureRect.y / atlasHeight;
            quadUV0 = quadUV4 = ul;
            quadUV2 = quadUV6 = ur;
            quadUV1 = quadUV3 = vb;
            quadUV5 = quadUV7 = vt;
          }

          switch (sprite.fillType) {
            case FillType$1.HORIZONTAL:
              vData[3] = quadUV0 + (quadUV2 - quadUV0) * fillStart;
              vData[4] = quadUV1 + (quadUV3 - quadUV1) * fillStart;
              vData[12] = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
              vData[13] = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
              vData[21] = quadUV4 + (quadUV6 - quadUV4) * fillStart;
              vData[22] = quadUV5 + (quadUV7 - quadUV5) * fillStart;
              vData[30] = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
              vData[31] = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
              break;

            case FillType$1.VERTICAL:
              vData[3] = quadUV0 + (quadUV4 - quadUV0) * fillStart;
              vData[4] = quadUV1 + (quadUV5 - quadUV1) * fillStart;
              vData[12] = quadUV2 + (quadUV6 - quadUV2) * fillStart;
              vData[13] = quadUV3 + (quadUV7 - quadUV3) * fillStart;
              vData[21] = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
              vData[22] = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
              vData[30] = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
              vData[31] = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
              break;

            default:
              errorID(2626);
              break;
          }
        },
        updateVertexData: function updateVertexData(sprite, fillStart, fillEnd) {
          var renderData = sprite.renderData;
          var dataList = renderData.data;
          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var width = uiTrans.width;
          var height = uiTrans.height;
          var appX = uiTrans.anchorX * width;
          var appY = uiTrans.anchorY * height;
          var l = -appX;
          var b = -appY;
          var r = width - appX;
          var t = height - appY;
          var progressStart = 0;
          var progressEnd = 0;

          switch (sprite.fillType) {
            case FillType$1.HORIZONTAL:
              progressStart = l + (r - l) * fillStart;
              progressEnd = l + (r - l) * fillEnd;
              l = progressStart;
              r = progressEnd;
              break;

            case FillType$1.VERTICAL:
              progressStart = b + (t - b) * fillStart;
              progressEnd = b + (t - b) * fillEnd;
              b = progressStart;
              t = progressEnd;
              break;

            default:
              errorID(2626);
              break;
          }

          dataList[0].x = l;
          dataList[0].y = b;
          dataList[1].x = r;
          dataList[1].y = b;
          dataList[2].x = l;
          dataList[2].y = t;
          dataList[3].x = r;
          dataList[3].y = t;
        },
        createData: function createData(sprite) {
          var renderData = sprite.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(4, 6);
          var dataList = renderData.data;

          for (var _iterator = _createForOfIteratorHelperLoose(dataList), _step; !(_step = _iterator()).done;) {
            var data = _step.value;
            data.z = 0;
          }

          return renderData;
        },
        updateWorldVertexData: function updateWorldVertexData(sprite, chunk) {
          var node = sprite.node;
          node.getWorldMatrix(matrix);
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = sprite.renderData.data;
          var vData = chunk.vb;
          var offset = 0;

          for (var i = 0; i < 4; i++) {
            var local = dataList[i];
            Vec3.transformMat4(vec3_temp$1, local, matrix);
            offset = i * stride;
            vData[offset] = vec3_temp$1.x;
            vData[offset + 1] = vec3_temp$1.y;
            vData[offset + 2] = vec3_temp$1.z;
          }
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
          var renderData = sprite.renderData;
          var chunk = renderData.chunk;

          if (sprite.node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVertexData(sprite, chunk);
            renderData.vertDirty = false;
          }

          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.vertexAccessor.getMeshBuffer(chunk.bufferId);
          var ib = chunk.vertexAccessor.getIndexBuffer(bid);
          var indexOffset = meshBuffer.indexOffset;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          meshBuffer.indexOffset += 6;
        },
        updateColor: function updateColor(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = sprite.node._uiProps.opacity;

          for (var i = 0; i < 4; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        }
      };

      var PI_2 = Math.PI * 2;
      var EPSILON$2 = 1e-6;
      var matrix$1 = new Mat4();
      var vec3_temp$2 = new Vec3();
      var _vertPos = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

      var _vertices = new Array(4);

      var _uvs = new Array(8);

      var _intersectPoint_1 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
      var _intersectPoint_2 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

      var _center = new Vec2();

      var _triangles = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

      function _calcIntersectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
        var sinAngle = Math.sin(angle);
        sinAngle = Math.abs(sinAngle) > EPSILON$2 ? sinAngle : 0;
        var cosAngle = Math.cos(angle);
        cosAngle = Math.abs(cosAngle) > EPSILON$2 ? cosAngle : 0;
        var tanAngle = 0;
        var cotAngle = 0;

        if (cosAngle !== 0) {
          tanAngle = sinAngle / cosAngle;

          if ((left - center.x) * cosAngle > 0) {
            var yLeft = center.y + tanAngle * (left - center.x);
            intersectPoints[0].x = left;
            intersectPoints[0].y = yLeft;
          }

          if ((right - center.x) * cosAngle > 0) {
            var yRight = center.y + tanAngle * (right - center.x);
            intersectPoints[2].x = right;
            intersectPoints[2].y = yRight;
          }
        }

        if (sinAngle !== 0) {
          cotAngle = cosAngle / sinAngle;

          if ((top - center.y) * sinAngle > 0) {
            var xTop = center.x + cotAngle * (top - center.y);
            intersectPoints[3].x = xTop;
            intersectPoints[3].y = top;
          }

          if ((bottom - center.y) * sinAngle > 0) {
            var xBottom = center.x + cotAngle * (bottom - center.y);
            intersectPoints[1].x = xBottom;
            intersectPoints[1].y = bottom;
          }
        }
      }

      function _calculateVertices(sprite) {
        var uiTrans = sprite.node._uiProps.uiTransformComp;
        var width = uiTrans.width;
        var height = uiTrans.height;
        var appX = uiTrans.anchorX * width;
        var appY = uiTrans.anchorY * height;
        var l = -appX;
        var b = -appY;
        var r = width - appX;
        var t = height - appY;
        var vertices = _vertices;
        vertices[0] = l;
        vertices[1] = b;
        vertices[2] = r;
        vertices[3] = t;
        var fillCenter = sprite.fillCenter;
        var cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l;
        var cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
        _vertPos[0].x = _vertPos[3].x = l;
        _vertPos[1].x = _vertPos[2].x = r;
        _vertPos[0].y = _vertPos[1].y = b;
        _vertPos[2].y = _vertPos[3].y = t;

        for (var _iterator = _createForOfIteratorHelperLoose(_triangles), _step; !(_step = _iterator()).done;) {
          var num = _step.value;
          Vec2.set(num, 0, 0);
        }

        if (cx !== vertices[0]) {
          Vec2.set(_triangles[0], 3, 0);
        }

        if (cx !== vertices[2]) {
          Vec2.set(_triangles[2], 1, 2);
        }

        if (cy !== vertices[1]) {
          Vec2.set(_triangles[1], 0, 1);
        }

        if (cy !== vertices[3]) {
          Vec2.set(_triangles[3], 2, 3);
        }
      }

      function _calculateUVs(spriteFrame) {
        var atlasWidth = spriteFrame.width;
        var atlasHeight = spriteFrame.height;
        var textureRect = spriteFrame.getRect();
        var u0 = 0;
        var u1 = 0;
        var v0 = 0;
        var v1 = 0;
        var uvs = _uvs;

        if (spriteFrame.isRotated()) {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.height) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.width) / atlasHeight;
          uvs[0] = uvs[2] = u0;
          uvs[4] = uvs[6] = u1;
          uvs[3] = uvs[7] = v1;
          uvs[1] = uvs[5] = v0;
        } else {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.width) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.height) / atlasHeight;
          uvs[0] = uvs[4] = u0;
          uvs[2] = uvs[6] = u1;
          uvs[1] = uvs[3] = v1;
          uvs[5] = uvs[7] = v0;
        }
      }

      function _getVertAngle(start, end) {
        var placementX = end.x - start.x;
        var placementY = end.y - start.y;

        if (placementX === 0 && placementY === 0) {
          return 0;
        } else if (placementX === 0) {
          if (placementY > 0) {
            return Math.PI * 0.5;
          } else {
            return Math.PI * 1.5;
          }
        } else {
          var angle = Math.atan(placementY / placementX);

          if (placementX < 0) {
            angle += Math.PI;
          }

          return angle;
        }
      }

      function _generateTriangle(dataList, offset, vert0, vert1, vert2) {
        var vertices = _vertices;
        var v0x = vertices[0];
        var v0y = vertices[1];
        var v1x = vertices[2];
        var v1y = vertices[3];
        dataList[offset].x = vert0.x;
        dataList[offset].y = vert0.y;
        dataList[offset + 1].x = vert1.x;
        dataList[offset + 1].y = vert1.y;
        dataList[offset + 2].x = vert2.x;
        dataList[offset + 2].y = vert2.y;
        var progressX = 0;
        var progressY = 0;
        progressX = (vert0.x - v0x) / (v1x - v0x);
        progressY = (vert0.y - v0y) / (v1y - v0y);

        _generateUV(progressX, progressY, dataList, offset);

        progressX = (vert1.x - v0x) / (v1x - v0x);
        progressY = (vert1.y - v0y) / (v1y - v0y);

        _generateUV(progressX, progressY, dataList, offset + 1);

        progressX = (vert2.x - v0x) / (v1x - v0x);
        progressY = (vert2.y - v0y) / (v1y - v0y);

        _generateUV(progressX, progressY, dataList, offset + 2);
      }

      function _generateUV(progressX, progressY, data, offset) {
        var uvs = _uvs;
        var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
        var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
        var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
        var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
        var uv = data[offset];
        uv.u = px1 + (px2 - px1) * progressY;
        uv.v = py1 + (py2 - py1) * progressY;
      }

      var radialFilled = {
        useModel: false,
        createData: function createData(sprite) {
          return sprite.requestRenderData();
        },
        updateRenderData: function updateRenderData(sprite) {
          var frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          var renderData = sprite.renderData;

          if (renderData && frame) {
            if (!renderData.vertDirty) {
              return;
            }

            var dataList = renderData.data;
            var fillStart = sprite.fillStart;
            var fillRange = sprite.fillRange;

            if (fillRange < 0) {
              fillStart += fillRange;
              fillRange = -fillRange;
            }

            while (fillStart >= 1.0) {
              fillStart -= 1.0;
            }

            while (fillStart < 0.0) {
              fillStart += 1.0;
            }

            fillStart *= PI_2;
            fillRange *= PI_2;
            var fillEnd = fillStart + fillRange;

            _calculateVertices(sprite);

            _calculateUVs(frame);

            _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);

            _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);

            var offset = 0;

            for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
              var triangle = _triangles[triangleIndex];

              if (!triangle) {
                continue;
              }

              if (fillRange >= PI_2) {
                renderData.dataLength = offset + 3;

                _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);

                offset += 3;
                continue;
              }

              var startAngle = _getVertAngle(_center, _vertPos[triangle.x]);

              var endAngle = _getVertAngle(_center, _vertPos[triangle.y]);

              if (endAngle < startAngle) {
                endAngle += PI_2;
              }

              startAngle -= PI_2;
              endAngle -= PI_2;

              for (var testIndex = 0; testIndex < 3; ++testIndex) {
                if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
                  renderData.dataLength = offset + 3;

                  if (endAngle >= fillEnd) {
                    _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _intersectPoint_2[triangleIndex]);
                  } else {
                    _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);
                  }

                  offset += 3;
                } else if (endAngle > fillStart) {
                  if (endAngle <= fillEnd) {
                    renderData.dataLength = offset + 3;

                    _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]);

                    offset += 3;
                  } else {
                    renderData.dataLength = offset + 3;

                    _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);

                    offset += 3;
                  }
                }

                startAngle += PI_2;
                endAngle += PI_2;
              }
            }

            renderData.resize(offset, offset);
            renderData.updateRenderData(sprite, frame);
          }
        },
        fillBuffers: function fillBuffers(comp, renderer) {
          var node = comp.node;
          var renderData = comp.renderData;
          var chunk = renderData.chunk;

          if (node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVertexAndUVData(comp, chunk);
            renderData.vertDirty = false;
          }

          this.updataColorLate(comp);
          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.vertexAccessor.getMeshBuffer(chunk.bufferId);
          var ib = chunk.vertexAccessor.getIndexBuffer(bid);
          var indexOffset = meshBuffer.indexOffset;

          for (var i = 0; i < renderData.indexCount; i++) {
            ib[indexOffset + i] = vid + i;
          }

          meshBuffer.indexOffset += renderData.indexCount;
          meshBuffer.setDirty();
        },
        updateWorldVertexAndUVData: function updateWorldVertexAndUVData(sprite, chunk) {
          var node = sprite.node;
          node.getWorldMatrix(matrix$1);
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = sprite.renderData.data;
          var vData = chunk.vb;
          var vertexCount = renderData.vertexCount;
          var vertexOffset = 0;

          for (var i = 0; i < vertexCount; i++) {
            var vert = dataList[i];
            Vec3.set(vec3_temp$2, vert.x, vert.y, 0);
            Vec3.transformMat4(vec3_temp$2, vec3_temp$2, matrix$1);
            vData[vertexOffset + 0] = vec3_temp$2.x;
            vData[vertexOffset + 1] = vec3_temp$2.y;
            vData[vertexOffset + 2] = vec3_temp$2.z;
            vData[vertexOffset + 3] = vert.u;
            vData[vertexOffset + 4] = vert.v;
            vertexOffset += stride;
          }
        },
        updateUVs: function updateUVs(sprite) {
          var renderData = sprite.renderData;
          renderData.vertDirty = true;
          sprite.markForUpdateRenderData();
        },
        updataColorLate: function updataColorLate(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var vertexCount = renderData.vertexCount;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = sprite.node._uiProps.opacity;

          for (var i = 0; i < vertexCount; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        },
        updateColor: function updateColor(sprite) {}
      };

      var vec3_temps$1 = [];

      for (var i$2 = 0; i$2 < 4; i$2++) {
        vec3_temps$1.push(new Vec3());
      }

      var simple = {
        createData: function createData(sprite) {
          var renderData = sprite.requestRenderData();
          renderData.dataLength = 2;
          renderData.resize(4, 6);
          return renderData;
        },
        updateRenderData: function updateRenderData(sprite) {
          var frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          var renderData = sprite.renderData;

          if (renderData && frame) {
            if (renderData.vertDirty) {
              this.updateVertexData(sprite);
            }

            renderData.updateRenderData(sprite, frame);
          }
        },
        updateWorldVerts: function updateWorldVerts(sprite, chunk) {
          var renderData = sprite.renderData;
          var vData = chunk.vb;
          var dataList = renderData.data;
          var node = sprite.node;
          var data0 = dataList[0];
          var data3 = dataList[1];
          var matrix = node.worldMatrix;
          var a = matrix.m00;
          var b = matrix.m01;
          var c = matrix.m04;
          var d = matrix.m05;
          var justTranslate = a === 1 && b === 0 && c === 0 && d === 1;
          var tx = matrix.m12;
          var ty = matrix.m13;
          var vl = data0.x;
          var vr = data3.x;
          var vb = data0.y;
          var vt = data3.y;

          if (justTranslate) {
            var vltx = vl + tx;
            var vrtx = vr + tx;
            var vbty = vb + ty;
            var vtty = vt + ty;
            vData[0] = vltx;
            vData[1] = vbty;
            vData[9] = vrtx;
            vData[10] = vbty;
            vData[18] = vltx;
            vData[19] = vtty;
            vData[27] = vrtx;
            vData[28] = vtty;
          } else {
            var al = a * vl;
            var ar = a * vr;
            var bl = b * vl;
            var br = b * vr;
            var cb = c * vb;
            var ct = c * vt;
            var db = d * vb;
            var dt = d * vt;
            var cbtx = cb + tx;
            var cttx = ct + tx;
            var dbty = db + ty;
            var dtty = dt + ty;
            vData[0] = al + cbtx;
            vData[1] = bl + dbty;
            vData[9] = ar + cbtx;
            vData[10] = br + dbty;
            vData[18] = al + cttx;
            vData[19] = bl + dtty;
            vData[27] = ar + cttx;
            vData[28] = br + dtty;
          }
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
          if (sprite === null) {
            return;
          }

          var renderData = sprite.renderData;
          var chunk = renderData.chunk;

          if (sprite.node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVerts(sprite, chunk);
            renderData.vertDirty = false;
          }

          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.vertexAccessor.getMeshBuffer(bid);
          var ib = chunk.vertexAccessor.getIndexBuffer(bid);
          var indexOffset = meshBuffer.indexOffset;
          ib[indexOffset++] = vid;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 2;
          ib[indexOffset++] = vid + 1;
          ib[indexOffset++] = vid + 3;
          meshBuffer.indexOffset += 6;
        },
        updateVertexData: function updateVertexData(sprite) {
          var renderData = sprite.renderData;

          if (!renderData) {
            return;
          }

          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var dataList = renderData.data;
          var cw = uiTrans.width;
          var ch = uiTrans.height;
          var appX = uiTrans.anchorX * cw;
          var appY = uiTrans.anchorY * ch;
          var l = 0;
          var b = 0;
          var r = 0;
          var t = 0;

          if (sprite.trim) {
            l = -appX;
            b = -appY;
            r = cw - appX;
            t = ch - appY;
          } else {
            var frame = sprite.spriteFrame;
            var originSize = frame.getOriginalSize();
            var rect = frame.getRect();
            var ow = originSize.width;
            var oh = originSize.height;
            var rw = rect.width;
            var rh = rect.height;
            var offset = frame.getOffset();
            var scaleX = cw / ow;
            var scaleY = ch / oh;
            var trimLeft = offset.x + (ow - rw) / 2;
            var trimRight = offset.x - (ow - rw) / 2;
            var trimBottom = offset.y + (oh - rh) / 2;
            var trimTop = offset.y - (oh - rh) / 2;
            l = trimLeft * scaleX - appX;
            b = trimBottom * scaleY - appY;
            r = cw + trimRight * scaleX - appX;
            t = ch + trimTop * scaleY - appY;
          }

          dataList[0].x = l;
          dataList[0].y = b;
          dataList[1].x = r;
          dataList[1].y = t;
          renderData.vertDirty = true;
        },
        updateUVs: function updateUVs(sprite) {
          if (!sprite.spriteFrame) return;
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var uv = sprite.spriteFrame.uv;
          vData[3] = uv[0];
          vData[4] = uv[1];
          vData[12] = uv[2];
          vData[13] = uv[3];
          vData[21] = uv[4];
          vData[22] = uv[5];
          vData[30] = uv[6];
          vData[31] = uv[7];
        },
        updateColor: function updateColor(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = color.a / 255;

          for (var _i = 0; _i < 4; _i++, colorOffset += renderData.floatStride) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
          }
        }
      };

      var vec3_temp$3 = new Vec3();
      var matrix$2 = new Mat4();
      var sliced = {
        createData: function createData(sprite) {
          var renderData = sprite.requestRenderData();
          renderData.dataLength = 4;
          renderData.resize(16, 54);
          return renderData;
        },
        updateRenderData: function updateRenderData(sprite) {
          var frame = sprite.spriteFrame;
          dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
          this.updateUVs(sprite);
          var renderData = sprite.renderData;

          if (renderData && frame) {
            var vertDirty = renderData.vertDirty;

            if (vertDirty) {
              this.updateVertexData(sprite);
            }

            renderData.updateRenderData(sprite, frame);
          }
        },
        updateVertexData: function updateVertexData(sprite) {
          var renderData = sprite.renderData;
          var dataList = renderData.data;
          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var width = uiTrans.width;
          var height = uiTrans.height;
          var appX = uiTrans.anchorX * width;
          var appY = uiTrans.anchorY * height;
          var frame = sprite.spriteFrame;
          var leftWidth = frame.insetLeft;
          var rightWidth = frame.insetRight;
          var topHeight = frame.insetTop;
          var bottomHeight = frame.insetBottom;
          var sizableWidth = width - leftWidth - rightWidth;
          var sizableHeight = height - topHeight - bottomHeight;
          var xScale = width / (leftWidth + rightWidth);
          var yScale = height / (topHeight + bottomHeight);
          xScale = Number.isNaN(xScale) || xScale > 1 ? 1 : xScale;
          yScale = Number.isNaN(yScale) || yScale > 1 ? 1 : yScale;
          sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
          sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
          dataList[0].x = -appX;
          dataList[0].y = -appY;
          dataList[1].x = leftWidth * xScale - appX;
          dataList[1].y = bottomHeight * yScale - appY;
          dataList[2].x = dataList[1].x + sizableWidth;
          dataList[2].y = dataList[1].y + sizableHeight;
          dataList[3].x = width - appX;
          dataList[3].y = height - appY;
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
          var renderData = sprite.renderData;
          var chunk = renderData.chunk;

          if (sprite.node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVertexData(sprite, chunk);
            renderData.vertDirty = false;
          }

          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.vertexAccessor.getMeshBuffer(chunk.bufferId);
          var ib = chunk.vertexAccessor.getIndexBuffer(bid);
          var indexOffset = meshBuffer.indexOffset;

          for (var r = 0; r < 3; ++r) {
            for (var c = 0; c < 3; ++c) {
              var start = vid + r * 4 + c;
              ib[indexOffset++] = start;
              ib[indexOffset++] = start + 1;
              ib[indexOffset++] = start + 4;
              ib[indexOffset++] = start + 1;
              ib[indexOffset++] = start + 5;
              ib[indexOffset++] = start + 4;
            }
          }

          meshBuffer.indexOffset = indexOffset;
        },
        updateWorldVertexData: function updateWorldVertexData(sprite, chunk) {
          var node = sprite.node;
          node.getWorldMatrix(matrix$2);
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = renderData.data;
          var vData = chunk.vb;
          var offset = 0;

          for (var row = 0; row < 4; ++row) {
            var rowD = dataList[row];

            for (var col = 0; col < 4; ++col) {
              var colD = dataList[col];
              Vec3.set(vec3_temp$3, colD.x, rowD.y, 0);
              Vec3.transformMat4(vec3_temp$3, vec3_temp$3, matrix$2);
              offset = (row * 4 + col) * stride;
              vData[offset++] = vec3_temp$3.x;
              vData[offset++] = vec3_temp$3.y;
              vData[offset++] = vec3_temp$3.z;
            }
          }
        },
        updateUVs: function updateUVs(sprite) {
          if (!sprite.spriteFrame) return;
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var uv = sprite.spriteFrame.uvSliced;
          var uvOffset = 3;

          for (var i = 0; i < 16; i++) {
            vData[uvOffset] = uv[i].u;
            vData[uvOffset + 1] = uv[i].v;
            uvOffset += stride;
          }
        },
        updateColor: function updateColor(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = sprite.node._uiProps.opacity;

          for (var i = 0; i < 16; i++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        }
      };

      var vec3_temps$2 = [];

      for (var i$3 = 0; i$3 < 4; i$3++) {
        vec3_temps$2.push(new Vec3());
      }

      var matrix$3 = new Mat4();
      var tiled = {
        createData: function createData(sprite) {
          return sprite.requestRenderData();
        },
        updateRenderData: function updateRenderData(sprite) {
          var renderData = sprite.renderData;
          var frame = sprite.spriteFrame;

          if (!frame || !renderData) {
            return;
          }

          renderData.updateRenderData(sprite, frame);

          if (!renderData.vertDirty) {
            return;
          }

          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var contentWidth = Math.abs(uiTrans.width);
          var contentHeight = Math.abs(uiTrans.height);
          var rect = frame.getRect();
          var leftWidth = frame.insetLeft;
          var rightWidth = frame.insetRight;
          var centerWidth = rect.width - leftWidth - rightWidth;
          var topHeight = frame.insetTop;
          var bottomHeight = frame.insetBottom;
          var centerHeight = rect.height - topHeight - bottomHeight;
          var sizableWidth = contentWidth - leftWidth - rightWidth;
          var sizableHeight = contentHeight - topHeight - bottomHeight;
          sizableWidth = sizableWidth > 0 ? sizableWidth : 0;
          sizableHeight = sizableHeight > 0 ? sizableHeight : 0;
          var hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
          var vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
          var row = Math.ceil(vRepeat + 2);
          var col = Math.ceil(hRepeat + 2);
          renderData.dataLength = Math.max(8, row + 1, col + 1);
          this.updateVerts(sprite, sizableWidth, sizableHeight, row, col);
          renderData.resize(row * col * 4, row * col * 6);
        },
        updateUVs: function updateUVs(sprite) {
          var renderData = sprite.renderData;
          renderData.vertDirty = true;
          sprite.markForUpdateRenderData();
        },
        fillBuffers: function fillBuffers(sprite, renderer) {
          var node = sprite.node;
          var renderData = sprite.renderData;
          var chunk = renderData.chunk;

          if (node.hasChangedFlags || renderData.vertDirty) {
            this.updateWorldVertexAndUVData(sprite, chunk);
            renderData.vertDirty = false;
          }

          this.updataColorLate(sprite);
          var bid = chunk.bufferId;
          var vid = chunk.vertexOffset;
          var meshBuffer = chunk.vertexAccessor.getMeshBuffer(chunk.bufferId);
          var ib = chunk.vertexAccessor.getIndexBuffer(bid);
          var indexOffset = meshBuffer.indexOffset;

          for (var _i = 0; _i < renderData.indexCount; _i += 6) {
            ib[indexOffset++] = vid;
            ib[indexOffset++] = vid + 1;
            ib[indexOffset++] = vid + 2;
            ib[indexOffset++] = vid + 1;
            ib[indexOffset++] = vid + 3;
            ib[indexOffset++] = vid + 2;
            vid += 4;
            meshBuffer.indexOffset += 6;
          }

          meshBuffer.setDirty();
        },
        updateWorldVertexAndUVData: function updateWorldVertexAndUVData(sprite, chunk) {
          var node = sprite.node;
          node.getWorldMatrix(matrix$3);
          var renderData = sprite.renderData;
          var stride = renderData.floatStride;
          var dataList = renderData.data;
          var vData = chunk.vb;
          var uiTrans = node._uiProps.uiTransformComp;
          var contentWidth = Math.abs(uiTrans.width);
          var contentHeight = Math.abs(uiTrans.height);
          var frame = sprite.spriteFrame;
          var rotated = frame.rotated;
          var uv = frame.uv;
          var uvSliced = frame.uvSliced;
          var rect = frame.rect;
          var leftWidth = frame.insetLeft;
          var rightWidth = frame.insetRight;
          var centerWidth = rect.width - leftWidth - rightWidth;
          var topHeight = frame.insetTop;
          var bottomHeight = frame.insetBottom;
          var centerHeight = rect.height - topHeight - bottomHeight;
          var sizableWidth = contentWidth - leftWidth - rightWidth;
          var sizableHeight = contentHeight - topHeight - bottomHeight;
          sizableWidth = sizableWidth > 0 ? sizableWidth : 0;
          sizableHeight = sizableHeight > 0 ? sizableHeight : 0;
          var hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
          var vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
          var row = Math.ceil(vRepeat + 2);
          var col = Math.ceil(hRepeat + 2);
          var vertexOffset = 0;
          var x = 0;
          var x1 = 0;
          var y = 0;
          var y1 = 0;

          for (var yIndex = 0, yLength = row; yIndex < yLength; ++yIndex) {
            y = dataList[yIndex].y;
            y1 = dataList[yIndex + 1].y;

            for (var xIndex = 0, xLength = col; xIndex < xLength; ++xIndex) {
              x = dataList[xIndex].x;
              x1 = dataList[xIndex + 1].x;
              Vec3.set(vec3_temps$2[0], x, y, 0);
              Vec3.set(vec3_temps$2[1], x1, y, 0);
              Vec3.set(vec3_temps$2[2], x, y1, 0);
              Vec3.set(vec3_temps$2[3], x1, y1, 0);

              for (var _i2 = 0; _i2 < 4; _i2++) {
                var vec3_temp = vec3_temps$2[_i2];
                Vec3.transformMat4(vec3_temp, vec3_temp, matrix$3);

                var _offset = _i2 * stride;

                vData[vertexOffset + _offset] = vec3_temp.x;
                vData[vertexOffset + _offset + 1] = vec3_temp.y;
                vData[vertexOffset + _offset + 2] = vec3_temp.z;
              }

              vertexOffset += 4 * stride;
            }
          }

          vertexOffset = 0;
          var offset = stride;
          var offset1 = offset;
          var offset2 = offset * 2;
          var offset3 = offset * 3;
          var offset4 = offset * 4;
          var coefU = 0;
          var coefV = 0;
          var tempXVerts = [];
          var tempYVerts = [];

          for (var _yIndex = 0, _yLength = row; _yIndex < _yLength; ++_yIndex) {
            if (sizableHeight > centerHeight) {
              if (sizableHeight >= _yIndex * centerHeight) {
                coefV = 1;
              } else {
                coefV = vRepeat % 1;
              }
            } else {
              coefV = vRepeat;
            }

            for (var _xIndex = 0, _xLength = col; _xIndex < _xLength; ++_xIndex) {
              if (sizableWidth > centerWidth) {
                if (sizableWidth >= _xIndex * centerWidth) {
                  coefU = 1;
                } else {
                  coefU = hRepeat % 1;
                }
              } else {
                coefU = hRepeat;
              }

              var vertexOffsetU = vertexOffset + 3;
              var vertexOffsetV = vertexOffsetU + 1;

              if (rotated) {
                if (_yIndex === 0) {
                  tempXVerts[0] = uvSliced[0].u;
                  tempXVerts[1] = uvSliced[0].u;
                  tempXVerts[2] = uvSliced[4].u + (uvSliced[8].u - uvSliced[4].u) * coefV;
                } else if (_yIndex < row - 1) {
                  tempXVerts[0] = uvSliced[4].u;
                  tempXVerts[1] = uvSliced[4].u;
                  tempXVerts[2] = uvSliced[4].u + (uvSliced[8].u - uvSliced[4].u) * coefV;
                } else if (_yIndex === row - 1) {
                  tempXVerts[0] = uvSliced[8].u;
                  tempXVerts[1] = uvSliced[8].u;
                  tempXVerts[2] = uvSliced[12].u;
                }

                if (_xIndex === 0) {
                  tempYVerts[0] = uvSliced[0].v;
                  tempYVerts[1] = uvSliced[1].v + (uvSliced[2].v - uvSliced[1].v) * coefU;
                  tempYVerts[2] = uvSliced[0].v;
                } else if (_xIndex < col - 1) {
                  tempYVerts[0] = uvSliced[1].v;
                  tempYVerts[1] = uvSliced[1].v + (uvSliced[2].v - uvSliced[1].v) * coefU;
                  tempYVerts[2] = uvSliced[1].v;
                } else if (_xIndex === col - 1) {
                  tempYVerts[0] = uvSliced[2].v;
                  tempYVerts[1] = uvSliced[3].v;
                  tempYVerts[2] = uvSliced[2].v;
                }

                tempXVerts[3] = tempXVerts[2];
                tempYVerts[3] = tempYVerts[1];
              } else {
                if (_xIndex === 0) {
                  tempXVerts[0] = uvSliced[0].u;
                  tempXVerts[1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefU;
                  tempXVerts[2] = uv[0];
                } else if (_xIndex < col - 1) {
                  tempXVerts[0] = uvSliced[1].u;
                  tempXVerts[1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefU;
                  tempXVerts[2] = uvSliced[1].u;
                } else if (_xIndex === col - 1) {
                  tempXVerts[0] = uvSliced[2].u;
                  tempXVerts[1] = uvSliced[3].u;
                  tempXVerts[2] = uvSliced[2].u;
                }

                if (_yIndex === 0) {
                  tempYVerts[0] = uvSliced[0].v;
                  tempYVerts[1] = uvSliced[0].v;
                  tempYVerts[2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefV;
                } else if (_yIndex < row - 1) {
                  tempYVerts[0] = uvSliced[4].v;
                  tempYVerts[1] = uvSliced[4].v;
                  tempYVerts[2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefV;
                } else if (_yIndex === row - 1) {
                  tempYVerts[0] = uvSliced[8].v;
                  tempYVerts[1] = uvSliced[8].v;
                  tempYVerts[2] = uvSliced[12].v;
                }

                tempXVerts[3] = tempXVerts[1];
                tempYVerts[3] = tempYVerts[2];
              }

              vData[vertexOffsetU] = tempXVerts[0];
              vData[vertexOffsetV] = tempYVerts[0];
              vData[vertexOffsetU + offset1] = tempXVerts[1];
              vData[vertexOffsetV + offset1] = tempYVerts[1];
              vData[vertexOffsetU + offset2] = tempXVerts[2];
              vData[vertexOffsetV + offset2] = tempYVerts[2];
              vData[vertexOffsetU + offset3] = tempXVerts[3];
              vData[vertexOffsetV + offset3] = tempYVerts[3];
              vertexOffset += offset4;
            }
          }
        },
        updateVerts: function updateVerts(sprite, sizableWidth, sizableHeight, row, col) {
          var uiTrans = sprite.node._uiProps.uiTransformComp;
          var renderData = sprite.renderData;
          var data = renderData.data;
          var frame = sprite.spriteFrame;
          var rect = frame.rect;
          var contentWidth = Math.abs(uiTrans.width);
          var contentHeight = Math.abs(uiTrans.height);
          var appx = uiTrans.anchorX * contentWidth;
          var appy = uiTrans.anchorY * contentHeight;
          var leftWidth = frame.insetLeft;
          var rightWidth = frame.insetRight;
          var centerWidth = rect.width - leftWidth - rightWidth;
          var topHeight = frame.insetTop;
          var bottomHeight = frame.insetBottom;
          var centerHeight = rect.height - topHeight - bottomHeight;
          var xScale = uiTrans.width / (leftWidth + rightWidth) > 1 ? 1 : uiTrans.width / (leftWidth + rightWidth);
          var yScale = uiTrans.height / (topHeight + bottomHeight) > 1 ? 1 : uiTrans.height / (topHeight + bottomHeight);
          var offsetWidth = 0;
          var offsetHeight = 0;

          if (centerWidth > 0) {
            offsetWidth = Math.floor(sizableWidth * 1000) / 1000 % centerWidth === 0 ? centerWidth : sizableWidth % centerWidth;
          } else {
            offsetWidth = sizableWidth;
          }

          if (centerHeight > 0) {
            offsetHeight = Math.floor(sizableHeight * 1000) / 1000 % centerHeight === 0 ? centerHeight : sizableHeight % centerHeight;
          } else {
            offsetHeight = sizableHeight;
          }

          for (var _i3 = 0; _i3 <= col; _i3++) {
            if (_i3 === 0) {
              data[_i3].x = -appx;
            } else if (_i3 > 0 && _i3 < col) {
              if (_i3 === 1) {
                data[_i3].x = leftWidth * xScale + Math.min(centerWidth, sizableWidth) - appx;
              } else if (centerWidth > 0) {
                if (_i3 === col - 1) {
                  data[_i3].x = leftWidth + offsetWidth + centerWidth * (_i3 - 2) - appx;
                } else {
                  data[_i3].x = leftWidth + Math.min(centerWidth, sizableWidth) + centerWidth * (_i3 - 2) - appx;
                }
              } else {
                data[_i3].x = leftWidth + sizableWidth - appx;
              }
            } else if (_i3 === col) {
              data[_i3].x = Math.min(leftWidth + sizableWidth + rightWidth, contentWidth) - appx;
            }
          }

          for (var _i4 = 0; _i4 <= row; _i4++) {
            if (_i4 === 0) {
              data[_i4].y = -appy;
            } else if (_i4 > 0 && _i4 < row) {
              if (_i4 === 1) {
                data[_i4].y = bottomHeight * yScale + Math.min(centerHeight, sizableHeight) - appy;
              } else if (centerHeight > 0) {
                if (_i4 === row - 1) {
                  data[_i4].y = bottomHeight + offsetHeight + (_i4 - 2) * centerHeight - appy;
                } else {
                  data[_i4].y = bottomHeight + Math.min(centerHeight, sizableHeight) + (_i4 - 2) * centerHeight - appy;
                }
              } else {
                data[_i4].y = bottomHeight + sizableHeight - appy;
              }
            } else if (_i4 === row) {
              data[_i4].y = Math.min(bottomHeight + sizableHeight + topHeight, contentHeight) - appy;
            }
          }
        },
        updataColorLate: function updataColorLate(sprite) {
          var renderData = sprite.renderData;
          var vData = renderData.chunk.vb;
          var stride = renderData.floatStride;
          var vertexCount = renderData.vertexCount;
          var colorOffset = 5;
          var color = sprite.color;
          var colorR = color.r / 255;
          var colorG = color.g / 255;
          var colorB = color.b / 255;
          var colorA = sprite.node._uiProps.opacity;

          for (var _i5 = 0; _i5 < vertexCount; _i5++) {
            vData[colorOffset] = colorR;
            vData[colorOffset + 1] = colorG;
            vData[colorOffset + 2] = colorB;
            vData[colorOffset + 3] = colorA;
            colorOffset += stride;
          }
        },
        updateColor: function updateColor(sprite) {}
      };

      var SpriteType$1 = Sprite.Type;
      var FillType$2 = Sprite.FillType;
      var spriteAssembler = exports('spriteAssembler', {
        getAssembler: function getAssembler(spriteComp) {
          var util = simple;
          var comp = spriteComp;

          switch (comp.type) {
            case SpriteType$1.SLICED:
              util = sliced;
              break;

            case SpriteType$1.TILED:
              util = tiled;
              break;

            case SpriteType$1.FILLED:
              if (comp.fillType === FillType$2.RADIAL) {
                util = radialFilled;
              } else {
                util = barFilled;
              }

              break;
          }

          return util;
        }
      });
      Sprite.Assembler = spriteAssembler;

      var _stencilManager = StencilManager.sharedManager;

      function applyClearMask(mask, renderer) {
        _stencilManager.clear(mask);

        renderer.commitModel(mask, mask._clearModel, mask._clearStencilMtl);
      }

      function applyAreaMask(mask, renderer) {
        _stencilManager.enterLevel(mask);

        if (mask.type === MaskType.IMAGE_STENCIL) {
          simple.fillBuffers(mask, renderer);
          var mat = mask.graphics.getMaterialInstance(0);
          renderer.forceMergeBatches(mat, mask.spriteFrame, mask.graphics);
        } else {
          mask.graphics.updateAssembler(renderer);
        }
      }

      var maskAssembler = {
        createData: function createData(mask) {
          var renderData = mask.requestRenderData();
          renderData.dataLength = 2;
          renderData.resize(4, 6);
          return renderData;
        },
        updateRenderData: function updateRenderData(mask) {
          if (mask.type === MaskType.IMAGE_STENCIL) {
            simple.updateRenderData(mask);
            simple.updateColor(mask);
          }
        },
        fillBuffers: function fillBuffers(mask, renderer) {
          if (mask.type !== MaskType.IMAGE_STENCIL || mask.spriteFrame) {
            _stencilManager.pushMask(mask);

            renderer.finishMergeBatches();
            applyClearMask(mask, renderer);
            applyAreaMask(mask, renderer);

            _stencilManager.enableMask();
          }
        }
      };
      var maskEndAssembler = {
        fillBuffers: function fillBuffers(mask, ui) {
          _stencilManager.exitMask();
        }
      };
      var StartAssembler = {
        getAssembler: function getAssembler() {
          return maskAssembler;
        }
      };
      var PostAssembler = {
        getAssembler: function getAssembler() {
          return maskEndAssembler;
        }
      };
      Mask.Assembler = StartAssembler;
      Mask.PostAssembler = PostAssembler;

      var MeshBuffer = exports('MeshBuffer', function () {
        function MeshBuffer() {
          this.byteOffset = 0;
          this.vertexOffset = 0;
          this.indexOffset = 0;
          this.vData = null;
          this.iData = null;
          this._dirty = false;
          this._vertexFormatBytes = 0;
          this._floatsPerVertex = 0;
          this._initVDataCount = 0;
          this._initIDataCount = 0;
          this._attributes = null;
          this._iaPool = [];
          this._iaInfo = null;
          this._nextFreeIAHandle = 0;
        }

        var _proto = MeshBuffer.prototype;

        _proto.initialize = function initialize(device, attrs, vFloatCount, iCount) {
          this._initVDataCount = vFloatCount;
          this._initIDataCount = iCount;
          this._attributes = attrs;
          this._floatsPerVertex = getComponentPerVertex(attrs);
          assertIsTrue(this._initVDataCount / this._floatsPerVertex < 65536, getError(9005));

          if (!this.vData || !this.iData) {
            this.vData = new Float32Array(this._initVDataCount);
            this.iData = new Uint16Array(this._initIDataCount);
          }

          this._iaPool.push(this.createNewIA(device));
        };

        _proto.reset = function reset() {
          this._nextFreeIAHandle = 0;
          this._dirty = false;
        };

        _proto.destroy = function destroy() {
          this.reset();
          this._attributes = null;
          this._iaInfo = null;
          this.vData = null;
          this.iData = null;

          for (var i = 0; i < this._iaPool.length; ++i) {
            var iaRef = this._iaPool[i];

            if (iaRef.vertexBuffers[0]) {
              iaRef.vertexBuffers[0].destroy();
            }

            if (iaRef.indexBuffer) {
              iaRef.indexBuffer.destroy();
            }

            iaRef.ia.destroy();
          }

          this._iaPool.length = 0;
        };

        _proto.setDirty = function setDirty() {
          this._dirty = true;
        };

        _proto.request = function request(vertexCount, indexCount) {
          warnID(9002);
          return false;
        };

        _proto.requireFreeIA = function requireFreeIA(device) {
          if (this._iaPool.length <= this._nextFreeIAHandle) {
            this._iaPool.push(this.createNewIA(device));
          }

          var ia = this._iaPool[this._nextFreeIAHandle++].ia;
          return ia;
        };

        _proto.recycleIA = function recycleIA(ia) {
          var pool = this._iaPool;

          for (var i = 0; i < this._nextFreeIAHandle; ++i) {
            if (ia === pool[i].ia) {
              var iaRef = pool[i];
              pool[i] = pool[--this._nextFreeIAHandle];
              pool[this._nextFreeIAHandle] = iaRef;
              return;
            }
          }
        };

        _proto.checkCapacity = function checkCapacity(vertexCount, indexCount) {
          var maxVertex = (this.vertexOffset + vertexCount) * this._floatsPerVertex;
          var maxIndex = this.indexOffset + indexCount;

          if (maxVertex > this._initVDataCount || maxIndex > this._initIDataCount) {
            return false;
          }

          return true;
        };

        _proto.uploadBuffers = function uploadBuffers() {
          if (this.byteOffset === 0 || !this._dirty) {
            return;
          }

          var iOS14 = sys.__isWebIOS14OrIPadOS14Env;
          var submitCount = iOS14 ? this._nextFreeIAHandle : 1;
          var byteCount = this.byteOffset;
          var indexCount = this.indexOffset;

          for (var i = 0; i < submitCount; ++i) {
            var iaRef = this._iaPool[i];
            var verticesData = new Float32Array(this.vData.buffer, 0, byteCount >> 2);
            var indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
            var vertexBuffer = iaRef.vertexBuffers[0];

            if (byteCount > vertexBuffer.size) {
              vertexBuffer.resize(byteCount);
            }

            vertexBuffer.update(verticesData);

            if (indexCount * 2 > iaRef.indexBuffer.size) {
              iaRef.indexBuffer.resize(indexCount * 2);
            }

            iaRef.indexBuffer.update(indicesData);
          }

          this._dirty = false;
        };

        _proto.createNewIA = function createNewIA(device) {
          var ia;
          var vertexBuffers;
          var indexBuffer;

          if (sys.__isWebIOS14OrIPadOS14Env || !this._iaPool[0]) {
            var vbStride = this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
            var ibStride = Uint16Array.BYTES_PER_ELEMENT;
            var vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbStride, vbStride));
            indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, ibStride, ibStride));
            vertexBuffers = [vertexBuffer];
            this._iaInfo = new InputAssemblerInfo(this._attributes, vertexBuffers, indexBuffer);
            ia = device.createInputAssembler(this._iaInfo);
          } else {
            ia = device.createInputAssembler(this._iaInfo);
            vertexBuffers = this._iaInfo.vertexBuffers;
            indexBuffer = this._iaInfo.indexBuffer;
          }

          return {
            ia: ia,
            vertexBuffers: vertexBuffers,
            indexBuffer: indexBuffer
          };
        };

        _createClass(MeshBuffer, [{
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "vertexFormatBytes",
          get: function get() {
            return this._vertexFormatBytes;
          }
        }]);

        return MeshBuffer;
      }());

      var mouseEvents = [Input.EventType.MOUSE_DOWN, Input.EventType.MOUSE_MOVE, Input.EventType.MOUSE_UP, Input.EventType.MOUSE_WHEEL];
      var touchEvents = [Input.EventType.TOUCH_START, Input.EventType.TOUCH_MOVE, Input.EventType.TOUCH_END, Input.EventType.TOUCH_CANCEL];

      var PointerEventDispatcher = function () {
        function PointerEventDispatcher() {
          this.priority = EventDispatcherPriority.UI;
          this._isListDirty = false;
          this._inDispatchCount = 0;
          this._pointerEventProcessorList = [];
          this._processorListToAdd = [];
          this._processorListToRemove = [];

          input._registerEventDispatcher(this);

          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this.addPointerEventProcessor, this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this.removePointerEventProcessor, this);
          NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.MARK_LIST_DIRTY, this._markListDirty, this);
        }

        var _proto = PointerEventDispatcher.prototype;

        _proto.dispatchEvent = function dispatchEvent(event) {
          var eventType = event.type;

          if (touchEvents.includes(eventType)) {
            return this.dispatchEventTouch(event);
          } else if (mouseEvents.includes(eventType)) {
            return this.dispatchEventMouse(event);
          }

          return true;
        };

        _proto.addPointerEventProcessor = function addPointerEventProcessor(pointerEventProcessor) {
          if (this._inDispatchCount === 0) {
            if (!this._pointerEventProcessorList.includes(pointerEventProcessor)) {
              this._pointerEventProcessorList.push(pointerEventProcessor);

              this._isListDirty = true;
            }
          } else if (!this._processorListToAdd.includes(pointerEventProcessor)) {
            this._processorListToAdd.push(pointerEventProcessor);
          }

          js.array.remove(this._processorListToRemove, pointerEventProcessor);
        };

        _proto.removePointerEventProcessor = function removePointerEventProcessor(pointerEventProcessor) {
          if (this._inDispatchCount === 0) {
            js.array.remove(this._pointerEventProcessorList, pointerEventProcessor);
            this._isListDirty = true;
          } else if (!this._processorListToRemove.includes(pointerEventProcessor)) {
            this._processorListToRemove.push(pointerEventProcessor);
          }

          js.array.remove(this._processorListToAdd, pointerEventProcessor);
        };

        _proto.dispatchEventMouse = function dispatchEventMouse(eventMouse) {
          this._inDispatchCount++;

          this._sortPointerEventProcessorList();

          var pointerEventProcessorList = this._pointerEventProcessorList;
          var length = pointerEventProcessorList.length;
          var dispatchToNextEventDispatcher = true;

          for (var i = 0; i < length; ++i) {
            var pointerEventProcessor = pointerEventProcessorList[i];

            if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventMouse && pointerEventProcessor._handleEventMouse(eventMouse)) {
              dispatchToNextEventDispatcher = false;

              if (!eventMouse.preventSwallow) {
                break;
              } else {
                eventMouse.preventSwallow = false;
              }
            }
          }

          if (--this._inDispatchCount <= 0) {
            this._updatePointerEventProcessorList();
          }

          return dispatchToNextEventDispatcher;
        };

        _proto.dispatchEventTouch = function dispatchEventTouch(eventTouch) {
          this._inDispatchCount++;

          this._sortPointerEventProcessorList();

          var pointerEventProcessorList = this._pointerEventProcessorList;
          var length = pointerEventProcessorList.length;
          var touch = eventTouch.touch;
          var dispatchToNextEventDispatcher = true;

          for (var i = 0; i < length; ++i) {
            var pointerEventProcessor = pointerEventProcessorList[i];

            if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventTouch) {
              if (eventTouch.type === InputEventType.TOUCH_START) {
                if (pointerEventProcessor._handleEventTouch(eventTouch)) {
                  pointerEventProcessor.claimedTouchIdList.push(touch.getID());
                  dispatchToNextEventDispatcher = false;

                  if (!eventTouch.preventSwallow) {
                    break;
                  } else {
                    eventTouch.preventSwallow = false;
                  }
                }
              } else if (pointerEventProcessor.claimedTouchIdList.length > 0) {
                var index = pointerEventProcessor.claimedTouchIdList.indexOf(touch.getID());

                if (index !== -1) {
                  pointerEventProcessor._handleEventTouch(eventTouch);

                  if (eventTouch.type === InputEventType.TOUCH_END || eventTouch.type === InputEventType.TOUCH_CANCEL) {
                    js.array.removeAt(pointerEventProcessor.claimedTouchIdList, index);
                  }

                  dispatchToNextEventDispatcher = false;

                  if (!eventTouch.preventSwallow) {
                    break;
                  } else {
                    eventTouch.preventSwallow = false;
                  }
                }
              }
            }
          }

          if (--this._inDispatchCount <= 0) {
            this._updatePointerEventProcessorList();
          }

          return dispatchToNextEventDispatcher;
        };

        _proto._updatePointerEventProcessorList = function _updatePointerEventProcessorList() {
          var listToAdd = this._processorListToAdd;
          var addLength = listToAdd.length;

          for (var i = 0; i < addLength; ++i) {
            this.addPointerEventProcessor(listToAdd[i]);
          }

          listToAdd.length = 0;
          var listToRemove = this._processorListToRemove;
          var removeLength = listToRemove.length;

          for (var _i = 0; _i < removeLength; ++_i) {
            this.removePointerEventProcessor(listToRemove[_i]);
          }

          listToRemove.length = 0;
        };

        _proto._sortPointerEventProcessorList = function _sortPointerEventProcessorList() {
          if (!this._isListDirty) {
            return;
          }

          var pointerEventProcessorList = this._pointerEventProcessorList;
          var length = pointerEventProcessorList.length;

          for (var i = 0; i < length; ++i) {
            var pointerEventProcessor = pointerEventProcessorList[i];
            var node = pointerEventProcessor.node;

            if (node._uiProps) {
              var trans = node._uiProps.uiTransformComp;
              pointerEventProcessor.cachedCameraPriority = trans.cameraPriority;
            }
          }

          pointerEventProcessorList.sort(this._sortByPriority);
          this._isListDirty = false;
        };

        _proto._sortByPriority = function _sortByPriority(p1, p2) {
          var node1 = p1.node;
          var node2 = p2.node;

          if (!p2 || !node2 || !node2.activeInHierarchy || !node2._uiProps.uiTransformComp) {
            return -1;
          } else if (!p1 || !node1 || !node1.activeInHierarchy || !node1._uiProps.uiTransformComp) {
            return 1;
          }

          if (p1.cachedCameraPriority !== p2.cachedCameraPriority) {
            return p2.cachedCameraPriority - p1.cachedCameraPriority;
          }

          var n1 = node1;
          var n2 = node2;
          var ex = false;

          while (((_n1$parent = n1.parent) === null || _n1$parent === void 0 ? void 0 : _n1$parent._id) !== ((_n2$parent = n2.parent) === null || _n2$parent === void 0 ? void 0 : _n2$parent._id)) {
            var _n1$parent, _n2$parent, _n, _n$parent, _n2, _n2$parent2;

            n1 = ((_n = n1) === null || _n === void 0 ? void 0 : (_n$parent = _n.parent) === null || _n$parent === void 0 ? void 0 : _n$parent.parent) === null ? (ex = true) && node2 : n1 && n1.parent;
            n2 = ((_n2 = n2) === null || _n2 === void 0 ? void 0 : (_n2$parent2 = _n2.parent) === null || _n2$parent2 === void 0 ? void 0 : _n2$parent2.parent) === null ? (ex = true) && node1 : n2 && n2.parent;
          }

          if (n1._id === n2._id) {
            if (n1._id === node2._id) {
              return -1;
            }

            if (n1._id === node1._id) {
              return 1;
            }
          }

          var priority1 = n1 ? n1.getSiblingIndex() : 0;
          var priority2 = n2 ? n2.getSiblingIndex() : 0;
          return ex ? priority1 - priority2 : priority2 - priority1;
        };

        _proto._markListDirty = function _markListDirty() {
          this._isListDirty = true;
        };

        return PointerEventDispatcher;
      }();

      var pointerEventDispatcher = new PointerEventDispatcher();

      var BufferAccessor = function () {
        function BufferAccessor(device, attributes) {
          this._device = null;
          this._attributes = null;
          this._vertexFormatBytes = void 0;
          this._floatsPerVertex = void 0;
          this._buffers = [];
          this._device = device;
          this._attributes = attributes;
          this._floatsPerVertex = getComponentPerVertex(attributes);
          this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
        }

        var _proto = BufferAccessor.prototype;

        _proto.initialize = function initialize() {};

        _proto.reset = function reset() {};

        _proto.request = function request(vertexCount, indexCount) {
        };

        _proto.appendBuffers = function appendBuffers(vertices, indices) {};

        _proto.uploadBuffers = function uploadBuffers() {};

        _proto.destroy = function destroy() {
          this._attributes.length = 0;
        };

        _createClass(BufferAccessor, [{
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "vertexFormatBytes",
          get: function get() {
            return this._vertexFormatBytes;
          }
        }, {
          key: "floatsPerVertex",
          get: function get() {
            return this._floatsPerVertex;
          }
        }]);

        return BufferAccessor;
      }();

      var _entryPool = new Pool$1(function () {
        return {
          offset: 0,
          length: 0
        };
      }, 32);

      var StaticVBChunk = function StaticVBChunk(vertexAccessor, bufferId, vertexOffset, vb, indexCount) {
        this.vertexAccessor = vertexAccessor;
        this.bufferId = bufferId;
        this.vertexOffset = vertexOffset;
        this.vb = vb;
      };
      var StaticVBAccessor = function (_BufferAccessor) {
        _inheritsLoose(StaticVBAccessor, _BufferAccessor);

        function StaticVBAccessor(device, attributes, vCount, iCount) {
          var _this;

          _this = _BufferAccessor.call(this, device, attributes) || this;
          _this._freeLists = [];
          _this._vCount = 0;
          _this._iCount = 0;
          _this._vCount = vCount || Math.floor(macro.BATCHER2D_MEM_INCREMENT * 1024 / _this._vertexFormatBytes);
          _this._iCount = iCount || _this._vCount * StaticVBAccessor.IB_SCALE;

          _this._allocateBuffer();

          return _this;
        }

        var _proto = StaticVBAccessor.prototype;

        _proto.destroy = function destroy() {
          for (var i = 0; i < this._buffers.length; ++i) {
            this._buffers[i].destroy();

            var freeList = this._freeLists[i];

            for (var j = 0; j < freeList.length; ++j) {
              _entryPool.free(freeList[j]);
            }
          }

          this._buffers.length = 0;
          this._freeLists.length = 0;

          _BufferAccessor.prototype.destroy.call(this);
        };

        _proto.reset = function reset() {
          for (var i = 0; i < this._buffers.length; ++i) {
            var buffer = this._buffers[i];
            buffer.indexOffset = 0;
            buffer.reset();
          }
        };

        _proto.getVertexBuffer = function getVertexBuffer(bid) {
          return this._buffers[bid].vData;
        };

        _proto.getIndexBuffer = function getIndexBuffer(bid) {
          return this._buffers[bid].iData;
        };

        _proto.getMeshBuffer = function getMeshBuffer(bid) {
          return this._buffers[bid];
        };

        _proto.uploadBuffers = function uploadBuffers() {
          for (var i = 0; i < this._buffers.length; ++i) {
            var firstEntry = this._freeLists[i][0];
            var buffer = this._buffers[i];

            if (!firstEntry || firstEntry.length < buffer.vData.byteLength) {
              buffer.uploadBuffers();
            }
          }
        };

        _proto.appendIndices = function appendIndices(bufferId, indices) {
          var buf = this._buffers[bufferId];
          var iCount = indices.length;

          if (iCount) {
            buf.iData.set(indices, buf.indexOffset);
            buf.indexOffset += indices.length;
          }
        };

        _proto.allocateChunk = function allocateChunk(vertexCount, indexCount) {
          var byteLength = vertexCount * this.vertexFormatBytes;
          var buf = null;
          var freeList;
          var bid = 0;
          var eid = -1;
          var entry = null;

          for (var i = 0; i < this._buffers.length; ++i) {
            buf = this._buffers[i];
            freeList = this._freeLists[i];

            for (var e = 0; e < freeList.length; ++e) {
              if (freeList[e].length >= byteLength) {
                entry = freeList[e];
                bid = i;
                eid = e;
                break;
              }
            }

            if (entry) break;
          }

          if (!entry) {
            bid = this._allocateBuffer();
            buf = this._buffers[bid];

            if (buf && buf.checkCapacity(vertexCount, indexCount)) {
              eid = 0;
              entry = this._freeLists[bid][eid];
            }
          }

          if (entry) {
            var _vertexOffset = entry.offset / this.vertexFormatBytes;

            assertIsTrue(Number.isInteger(_vertexOffset));

            var _vb = new Float32Array(buf.vData.buffer, entry.offset, byteLength >> 2).fill(0);

            this._allocateChunkFromEntry(bid, eid, entry, byteLength);

            return new StaticVBChunk(this, bid, _vertexOffset, _vb, indexCount);
          } else {
            errorID(9004, byteLength);
            return null;
          }
        };

        _proto.recycleChunk = function recycleChunk(chunk) {
          var freeList = this._freeLists[chunk.bufferId];
          var buf = this._buffers[chunk.bufferId];
          var offset = chunk.vertexOffset * this.vertexFormatBytes;
          var bytes = chunk.vb.byteLength;
          if (bytes === 0) return;
          var recycled = false;
          var i = 0;
          var prevEntry = null;
          var nextEntry = freeList[i];

          while (nextEntry && nextEntry.offset < offset) {
            prevEntry = nextEntry;
            nextEntry = freeList[++i];
          }

          if (prevEntry) {
            var distance = offset - (prevEntry.offset + prevEntry.length);
            assertIsTrue(distance >= 0);

            if (distance === 0) {
              prevEntry.length += bytes;
              offset = prevEntry.offset;
              bytes = prevEntry.length;

              if (nextEntry && nextEntry.offset - (offset + bytes) === 0) {
                prevEntry.length += nextEntry.length;
                freeList.splice(i, 1);

                _entryPool.free(nextEntry);

                nextEntry = null;
              }

              recycled = true;
            }
          }

          if (!recycled && nextEntry) {
            var _distance = nextEntry.offset - (offset + bytes);

            assertIsTrue(_distance >= 0);

            if (_distance === 0) {
              nextEntry.offset = offset;
              nextEntry.length += bytes;
            } else {
              var newEntry = _entryPool.alloc();

              newEntry.offset = offset;
              newEntry.length = bytes;
              freeList.splice(i, 0, newEntry);
            }

            recycled = true;
          }

          if (recycled) {
            if (offset + bytes === buf.byteOffset) {
              buf.byteOffset = offset;
            }
          } else {
            var _newEntry = _entryPool.alloc();

            _newEntry.offset = offset;
            _newEntry.length = bytes;
            freeList.push(_newEntry);
          }
        };

        _proto._allocateChunkFromEntry = function _allocateChunkFromEntry(bid, eid, entry, bytes) {
          var remaining = entry.length - bytes;
          var offset = entry.offset + bytes;
          var buf = this._buffers[bid];

          if (buf.byteOffset < offset) {
            buf.byteOffset = offset;
          }

          assertID(remaining >= 0, 9004, bid, entry.offset, entry.length);

          if (remaining === 0) {
            this._freeLists[bid].splice(eid, 1);

            _entryPool.free(entry);
          } else {
            entry.offset += bytes;
            entry.length = remaining;
          }
        };

        _proto._allocateBuffer = function _allocateBuffer() {
          assertID(this._buffers.length === this._freeLists.length, 9003);
          var buffer = new MeshBuffer();
          var vFloatCount = this._vCount * this._floatsPerVertex;
          buffer.initialize(this._device, this._attributes, vFloatCount, this._iCount);

          this._buffers.push(buffer);

          var entry = _entryPool.alloc();

          entry.offset = 0;
          entry.length = buffer.vData.byteLength;
          var freeList = [entry];

          this._freeLists.push(freeList);

          return this._buffers.length - 1;
        };

        return StaticVBAccessor;
      }(BufferAccessor);
      StaticVBAccessor.IB_SCALE = 4;

      var _dsInfo$2 = new DescriptorSetInfo(null);

      var m4_1$2 = new Mat4();
      var Batcher2D = exports('UI', function () {
        function Batcher2D(_root) {
          var _this = this;

          this.device = void 0;
          this._screens = [];
          this._staticVBBuffer = null;
          this._bufferAccessors = new Map();
          this._drawBatchPool = void 0;
          this._batches = void 0;
          this._currBID = -1;
          this._indexStart = 0;
          this._emptyMaterial = new Material();
          this._currRenderData = null;
          this._currMaterial = this._emptyMaterial;
          this._currTexture = null;
          this._currSampler = null;
          this._currStaticRoot = null;
          this._currComponent = null;
          this._currTransform = null;
          this._currTextureHash = 0;
          this._currSamplerHash = 0;
          this._currLayer = 0;
          this._currDepthStencilStateStage = null;
          this._currIsStatic = false;
          this._currHash = 0;
          this._pOpacity = 1;
          this._opacityDirty = 0;
          this._descriptorSetCache = new DescriptorSetCache();
          this._meshDataArray = [];
          this._root = _root;
          this.device = _root.device;
          this._batches = new CachedArray(64);
          this._drawBatchPool = new Pool$1(function () {
            return new DrawBatch2D();
          }, 128, function (obj) {
            return obj.destroy(_this);
          });
        }

        var _proto = Batcher2D.prototype;

        _proto.initialize = function initialize() {
          return true;
        };

        _proto.destroy = function destroy() {
          for (var i = 0; i < this._batches.length; i++) {
            if (this._batches.array[i]) {
              this._batches.array[i].destroy(this);
            }
          }

          this._batches.destroy();

          this._bufferAccessors.forEach(function (accessor) {
            accessor.destroy();
          });

          this._bufferAccessors.clear();

          if (this._drawBatchPool) {
            this._drawBatchPool.destroy();
          }

          this._descriptorSetCache.destroy();

          StencilManager.sharedManager.destroy();
        };

        _proto.addScreen = function addScreen(comp) {
          this._screens.push(comp);

          this._screens.sort(this._screenSort);
        };

        _proto.removeScreen = function removeScreen(comp) {
          var idx = this._screens.indexOf(comp);

          if (idx === -1) {
            return;
          }

          this._screens.splice(idx, 1);
        };

        _proto.sortScreens = function sortScreens() {
          this._screens.sort(this._screenSort);
        };

        _proto.getFirstRenderCamera = function getFirstRenderCamera(node) {
          if (node.scene && node.scene.renderScene) {
            var cameras = node.scene.renderScene.cameras;

            for (var i = 0; i < cameras.length; i++) {
              var camera = cameras[i];

              if (camera.visibility & node.layer) {
                return camera;
              }
            }
          }

          return null;
        };

        _proto.update = function update() {
          var screens = this._screens;
          var offset = 0;

          for (var i = 0; i < screens.length; ++i) {
            var screen = screens[i];

            var scene = screen._getRenderScene();

            if (!screen.enabledInHierarchy || !scene) {
              continue;
            }

            this._opacityDirty = 0;
            this._pOpacity = 1;
            this.walk(screen.node);
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
            var batchPriority = 0;

            if (this._batches.length > offset) {
              for (; offset < this._batches.length; ++offset) {
                var batch = this._batches.array[offset];

                if (batch.model) {
                  var subModels = batch.model.subModels;

                  for (var j = 0; j < subModels.length; j++) {
                    subModels[j].priority = batchPriority++;
                  }
                } else {
                  batch.descriptorSet = this._descriptorSetCache.getDescriptorSet(batch);
                }

                scene.addBatch(batch);
              }
            }
          }
        };

        _proto.uploadBuffers = function uploadBuffers() {
          if (this._batches.length > 0) {
            this._meshDataArray.forEach(function (rd) {
              rd.uploadBuffers();
            });

            this._bufferAccessors.forEach(function (accessor) {
              accessor.uploadBuffers();
              accessor.reset();
            });

            this._descriptorSetCache.update();
          }
        };

        _proto.reset = function reset() {
          for (var i = 0; i < this._batches.length; ++i) {
            var batch = this._batches.array[i];

            if (batch.isStatic) {
              continue;
            }

            batch.clear();

            this._drawBatchPool.free(batch);
          }

          this._bufferAccessors.forEach(function (accessor) {
            accessor.reset();
          });

          this._meshDataArray.forEach(function (rd) {
            rd.freeIAPool();
          });

          this._meshDataArray.length = 0;
          this._staticVBBuffer = null;
          this._currBID = -1;
          this._indexStart = 0;
          this._currHash = 0;
          this._currLayer = 0;
          this._currRenderData = null;
          this._currMaterial = this._emptyMaterial;
          this._currTexture = null;
          this._currSampler = null;
          this._currComponent = null;
          this._currTransform = null;

          this._batches.clear();

          StencilManager.sharedManager.reset();
        };

        _proto.switchBufferAccessor = function switchBufferAccessor(attributes) {
          if (attributes === void 0) {
            attributes = vfmtPosUvColor;
          }

          var strideBytes = attributes === vfmtPosUvColor ? 36 : getAttributeStride(attributes);

          if (!this._staticVBBuffer || this._staticVBBuffer.vertexFormatBytes !== strideBytes) {
            var accessor = this._bufferAccessors.get(strideBytes);

            if (!accessor) {
              accessor = new StaticVBAccessor(this.device, attributes);

              this._bufferAccessors.set(strideBytes, accessor);
            }

            this._staticVBBuffer = accessor;
            this._currBID = -1;
          }

          return this._staticVBBuffer;
        };

        _proto.registerBufferAccessor = function registerBufferAccessor(key, accessor) {
          this._bufferAccessors.set(key, accessor);
        };

        _proto.updateBuffer = function updateBuffer(attributes, bid) {
          var accessor = this.switchBufferAccessor(attributes);

          if (this._currBID !== bid) {
            this._currBID = bid;
            this._indexStart = accessor.getMeshBuffer(bid).indexOffset;
          }
        };

        _proto.commitComp = function commitComp(comp, renderData, frame, assembler, transform) {
          var dataHash = 0;
          var mat;
          var bufferID = -1;

          if (renderData && renderData.chunk) {
            if (!renderData.isValid()) return;
            dataHash = renderData.dataHash;
            mat = renderData.material;
            bufferID = renderData.chunk.bufferId;
          }

          comp.stencilStage = StencilManager.sharedManager.stage;
          var depthStencilStateStage = comp.stencilStage;

          if (this._currHash !== dataHash || dataHash === 0 || this._currMaterial !== mat || this._currDepthStencilStateStage !== depthStencilStateStage) {
            this.autoMergeBatches(this._currComponent);

            if (renderData && !renderData.isMeshBuffer) {
              this.updateBuffer(renderData.vertexFormat, bufferID);
            }

            this._currRenderData = renderData;
            this._currHash = renderData ? renderData.dataHash : 0;
            this._currComponent = comp;
            this._currTransform = transform;
            this._currMaterial = comp.getRenderMaterial(0);
            this._currDepthStencilStateStage = depthStencilStateStage;
            this._currLayer = comp.node.layer;

            if (frame) {
              this._currTexture = frame.getGFXTexture();
              this._currSampler = frame.getGFXSampler();
              this._currTextureHash = frame.getHash();
              this._currSamplerHash = this._currSampler.hash;
            } else {
              this._currTexture = null;
              this._currSampler = null;
              this._currTextureHash = 0;
              this._currSamplerHash = 0;
            }
          }

          assembler.fillBuffers(comp, this);
        };

        _proto.commitIA = function commitIA(renderComp, ia, tex, mat, transform) {
          if (this._currMaterial !== this._emptyMaterial) {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
          }

          var blendState;
          var depthStencil;
          var dssHash = 0;
          var bsHash = 0;

          if (renderComp) {
            blendState = renderComp.blendHash === -1 ? null : renderComp.getBlendState();
            bsHash = renderComp.blendHash;
            renderComp.stencilStage = StencilManager.sharedManager.stage;

            if (renderComp.customMaterial !== null) {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
            } else {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
            }

            dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          }

          var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = renderComp.node.layer;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = transform || null;

          if (tex) {
            curDrawBatch.texture = tex.getGFXTexture();
            curDrawBatch.sampler = tex.getGFXSampler();
            curDrawBatch.textureHash = tex.getHash();
            curDrawBatch.samplerHash = curDrawBatch.sampler.hash;
          }

          curDrawBatch.fillPasses(mat || null, depthStencil, dssHash, blendState, bsHash, null, this);

          this._batches.push(curDrawBatch);
        };

        _proto.commitModel = function commitModel(comp, model, mat) {
          if (this._currMaterial !== this._emptyMaterial) {
            this.autoMergeBatches(this._currComponent);
            this.resetRenderStates();
          }

          var depthStencil;
          var dssHash = 0;

          if (mat) {
            if (comp.stencilStage === Stage.ENABLED || comp.stencilStage === Stage.DISABLED) {
              comp.stencilStage = StencilManager.sharedManager.stage;
            }

            depthStencil = StencilManager.sharedManager.getStencilStage(comp.stencilStage, mat);
            dssHash = StencilManager.sharedManager.getStencilHash(comp.stencilStage);
          }

          var stamp = legacyCC.director.getTotalFrames();

          if (model) {
            model.updateTransform(stamp);
            model.updateUBOs(stamp);
          }

          for (var i = 0; i < model.subModels.length; i++) {
            var curDrawBatch = this._drawBatchPool.alloc();

            var subModel = model.subModels[i];
            curDrawBatch.visFlags = comp.node.layer;
            curDrawBatch.model = model;
            curDrawBatch.texture = null;
            curDrawBatch.sampler = null;
            curDrawBatch.useLocalData = null;

            if (!depthStencil) {
              depthStencil = null;
            }

            curDrawBatch.fillPasses(mat, depthStencil, dssHash, null, 0, subModel.patches, this);
            curDrawBatch.inputAssembler = subModel.inputAssembler;
            curDrawBatch.model.visFlags = curDrawBatch.visFlags;
            curDrawBatch.descriptorSet = subModel.descriptorSet;

            this._batches.push(curDrawBatch);
          }
        };

        _proto.setupStaticBatch = function setupStaticBatch(staticComp, bufferAccessor) {
          this.finishMergeBatches();
          this._staticVBBuffer = bufferAccessor;
          this.currStaticRoot = staticComp;
        };

        _proto.endStaticBatch = function endStaticBatch() {
          this.finishMergeBatches();
          this.currStaticRoot = null;
          this._staticVBBuffer = null;
          this.switchBufferAccessor();
        };

        _proto.commitStaticBatch = function commitStaticBatch(comp) {
          this._batches.concat(comp.drawBatchList);

          this.finishMergeBatches();
        };

        _proto.autoMergeBatches = function autoMergeBatches(renderComp) {
          var mat = this._currMaterial;

          if (!mat) {
            return;
          }

          var ia;
          var rd = this._currRenderData;
          var accessor = this._staticVBBuffer;

          if (rd && rd.isMeshBuffer) {
            ia = rd.requestIA(this.device);

            if (this._meshDataArray.indexOf(rd) === -1) {
              this._meshDataArray.push(rd);
            }
          } else if (accessor) {
            var bid = this._currBID;
            var buf = accessor.getMeshBuffer(bid);

            if (!buf) {
              return;
            }

            var indexCount = buf.indexOffset - this._indexStart;
            if (indexCount <= 0) return;
            assertIsTrue(this._indexStart < buf.indexOffset);
            buf.setDirty();
            ia = buf.requireFreeIA(this.device);
            ia.firstIndex = this._indexStart;
            ia.indexCount = indexCount;
            this._indexStart = buf.indexOffset;
          }

          this._currBID = -1;

          if (!ia) {
            return;
          }

          var blendState;
          var depthStencil;
          var dssHash = 0;
          var bsHash = 0;

          if (renderComp) {
            blendState = renderComp.blendHash === -1 ? null : renderComp.getBlendState();
            bsHash = renderComp.blendHash;

            if (renderComp.customMaterial !== null) {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
            } else {
              depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
            }

            dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
          }

          var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          curDrawBatch.visFlags = this._currLayer;
          curDrawBatch.texture = this._currTexture;
          curDrawBatch.sampler = this._currSampler;
          curDrawBatch.inputAssembler = ia;
          curDrawBatch.useLocalData = this._currTransform;
          curDrawBatch.textureHash = this._currTextureHash;
          curDrawBatch.samplerHash = this._currSamplerHash;
          curDrawBatch.fillPasses(mat, depthStencil, dssHash, blendState, bsHash, null, this);

          this._batches.push(curDrawBatch);
        };

        _proto.forceMergeBatches = function forceMergeBatches(material, frame, renderComp) {
          this._currMaterial = material;

          if (frame) {
            this._currTexture = frame.getGFXTexture();
            this._currSampler = frame.getGFXSampler();
            this._currTextureHash = frame.getHash();
            this._currSamplerHash = this._currSampler.hash;
          } else {
            this._currTexture = this._currSampler = null;
            this._currTextureHash = this._currSamplerHash = 0;
          }

          this._currLayer = renderComp.node.layer;
          this.autoMergeBatches(renderComp);
        };

        _proto.resetRenderStates = function resetRenderStates() {
          this._currMaterial = this._emptyMaterial;
          this._currRenderData = null;
          this._currTexture = null;
          this._currComponent = null;
          this._currTransform = null;
          this._currTextureHash = 0;
          this._currSamplerHash = 0;
          this._currLayer = 0;
        };

        _proto.finishMergeBatches = function finishMergeBatches() {
          this.autoMergeBatches();
          this.resetRenderStates();
        };

        _proto.flushMaterial = function flushMaterial(mat) {
          this._currMaterial = mat;
        };

        _proto.walk = function walk(node, level) {
          if (level === void 0) {
            level = 0;
          }

          if (!node.activeInHierarchy) {
            return;
          }

          var children = node.children;
          var uiProps = node._uiProps;
          var render = uiProps.uiComp;
          var parentOpacity = this._pOpacity;
          var opacity = parentOpacity;
          var selfOpacity = render && render.color ? render.color.a / 255 : 1;
          this._pOpacity = opacity *= selfOpacity * uiProps.localOpacity;
          uiProps._opacity = opacity;

          if (uiProps.colorDirty) {
            this._opacityDirty++;
          }

          if (render && render.enabledInHierarchy) {
            render.updateAssembler(this);
          }

          if (this._opacityDirty && render && !render.useVertexOpacity && render.renderData && render.renderData.vertexCount > 0) {
            updateOpacity(render.renderData, opacity);
            var buffer = render.renderData.getMeshBuffer();

            if (buffer) {
              buffer.setDirty();
            }
          }

          if (children.length > 0 && !node._static) {
            for (var i = 0; i < children.length; ++i) {
              var child = children[i];
              this.walk(child, level);
            }
          }

          if (uiProps.colorDirty) {
            this._opacityDirty--;
            uiProps.colorDirty = false;
          }

          this._pOpacity = parentOpacity;

          if (render && render.enabledInHierarchy) {
            render.postUpdateAssembler(this);
          }

          level += 1;
        };

        _proto._screenSort = function _screenSort(a, b) {
          return a.node.getSiblingIndex() - b.node.getSiblingIndex();
        };

        _proto._releaseDescriptorSetCache = function _releaseDescriptorSetCache(textureHash) {
          this._descriptorSetCache.releaseDescriptorSetCache(textureHash);
        };

        _createClass(Batcher2D, [{
          key: "currBufferAccessor",
          get: function get() {
            if (this._staticVBBuffer) return this._staticVBBuffer;
            this._staticVBBuffer = this.switchBufferAccessor();
            return this._staticVBBuffer;
          }
        }, {
          key: "batches",
          get: function get() {
            return this._batches;
          }
        }, {
          key: "currStaticRoot",
          set: function set(value) {
            this._currStaticRoot = value;
          }
        }, {
          key: "currIsStatic",
          set: function set(value) {
            this._currIsStatic = value;
          }
        }]);

        return Batcher2D;
      }());

      var LocalDescriptorSet = function () {
        function LocalDescriptorSet() {
          this._descriptorSet = null;
          this._transform = null;
          this._textureHash = 0;
          this._samplerHash = 0;
          this._localBuffer = null;
          this._transformUpdate = true;
          var device = legacyCC.director.root.device;
          this._localData = new Float32Array(UBOLocal.COUNT);
          this._localBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));
        }

        var _proto2 = LocalDescriptorSet.prototype;

        _proto2.initialize = function initialize(batch) {
          var device = legacyCC.director.root.device;
          this._transform = batch.useLocalData;
          this._textureHash = batch.textureHash;
          this._samplerHash = batch.samplerHash;
          _dsInfo$2.layout = batch.passes[0].localSetLayout;
          this._descriptorSet = device.createDescriptorSet(_dsInfo$2);

          this._descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);

          var binding = ModelLocalBindings.SAMPLER_SPRITE;

          this._descriptorSet.bindTexture(binding, batch.texture);

          this._descriptorSet.bindSampler(binding, batch.sampler);

          this._descriptorSet.update();

          this._transformUpdate = true;
        };

        _proto2.updateTransform = function updateTransform(transform) {
          if (transform === this._transform) return;
          this._transform = transform;
          this._transformUpdate = true;
          this.uploadLocalData();
        };

        _proto2.equals = function equals(transform, textureHash, samplerHash) {
          return this._transform === transform && this._textureHash === textureHash && this._samplerHash === samplerHash;
        };

        _proto2.reset = function reset() {
          this._transform = null;
          this._textureHash = 0;
          this._samplerHash = 0;
        };

        _proto2.destroy = function destroy() {
          if (this._localBuffer) {
            this._localBuffer.destroy();

            this._localBuffer = null;
          }

          if (this._descriptorSet) {
            this._descriptorSet.destroy();

            this._descriptorSet = null;
          }

          this._localData = null;
        };

        _proto2.isValid = function isValid() {
          return this._transform && this._transform.isValid;
        };

        _proto2.uploadLocalData = function uploadLocalData() {
          var node = this._transform;

          if (node.hasChangedFlags || node._dirtyFlags) {
            node.updateWorldTransform();
            this._transformUpdate = true;
          }

          if (this._transformUpdate) {
            var worldMatrix = node.worldMatrix;
            Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
            Mat4.inverseTranspose(m4_1$2, worldMatrix);

            {
              var det = Mat4.determinant(m4_1$2);
              var factor = 1.0 / Math.sqrt(det);
              Mat4.multiplyScalar(m4_1$2, m4_1$2, factor);
            }

            Mat4.toArray(this._localData, m4_1$2, UBOLocal.MAT_WORLD_IT_OFFSET);

            this._localBuffer.update(this._localData);

            this._transformUpdate = false;
          }
        };

        _createClass(LocalDescriptorSet, [{
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          }
        }]);

        return LocalDescriptorSet;
      }();

      var DescriptorSetCache = function () {
        function DescriptorSetCache() {
          this._descriptorSetCache = new Map();
          this._dsCacheHashByTexture = new Map();
          this._localDescriptorSetCache = [];
          this._localCachePool = void 0;
          this._localCachePool = new Pool$1(function () {
            return new LocalDescriptorSet();
          }, 16, function (obj) {
            return obj.destroy();
          });
        }

        var _proto3 = DescriptorSetCache.prototype;

        _proto3.getDescriptorSet = function getDescriptorSet(batch) {
          var root = legacyCC.director.root;
          var hash;

          if (batch.useLocalData) {
            var caches = this._localDescriptorSetCache;

            for (var i = 0, len = caches.length; i < len; i++) {
              var cache = caches[i];

              if (cache.equals(batch.useLocalData, batch.textureHash, batch.samplerHash)) {
                return cache.descriptorSet;
              }
            }

            var localDs = this._localCachePool.alloc();

            localDs.initialize(batch);

            this._localDescriptorSetCache.push(localDs);

            return localDs.descriptorSet;
          } else {
            hash = batch.textureHash ^ batch.samplerHash;

            if (this._descriptorSetCache.has(hash)) {
              return this._descriptorSetCache.get(hash);
            } else {
              _dsInfo$2.layout = batch.passes[0].localSetLayout;
              var descriptorSet = root.device.createDescriptorSet(_dsInfo$2);
              var binding = ModelLocalBindings.SAMPLER_SPRITE;
              descriptorSet.bindTexture(binding, batch.texture);
              descriptorSet.bindSampler(binding, batch.sampler);
              descriptorSet.update();

              this._descriptorSetCache.set(hash, descriptorSet);

              this._dsCacheHashByTexture.set(batch.textureHash, hash);

              return descriptorSet;
            }
          }
        };

        _proto3.update = function update() {
          var caches = this._localDescriptorSetCache;
          var uselessArray = [];
          caches.forEach(function (value) {
            if (value.isValid()) {
              value.uploadLocalData();
            } else {
              value.reset();
              var pos = caches.indexOf(value);
              uselessArray.push(pos);
            }
          });

          for (var i = uselessArray.length - 1; i >= 0; i--) {
            caches.splice(uselessArray[i], 1);
          }
        };

        _proto3.reset = function reset() {
          var _this2 = this;

          var caches = this._localDescriptorSetCache;
          caches.forEach(function (value) {
            _this2._localCachePool.free(value);
          });
          this._localDescriptorSetCache.length = 0;
        };

        _proto3.releaseDescriptorSetCache = function releaseDescriptorSetCache(textureHash) {
          var key = this._dsCacheHashByTexture.get(textureHash);

          if (key && this._descriptorSetCache.has(key)) {
            this._descriptorSetCache.get(key).destroy();

            this._descriptorSetCache["delete"](key);

            this._dsCacheHashByTexture["delete"](textureHash);
          }
        };

        _proto3.destroy = function destroy() {
          this._descriptorSetCache.forEach(function (value, key, map) {
            value.destroy();
          });

          this._descriptorSetCache.clear();

          this._dsCacheHashByTexture.clear();

          this._localDescriptorSetCache.length = 0;

          this._localCachePool.destroy();
        };

        return DescriptorSetCache;
      }();

      legacyCC.internal.Batcher2D = Batcher2D;

      markAsWarning(MeshBuffer.prototype, 'MeshBuffer', ['byteStart', 'vertexStart', 'indicesStart', 'request'].map(function (item) {
        return {
          name: item,
          suggest: "please use meshBuffer.accessor." + item + " instead"
        };
      }));
      replaceProperty(MeshBuffer.prototype, 'MeshBuffer', [{
        name: 'indicesOffset',
        newName: 'indexOffset'
      }]);
      removeProperty(MeshBuffer.prototype, 'MeshBuffer', [{
        name: 'vertexBuffers'
      }, {
        name: 'indexBuffer'
      }]);
      replaceProperty(Batcher2D.prototype, 'Batcher2D', [{
        name: 'currBufferBatch',
        newName: 'currBufferAccessor'
      }, {
        name: 'acquireBufferBatch',
        newName: 'switchBufferAccessor'
      }]);
      removeProperty(MeshRenderData.prototype, 'MeshRenderData', [{
        name: 'formatByte'
      }, {
        name: 'byteStart'
      }, {
        name: 'byteCount'
      }]);
      replaceProperty(MeshRenderData.prototype, 'MeshRenderData', [{
        name: 'indicesStart',
        newName: 'indexStart'
      }]);
      var QuadRenderData = exports('QuadRenderData', function (_MeshRenderData) {
        _inheritsLoose(QuadRenderData, _MeshRenderData);

        function QuadRenderData(vertexFormat) {
          var _this;

          _this = _MeshRenderData.call(this, vertexFormat) || this;
          warnID(9006);
          return _this;
        }

        return QuadRenderData;
      }(MeshRenderData));

      var _canvasContext = null;

      var _intervalId = -1;

      var _testString = "BES bswy:->@123\u4E01\u3041\u1101";

      var _fontFaces = Object.create(null);

      var _loadingFonts = [];
      var _timeout = 3000;

      var useNativeCheck = function () {
        var nativeCheck;
        return function () {
          if (nativeCheck === undefined) {
            if ('FontFace' in window) {
              var match = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent);
              var safari10Match = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);

              if (match) {
                nativeCheck = parseInt(match[1], 10) > 42;
              } else if (safari10Match) {
                nativeCheck = false;
              } else {
                nativeCheck = true;
              }
            } else {
              nativeCheck = false;
            }
          }

          return nativeCheck;
        };
      }();

      function checkFontLoaded() {
        var allFontsLoaded = true;
        var now = Date.now();

        for (var i = _loadingFonts.length - 1; i >= 0; i--) {
          var fontLoadHandle = _loadingFonts[i];
          var fontFamily = fontLoadHandle.fontFamilyName;

          if (now - fontLoadHandle.startTime > _timeout) {
            warnID(4933, fontFamily);
            fontLoadHandle.onComplete(null, fontFamily);

            _loadingFonts.splice(i, 1);

            continue;
          }

          var oldWidth = fontLoadHandle.refWidth;
          var fontDesc = "40px " + fontFamily;
          _canvasContext.font = fontDesc;
          var newWidth = safeMeasureText(_canvasContext, _testString, fontDesc);

          if (oldWidth !== newWidth) {
            _loadingFonts.splice(i, 1);

            fontLoadHandle.onComplete(null, fontFamily);
          } else {
            allFontsLoaded = false;
          }
        }

        if (allFontsLoaded) {
          clearInterval(_intervalId);
          _intervalId = -1;
        }
      }

      function nativeCheckFontLoaded(start, font, callback) {
        var loader = new Promise(function (resolve, reject) {
          var check = function check() {
            var now = Date.now();

            if (now - start >= _timeout) {
              reject();
            } else {
              document.fonts.load("40px " + font).then(function (fonts) {
                if (fonts.length >= 1) {
                  resolve();
                } else {
                  setTimeout(check, 100);
                }
              }, function () {
                reject();
              });
            }
          };

          check();
        });
        var timeoutId = null;
        var timer = new Promise(function (resolve, reject) {
          timeoutId = setTimeout(reject, _timeout);
        });
        Promise.race([timer, loader]).then(function () {
          if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }

          callback(null, font);
        }, function () {
          warnID(4933, font);
          callback(null, font);
        });
      }

      function loadFont(url, options, onComplete) {
        var fontFamilyName = getFontFamily(url);

        if (_fontFaces[fontFamilyName]) {
          onComplete(null, fontFamilyName);
          return;
        }

        if (!_canvasContext) {
          var labelCanvas = document.createElement('canvas');
          labelCanvas.width = 100;
          labelCanvas.height = 100;
          _canvasContext = labelCanvas.getContext('2d');
        }

        var fontDesc = "40px " + fontFamilyName;
        var refWidth = safeMeasureText(_canvasContext, _testString, fontDesc);
        var fontStyle = document.createElement('style');
        fontStyle.type = 'text/css';
        var fontStr = '';

        if (Number.isNaN(fontFamilyName)) {
          fontStr += "@font-face { font-family:" + fontFamilyName + "; src:";
        } else {
          fontStr += "@font-face { font-family:\"" + fontFamilyName + "\"; src:";
        }

        fontStr += "url(\"" + url + "\");";
        fontStyle.textContent = fontStr + "}";
        document.body.appendChild(fontStyle);
        var preloadDiv = document.createElement('div');
        var divStyle = preloadDiv.style;
        divStyle.fontFamily = fontFamilyName;
        preloadDiv.innerHTML = '.';
        divStyle.position = 'absolute';
        divStyle.left = '-100px';
        divStyle.top = '-100px';
        document.body.appendChild(preloadDiv);

        if (useNativeCheck()) {
          nativeCheckFontLoaded(Date.now(), fontFamilyName, onComplete);
        } else {
          var fontLoadHandle = {
            fontFamilyName: fontFamilyName,
            refWidth: refWidth,
            onComplete: onComplete,
            startTime: Date.now()
          };

          _loadingFonts.push(fontLoadHandle);

          if (_intervalId === -1) {
            _intervalId = setInterval(checkFontLoaded, 100);
          }
        }

        _fontFaces[fontFamilyName] = fontStyle;
      }
      function getFontFamily(fontHandle) {
        var ttfIndex = fontHandle.lastIndexOf('.ttf');

        if (ttfIndex === -1) {
          return fontHandle;
        }

        var slashPos = fontHandle.lastIndexOf('/');
        var fontFamilyName;

        if (slashPos === -1) {
          fontFamilyName = fontHandle.substring(0, ttfIndex) + "_LABEL";
        } else {
          fontFamilyName = fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
        }

        if (fontFamilyName.indexOf(' ') !== -1) {
          fontFamilyName = "\"" + fontFamilyName + "\"";
        }

        return fontFamilyName;
      }

      function createFont(id, data, options, onComplete) {
        var out = new TTFFont();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }

      downloader.register({
        '.font': loadFont,
        '.eot': loadFont,
        '.ttf': loadFont,
        '.woff': loadFont,
        '.svg': loadFont,
        '.ttc': loadFont
      });
      factory.register({
        '.font': createFont,
        '.eot': createFont,
        '.ttf': createFont,
        '.woff': createFont,
        '.svg': createFont,
        '.ttc': createFont
      });

      legacyCC.UI = {
        MeshBuffer: MeshBuffer,
        spriteAssembler: spriteAssembler,
        graphicsAssembler: graphicsAssemblerManager,
        labelAssembler: labelAssembler,
        RenderData: RenderData,
        MeshRenderData: MeshRenderData
      };

      var _dec$1m, _class$1o, _class2$19, _descriptor$10, _temp$1f;
      var VideoClip = exports('VideoClip', (_dec$1m = ccclass('cc.VideoClip'), _dec$1m(_class$1o = (_class2$19 = (_temp$1f = function (_Asset) {
        _inheritsLoose(VideoClip, _Asset);

        function VideoClip() {
          var _this;

          _this = _Asset.call(this) || this;

          _initializerDefineProperty(_this, "_duration", _descriptor$10, _assertThisInitialized(_this));

          _this._video = null;
          return _this;
        }

        _createClass(VideoClip, [{
          key: "_nativeAsset",
          get: function get() {
            return this._video;
          },
          set: function set(clip) {
            this._video = clip;

            if (clip) {
              this._duration = clip.duration;
            } else {
              this._duration = 0;
            }
          }
        }]);

        return VideoClip;
      }(Asset), _temp$1f), (_descriptor$10 = _applyDecoratedDescriptor(_class2$19.prototype, "_duration", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2$19)) || _class$1o));

      function downloadVideo(url, options, onComplete) {
        var video = document.createElement('video');
        var source = document.createElement('source');
        video.appendChild(source);
        var req = new XMLHttpRequest();
        req.open('GET', url, true);
        req.responseType = 'blob';

        req.onload = function onload() {
          if (this.status === 200 || this.status === 0) {
            source.src = URL.createObjectURL(this.response);
            onComplete(null, video);
          } else {
            onComplete(new Error(req.status + "(no response)"));
          }
        };

        req.onerror = function onerror() {
          var message = "load video failure - " + url;
          log(message);
          onComplete(new Error(message));
        };

        req.send();
      }

      function createVideoClip(id, data, options, onComplete) {
        var out = new VideoClip();
        out._nativeUrl = id;
        out._nativeAsset = data;
        onComplete(null, out);
      }

      downloader.register({
        '.mp4': downloadVideo,
        '.avi': downloadVideo,
        '.mov': downloadVideo,
        '.mpg': downloadVideo,
        '.mpeg': downloadVideo,
        '.rm': downloadVideo,
        '.rmvb': downloadVideo
      });
      factory.register({
        '.mp4': createVideoClip,
        '.avi': createVideoClip,
        '.mov': createVideoClip,
        '.mpg': createVideoClip,
        '.mpeg': createVideoClip,
        '.rm': createVideoClip,
        '.rmvb': createVideoClip
      });

      var ResourceType = Enum({
        REMOTE: 0,
        LOCAL: 1
      });
      var EventType$6;

      (function (EventType) {
        EventType["NONE"] = "none";
        EventType["PLAYING"] = "playing";
        EventType["PAUSED"] = "paused";
        EventType["STOPPED"] = "stopped";
        EventType["COMPLETED"] = "completed";
        EventType["META_LOADED"] = "meta-loaded";
        EventType["READY_TO_PLAY"] = "ready-to-play";
        EventType["ERROR"] = "error";
        EventType["CLICKED"] = "clicked";
      })(EventType$6 || (EventType$6 = {}));

      var READY_STATE;

      (function (READY_STATE) {
        READY_STATE[READY_STATE["HAVE_NOTHING"] = 0] = "HAVE_NOTHING";
        READY_STATE[READY_STATE["HAVE_METADATA"] = 1] = "HAVE_METADATA";
        READY_STATE[READY_STATE["HAVE_CURRENT_DATA"] = 2] = "HAVE_CURRENT_DATA";
        READY_STATE[READY_STATE["HAVE_FUTURE_DATA"] = 3] = "HAVE_FUTURE_DATA";
        READY_STATE[READY_STATE["HAVE_ENOUGH_DATA"] = 4] = "HAVE_ENOUGH_DATA";
      })(READY_STATE || (READY_STATE = {}));

      var VideoPlayerImpl = function () {
        function VideoPlayerImpl(component) {
          var _this = this;

          this._componentEventList = new Map();
          this._state = EventType$6.NONE;
          this._video = null;
          this._onHide = void 0;
          this._onShow = void 0;
          this._interrupted = false;
          this._loaded = false;
          this._loadedMeta = false;
          this._ignorePause = false;
          this._fullScreenOnAwake = false;
          this._visible = true;
          this._playing = false;
          this._cachedCurrentTime = -1;
          this._waitingFullscreen = false;
          this._waitingPlay = false;
          this._keepAspectRatio = false;
          this._component = null;
          this._uiTrans = null;
          this._node = null;
          this._stayOnBottom = false;
          this._dirty = false;
          this._forceUpdate = false;
          this._w = 0;
          this._h = 0;
          this._m00 = 0;
          this._m01 = 0;
          this._m04 = 0;
          this._m05 = 0;
          this._m12 = 0;
          this._m13 = 0;
          this._component = component;
          this._node = component.node;
          this._uiTrans = component.node.getComponent(UITransform);

          this._onHide = function () {
            if (!_this.video || _this._state !== EventType$6.PLAYING) {
              return;
            }

            _this.video.pause();

            _this._interrupted = true;
          };

          this._onShow = function () {
            if (!_this._interrupted || !_this.video) {
              return;
            }

            _this.video.play();

            _this._interrupted = false;
          };

          legacyCC.game.on(legacyCC.Game.EVENT_HIDE, this._onHide);
          legacyCC.game.on(legacyCC.Game.EVENT_SHOW, this._onShow);
        }

        var _proto = VideoPlayerImpl.prototype;

        _proto.onLoadedMetadata = function onLoadedMetadata(e) {
          this._loadedMeta = true;
          this._forceUpdate = true;

          if (this._visible) {
            this.enable();
          } else {
            this.disable();
          }

          this.dispatchEvent(EventType$6.META_LOADED);
          var video = e.target;

          if (this._keepAspectRatio && video) {
            this.syncUITransform(video.videoWidth, video.videoHeight);
          }

          this.delayedFullScreen();
          this.delayedPlay();
        };

        _proto.onCanPlay = function onCanPlay(e) {
          this._loaded = true;
          this.dispatchEvent(EventType$6.READY_TO_PLAY);
        };

        _proto.onPlay = function onPlay(e) {
          this._playing = true;
          this.dispatchEvent(EventType$6.PLAYING);
        };

        _proto.onPlaying = function onPlaying(e) {
          this.dispatchEvent(EventType$6.PLAYING);
        };

        _proto.onPause = function onPause(e) {
          if (this._ignorePause) {
            this._ignorePause = false;
            return;
          }

          this._playing = false;
          this.dispatchEvent(EventType$6.PAUSED);
        };

        _proto.onStoped = function onStoped(e) {
          this._playing = false;
          this._ignorePause = false;
          this.dispatchEvent(EventType$6.STOPPED);
        };

        _proto.onEnded = function onEnded(e) {
          this.dispatchEvent(EventType$6.COMPLETED);
        };

        _proto.onClick = function onClick(e) {
          this.dispatchEvent(EventType$6.CLICKED);
        };

        _proto.onError = function onError(e) {
          this.dispatchEvent(EventType$6.ERROR);
          var video = e.target;

          if (video && video.error) {
            error("Error " + video.error.code + "; details: " + video.error.message);
          }
        };

        _proto.play = function play() {
          if (this._loadedMeta || this._loaded) {
            this.canPlay();
          } else {
            this._waitingPlay = true;
          }
        };

        _proto.delayedPlay = function delayedPlay() {
          if (this._waitingPlay) {
            this.canPlay();
            this._waitingPlay = false;
          }
        };

        _proto.syncFullScreenOnAwake = function syncFullScreenOnAwake(enabled) {
          this._fullScreenOnAwake = enabled;

          if (this._loadedMeta || this._loaded) {
            this.canFullScreen(enabled);
          } else {
            this._waitingFullscreen = true;
          }
        };

        _proto.delayedFullScreen = function delayedFullScreen() {
          if (this._waitingFullscreen) {
            this.canFullScreen(this._fullScreenOnAwake);
            this._waitingFullscreen = false;
          }
        };

        _proto.dispatchEvent = function dispatchEvent(key) {
          var callback = this._componentEventList.get(key);

          if (callback) {
            this._state = key;
            callback.call(this);
          }
        };

        _proto.syncUITransform = function syncUITransform(width, height) {
          if (this._uiTrans) {
            this._uiTrans.width = width;
            this._uiTrans.height = height;
          }
        };

        _proto.syncCurrentTime = function syncCurrentTime() {
          if (!this.video) {
            return;
          }

          if (this._cachedCurrentTime !== -1 && this.video.currentTime !== this._cachedCurrentTime) {
            this.seekTo(this._cachedCurrentTime);
            this._cachedCurrentTime = -1;
          }
        };

        _proto.destroy = function destroy() {
          this.removeVideoPlayer();

          this._componentEventList.clear();

          legacyCC.game.off(legacyCC.Game.EVENT_HIDE, this._onHide);
          legacyCC.game.off(legacyCC.Game.EVENT_SHOW, this._onShow);
        };

        _createClass(VideoPlayerImpl, [{
          key: "fullScreenOnAwake",
          get: function get() {
            return this._fullScreenOnAwake;
          }
        }, {
          key: "loaded",
          get: function get() {
            return this._loaded;
          }
        }, {
          key: "componentEventList",
          get: function get() {
            return this._componentEventList;
          }
        }, {
          key: "video",
          get: function get() {
            return this._video;
          }
        }, {
          key: "state",
          get: function get() {
            return this._state;
          }
        }, {
          key: "isPlaying",
          get: function get() {
            return this._playing;
          }
        }, {
          key: "UICamera",
          get: function get() {
            return director.root.batcher2D.getFirstRenderCamera(this._node);
          }
        }]);

        return VideoPlayerImpl;
      }();
      legacyCC.internal.VideoPlayerImpl = VideoPlayerImpl;

      var MIN_ZINDEX = -Math.pow(2, 15);

      var _mat4_temp$2 = mat4();

      var VideoPlayerImplWeb = function (_VideoPlayerImpl) {
        _inheritsLoose(VideoPlayerImplWeb, _VideoPlayerImpl);

        function VideoPlayerImplWeb(component) {
          var _this;

          _this = _VideoPlayerImpl.call(this, component) || this;
          _this._eventList = new Map();
          _this._clearColorA = -1;
          _this._clearFlag = void 0;
          return _this;
        }

        var _proto = VideoPlayerImplWeb.prototype;

        _proto.addListener = function addListener(type, handler) {
          if (!this._video) {
            return;
          }

          this._eventList.set(type, handler);

          this._video.addEventListener(type, handler);
        };

        _proto.removeAllListeners = function removeAllListeners() {
          var _this2 = this;

          this._eventList.forEach(function (handler, type) {
            if (!_this2._video) {
              return;
            }

            _this2._video.removeEventListener(type, handler);
          });

          this._eventList.clear();
        };

        _proto.canPlay = function canPlay() {
          var _this3 = this;

          if (this.video) {
            var promise = this.video.play();

            if (window.Promise && promise instanceof Promise) {
              promise["catch"](function (error) {}).then(function () {
                _this3.syncCurrentTime();
              });
            }
          }
        };

        _proto.pause = function pause() {
          if (this.video) {
            this.video.pause();
            this._cachedCurrentTime = this.video.currentTime;
          }
        };

        _proto.resume = function resume() {
          this.play();
        };

        _proto.stop = function stop() {
          var _this4 = this;

          if (this.video) {
            this._ignorePause = true;
            this.video.currentTime = 0;
            this.video.pause();
            this._cachedCurrentTime = 0;
            setTimeout(function () {
              _this4._ignorePause = false;

              _this4.dispatchEvent(EventType$6.STOPPED);
            }, 0);
          }
        };

        _proto.syncClip = function syncClip(clip) {
          this.removeVideoPlayer();

          if (!clip) {
            return;
          }

          this.createVideoPlayer(clip.nativeUrl);
        };

        _proto.syncURL = function syncURL(url) {
          this.removeVideoPlayer();

          if (!url) {
            return;
          }

          this.createVideoPlayer(url);
        };

        _proto.syncPlaybackRate = function syncPlaybackRate(val) {
          if (sys.browserType === BrowserType.UC) {
            warn('playbackRate is not supported by the uc mobile browser.');
            return;
          }

          if (this.video) {
            this.video.playbackRate = val;
          }
        };

        _proto.syncVolume = function syncVolume(val) {
          if (this.video) {
            this.video.volume = val;
          }
        };

        _proto.syncMute = function syncMute(enabled) {
          if (this.video) {
            this.video.muted = enabled;
          }
        };

        _proto.syncLoop = function syncLoop(enabled) {
          if (this.video) {
            this.video.loop = enabled;
          }
        };

        _proto.getDuration = function getDuration() {
          if (!this.video) {
            return 0;
          }

          return this.video.duration;
        };

        _proto.getCurrentTime = function getCurrentTime() {
          if (this.video) {
            return this.video.currentTime;
          }

          return -1;
        };

        _proto.seekTo = function seekTo(val) {
          if (this.video) {
            this.video.currentTime = val;
          }
        };

        _proto.canFullScreen = function canFullScreen(enabled) {
          var _this5 = this;

          var video = this._video;

          if (!video || video.readyState !== READY_STATE.HAVE_ENOUGH_DATA) {
            return;
          }

          if (sys.os === OS.IOS && sys.isBrowser) {
            if (enabled) {
              if (video.webkitEnterFullscreen) {
                video.webkitEnterFullscreen();
              }
            } else if (video.webkitExitFullscreen) {
              video.webkitExitFullscreen();
            }

            this._fullScreenOnAwake = video.webkitDisplayingFullscreen;
            return;
          }

          if (!screen.supportsFullScreen) {
            this._fullScreenOnAwake = enabled;
            this._forceUpdate = true;
            this.syncMatrix();
            return;
          }

          if (enabled) {
            if (sys.browserType === BrowserType.IE) {
              video.style.transform = '';
            }

            video.setAttribute('x5-video-player-fullscreen', 'true');
            screen.requestFullScreen(video, function (document) {
              var fullscreenElement = sys.browserType === BrowserType.IE ? document.msFullscreenElement : document.fullscreenElement;
              _this5._fullScreenOnAwake = fullscreenElement === video;
            }, function () {
              _this5._fullScreenOnAwake = false;
            });
          } else {
            video.removeAttribute('x5-video-player-fullscreen');
            screen.exitFullScreen();
          }
        };

        _proto.syncStayOnBottom = function syncStayOnBottom(enabled) {
          if (this._video) {
            this._video.style['z-index'] = enabled ? MIN_ZINDEX : 0;
            this._stayOnBottom = enabled;
          }

          this._dirty = true;
        };

        _proto.syncKeepAspectRatio = function syncKeepAspectRatio(enabled) {
          this._keepAspectRatio = enabled;

          if (enabled && this._loadedMeta && this._video) {
            this.syncUITransform(this._video.videoWidth, this._video.videoHeight);
          }
        };

        _proto.removeVideoPlayer = function removeVideoPlayer() {
          var video = this._video;

          if (video) {
            if (contains$1(game.container, video)) {
              game.container.removeChild(video);
              this.removeAllListeners();
            }
          }

          this._cachedCurrentTime = 0;
          this._playing = false;
          this._loaded = false;
          this._loadedMeta = false;
          this._video = null;
        };

        _proto.createVideoPlayer = function createVideoPlayer(url) {
          var video = this._video = document.createElement('video');
          video.className = 'cocosVideo';
          video.style.visibility = 'hidden';
          video.style.position = 'absolute';
          video.style.bottom = '0px';
          video.style.left = '0px';
          video.style['transform-origin'] = '0px 100% 0px';
          video.style['-webkit-transform-origin'] = '0px 100% 0px';
          video.setAttribute('preload', 'auto');
          video.setAttribute('webkit-playsinline', '');
          video.setAttribute('x5-playsinline', '');
          video.setAttribute('playsinline', '');

          this._bindDomEvent();

          game.container.appendChild(video);
          var source = document.createElement('source');
          video.appendChild(source);
          source.src = url;
        };

        _proto._bindDomEvent = function _bindDomEvent() {
          var video = this._video;
          this.addListener('loadedmetadata', this.onLoadedMetadata.bind(this));
          this.addListener('canplay', this.onCanPlay.bind(this));
          this.addListener('canplaythrough', this.onCanPlay.bind(this));
          this.addListener('play', this.onPlay.bind(this));
          this.addListener('playing', this.onPlaying.bind(this));
          this.addListener('pause', this.onPause.bind(this));
          this.addListener('click', this.onClick.bind(this));
          this.addListener('ended', this.onEnded.bind(this));
          this.addListener('error', this.onError.bind(this));
        };

        _proto.onCanPlay = function onCanPlay(e) {
          var video = e.target;

          if (this._loaded && video) {
            return;
          }

          switch (video.readyState) {
            case READY_STATE.HAVE_METADATA:
            case READY_STATE.HAVE_ENOUGH_DATA:
              {
                _VideoPlayerImpl.prototype.onCanPlay.call(this, e);

                break;
              }
          }
        };

        _proto.enable = function enable() {
          if (this._video) {
            this._visible = true;

            if (this._video.style.visibility === 'visible') {
              return;
            }

            this._video.style.visibility = 'visible';
          }
        };

        _proto.disable = function disable(noPause) {
          if (this._video) {
            if (!noPause && this._playing) {
              this._video.pause();
            }

            this._visible = false;

            if (this._video.style.visibility === 'hidden') {
              return;
            }

            this._video.style.visibility = 'hidden';
          }
        };

        _proto.syncMatrix = function syncMatrix() {
          if (!this._video || !this._visible || !this._component) return;
          var camera = this.UICamera;

          if (!camera) {
            return;
          }

          if (screen.fullScreen()) {
            return;
          }

          if (this._dirty) {
            this._dirty = false;

            if (this._stayOnBottom) {
              this._clearColorA = camera.clearColor.w;
              this._clearFlag = camera.clearFlag;
              camera.clearColor.w = 0;
              camera.clearFlag = ClearFlagBit.ALL;
            } else if (this._clearFlag) {
              camera.clearColor.w = this._clearColorA;
              camera.clearFlag = this._clearFlag;
              this._clearColorA = -1;
              this._clearFlag = null;
            }
          }

          this._component.node.getWorldMatrix(_mat4_temp$2);

          camera.update(true);
          camera.worldMatrixToScreen(_mat4_temp$2, _mat4_temp$2, game.canvas.width, game.canvas.height);
          var width = 0;
          var height = 0;

          if (this._fullScreenOnAwake) {
            width = visibleRect.width;
            height = visibleRect.height;
          } else {
            width = this._uiTrans.contentSize.width;
            height = this._uiTrans.contentSize.height;
          }

          if (!this._forceUpdate && this._m00 === _mat4_temp$2.m00 && this._m01 === _mat4_temp$2.m01 && this._m04 === _mat4_temp$2.m04 && this._m05 === _mat4_temp$2.m05 && this._m12 === _mat4_temp$2.m12 && this._m13 === _mat4_temp$2.m13 && this._w === width && this._h === height) {
            return;
          }

          this._m00 = _mat4_temp$2.m00;
          this._m01 = _mat4_temp$2.m01;
          this._m04 = _mat4_temp$2.m04;
          this._m05 = _mat4_temp$2.m05;
          this._m12 = _mat4_temp$2.m12;
          this._m13 = _mat4_temp$2.m13;
          this._w = width;
          this._h = height;
          var dpr = screenAdapter.devicePixelRatio;
          var scaleX = 1 / dpr;
          var scaleY = 1 / dpr;
          var container = game.container;
          var sx = _mat4_temp$2.m00 * scaleX;
          var b = _mat4_temp$2.m01;
          var c = _mat4_temp$2.m04;
          var sy = _mat4_temp$2.m05 * scaleY;
          this._video.style.width = this._w + "px";
          this._video.style.height = this._h + "px";

          if (sys.browserType !== BrowserType.MOBILE_QQ) {
            this._video.style.objectFit = this._keepAspectRatio ? 'none' : 'fill';
          } else {
            warn('keepAspectRatio is not supported by the qq mobile browser.');
          }

          var w = this._w * scaleX;
          var h = this._h * scaleY;
          var _anchorPoint = this._uiTrans.anchorPoint,
              x = _anchorPoint.x,
              y = _anchorPoint.y;
          var appx = w * _mat4_temp$2.m00 * x;
          var appy = h * _mat4_temp$2.m05 * y;
          var offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0;
          var offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
          var tx = _mat4_temp$2.m12 * scaleX - appx + offsetX;
          var ty = _mat4_temp$2.m13 * scaleY - appy + offsetY;
          var matrix = "matrix(" + sx + "," + -b + "," + -c + "," + sy + "," + tx + "," + -ty + ")";
          this._video.style.transform = matrix;
          this._video.style['-webkit-transform'] = matrix;

          if (sys.browserType !== BrowserType.IE) {
            this._forceUpdate = false;
          }
        };

        return VideoPlayerImplWeb;
      }(VideoPlayerImpl);

      var VideoPlayerImplManager = function () {
        function VideoPlayerImplManager() {}

        VideoPlayerImplManager.getImpl = function getImpl(component) {
          return new VideoPlayerImplWeb(component);
        };

        return VideoPlayerImplManager;
      }();
      legacyCC.internal.VideoPlayerImplManager = VideoPlayerImplManager;

      var _dec$1n, _dec2$W, _dec3$P, _dec4$G, _dec5$B, _dec6$v, _dec7$t, _dec8$q, _dec9$n, _dec10$n, _dec11$l, _dec12$k, _dec13$i, _dec14$f, _dec15$f, _dec16$d, _dec17$d, _dec18$d, _dec19$d, _dec20$d, _dec21$d, _dec22$d, _dec23$c, _class$1p, _class2$1a, _descriptor$11, _descriptor2$M, _descriptor3$B, _descriptor4$w, _descriptor5$p, _descriptor6$f, _descriptor7$e, _descriptor8$e, _descriptor9$d, _descriptor10$d, _descriptor11$c, _descriptor12$b, _class3$A, _temp$1g;
      var VideoPlayer = exports('VideoPlayer', (_dec$1n = ccclass('cc.VideoPlayer'), _dec2$W = help(), _dec3$P = menu(), _dec4$G = requireComponent(UITransform), _dec5$B = type(VideoClip), _dec6$v = type(ResourceType), _dec7$t = tooltip(), _dec8$q = tooltip(), _dec9$n = type(VideoClip), _dec10$n = tooltip(), _dec11$l = tooltip(), _dec12$k = range(), _dec13$i = tooltip(), _dec14$f = range(), _dec15$f = tooltip(), _dec16$d = tooltip(), _dec17$d = tooltip(), _dec18$d = tooltip(), _dec19$d = tooltip(), _dec20$d = tooltip(), _dec21$d = type([EventHandler]), _dec22$d = displayOrder(), _dec23$c = tooltip(), _dec$1n(_class$1p = _dec2$W(_class$1p = _dec3$P(_class$1p = _dec4$G(_class$1p = executeInEditMode(_class$1p = (_class2$1a = (_temp$1g = _class3$A = function (_Component) {
        _inheritsLoose(VideoPlayer, _Component);

        function VideoPlayer() {
          var _this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _Component.call.apply(_Component, [this].concat(args)) || this;

          _initializerDefineProperty(_this, "_resourceType", _descriptor$11, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_remoteURL", _descriptor2$M, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_clip", _descriptor3$B, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_playOnAwake", _descriptor4$w, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_volume", _descriptor5$p, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_mute", _descriptor6$f, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_playbackRate", _descriptor7$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_loop", _descriptor8$e, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_fullScreenOnAwake", _descriptor9$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_stayOnBottom", _descriptor10$d, _assertThisInitialized(_this));

          _initializerDefineProperty(_this, "_keepAspectRatio", _descriptor11$c, _assertThisInitialized(_this));

          _this._impl = null;
          _this._cachedCurrentTime = 0;

          _initializerDefineProperty(_this, "videoPlayerEvent", _descriptor12$b, _assertThisInitialized(_this));

          return _this;
        }

        var _proto = VideoPlayer.prototype;

        _proto.syncSource = function syncSource() {
          if (!this._impl) {
            return;
          }

          if (this._resourceType === ResourceType.REMOTE) {
            this._impl.syncURL(this._remoteURL);
          } else {
            this._impl.syncClip(this._clip);
          }
        };

        _proto.__preload = function __preload() {

          this._impl = VideoPlayerImplManager.getImpl(this);
          this.syncSource();

          this._impl.syncLoop(this._loop);

          this._impl.syncVolume(this._volume);

          this._impl.syncMute(this._mute);

          this._impl.seekTo(this._cachedCurrentTime);

          this._impl.syncPlaybackRate(this._playbackRate);

          this._impl.syncStayOnBottom(this._stayOnBottom);

          this._impl.syncKeepAspectRatio(this._keepAspectRatio);

          this._impl.syncFullScreenOnAwake(this._fullScreenOnAwake);

          this._impl.componentEventList.set(EventType$6.META_LOADED, this.onMetaLoaded.bind(this));

          this._impl.componentEventList.set(EventType$6.READY_TO_PLAY, this.onReadyToPlay.bind(this));

          this._impl.componentEventList.set(EventType$6.PLAYING, this.onPlaying.bind(this));

          this._impl.componentEventList.set(EventType$6.PAUSED, this.onPaused.bind(this));

          this._impl.componentEventList.set(EventType$6.STOPPED, this.onStopped.bind(this));

          this._impl.componentEventList.set(EventType$6.COMPLETED, this.onCompleted.bind(this));

          this._impl.componentEventList.set(EventType$6.ERROR, this.onError.bind(this));

          if (this._playOnAwake && this._impl.loaded) {
            this.play();
          }
        };

        _proto.onEnable = function onEnable() {
          if (this._impl) {
            this._impl.enable();
          }
        };

        _proto.onDisable = function onDisable() {
          if (this._impl) {
            this._impl.disable();
          }
        };

        _proto.onDestroy = function onDestroy() {
          if (this._impl) {
            this._impl.destroy();

            this._impl = null;
          }
        };

        _proto.update = function update(dt) {
          if (this._impl) {
            this._impl.syncMatrix();
          }
        };

        _proto.onMetaLoaded = function onMetaLoaded() {
          EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.META_LOADED);
          this.node.emit('meta-loaded', this);
        };

        _proto.onReadyToPlay = function onReadyToPlay() {
          if (this._playOnAwake && !this.isPlaying) {
            this.play();
          }

          EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.READY_TO_PLAY);
          this.node.emit(EventType$6.READY_TO_PLAY, this);
        };

        _proto.onPlaying = function onPlaying() {
          EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.PLAYING);
          this.node.emit(EventType$6.PLAYING, this);
        };

        _proto.onPaused = function onPaused() {
          EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.PAUSED);
          this.node.emit(EventType$6.PAUSED, this);
        };

        _proto.onStopped = function onStopped() {
          EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.STOPPED);
          this.node.emit(EventType$6.STOPPED, this);
        };

        _proto.onCompleted = function onCompleted() {
          EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.COMPLETED);
          this.node.emit(EventType$6.COMPLETED, this);
        };

        _proto.onError = function onError() {
          EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.ERROR);
          this.node.emit(EventType$6.ERROR, this);
        };

        _proto.play = function play() {
          if (this._impl) {
            this._impl.play();
          }
        };

        _proto.resume = function resume() {
          if (this._impl) {
            this._impl.resume();
          }
        };

        _proto.pause = function pause() {
          if (this._impl) {
            this._impl.pause();
          }
        };

        _proto.stop = function stop() {
          if (this._impl) {
            this._impl.stop();
          }
        };

        _createClass(VideoPlayer, [{
          key: "resourceType",
          get: function get() {
            return this._resourceType;
          },
          set: function set(val) {
            if (this._resourceType !== val) {
              this._resourceType = val;
              this.syncSource();
            }
          }
        }, {
          key: "remoteURL",
          get: function get() {
            return this._remoteURL;
          },
          set: function set(val) {
            if (this._remoteURL !== val) {
              this._remoteURL = val;
              this.syncSource();
            }
          }
        }, {
          key: "clip",
          get: function get() {
            return this._clip;
          },
          set: function set(val) {
            if (this._clip !== val) {
              this._clip = val;
              this.syncSource();
            }
          }
        }, {
          key: "playOnAwake",
          get: function get() {
            return this._playOnAwake;
          },
          set: function set(value) {
            this._playOnAwake = value;
          }
        }, {
          key: "playbackRate",
          get: function get() {
            return this._playbackRate;
          },
          set: function set(value) {
            this._playbackRate = value;

            if (this._impl) {
              this._impl.syncPlaybackRate(value);
            }
          }
        }, {
          key: "volume",
          get: function get() {
            return this._volume;
          },
          set: function set(value) {
            this._volume = value;

            if (this._impl) {
              this._impl.syncVolume(value);
            }
          }
        }, {
          key: "mute",
          get: function get() {
            return this._mute;
          },
          set: function set(value) {
            this._mute = value;

            if (this._impl) {
              this._impl.syncMute(value);
            }
          }
        }, {
          key: "loop",
          get: function get() {
            return this._loop;
          },
          set: function set(value) {
            this._loop = value;

            if (this._impl) {
              this._impl.syncLoop(value);
            }
          }
        }, {
          key: "keepAspectRatio",
          get: function get() {
            return this._keepAspectRatio;
          },
          set: function set(value) {
            if (this._keepAspectRatio !== value) {
              this._keepAspectRatio = value;

              if (this._impl) {
                this._impl.syncKeepAspectRatio(value);
              }
            }
          }
        }, {
          key: "fullScreenOnAwake",
          get: function get() {
            {
              if (this._impl) {
                this._fullScreenOnAwake = this._impl.fullScreenOnAwake;
                return this._fullScreenOnAwake;
              }
            }

            return this._fullScreenOnAwake;
          },
          set: function set(value) {
            if (this._fullScreenOnAwake !== value) {
              this._fullScreenOnAwake = value;

              if (this._impl) {
                this._impl.syncFullScreenOnAwake(value);
              }
            }
          }
        }, {
          key: "stayOnBottom",
          get: function get() {
            return this._stayOnBottom;
          },
          set: function set(value) {
            if (this._stayOnBottom !== value) {
              this._stayOnBottom = value;

              if (this._impl) {
                this._impl.syncStayOnBottom(value);
              }
            }
          }
        }, {
          key: "nativeVideo",
          get: function get() {
            return this._impl && this._impl.video || null;
          }
        }, {
          key: "currentTime",
          get: function get() {
            if (!this._impl) {
              return this._cachedCurrentTime;
            }

            return this._impl.getCurrentTime();
          },
          set: function set(val) {
            if (Number.isNaN(val)) {
              warn("illegal video time! value:" + val);
              return;
            }

            val = clamp(val, 0, this.duration);
            this._cachedCurrentTime = val;

            if (this._impl) {
              this._impl.seekTo(val);
            }
          }
        }, {
          key: "duration",
          get: function get() {
            if (!this._impl) {
              return 0;
            }

            return this._impl.getDuration();
          }
        }, {
          key: "state",
          get: function get() {
            if (!this._impl) {
              return EventType$6.NONE;
            }

            return this._impl.state;
          }
        }, {
          key: "isPlaying",
          get: function get() {
            if (!this._impl) {
              return false;
            }

            return this._impl.isPlaying;
          }
        }]);

        return VideoPlayer;
      }(Component), _class3$A.EventType = EventType$6, _class3$A.ResourceType = ResourceType, _temp$1g), (_descriptor$11 = _applyDecoratedDescriptor(_class2$1a.prototype, "_resourceType", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ResourceType.LOCAL;
        }
      }), _descriptor2$M = _applyDecoratedDescriptor(_class2$1a.prototype, "_remoteURL", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return '';
        }
      }), _descriptor3$B = _applyDecoratedDescriptor(_class2$1a.prototype, "_clip", [_dec5$B, serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4$w = _applyDecoratedDescriptor(_class2$1a.prototype, "_playOnAwake", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor5$p = _applyDecoratedDescriptor(_class2$1a.prototype, "_volume", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.0;
        }
      }), _descriptor6$f = _applyDecoratedDescriptor(_class2$1a.prototype, "_mute", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor7$e = _applyDecoratedDescriptor(_class2$1a.prototype, "_playbackRate", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor8$e = _applyDecoratedDescriptor(_class2$1a.prototype, "_loop", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor9$d = _applyDecoratedDescriptor(_class2$1a.prototype, "_fullScreenOnAwake", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor10$d = _applyDecoratedDescriptor(_class2$1a.prototype, "_stayOnBottom", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor11$c = _applyDecoratedDescriptor(_class2$1a.prototype, "_keepAspectRatio", [serializable], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2$1a.prototype, "resourceType", [_dec6$v, _dec7$t], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "resourceType"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "remoteURL", [_dec8$q], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "remoteURL"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "clip", [_dec9$n, _dec10$n], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "clip"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "playOnAwake", [_dec11$l], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "playOnAwake"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "playbackRate", [slide, _dec12$k, _dec13$i], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "playbackRate"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "volume", [slide, _dec14$f, _dec15$f], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "volume"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "mute", [_dec16$d], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "mute"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "loop", [_dec17$d], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "loop"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "keepAspectRatio", [_dec18$d], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "keepAspectRatio"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "fullScreenOnAwake", [_dec19$d], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "fullScreenOnAwake"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "stayOnBottom", [_dec20$d], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "stayOnBottom"), _class2$1a.prototype), _descriptor12$b = _applyDecoratedDescriptor(_class2$1a.prototype, "videoPlayerEvent", [serializable, _dec21$d, _dec22$d, _dec23$c], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2$1a)) || _class$1p) || _class$1p) || _class$1p) || _class$1p) || _class$1p));
      legacyCC.internal.VideoPlayer = VideoPlayer;

      replaceProperty(VideoPlayer.prototype, 'VideoPlayer.prototype', [{
        name: 'onPasued',
        newName: 'onPaused'
      }]);

    }
  };
});
